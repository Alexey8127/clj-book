
`\(.+?\)`
\\hl{\1}

`\(.+?\)`
\\hl{\1}

\\hl{\(.+?\)}
\\spverb|\1|

^## \(.+?\)$
\\section{\1}

^### \(.+?\)$
\\subsection{\1}

`\(.+?\)`
\\spverb|\1|

^~~~.+?$
\\begin{verbatim}

^~~~$
\\end{verbatim}

\*\*\(.+?\)\*\*
\\emph{\1}

 --
~---

 —
~---

quotes
ident

\rule{\textwidth}{.5pt}


елечки
spec -- summary
spec -- s/tuple
spec -- угловые кавычки


web more chapter tags


{code}
{verbatim}

TODO
less Рассмотрим

\subsection{Ключ :fn}

Функциональная спека принимает ключ \spverb|:fn|. Это спека для третей стадии
проверки. В нее одновременно попадают аргументы и результат. Иногда результат
зависит от параметров по особым правилам. Например, если функция находит число
из диапазона, проверка на \spverb|int?| недостаточна. Нужно убедиться, что число
действительно не выходит за границы аргументов.

Спека \spverb|:fn| получает словарь с ключами \spverb|:args| и \spverb|:ret|. В
\spverb|:args| находятся аргументы, которые вернула спека с ключом
\spverb|:args|. В \spverb|:ret|~--- результат функции. Спека должна их сравнить
и вернуть истину или ложь.

Для функции \spverb|date-range-sec| действует правило: если первая дата больше
второй, то результат отрицательный. Напишите спеку \spverb|:fn|, которая
проверяет это условие. Тем самым вы предотвратите случай, когда кто-то решит,
что результат должен быть по модулю.

\begin{verbatim}
(s/fdef date-range-sec
  :args (s/cat :start inst? :end inst?)
  :ret int?
)
\end{verbatim}

https://clojure.org/guides/spec#_specing_functions

table of code (3 columns)
1st chapter headings

(defn install-better-logging []
  (alter-var-root
   (var clojure.tools.logging/log*)
   (fn [log*] ;; origin log function
     (fn [logger level throwable message]
       (if throwable
         (log* logger level nil
               (str message \newline
                    (with-out-str
                      (ex-print throwable))))
         (log* logger level throwable message))))))

Reflection warning,  - reference to field toString can't be resolved.

\begin{figure}[!ht]

\begin{verbatim}
version: '2'
services:
  postgres:
    image: postgres
    environment:
      POSTGRES_DB: project_db
      POSTGRES_USER: project_user
      POSTGRES_PASSWORD: project_secret
\end{verbatim}

%% С точки зрения системы образ это черный ящик. Технически возможно подключиться к
%% запущенному образу (он называется контейнер). Но во-первых, изменения контейнере
%% не сохраняются в образ и живут в памяти до завершения работы. Во-вторых,
%% подключаться к пяти экземплярам приложения и менять что-то вручную утомительно и
%% непродуктивно. Остается только собрать образ с новым конфигурационным файлом на
%% борту, загружать его в хранилище и перезапускать сервис, что в целом долго.

%% Облачные платформы достаточно развиты, чтобы избежать таких сценариев. В панели
%% администратора для каждого сервиса есть форма с переменными среды, которые
%% процесс получит при старте. Если приложение читает конфигурацию из среды,
%% достаточно поменять значение прямо в форме и перезагрузить сервис.

%% Чтобы проверить регистрацию, понадобится запущенная система: веб-сервер,
%% почтовый сервер, база данных. Интеграционный тест подключается к браузеру по
%% протоколу WebDriver\footurl{https://www.w3.org/TR/webdriver/} и командует
%% им. Открывает страницу регистрации, вводит данные и нажимает кнопку. Проверяет,
%% что появился текст с просьбой проверить почту. По протоколу SMTP скачивает
%% последнее письмо. Ищет ссылку активации регулярным выражением. Открывает ссылку
%% в новой вкладке. Переходит на страницу авторизации и вводит почту и
%% пароль. Убеждается, что попал в личный кабинет.


(defn wrap-headers-kw
[handler]
(fn [req]
(-> req
(update :headers keywordize-keys)
handler
(update :headers stringify-keys)))) ;; <-


https://grishaev.me/clj-book-web-1/#comment-4519528307

table for code
syntax highlight
use minted


\begin{verbatim}
Fail in test-square-roots
One root ;; message from the testing macro
expected: nil
  actual: -3
\end{verbatim}


:once 1 starts
 :once 2 starts
  :each 3 starts   +
   :each 4 starts  | test1
   :each 4 ends    |
  :each 3 ends     +
  :each 3 starts   +
   :each 4 starts  | test2
   :each 4 ends    |
  :each 3 ends     +
  :each 3 starts   +
   :each 4 starts  | test3
   :each 4 ends    |
  :each 3 ends     +
  :each 3 starts   +
   :each 4 starts  | test4
   :each 4 ends    |
  :each 3 ends     +
 :once 2 ends
:once 1 ends


%% \usepackage{qrcode}

%% \marginpar{\qrcode[height=1cm]{https://test}}

%% \begin{wrapfigure}{r}{0.5\textwidth}
%%     \qrcode[height=1cm]{https://github.com/exoscale/obwald}
%% \end{wrapfigure}
