\chapter{Изменяемость}

\begin{teaser}
В классических языках данные меняются, а стандартная библиотека предлагает
ограничения: локи, атомарные действия, постоянные коллекции. В Clojure,
наоборот, данные не меняются, а мутабельные типы задвинуты на второй план. Это
сделано намеренно, потому что неизменяемость~--- центральная идея языка.
\end{teaser}

Руководства по Clojure учат постоянными коллекциям. Это правильный подход, но
когда появляется состояние, новички испытывают трудности. В этой главе мы займем
другую позицию: рассмотрим, как управлять состоянием в программах.

\section{Общие проблемы}

На Clojure трудно писать в императивном стиле, когда акцент сделан на изменении
данных. Скажем, чтобы получить список удвоенных чисел, выполняют шаги:

\begin{itemize}
\item
  создать пустой список;
\item
  пройти по всем элементам исходного списка;
\item
  на каждом шаге вычислить элемент;
\item
  добавить его к новому списку.
\end{itemize}

Базовые типы Clojure не меняются, и к ним нельзя применить алгоритм выше. Те,
кто пришел из императивных языков, поначалу не могут писать код с постоянными
коллекциями. Привычка менять данные укрепилась в них так сильно, что
иммутабельность кажется физическим ограничением.

Это сделано нарочно. Создатель Clojure полагает, что изменяемость~--- основная
проблема в разработке ПО. Когда мы пишем код, то видим его начальное состояние в
котором он будет первый такт процессора. Затем программа инициирует классы,
заполнит поля, и объекты изменятся.

Некоторые ошибки трудно расследовать, потому что код и состояние
расходятся. Чтобы исправить ошибку, ее повторяют в локальном окружении. Однако
привести его в конкретное состояние не так просто. Неизменяемые данные отсекают
целый пласт ошибок, от которых страдают императивные языки.

Рассмотрим примеры на Python. В модуле заданы параметры запроса по
умолчанию. Функция \spverb|api_call| принимает дополнительные параметры,
объединяет со стандартными и передает в HTTP-клиент:

\begin{english}
  \begin{python}
DEFAULT_PARAMS = {
    "allow_redirects": True,
    "timeout": 5,
    "headers": {"Content-Type": "application/json"},
    "auth": ("username", "password"),
}

def api_call(**params):
    api_params = DEFAULT_PARAMS # [1]
    api_params.update(params)   # [2]
    resp = requests.post("https://api.host.com", **api_params)
    return resp.json()
  \end{python}
\end{english}

В теле \spverb|api_call| грубая ошибка: переменная \spverb|api_params| получает
не копию глобальных параметров, а \emph{ссылку} на них \spverb|[1]|. Изменяя
\spverb|api_params|, мы на самом деле меняем \spverb|DEFAULT_PARAMS|
\spverb|[2]|. На каждый вызов глобальные параметры меняются, что ведет к
странному поведению программы. Код и состояние <<разъехались>>.

На собеседованиях часто задают вопрос следующий. Представьте функцию с
сигнатурой ниже. Объясните, что в ней не так и приведите пример ошибки?

\begin{english}
  \begin{python}
def foo(bar=[]):
  \end{python}
\end{english}

Ответ: параметры функции по умолчанию создаются однажды. В данном случае
\spverb|bar| равен пустому списку. В Python список изменяется. Если в
\spverb|bar| ничего не передали, получим исходный список. Добавим в него
элемент, и в следующий раз \spverb|bar| будет уже не пустой:

\begin{english}
  \begin{python}
def foo(bar=[]):
    bar.append(1)
    return bar
  \end{python}
\end{english}

Вызов \spverb|foo| вернет списки \spverb|[1]|, \spverb|[1, 1]| и так далее. Еще
хуже: если результат \spverb|foo| сохранить в переменную и добавить к ней
элемент, на самом деле изменится злосчастный \spverb|bar|.

Современные IDE проверяют код на неявные ошибки. Про список в сигнатуре знают
все анализаторы и линтеры. Но мы не можем целиком положиться на утилиты. Если
данные меняются постоянно, трудно понять, где ошибка, а где умысел.

Начинающих кложуристов выдает код:

\begin{english}
  \begin{clojure}
(let [result (atom [])
      data [1 2 3 4 5]]
  (doseq [item data]
    (let [new-item (* 2 item)]
      (swap! result conj new-item)))
  @result)
  \end{clojure}
\end{english}

\noindent
Это привычка из императивного прошлого. Атом-аккумулятор лишний, достаточно
\spverb|map| или \spverb|for|:

\begin{english}
  \begin{clojure}
(map (partial * 2) [1 2 3 4 5])

(for [n [1 2 3 4 5]]
  (* n 2))
  \end{clojure}
\end{english}

Оба выражения короче и понятней. Не нужно создавать вектор и добавлять в него
элементы~--- это делают функции. Если обход коллекции завязан на
атоме, скорее всего это слабое решение.

Авторы Clojure сделали вс\"{е}, чтобы выделить состояние на общем фоне. К
состоянию прибегают только в крайних случаях. Если вы написали код на атомах без
уважительной причины, вам сделают замечание или не примут работу.

\subsection{В защиту состояния}

Мы говорили, что состояние несет потенциальные ошибки. Это слишком линейное
заявление: без состояния работают только небольшие программы. Например, скрипты,
которые запускают раз в день. Писать промышленный код без состояния невозможно.

Постоянные данные избавляют нас от ошибок с перезаписью полей. Это значимый
выигрыш, но кроме данных приложение полагается на \emph{ресурсы}. Для них
действует правило: дешевле работать с открытым ресурсом, чем постоянно открывать
и закрывать его. Состояние повышает скорость программы.

Много лет назад веб-серверы работали по протоколу CGI, Common Gateway
Interface\footurl{https://en.wikipedia.org/wiki/Common\_Gateway\_Interface}. На
каждый запрос сервер запускал скрипт или бинарный файл. Скрипт получал данные
запроса из переменных среды. Программа писала ответ в стандартный поток. Сервер
перехватывал его и выводил пользователю.

Схема была простой и удобной. Приложение могло быть скриптом на Perl или
программой на C\Plus\Plus. У сервера не было состояния. В любой момент
разработчик обновлял файл, и изменения вступали в силу немедленно.

За эти преимущества платили скоростью. Каждый запрос к серверу порождал новый
процесс. Даже если программа написана на C, запуск процесса занимает
время. Индустрия пришла к тому, что приложение должно работать постоянно, а не
по запросу.

Приложение на FastCGI устроено как самостоятельный сервер. Его
производительность на два порядка выше, чем у CGI. В н\"{е}м появилось
состояние~--- открытый порт и цикл ввода-вывода. Цикл читает запрос и делегирует
отдельному потоку. Это усложнило разработку, что привело к новым парадигмам
и фреймворкам.

Похоже устроены соединения с базой данных. Представим, что на каждый запрос мы
открываем соединение, работаем с ним и закрываем. В машинном мире открыть
TCP-соединение это долгая операция. Так появились пулы соединений.

Пул это объект, который держит несколько открытых соединений. Пул знает, какое
из них занято или свободно. Чтобы работать с базой, мы занимаем одно из
свободных соединений, передаем по нему данные и возвращаем. Для потребителя пул
это примитивный объект, который выдает и забирает соединения.

%% --------------

Внутренняя логика пула довольно сложная. Если соединений не хватает, он
увеличивает свою емкость, а при избытке сокращает. Для каждого соединения пул
считает время работы и сколько раз им пользовались. Он же решает, когда закрыть
соединение и заменить его новым. Пул работает в отдельном потоке, чтобы не
блокировать основную программу.

Столь сложное устройство пула компенсирует скорость доступа. Каждый запрос к
базе протекает по заранее открытому соединению, что намного быстрее, чем
открывать его каждый раз.

Сама архитектура машин поощряет изменять данные. В школе нам объясняют память
компьютера как массив ячеек. Запись в ячейку по адресу дешева. И в C\Plus\Plus,
и в Python одинаково легко обновить элемент массива:

\begin{english}
  \begin{python}
items[i] = 5;
  \end{python}
\end{english}

Постоянные структуры хуже ложатся на такую модель памяти. Поэтому они сложнее:
неизменяемый список это уже не цепочка, а дерево узлов с указателем. Постоянные
коллекции достаточно умны, чтобы копировать данные не полностью, а частично. Все
же на больших данных выгоднее работать с изменяемыми структурами.

Это не отменяет достоинства их постоянных аналогов. Мы не призываем всюду
внедрять состояние. Древовидность и замедление это цена, которую платят за
меньший риск ошибки. Инженер должен знать, на что идет, когда добавляет
состояние или избавляется от него.

Далее мы изучим императивные возможности Clojure~--- как ими пользоваться и
когда это действительно нужно.

\section{Атомы}

Clojure предлагает несколько способов изменять данные. Самый простой из них~---
атом. Это объект, который прячет в себе другой объект. Атом получают из
одноименной функции с начальным значением:

\begin{english}
  \begin{clojure}
(def store (atom 42))
  \end{clojure}
\end{english}

Если напечатать атом, увидим следующее:

\begin{english}
  \begin{clojure}
#<Atom@10ed2e87: 42>
  \end{clojure}
\end{english}

Чтобы извлечь значение, применяют оператор \spverb|@|. Запись \spverb|@store|
это укороченный вариант \spverb|(deref store)|. Функция \spverb|deref| принимает
атом и возвращает его внутренний объект. Семантически это то же самое, что
получить значение по указателю. В русской литературе операцию называют
<<разыменование>>. В разговорном языке про оператор \spverb|@| говорят
<<дереф>>, <<дерефнуть>>.

\begin{english}
  \begin{clojure}
@store ;; 42
  \end{clojure}
\end{english}

В отличии от коллекций, атом меняет содержимое, при этом остается тем самым
объектом. Это важное отличие от коллекций: если добавить к словарю ключ, получим
новый словарь, при этом старый не изменится. Если изменить содержимое атома, это
будет вс\"{е} тот же атом с номером \spverb|10ed2e87|.

Наивный способ изменить атом~--- вызвать \spverb|reset!|. Функция принимает атом
и новое значение. Оно может быть любого типа, в том числе \spverb|nil|,
коллекцией, исключением:

\begin{english}
  \begin{clojure}
(reset! store nil)
(reset! store {:items [1 2 3]})
(reset! store (ex-info "error" {:id 42}))
  \end{clojure}
\end{english}

Если выполнить \spverb|@store| после каждого выражения, получим то, что передали
в \spverb|reset!|. Последний случай не бросит исключение, потому что нет
оператора \spverb|throw|.

\subsection{Приращение атома}

Мы назвали \spverb|reset!| наивным, потому что функция не учитывает текущее
значение атома. На практике атом изменяют, отталкиваясь от текущего состояния.
Если это счетчик, неважно, какое значение в нем сейчас. Атому посылают команду
<<прибавь к содержимому единицу>>. Если это вектор, сообщение выглядит как
<<добавь к содержимому этот элемент>>.

Значение атома уходит на второй план; нас интересует \emph{действие}. Чтобы
обновить атом с учетом состояния, ему посылают функцию. Она принимает текущее
значение и возвращает новое, которое заменит содержимое. В функцию
\spverb|swap!| передают атом и функцию для расчета нового значения:

\begin{english}
  \begin{clojure}
(def counter (atom 0))
(swap! counter inc) ;; 1
  \end{clojure}
\end{english}

Если повторять вызов \spverb|swap!|, значение \spverb|counter| каждый раз
увеличится на единицу.

\spverb|Swap!| принимает дополнительные параметры для расчета. Предположим, мы
хотим увеличить счетчик сразу на три позиции или отмотать назад. Вместо
\spverb|inc| возьмем сложение и вычитание: $+$ и $-$. Их первым аргументом
станет текущее значение атома, а второй аргумент передают в \spverb|swap!|:

\begin{english}
  \begin{clojure}
(swap! counter + 3) ;; increase by 3
(swap! counter - 2) ;; decrease by 2
  \end{clojure}
\end{english}

Атом вычислит новое значение по принципу:

\begin{english}
  \begin{clojure}
(+ <current> 3)
(- <current> 2)
  \end{clojure}
\end{english}

\noindent
, где \spverb|<current>|~--- текущее значение.

Это был частный случай \spverb|swap!| с одним аргументом. В общем случае функция
принимает их произвольное количество:

\begin{english}
  \begin{clojure}
(swap! <atom> func arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

\noindent
Новое значение находят формой:

\begin{english}
  \begin{clojure}
(func <current> arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

До сих пор мы хранили в атомах счетчики. На практике редко считают одну
сущность. Гораздо чаще счетчики ведут в разрезе чего-то. Например, просмотры
страниц по адресам, число сообщений у пользователя и так далее.

Чтобы не создавать по атому на каждую сущность, их объединяют в
словарь. Рассмотрим подсчет системных ресурсов. Ключи словаря означают тип
ресурса, значения~--- степень потребления в байтах или процентах.

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))
  \end{clojure}
\end{english}

Отдельная функция вычисляет потребление диска. Чтобы записать новое значение в
атом по ключу \spverb|:store|, вызовем \spverb|swap!| следующим образом:

\begin{english}
  \begin{clojure}
(defn get-disk-usage []
  (rand-int 99999999))

(let [store (get-disk-usage)]
  (swap! usage assoc :store store))
  \end{clojure}
\end{english}

Эта форма перепишет значение в \spverb|:store| на новое. Возможен и другой
подход, когда мы не считаем все занятое место на диске, а фиксируем разницу на
каждое изменение. Скажем, если пользователь создал или удалил файл, мы читаем
событие и обновляем \spverb|:store| с приращением.

Функция \spverb|get-file-event| каким-то образом вернет событие файловой
системы. Это словарь с ключами \spverb|:action| и \spverb|:size|. В зависимости
от \spverb|:action| мы наращиваем или уменьшаем потребление диска. Наша версия
\spverb|get-file-event| это заглушка, которая случайно вернет одно из двух
событий:

\begin{english}
  \begin{clojure}
(defn get-file-event []
  (rand-nth
   [{:action :delete
     :path "/path/to/deleted/file.txt"
     :size 563467}
    {:action :create
     :path "/path/to/new/photo.jpg"
     :size 7345626}]))
  \end{clojure}
\end{english}

\noindent
Пересчет диска изменится:

\begin{english}
  \begin{clojure}
(let [{:keys [action size]} (get-file-event)]
  (case action
    :delete
    (swap! usage update :store - size)
    :create
    (swap! usage update :store + size)))
  \end{clojure}
\end{english}

Так считают ресурсы в облачных платформах. Обращение к диску это дорогая
операция: нельзя в пробежаться по дереву папок и посчитать потребление. Иногда
файлы одного клиента лежат на разных дисках и серверах. Поэтому ресурсы считают
итеративно и раз в интервал сверяют цифры.

Усложним пример с ресурсами: теперь их считают в разрезе пользователей. Ключи
верхнего уровня означают номер пользователя, а значения~--- словари
ресурсов. Для каждого пользователя ведем список его процессов. Это множество
идентификаторов \spverb|PID|\footurl{https://en.wikipedia.org/wiki/Process\_identifier}.

\begin{english}
  \begin{clojure}
(def usage-all
  (atom {1005 {:cpu 35
               :store 63466734
               :memory 10442856
               :pids #{6266, 5426, 6542}}}))
  \end{clojure}
\end{english}

Чтобы добавить процесс пользователю 1005, выполним \spverb|swap!|:

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] conj 9999)
  \end{clojure}
\end{english}

Получилось комбо: в \spverb|swap!| передали функцию, которая принимает
функцию. Разберем по шагам, что произошло.

\begin{itemize}

\item
  Получим множество старых процессов \spverb|<pids>|:\\
  \spverb|(get-in <current> [1005 :pids])|.

\item
  Добавим к нему новый процесс: \spverb|(conj <pids> 9999)|.\\
  Обозначим новое множество \spverb|<pids*>|.

\item
  Обновим \spverb|<current>| этим множеством по пути 1005 \arr{} \spverb|:pids|:\\
  \spverb|(assoc-in <current> [1005 :pids] <pids*>)|.

\end{itemize}

Чтобы удалить процесс, замените \spverb|conj| на \spverb|disj|. Это обратная
функция: она удаляет элемент из множества.

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] disj 9999)
  \end{clojure}
\end{english}

Чаще всего \spverb|reset!| нужен, чтобы сбросить атом в исходное состояние. В
других случаях важно знать текущее значение атома, чтобы вычислить
новое. Поэтому \spverb|swap!| мощнее и гибче \spverb|reset!|.

\subsection{Совместный доступ}

Функция, которую передают в \spverb|swap!|, должна быть без побочных эффектов. В
функциональном программировании ее бы назвали \emph{чистой функцией}. Она не
должна обращаться к базе данных, файлам, выводу на экран. Технически это
возможно, но вы столкнетесь со странным поведением. Дело в том, иногда функция
срабатывает несколько раз за один \spverb|swap!|. Причина в способе, которым
атом обновляет содержимое.

Предположим, ресурсы считают в нескольких потоках. Один слушает события файловой
системы, а второй процессы. Возникает проблема совместного доступа. Возможна
ситуация, когда два потока обновляют одни и те же данные. Первый поток справился
быстрее и записал в атом свою версию данных. Второй поток рассчитал свой
вариант. Когда он изменит атом, эффект первого аннулируется.

Это классическая задача про терминал и семейную пару. Муж и жена вносят наличные
на общий пустой счет. Жена вносит 100 рублей, терминал прибавляет эту сумму к
нулю и записывает в базу. Муж вносит 50 рублей, терминал делает то же
самое. Итого на счете 50 рублей, а 100 пропали.

Атом не допустит такого поведения. Он запоминает свое значение в момент
вычисления нового. Назовем его \emph{начальным}. Перед тем как обновить
содержимое, атом проверяет, что текущее значение совпадает с начальным. Если они
не равны, атом обновили из другого потока.

В этом случае атом повторяет цикл. Текущее становится начальным, и от него
вычисляют новое значение. Атом еще раз сравнивает текущее и начальное
значения. Цикл повторяется до тех пор, пока они не равны. Это значит, за время
вычислений атом не обновили. Атом меняет текущее значение на новое и выходит из
цикла.

Покажем сказанное на примере. Возьмем атом со словарем:

\begin{english}
  \begin{clojure}
(def sample (atom {:number 0}))
  \end{clojure}
\end{english}

Понадобится функция \emph{медленного} сложения. Она принимает текущее значение,
приращение и время простоя. Для ясности добавим вывод в консоль.

\begin{english}
  \begin{clojure}
(defn +slow
  [num delta timeout]
  (println (format "Current: %s, timeout: %s" num timeout))
  (Thread/sleep timeout)
  (+ num delta))
  \end{clojure}
\end{english}

Обновим атом одновременно из двух потоков. Для этого вызовем \spverb|swap!| в
футуре. В первой ждем две секунды, во второй пять:

\begin{english}
  \begin{clojure}
(do (future (swap! sample update :number +slow 1 2000))
    (future (swap! sample update :number +slow 2 5000)))
  \end{clojure}
\end{english}

\noindent
Проверим атом:

\begin{english}
  \begin{clojure}
@sample ;; {:number 3}
  \end{clojure}
\end{english}

\noindent
Это правильное значение: $0 + 1 + 2 = 3$. Вывод консоли:

\begin{english}
  \begin{text}
Current: 0, timeout: 2000
Current: 0, timeout: 5000
Current: 1, timeout: 5000
  \end{text}
\end{english}

Вторая функция сработала два раза, что и следует из алгоритма. Второй
\spverb|swap!| начал расчеты с начальным значением \spverb|{:number 0}|, а к их
завершению значение стало \spverb|{:number 1}|~--- его записал первый
\spverb|swap!|. Чтобы избежать ошибки, атом запустил второй \spverb|swap!| еще
раз относительно \spverb|{:number 1}|.

Когда атом меняют из нескольких потоков, перезапуск случается больше двух
раз. Это недопустимо для функций, которые меняют окружение.

\subsection{Валидаторы и вотчеры}

Поведение атомов расширяют валидаторы и вотчеры (анг. \emph{watcher},
наблюдатель). Валидаторы это функции проверки. Они принимают новое значение
\emph{до того}, как оно записано в текущее. Если валидатор вернул ложь, вызов
\spverb|swap!| обернется ошибкой.

Функция \spverb|set-validator!| добавляет валидатор к атому. Для счетчика
предположим, что он не может быть отрицательным. Попытка понизить его в нулевом
состоянии вызовет исключение:

\begin{english}
  \begin{clojure}
(def counter (atom 2))
(set-validator! counter (complement neg?))
(swap! counter dec) ;; repeat 3 times...
;; Execution error (IllegalStateException)
;; Invalid reference state
  \end{clojure}
\end{english}

Вотчеры это побочные эффекты атома. Они срабатывают \emph{после того}, как атом
перешел в новое состояние. Вотчер задают уникальным ключом и функцией. Эта
функция принимает четыре аргумента: ключ, атом, старое и новое значения. Одному
атому можно назначить несколько вотчеров.

Разберемся, когда полезны вотчеры. Вспомним подсчет ресурсов: система получает
события и обновляет атом. Если потребление диска превысило лимит, мы не можем
бросить исключение. В этом нет смысла, потому что события поступают из внешней
системы. Исключение на нашей стороне не остановит поток событий.

Правильно задать \emph{реакцию} на превышение лимита. Например, уведомить
пользователя письмом, что ресурс исчерпан. Или отправить запрос в подсистему,
которая отвечает за доступ. Для этого и нужен вотчер: он связывает изменение
атома и реакцию на него.

В примере ниже, если потребление вышло за лимит, в лог пишут сообщение. Объявим
функцию вотчера:

\begin{english}
  \begin{clojure}
(def STORE_LIMIT (* 1024 1024 1024 25)) ;; 25 Gb
(defn store-watcher
  [_key _atom _old value]
  (let [{:keys [store]} value]
    (when (> store STORE_LIMIT)
      (log/errorf "Disk usage %s has reached the limit %s"
                  store STORE_LIMIT))))
  \end{clojure}
\end{english}

Примечание: из четырех параметров мы пользуемся только последним~---
\spverb|value|. Это новое значение атома. В боевом коде мы бы назначили первым
трем символ подчеркивания. Оно затеняет лишние переменные и поэтому работает
быстрее. Однако мы оставили имена, чтобы передать их семантику.

Назначим вотчер атому с ключом \spverb|:store|:

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))

(add-watch usage :store store-watcher)
  \end{clojure}
\end{english}

\noindent
Если потребление диска превысит лимит, увидим запись в лог:

\begin{english}
  \begin{clojure}
(swap! usage update :store + STORE_LIMIT)
;; Disk usage 26907012334 has reached the limit 26843545600
  \end{clojure}
\end{english}

Валидацию и вотчеры рассматривают как пре- и постэффекты. Разница в том, что
первые могут прервать исполнение, а вторые нет. У них разные задачи:
предварительные эффекты проверяют то, что \emph{может случиться}, а
постэффекты~--- то, что \emph{уже случилось}. Поэтому на них реагируют
по-разному.

\subsection{Другие примеры}

На атомы опираются некоторые функции Clojure, например \spverb|memoize|. Это
декоратор, который возвращает улучшенную версию функции. Она запоминает
результат относительно аргументов и записывает во внутреннюю таблицу. Если
вызвать функцию с теми же аргументами, получим результат из таблицы без
вычислений.

Роль таблицы играет атом. Функция-результат \spverb|memoize| замкнута на атоме,
который виден только ей. Вот как выглядит декоратор:

\begin{english}
  \begin{clojure}
(defn memoize [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
  \end{clojure}
\end{english}

Заметим, что для поиска в словаре используют \spverb|find| вместо
\spverb|get|. Разница в том, как функции трактуют пустое значение. Если по ключу
записан \spverb|nil|, \spverb|get| тоже вернет \spverb|nil|, и форма
\spverb|if-let| выполнит ложную ветку. Функция \spverb|find| вернет пару
\spverb|MapEntry|, значение из которой находят про помощи \spverb|val|.

Проверим декоратор на функции \spverb|+slow|, которую задали выше. Объявим
аналог этой функции и замерим вызовы:

\begin{english}
  \begin{clojure}
(def +mem (memoize +slow))

(time (+mem 1 2 2000))
;; Elapsed time: 2004.699832 msecs

(time (+mem 1 2 2000))
;; Elapsed time: 0.078052 msecs
  \end{clojure}
\end{english}

Первый вызов долгий, потому что срабатывает \spverb|Thread/sleep| в теле
функции. Второй вызов получает результат из атома, что на порядки быстрее.

Атомы полезны в веб-разработке: это дешевый способ хранить состояние между
запросами. На атомах легко сделать счетчики просмотров, сессии, кэш. Счетчик
просмотренных страниц это комбинация атома и middleware:

\begin{english}
  \begin{clojure}
(def page-counter
  (atom {"/" 0}))

(defn wrap-page-counter
  [handler]
  (fn [request]
    (let [{:keys [request-method uri]} request]
      (when (= request-method :get)
        (swap! page-counter update uri (fnil inc 0)))
      (handler request))))
  \end{clojure}
\end{english}

На каждый GET-запрос мы увеличиваем счетчик для текущего адреса. Обратите
внимание на форму \spverb|fnil|, которую передаем в \spverb|update|. Она
возвращает особую версию \spverb|inc|, которая не вызовет исключение, если
первый аргумент \spverb|nil|. Это возможно, если в словаре еще нет нужного
ключа; вместо \spverb|nil| функция получит ноль.

Функция \spverb|page-seen| вернет число просмотров по адресу страницы. Напишем
компонент подвала сайта, где мелким шрифтом указано, сколько раз смотрели
страницу. Для HTML-разметки подойдет библиотека
Hiccup\footurl{https://github.com/weavejester/hiccup} и аналоги.

\begin{english}
  \begin{clojure}
(defn page-seen [uri]
  (get @page-counter uri 0))

(defn component-footer [uri]
  [:div {:class "footer"}
   (let [seen (page-seen uri)]
     [:p [:small "This page has been seen " seen " times."]])])
  \end{clojure}
\end{english}

\subsection{Замечания к атому}

У решений на атомах есть недостатки. Атомы не связаны с другими экземплярами
программы. Когда приложение занимает несколько нод, каждая хранит свой
счетчик. Если запросы расходятся по ним равномерно, клиент увидит разные
данные. Чтобы избежать странностей, используют сетевые хранилища вроде Redis.

Атомы непостоянны: если завершить программу, они теряют состояние. Допуст\'{и}м
вариант, когда атом читает начальные данные и время от времени сохраняет их в
ресурс.

\section{Volatile}

Атом устроен довольно сложно: он отвечает за параллельный доступ, вызывает
валидацию и следит за изменениями. Иногда эти возможности излишни, и пользуются
упрощенной версией атома~--- \spverb|volatile|.

Объект \spverb|volatile| тоже хранит и изменяет значение. Одноименная функция
создает объект с состоянием. Функции \spverb|vreset!| и \spverb|vswap!|
аналогичным тем, что мы рассмотрели для атома. Префикс \spverb|v| означает, что
они работают с \spverb|volatile|.

Пример с ресурсами: вместо атома используем другой тип хранилища:

\begin{english}
  \begin{clojure}
(def vusage (volatile! nil))
(vreset! vusage
         {:cpu 35
          :store 63466734
          :memory 10442856})
(vswap! vusage update :store + (* 1024 1024 5))
(println "Disk usage is" (get @vusage :store))
;; Disk usage is 68709614
  \end{clojure}
\end{english}

\spverb|Volatile| отличается от атома тем, что не контролирует запись из
нескольких потоков. Перепишем пример с футурами:

\begin{english}
  \begin{clojure}
(def vsample (volatile! {:number 0}))
(do (future (vswap! vsample update :number +slow 1 2000))
    (future (vswap! vsample update :number +slow 2 5000)))
;; Current: 0, timeout: 2000
;; Current: 0, timeout: 5000
@vsample ;; {:number 2}
  \end{clojure}
\end{english}

Вывод говорит, что второе действие сработало один раз. Если для атома итог был
3, то с \spverb|volatile| получилось 2. Операцию \spverb|+1| мы потеряли. Из
этого следует, что \spverb|volatile| не подходит для многопоточного
кода. Валидаторы и вотчеры тоже не предусмотрены. Это освобождает
\spverb|volatile| от слежки за содержим. Запись без проверок и эффектов работает
быстрее.

\subsection{Применение}

У \spverb|volatile| две области применения~--- трансдьюсеры и императивный
код. Трансдьюсеры это особый способ работать с коллекцией. Они оборачивают
функции \spverb|map|, \spverb|reduce| и другие таким образом, что их комбинация
не порождает промежуточных списков. Это возможно за счет внутреннего
состояния. Для трансдьюсера важна скорость записи, поэтому \spverb|volatile|
подходит на роль состояния лучше, чем атом.

\spverb|Volatile| полезен, когда пишут императивный код. Отнеситесь к этому
спокойно: иногда бизнес-требования слишком сложны, чтобы накладывать их на
функциональный стиль.

Представим, что нужно получить плоский список из дерева. Оно устроено по сложным
правилам: если в первой ветке одно значение, то рассматривать вторую, а иначе
третью. И дальше: если для первой и третьей веток выпоняется условие $x$,
положить в список произведение их значений.

Эти требования насквозь императивны, и выгодно задать их таким же образом. Так
мы сделаем код ближе к бизнес-логике и облегчим поддержку. Пример подмножества
дерева:

\begin{english}
  \begin{clojure}
(def data
  {:items [{:result {:value 74}}
           {:result {:value 65}}]
   :records [{:usage 99 :date "2018-09-09"}
             {:usage 52 :date "2018-11-05"}]})
  \end{clojure}
\end{english}

Код похож на набор блоков, где каждый блок это каскад \spverb|when-let|. На
нижнем уровне мы изменяем коллекцию. Это императивный стиль, но в данном случае
он удобен. Если одно из правил станет не нужно, блок удаляют. Удобно, когда над
блоком пишут комментарий или ссылку на документацию:

\begin{english}
  \begin{clojure}
(let [result (volatile! [])]

  ;; see section 5.4 from the doc
  (when-let [a (some-> data :items first :result :value)]
    (when-let [b (some-> data :records last :usage)]
      (when (> a b)
        (vswap! result conj (* a b)))))

  ;; more expressions...
  @result)
  \end{clojure}
\end{english}

\section{Переходные коллекции}

С помощью атома мы создали подобие изменяемых коллекций. Познакомьтесь с новой
техникой: Clojure предлагает \emph{настоящие} изменяемые коллекции. По-другому
они называются \spverb|transient| (анг. временный, переходный).

Изменяемые коллекции получают из постоянных аналогов. С ними работает гораздо
меньше функций, буквально добавить и удалить элемент. Стадартные \spverb|map|,
\spverb|filter| и другие функции не работают с \spverb|transient|-коллекциями.
Происходит своего рода обмен: мы теряем мощь стандартной библиотеки, но обретаем
скорость и императивный подход.

Транзиентные коллекции в несколько раз быстрее постоянных. Исторически
компьютеры устроены так, что изменить ячейку памяти проще, чем выделить
новую. Неизменяемые структуры похожи на дерево узлов. Изменить дерево в целом
сложнее, чем плоскую структуру.

Транзиентная коллекция это слепок ее постоянной копии. В этом режиме коллекцию
меняют императивно. Когда алгоритм закончил работу, ее замораживают и получают
неизменяемую коллекцию.

Функция \spverb|transient| порождает переходную коллекцию из исходной. Для
работы с ней используют особые функции \spverb|conj!|, \spverb|assoc!|,
\spverb|dissoc!| и другие. Восклицательный знак на конце предупреждает об
изменении данных. Функции меняют \emph{содержимое} коллекции, а не возвращают
новую копию, как это делают обычные \spverb|conj| и \spverb|assoc|.

\subsection{Технические детали}

Функция \spverb|persistent!| завершает работу с переходной коллекцией. Она
возвращает постоянную версию и одновременно <<запечатывает>> оригинал. После
\spverb|persistent!| коллекцию уже нельзя изменить.

Рассмотрим переходный вектор. На него действуют функции \spverb|conj!| и
\spverb|pop!|, добавить и убрать элемент из хвоста:

\begin{english}
  \begin{clojure}
(let [items* (transient [1 2 3])]
  (conj! items* :a)
  (conj! items* :b)
  (pop! items*)
  (persistent! items*))
;; [1 2 3 :a]
  \end{clojure}
\end{english}

\noindent
Вариант со словарем, \spverb|assoc!| и \spverb|dissoc!|:

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (assoc! params* :c 3)
  (dissoc! params* :b)
  (persistent! params*))
;; {:a 1, :c 3}
  \end{clojure}
\end{english}

Примечание: в примерах выше мы обозначили переменную звездочкой. Это не нарушает
синтаксис Clojure. В отличии от других языков, в имени переменной могут быть
дефис, апостроф и другие символы. Особые переменные выделяют штрихом или
звездочкой. Переходные коллекции встречаются редко, поэтому их считают особыми.

После \spverb|persistent!| коллекцию нельзя изменить. Следующий пример бросит
исключение:

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (persistent! params*)
  (assoc! params* :c 3))
;; IllegalAccessError: Transient used after persistent! call
  \end{clojure}
\end{english}

Форма \spverb|(persistent! <mutable>)|, как правило, замыкает блок с изменяемой
переменной.

Переходные коллекции помогают там, где нужен императивный подход. Выше мы
работали с деревом и \spverb|volatile| для аккумуляции данных. Перепишем код на
транзиентный вектор:

\begin{english}
  \begin{clojure}
(let [result* (transient [])
      push! (fn [item]
              (conj! result* item))]

  ;; see section 5.4 from the doc: http://...
  (when-let [a (some-> data :items first :result :value)]
    (when-let [b (some-> data :records last :usage)]
      (when (> a b)
        (push! (* a b)))))

  ;; more expressions
  (persistent! result*))
  \end{clojure}
\end{english}

Чтобы не писать каждый раз \spverb|(conj! result* item)|, мы
вводим локальную функцию \spverb|push!|. Она замкнута на \spverb|result*| и
принимает только значение. Чтобы добавить элемент, достаточно вызвать
\spverb|(push! x)|. Это сокращает код и скрывает реализацию.

\subsection{Итерация с изменением}

Мы говорили, что переходные коллекции быстрее постоянных. Это заметно на долгих
итерациях через \spverb|loop/recur|. Как правило, одна из переменных
\spverb|loop| это коллекция-результат. В каждом \spverb|recur| мы передаем ее
копию, дополненную через \spverb|conj| или \spverb|assoc|.

Когда итераций много, прибегают к уловке: вместо постоянной коллекции передают
ее транзиентный вариант. Этим код ускоряют в 2-4 раза. Изменения в коде малы,
нужно лишь учесть следующее:

\begin{itemize}

\item
  изменить тип коллекции на \spverb|(transient <coll>)|;

\item
  вместо \spverb|conj| или \spverb|assoc| вызывать их аналоги: \spverb|conj!|,
  \spverb|assoc!|;

\item
  в конце вернуть постоянную коллекцию через \spverb|persistent!|.

\end{itemize}

Для экспериментов объявим переменную \spverb|nums|, список из миллиона чисел:

\begin{english}
  \begin{clojure}
(def nums (range 999999))
  \end{clojure}
\end{english}

\noindent
Построим второй список обычным \spverb|loop|:

\begin{english}
  \begin{clojure}
(loop [result []
       [n & nums] nums]
  (if n
    (recur (conj result n) nums)
    result))
  \end{clojure}
\end{english}

\noindent
То же самое с изменяемым вектором:

\begin{english}
  \begin{clojure}
(loop [result* (transient [])
       [n & nums] nums]
  (if n
    (recur (conj! result* n) nums)
    (persistent! result*)))
  \end{clojure}
\end{english}

Число строк осталось прежним, изменилось имя переменной и некоторые
детали. Важно, что правки не выходят за пределы \spverb|loop|. Это дает свободу
действий. На ранних стадиях код пишут без изменяемых коллекций. Если скорость
критична, цикл улучшают так, что внутренние данные меняются.

Макрос \spverb|time| блок кода и печатает затраченное время. Если обернуть в
\spverb|time| оба примера, получим результаты:

\begin{english}
  \begin{text}
;; 166.688721 msecs
;;  69.415038 msecs
  \end{text}
\end{english}

Конкретные цифры зависят от оборудования и платформы, но разница в несколько раз
очевидна. Транзиентные коллекции действительно быстрее постоянных аналогов.

Ускорение работает и для \spverb|reduce|. В других языках эта функция называется
\spverb|fold| или <<свертка>>. Центральная точка в \spverb|reduce|~---
коллекция-аккумулятор. Строго говоря, аккумулятором может быть любой тип, в том
числе число или строка для сложения и конкатенации. Однако чаще всего это списки
и словари.

Различают два способа начать свертку. В первом роль аккумулятора играет
начальный элемент коллекции. Для списка \spverb|(1, 2, 3)| и функции сложения им
станет единица. Во втором аккумулятор задают отдельно, например пустым вектором,
куда в будущем запишут данные.

Идея в том, чтобы передать в аккумулятор изменяемую коллекцию. На каждом шаге
\spverb|reduce| изменяет ее функциями \spverb|conj!| и аналогами. Сравним
обычный \spverb|reduce|:

\begin{english}
  \begin{clojure}
(reduce
 (fn [result n]
   (conj result n))
 []
 nums)
  \end{clojure}
\end{english}

\noindent
и его мутабельную версию:

\begin{english}
  \begin{clojure}
(persistent!
 (reduce
  (fn [result* n]
    (conj! result* n))
  (transient [])
  nums))
  \end{clojure}
\end{english}

Второй \spverb|reduce| пришлось обернуть в \spverb|persistent!|. В случае с
\spverb|loop| мы втянули \spverb|persistent!| внутрь и тем самым изолировали
изменения. \spverb|Reduce| не такой гибкий в этом плане: в анонимной функции мы
не знаем, достигли мы конца итерации или нет. Без \spverb|persistent!| второй
пример вернет транзиентную коллекцию, что недоспустимо.

\subsection{Семантика и ограничения}

Изменяемые данные это продвинутая техника. Как только вы отказались от
постоянных коллекций, контроль за изменениями ложится на вас.

Выигрыш в скорости еще не значит, что их применяют на каждом шагу. Худшее, что
может сделать разработчик~--- написать код, где функции обмениваются такими
коллекциями. Если это ваш случай, задумайтесь, почему автор языка уделил так
много внимания неизменяемости. Будет ошибкой игнорировать его идеи.

Феномен, когда на раннем этапе пытаются выжать скорость, называется
преждевременной оптимизацией. Как заметил Дональд Кнут, это корень всех зол.
Занимаясь оптимизацией, задавайте себе вопросы. Действительно важно ускорить
этот цикл? Поможет ли это проекту или вы действуете из любопытства?

Изолируйте транзиентные коллекции в небольших функциях. Тогда переход от
постоянных типов к изменяемым не повлияет на результат. Рефакторинг должен
касаться только функции, а не ее потребителей.

Изменяемая коллекция не имеет право быть глобальной. Воздержитесь от определений
\spverb|(def users* (transient []))| и подобных. Вы придете к тому, что
\spverb|users*| станет буфером обмена между функциями. Результат такой функции
невозможно предсказать.

В отличии от атома, транзиентные типы не контроллируют обращение к ним из разных
потоков. Следите, чтобы только один поток изменял коллекцию. Не передавайте их в
футуры.

\section{Переменные и alter-var-root}

\label{alter-var-root}

Атомы и переходные коллекции меняют объект, а не переменную. Это не всегда то,
что мы ожидаем. Например, переменная \spverb|size| это атом:

\begin{english}
  \begin{clojure}
(def size (atom 0))
  \end{clojure}
\end{english}

Чтобы изменить его, вызовем \spverb|reset!| или \spverb|swap!| как в примерах
выше. Но переменная \spverb|size| всегда будет атомом. То же самое с переходными
коллекциями: к ним легко добавить и удалить элемент, но это будет та же самая
коллекция. Невозможно присвоить ей \spverb|nil|.

Иногда переменную нужно изменить: сделать так, чтобы сперва она была
\spverb|nil|, затем словарем, затем снова \spverb|nil|. Авторы намеренно
усложнили этот сценарий. Менять переменные можно, но нежелательно с точки зрения
языка.

Clojure не поощряет стиль Python или Java, когда переменную меняют много
раз. Глобальная переменная без уважительной причины~--- признак плохого кода.
Программист должен понимать, зачем она понадобилась и можно ли от нее
избавиться.

Все же бывают случаи, когда глобальные переменные полезны. Это система и monkey
patch. Разберем новые термины.

Проект на Clojure состоит из отдельных компонентов или доменов. Это веб-сервер,
база данных, очередь сообщений. Каждый домен помещают в свой модуль:
\spverb|http.clj|, \spverb|db.clj| и так далее.

Редко бывает так, что приложение работает с двумя базами или очередями. Поэтому
объявляют переменную, которая хранит состояние компонента. Например,
\spverb|server| в модуле сервера и \spverb|conn| в модуле базы. Возникает
проблема, как задать переменную. Начинающие допускают ошибку, когда инициируют
ее в лоб:

\begin{english}
  \begin{clojure}
(def server (jetty/run-jetty app {:port 8080}))
  \end{clojure}
\end{english}

Выражение запустит сервер при загрузке модуля. Это плохая практика, потому что в
загрузке не должно быть побочных эффектов. С таким кодом невозможно работать
REPL: он делает то, о чем не просили.

Сервер, базы данных и другие компоненты должны включаться по требованию. Поэтому
переменная \spverb|server| вначале равна \spverb|nil|. Функция \spverb|start!|
запускает сервер и записывает его в \spverb|server|. Функция \spverb|stop!|
останавливает и меняет переменную на \spverb|nil|.

\subsection{Понятие переменной}

\label{var-section}

Чтобы изменить \emph{переменную}, прибегают к \spverb|alter-var-root|. Функция
меняет объекты, которые задали в \spverb|def| и \spverb|defn|. Вызов похож на
\spverb|swap!| для атома: функция принимает объект \spverb|Var| и другую
функцию, которая вычислит новое значение на базе прежнего.

Рассмотрим, что такое \spverb|Var|. Это экземпляр класса \spverb|clojure.lang.Var|
из библиотеки Clojure. \spverb|Var| описывает переменную в пространстве имен.
Чтобы получить объект переменной, ее символ передают в макрос \spverb|var|,
например \spverb|(var server)|. Эта запись аналогична \spverb|#'server|,
что немного короче.

\emph{Символ} переменной и ее \emph{объект} это разные сущности. Сам по себе
символ ничего не значит: он равен только самому себе. Представьте, что символ
это слово языка, комбинация букв. В языке не бывает двух одинаковых слов, однако
у слова может быть несколько значений.

Символ это посредник между пространством имен и переменными. Когда мы пишем
\spverb|(def num 42)|, это не значит, что переменная \spverb|num| равна числу
42. На самом деле мы создали объект \spverb|Var| со значением 42. Затем
поместили его в текущее пространство под символом \spverb|num|.

Пространство имен работает как словарь. Ключи это символы, а значения
переменные. Формы \spverb|def| и \spverb|defn| наполняют этот словарь. Можно
сказать, что \spverb|def| задает слову смысл, и в момент компиляции Clojure
понимает это слово.

С символом связана операция \emph{вычисления}. Если в REPL ввести \spverb|num|,
он выполнит поиск с таким ключом в пространстве имен. Когда ключ найден, REPL
вернет значение переменной, в нашем случае 42. В противном случае возникнет
ошибка.

Clojure намеренно скрывает от нас стадию переменной, и это правильно. Если бы
выражение \spverb|num| вернуло переменную, в этом бы не было смысла. \spverb|Var|~---
не цифра, а сложный объект. Значение 42 это лишь одно из множества его полей.
Как правило, переменные скрыты от пользователя. Разработчик видит либо их символ
(\spverb|num|), либо значение (\spverb|42|). Функция \spverb|alter-var-root|~---
тот случай, когда переменные заявляют о себе.

\subsection{Запуск по требованию}

Вернемся к серверу. Объявим переменную, которая в будущем станет объектом
\spverb|jetty.server.Server|. По умолчанию это \spverb|nil|:

\begin{english}
  \begin{clojure}
(def server nil)
  \end{clojure}
\end{english}

Функция \spverb|start!| заменяет \spverb|server| результатом анонимной
функции. Она принимает текущее значение переменной. Когда это \spverb|nil|,
создаем и возвращаем новый сервер. Если нет, вернем текущий.

\begin{english}
  \begin{clojure}
(defn start! []
  (alter-var-root
   (var server)
   (fn [server]
     (if-not server
       (run-jetty app {:port 8080 :join? false})
       server))))
  \end{clojure}
\end{english}

\noindent
Аналогично работает \spverb|stop!|: если сервер включен (не \spverb|nil|),
остановим его и вернем \spverb|nil|.

\begin{english}
  \begin{clojure}
(defn stop! []
  (alter-var-root
   (var server)
   (fn [server]
     (when server
       (.stop server))
     nil)))
  \end{clojure}
\end{english}

Вызов \spverb|(start!)| запустит сервер в фоне. Браузер ответит на запросы по
адресу localhost:8080. Переменная \spverb|server| напечатает в REPL Java-объект
сервера.

Похожим образом работают с базой. Чтобы не открывать подключение на каждый
запрос, применяют пулы соединений. В модуле БД объявляют переменную
\spverb|pool| со значением \spverb|nil|. Функция \spverb|start!| создает новый
пул и обновляет переменную.

После старта к базе посылают запросы. Это функции \spverb|query|,
\spverb|update!| и другие из пакета \spverb|clojure.java.jdbc|. Первым
параметром они принимают подключение к базе или пул:

\begin{english}
  \begin{clojure}
(jdbc/query pool "select 1 as result")

(defn get-user-by-id [user-id]
  (jdbc/get-by-id pool :users user-id))
  \end{clojure}
\end{english}

Функция \spverb|stop!| выключает пул, закрывает соединения с базой и выставляет
\spverb|pool| в \spverb|nil|. Мы опустим код этих функций, потому что они
отличаются только именем глобальной переменной (\spverb|pool| вместо
\spverb|server|) и выражением, в котором создают сервер и пул.

\subsection{Коротко о системах}

\label{systems-intro}

Техника \spverb|alter-var-root| задает модулю состояние: включен и выключен. Это
удобно для разработки, когда нас интересует конкретная подсистема. Например, для
отладки базы не требуется веб-сервер, а кэширование не зависит от рассылки
писем.

То, что мы описали называют системой. Это набор компонентов, из которых состоит
приложение. С помощью \spverb|alter-var-root| строят системы в небольших
проектах. Как правило, это веб-приложение с сервером и базой данных. В шутку их
называют <<системами для бедных>>.

<<Бедные>> системы не зависят от сторонних библиотек. Каждый модуль выставляет
универсальные <<ручки управления>>: функции \spverb|start!| и \spverb|stop!|,
которые обращаются к \spverb|alter-var-root|. Это простая и удобная схема.

С другой стороны, <<бедные>> системы не знают, как один компонент зависит от
другого. Со временем зависимости становятся проблемой, поэтому большие системы
строят с помощью библиотек. Некоторые из них тоже опираются на
\spverb|alter-var-root|. Мы подробно рассмотрим системы в отдельной
главе \page{chapter-systems}.

\subsection{Патчинг}

Выше мы изменили переменную в текущем модуле. Истинная мощь
\spverb|alter-var-root| в том, что функция работает с переменными любого
пространства. Под любым мы понимаем:

\begin{itemize}

\item
  текущий модуль;

\item
  соседние модули проекта;

\item
  сторонние библиотеки;

\item
  стандартные модули Сlojure, например \spverb|clojure.core|.

\end{itemize}

С помощью \spverb|alter-var-root| можно повлиять на любую точку проекта. В том
числе вторгнуться в чужие модули и даже те, что идут в поставке с Clojure!

Это мощная техника, но к ней прибегают редко. Менять код в полете считается
сомнительной практикой. По-другому ее называют <<monkey
patch>>\footurl{https://en.wikipedia.org/wiki/Monkey\_patch}. Термин означает
изменение классов и функций не на уровне кода, а когда программа уже запущена.

Если патчингом злоупотребляют, программа ведет себя неочевидным
образом. Коллегам будет трудно понять, почему в коде написано одно, а
выполняется другое. Это затрудняет поддержку проекта, вносит раздражение в
работу.

К патчингу прибегают, если сошлись несколько условий:

\begin{itemize}

\item
  без изменений нельзя двигаться дальше;

\item
  проблема не в нашем коде, а в сторонней библиотеке или платформе;

\item
  на устранение проблемы уйдет время.

\end{itemize}

Патчинг оправдан, когда вы нашли ошибку в чужой библиотеке. Даже если изменения
примут сразу, выпуск новой версии случится займет время. Если ошибка задерживает
выпуск продукта, подмените проблемную функцию с помощью \spverb|alter-var-root|.

Представим, условная библиотека \spverb|yamler| парсит файлы YAML. Функция
\spverb|read-yaml-tag| отвечает за теги. Выяснилось, что в разбор тегов
закралась ошибка, а нам нужно расставить их файле. Если ошибку легко исправить,
напишем функцию со звездочкой и заменим оригинал:

\begin{english}
  \begin{clojure}
(defn read-yaml-tag* [stream tag]
  ...)

(alter-var-root
 (var yamler.tags/read-yaml-tag)
 (constantly read-yaml-tag*))
  \end{clojure}
\end{english}

Добавьте комментарий с ссылкой на артефакт (GitHub, Jira). Создайте задачу,
чтобы удалить патч по выходу новой версии библиотеки.

Патчинг полезен и в разработке. Данные часто печатают на экран, чтобы
исследовать их. Недостаток \spverb|println| в том, что ее вывод не
структурирован. Коллекции слипаются, их трудно читать.

Пакет \spverb|clojure.pprint| (сокращение от анг. pretty printing) решает эту
проблему. Функция \spverb|pprint| выводит данные с отступами и переносами строк,
что удобно для вложенных словарей. Но писать \spverb|(clojure.pprint/pprint data)|
вместо \spverb|(println data)| долго. Чтобы сократить код, заменим \spverb|println|
на \spverb|pprint|. Пропатчим функцию следующим образом:

\begin{english}
  \begin{clojure}
(require 'clojure.pprint)

(alter-var-root
 (var println)
 (constantly clojure.pprint/pprint))
  \end{clojure}
\end{english}

Выполните этот патч один раз в любом месте проекта. Теперь вызов
\spverb|(println data)| напечатает данные так, как это делает \spverb|pprint|:

\begin{english}
  \begin{clojure}
(println <vector-of-dicts-of-vectors>)

[{:foo 42, :bar [1 2 3 4 5 {:foo 42, :bar [1 2 {#, #}]}]}
 {:foo 42, :bar [1 2 {:foo 42, :bar [1 2 {#, #}]}]}]
  \end{clojure}
\end{english}

Функция заменяет вложенные участки на символ \spverb|#|, чтобы не обрушить на
вас лавину данных. На глубину и длину печати влияют особые переменные. Позже мы
узнаем, как управлять ими.

\subsection{В боевом режиме}

\label{install-logger}

Рассмотрим, когда \spverb|alter-var-root| полезен в промышленном запуске. В
главе об исключениях мы отметили проблему: макросы \spverb|log/info|,
\spverb|log/error| и другие принимают исключение \page{log-ex-param}. У нас нет
контроля за тем, как выглядит исключение в логе. Длина трейса и цепочка
исключений отличаются в зависимости от бекенда (log4j, Logback и другие).

Мы написали функцию \spverb|ex-print|, которая печатает исключение как нужно
нам. Функция не вываливает стек-трейс на весь экран, а обходит цепочку для
каждого звена печатает класс, сообщение и контекст:

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

\noindent
Минус в том, что вместо \spverb|(log/error e)| приходится писать:

\begin{english}
  \begin{clojure}
(log/error (with-out-str (ex-print e)))
  \end{clojure}
\end{english}

Это долго и вынуждает импортировать \spverb|ex-print| в каждый модуль, где пишут
исключения. Будет удобней, если мы оставим \spverb|(log/error e)|, а
\spverb|ex-print| сработает где-то за кадром. Это возможно с помощью
\spverb|alter-var-root|.

Заметим, что \spverb|log/error|, \spverb|log/info| и аналоги это не функции, а
макросы. Макрос это эфемерная сущность, на которую нельзя сослаться через
\spverb|var|. Макрос живет \emph{до} компиляции программы; позже на его месте
остается код, который он произвел. Нельзя изменить макрос, но можно подменить
функции, которые он вызывает.

Макросы \spverb|log/error| и другие сводится к функции \spverb|log/log*|. Это
бутылочное горлышко, через которое проходят все логи. Вот как выглядит ее
сигнатура:

\begin{english}
  \begin{clojure}
(defn log* [logger level throwable message])
  \end{clojure}
\end{english}

Параметр \spverb|throwable| это исключение или \spverb|nil|. Подменим
\spverb|log*| на анонимную функцию со следующей логикой:

\begin{itemize}

\item
  если \spverb|throwable| не \spverb|nil|, перевести исключение в текст;

\item
  добавить его к исходному сообщению через перенос строки;

\item
  вызвать в оригинальный \spverb|log*| с новым сообщением и \spverb|nil| для
  \spverb|throwable|. В нем отпала потребность, поскольку мы сделали его частью
  сообщения.

\item
  если \spverb|throwable| был \spverb|nil|, вызвать \spverb|log*| с исходными
  аргументами.

\end{itemize}

\noindent
Реализация:

\begin{english}
  \begin{clojure}
(defn install-better-logging []
  (alter-var-root
   (var clojure.tools.logging/log*)
   (fn [log*] ;; the origin function
     (fn [logger level throwable message]
       (if throwable
         (let [ex-out (with-out-str (ex-print throwable))
               message* (str message \newline ex-out)]
           (log* logger level nil message*))
         (log* logger level throwable message))))))
  \end{clojure}
\end{english}

Хитрость кроется в строке с комментарием. Анонимная функция в
\spverb|alter-var-root| принимает текущее значение переменной. Это исходная
функция \spverb|clojure.tools.logging/log*|, и параметр \spverb|log*| ссылается
на нее. Новая функция замкнута на \spverb|log*| и может ее вызывать.

Получился декоратор: новая версия \spverb|log*| меняет входные параметры и
вызывает старую функцию. После вызова \spverb|(install-better-logging)| вывод
исключений изменится. Достаточно написать \spverb|(log/error e)|, чтобы ошибка
приняла нужный вид.

Преимущество в том, что мы управляем всем на уровне Clojure. Если нужно улучшить
логи, доработаем \spverb|ex-print| в любой момент. Это удобнее, чем наследовать
условный класс \spverb|com.logging.ThrowableRenderer| и переопределять методы.

Вред от необдуманного \spverb|alter-var-root| сводит на нет плюсы, что мы
рассмотрели. Функция нужна, чтобы точечно менять переменные в особых
случаях. Прибегайте к патчингу только если другие варианты исчерпаны.

\section{Немного о set!}

Вернемся к функции \spverb|pprint| для красивой печати. Она интересна тем, что
проверяет длину и уровень коллекций. Так мы не допустим ситуации, когда вывод
заливают несколько экранов. Проверка на длину особенно важна, потому что
некоторые коллекции не просто велики, а \emph{бесконечны}.

Длину и вложенность вывода задают глобальные переменные \spverb|*print-length*|
и \spverb|*print-level*|. По умолчанию \spverb|*print-length*| равен 100. Это
довольно много, особенно если учесть, что элементами могут быть другие
коллекции. Например, результат запроса к базе это список словарей. Печатать сто
словарей расточительно, поэтому уменьшим \spverb|*print-length*| на старте
приложения. Для этого служит форма \spverb|set!|:

\begin{english}
  \begin{clojure}
(set! *print-length* 8)
  \end{clojure}
\end{english}

\noindent
Печать бесконечной коллекции покажет только первые 8 элементов:

\begin{english}
  \begin{clojure}
(println (repeat 1))
;; (1 1 1 1 1 1 1 1 ...)
  \end{clojure}
\end{english}

\noindent
Многоточие означает, что остальные элементы отбросили.

Вложенность или уровень коллекции это воображаемый индекс. Когда одна коллекция
становится элементом другой, ее индекс увеличивается на единицу. Объявим
вложенную структуру:

\begin{english}
  \begin{clojure}
(def data {:foo {:bar {:baz [42]}}})
  \end{clojure}
\end{english}

\noindent
Вывод при разных значениях \spverb|*print-level*|:

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
;; {:foo {:bar #}}

(set! *print-level* 2)
(println data)
;; {:foo #}
  \end{clojure}
\end{english}

\noindent
При нулевом уровне увидим только \spverb|#|.

В Clojure около десяти переменных с <<ушками>>. По другому их называют
системными, потому что они влияют на поведение языка в целом. Две переменных мы
уже рассмотрели: это \spverb|*print-length*| и \spverb|*print-level*| для
печати. Перечислим несколько других:

\begin{itemize}

\item
  \spverb|*warn-on-reflection*|: если истина, компилятор предупреждает о тех
  местах, где он обратился к рефлексии. Проблему решают расстановкой тегов с
  типами.

\item
  \spverb|*assert*|: если ложь, отключает \spverb|assert|-макрос. Форма \spverb|assert|
  проверяет выражение на истинность. Когда оно ложно, макрос бросает исключение.
  По умолчанию \spverb|assert|ы включены; ими пользуются в разработке и тестировании.
  В боевом режиме их выключают, чтобы не тратить ресурсы.

\item
  \spverb|*in*|, \spverb|*out*|: каналы стандартного ввода и вывода. Это объекты
  \spverb|Reader| и \spverb|Writer|, откуда JVM читает и пишет данные.

\end{itemize}

Эти и другие переменные изменяют формой \spverb|set!|. Значение зависит от
семантики переменной. Рассмотрим несколько примеров.

Показать предупреждения, если компилятор не вывел тип:

\begin{english}
  \begin{clojure}
(set! *warn-on-reflection* true)
(def ms (System/currentTimeMillis))
(.toString ms)       ;; reflection warning
(.toString ^Long ms) ;; no warning
  \end{clojure}
\end{english}

Отключить формы \spverb|assert|. Ложные выражения не вызовут ошибку:

\begin{english}
  \begin{clojure}
(set! *assert* false)
(assert (get {:foo 42} :bar))
;; won't throw an exception
  \end{clojure}
\end{english}

Утилиты для управления проектами читают переменые с <<ушками>> из
словаря. Конфигурация \spverb|lein| учитывает ключ \spverb|:global-vars|. Еще
большей гибкости можно добиться, если указать переменные в профилях. Ниже мы
задаем разные переменные в зависимости от режима разработки (dev) и сборки
(uberjar).

\begin{english}
  \begin{clojure}
{:profiles
 :dev {:global-vars {*warn-on-reflection* true
                     *assert* true}}
 :uberjar {:global-vars {*warn-on-reflection* false
                         *assert* false}}}
  \end{clojure}
\end{english}

С помощью \spverb|set!| нельзя изменить свои переменные, даже если они с
<<ушками>> и помечены как динамические. Пример ниже бросит исключение:

\begin{english}
  \begin{clojure}
(def ^:dynaimc *data* nil)
(set! *data* {:user 1})
;; Unhandled java.lang.IllegalStateException
;; Can't change/establish root binding of: *data* with set
  \end{clojure}
\end{english}

\section{Изменения в контексте}

Приемы, которые мы рассмотрели, похожи в следующем: их эффект длится до конца
программы. Изменения в атомах, транзиентных коллекциях и глобальных переменных
называют \emph{персистентными} (анг. persistent~--- постоянный).

Иногда изменения должны быть временными: глобальная переменная равна $x$, но
участок кода ожидает $y$. Можно сделать временные изменения на базе постоянных:
окружить код вызовом \spverb|alter-var-root| с новым и старым значениями. У
такого подхода две проблемы: изоляция и откат.

Временные изменения протекают в одном потоке. Эффект \spverb|alter-var-root|
противоположный~--- функция меняет переменную для всех потоков. Если фрагмент
кода вызывает \spverb|alter-var-root| для своих нужд, он задевает всех
участников. Это приводит к странному поведению программы.

Проблема отката означает, при выходе из участка переменную нужно вернуть в
прежнее состояние. Прием, когда код оборачивают в \spverb|alter-var-root| или
\spverb|set!| плох тем, что одна из форм может потеряться. И снова странное
поведение и часы отладки.

С этого момента мы займемся временным изменением данных. Clojure предлагает
несколько форм, чтобы выполнить код в контексте переменных с новым
значением. Одна из них это \spverb|binding| \eng{связывание}.

Синтаксис \spverb|binding| похож на \spverb|let|: это форма связывания и
произвольный код. Связывание это вектор, где указаны символы переменных и новые
значения. Символы ссылаются на уже объявленные переменные. Блок кода запускается
с новыми значениями у переменных. Результат \spverb|binding| это последнее
выражение блока. Изменения \spverb|binding| протекают в рамках текущего потока и
не влияют на соседние. При выходе переменные получат старые значения.

\subsection{Динамические переменные}

\label{dynamic-vars}

\spverb|Binding| работает только с динамическими переменными. Компилятор считает
переменную таковой, если ей назначили тег \spverb|^:dynamic|. Это сокращенная
форма \spverb|^{:dynamic true}|:

\begin{english}
  \begin{clojure}
(def ^:dynamic *server* nil)
;; or
(def ^{:dynamic true} *server* nil)
  \end{clojure}
\end{english}

Словарь с крышкой в \spverb|def| называют метаданными. Это дополнительные
параметры будущей переменной. В данном случае мы сообщаем компилятору, что
переменная динамическая и может быть изменена в будущем.

Глобальные переменные принято выделять <<ушками>>, звездочками по краям. В
английском языке такую запись называют <<earmuffs syntax>>. Правило возникло в
старых Lisp-системах, и Clojure следует традиции.

Ушки и динамичность связаны между собой. Если переменная с ушками, но не
динамическая, компилятор скажет о расхождении. Сами по себе ушки не делают
переменную динамической, это просто соглашение.

\begin{english}
  \begin{clojure}
(def *server* nil)
;; Warning: *server* not declared dynamic and thus [...]
;; Please either indicate ^:dynamic *server* or change the name.
  \end{clojure}
\end{english}

Если переменная не динамическая, \spverb|binding| бросит исключение:

\begin{english}
  \begin{clojure}
(binding [*server* {:port 8080}]
  (println *server*))
;; Execution error (IllegalStateException)
;; Can't dynamically bind non-dynamic var: *server*
  \end{clojure}
\end{english}

\subsection{Отказ от set!}

Вспомним ограничения на длину и глубину печати. Чтобы обезапасить себя от
больших данных, мы писали что-то похожее:

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
  \end{clojure}
\end{english}

Это неудачный пример: он нарушает принципы изоляции и отката, которые мы
рассмотрели. Изменение \spverb|*print-level*| не изолировано и влияет на систему
глобально. Если другой поток что-то напечатает, мы увидим результат с уровнем 4,
что может нас не устроить. Сразу после \spverb|(println data)| нужно
восстановить прежнее значение \spverb|*print-level*|, но об этом легко забыть.

Код ниже избавлен от недостатков. Вне \spverb|binding| переменные получат
прежние значения, а соседние потоки ничего не заметят.

\begin{english}
  \begin{clojure}
(binding [*print-level* 8
          *print-length* 4]
  (println {:foo {:bar {:baz (repeat 1)}}}))
;; {:foo {:bar {:baz (1 1 1 1 ...)}}}
  \end{clojure}
\end{english}

Чтобы направить печать в файл, свяжите переменную \spverb|*out*| с объектом
\spverb|Writer|:

\begin{english}
  \begin{clojure}
(with-open [out (io/writer "dump.edn")]
  (binding [*out* out]
    (clojure.pprint/pprint {:test 42})))
  \end{clojure}
\end{english}

Объединим эти примеры в функцию для сброса данных в файл. Функция полезна для
отладки больших данных. Она принимает путь к файлу и коллекцию. Внутри функция
связывает вывод с открытым файлом и печатает данные. Чтобы увидеть все элементы,
повысим лимиты на печать.

\begin{english}
  \begin{clojure}
(defn dump-data
  [path data]
  (with-open [out (io/writer path)]
    (binding [*out* out
              *print-level* 32
              *print-length* 512]
      (clojure.pprint/pprint data))))
  \end{clojure}
\end{english}

\noindent
Сброс данных в файл:

\begin{english}
  \begin{clojure}
(dump-data "sample.edn" {:foo [1 2 3 {:foo [1 2 3]}]})
  \end{clojure}
\end{english}

\noindent
и восстановление:

\begin{english}
  \begin{clojure}
(-> "sample.edn" slurp read-string)
;; {:foo [1 2 3 {:foo [1 2 3]}]}
  \end{clojure}
\end{english}

Доработайте функцию так, чтобы можно было задать \spverb|*print-level*| и
\spverb|*print-length*|. В идеале это необязательный словарь \spverb|opt|, в
котором функция ищет настройки.

\subsection{Практика: перевод строк}

Приведем пример с \spverb|binding| из реального проекта. Это веб-приложение с на
разных языках. В зависимости от настроек клиент видит текст на английском или
русском языках.

Перевод текста хранят в виде словаря. В нем два уровния: \emph{локаль} и
\emph{теги}. Локаль это код языка: \spverb|ru| и \spverb|en| другие. Локаль
может состоять из доменов с подчеркиванием или дефисом, например \spverb|en_US|
или \spverb|en_GB|. В данном случае \spverb|US| и \spverb|GB| означают
американский и британский виды английского. В восточных языках встречается
тройная вложенность доменов, чтобы обозначить локальный диалект провинции.

Под тегом понимают короткую машинную строку. Она описывает семантику фразы, на
которую позже ее заменят. Например, по тегу \spverb|ui/add-to-cart| легко
угадать, что это надпись <<добавить в корзину>>.

В зависимости от библиотеки словари хранят в коде или файлах. Но принцип
перевода прежний: по локали и тегу библиотека ищет перевод в словаре (еще
говорят <<совершает lookup>>). Напишем наивный подход на Clojure:

%% \begin{english}
  \begin{clojure}
(def tr-map
  {:en {:ui/add-to-cart "Add to Cart"}
   :ru {:ui/add-to-cart "Добавить в корзину"}})

(defn tr [locale tag]
  (or (get-in tr-map [locale tag])
      (format "<%s%s>" locale tag)))
  \end{clojure}
%% \end{english}

Функция \spverb|tr| возвращает перевод то локали и тегу. Если перевод не найден,
получим машинное выражение \spverb|<:en:ui/sign-in>|.

Недостаток функции в том, что каждый раз нужно указывать локаль. Это
утомительно, особенно с учетом того, что локаль не меняется в рамках
запроса. Между вычислением локали и переводом большая физическая и ментальная
дистанция, и хотелось бы ее сократить.

Под физическим расстоянием понимают стек вызовов. Обычно локаль вычисляют в
middleware на вершине запроса. Перевод текста, напротив, работает внизу на
уровне страницы. Если не сделать локаль глобальной, придется спускать ее в
аргументах по стеку вызовов, что усложняет код.

Ментальная дистанция означает, что в момент перевода нам не важно, откуда пришла
локаль. Эти сведения избыточны. Хотелось бы, чтобы в коде была примитивная
операция <<перевести тег>>, и не больше. Польза такого упрощения видна на
примере шаблонной системы, устроенной по принципу
Django\footurl{https://docs.djangoproject.com/en/2.2/topics/templates/}.

Аналог такой системы в Clojure называется
Selmer\footurl{https://github.com/yogthos/Selmer}. Его шаблоны похожи на обычные
HTML-файлы со вставками в фигурных скобках. Код в скобках это значения или
выражения. Вертикальные линии отделяют фильтры. Например, запись:

\begin{english}
  \begin{htmldjango}
<p>{{ user.email|lower }}</p>
  \end{htmldjango}
\end{english}

\noindent
означает, что между тегами параграфа находится поле \spverb|:email| из словаря
\spverb|user|. Регистр поля меняют на нижний фильтром \spverb|lower|. То же
самое на Clojure:

\begin{english}
  \begin{clojure}
(str/lower-case (:name user))
  \end{clojure}
\end{english}

Фильтром может быть любая функция, в том числе наша \spverb|tr|. Хотелось бы,
чтобы шаблон выглядел как можно просто:

\begin{english}
  \begin{htmldjango}
<div class="widget">
  <a href="/login">{{ "ui/log-in"|tr }}</a>
  <a href="/help">{{ "ui/help"|tr }}</a>
</div>
  \end{htmldjango}
\end{english}

Фильтр \spverb|tr| это функциея одной переменной. Она принимает строку тега и
возвращает перевод. Очевидно, локаль должна быть известна заранее. Сделаем так,
фильтр читал ее из middleware, и при этом не влиял на перевод в параллельных
запросах.

Поможет связывание через \spverb|binding|. Определим переменную
\spverb|*locale*| без значения. В Clojure такая переменная называется
несвязанной. Считайте ее ячейкой, в которой нет данных.

Изменим функцию \spverb|tr|: теперь она принимает только тег, а в качестве
локали ссылается на глобальную \spverb|*locale*|:

\begin{english}
  \begin{clojure}
(def ^:dynamic *locale*)

(defn tr [tag]
  (get-in tr-map [*locale* tag]))
  \end{clojure}
\end{english}

Чтобы изолировать \spverb|*locale*| от внешнего кода, предоставим макрос
\spverb|with-locale|. Он выполняет тело, пока переменная связана с заданной
локалью. Любой перевод внутри макроса сработает для этой локали:

%% \begin{english}
  \begin{clojure}
(defmacro with-locale
  [locale & body]
  `(binding [*locale* ~locale]
     ~@body))

(with-locale :en
  (tr :ui/add-to-cart))
;; "Add to Cart"

(with-locale :ru
  (tr :ui/add-to-cart))
;; "Добавить в корзину"
  \end{clojure}
%% \end{english}

Напишем middleware, чтобы определить локаль. Для простоты решим, что это
параметр \spverb|lang| из адресной строки. Если параметра нет, берем локаль по
умолчанию. Код ниже по стеку обернут в макрос \spverb|with-locale|:

\begin{english}
  \begin{clojure}
(defn wrap-locale [handler]
  (fn [request]
    (let [locale (get-in request [:params "lang"])
          locale (if locale
                   (keyword locale)
                   :en)]
      (with-locale locale
        (handler request)))))
  \end{clojure}
\end{english}

Напишем фильтр \spverb|tr| для шаблонов. В Selmer нельзя указать кейворд,
поэтому вместо \spverb|{{ :ui/sign-in }}| пишут \spverb|{{ "ui/sign-in"}}|.
Фильтр \spverb|tr| переводит строку в ключ, а затем ищет по нему
перевод. Функция \spverb|add-filter!| добавляет \spverb|tr| в регистр фильтров.

\begin{english}
  \begin{clojure}
(require '[selmer.filters :refer [add-filter!]])

(add-filter! :tr
 (fn [line]
   (-> line keyword tr)))
  \end{clojure}
\end{english}

Нам не важен источник локали в переводах. В любой момент мы изменим код
\spverb|with-locale| и \spverb|wrap-locale|, но это не отразится на
шаблонах. Запись \spverb={{ "ui/log-in"|tr }}= останется прежней, даже если
механизм переводов изменится.

\section{Локальные переменные в контексте}

Макрос \spverb|with-local-vars| задает локальные переменные. Внутри макроса они
ведут себя как маленькие атомы. В переменную можно записать значение и
<<дерефнуть>>, чтобы его получить. Локальные переменные полезны для запутанной
бизнес-логики. Блок с ними выглядит линейно, его проще читать.

Форма \spverb|with-local-vars| похожа на \spverb|let|: это вектор связывания и
произвольный код. Разница в том, что внутри макроса работают функции
\spverb|var-get| и \spverb|var-set|. С их помощью переменые читают и
записывают. Например, если макрос задал переменную \spverb|a|, форма
\spverb|(var-set a 9)| установит ее содержимое в 9.

Важно: символ переменной вернет ее \emph{объект}, а не значение. В примере ниже
получим не ноль, а объект типа \spverb|Var|. Запись \spverb|(+ a 1)| приведет к
ошибке приведения типов.

\begin{english}
  \begin{clojure}
(with-local-vars [a 0] a)
;; #<Var: --unnamed-->
  \end{clojure}
\end{english}

Функция \spverb|var-get| получает значение из переменной. Для краткости
прибегают к оператору \spverb|@|: \spverb|(+ @a 1)|.

Представим, в дереве данных нужно найти несколько величин и вернуть их
композицию: сумму, произведение или выражение. В прошлый раз мы работали с
атомом, теперь решим задачу на локальных переменных.

Функция \spverb|calc-billing| рассчитывает сумму к оплате для клиента. Параметр
\spverb|data| это данные о потреблении ресурсов. Итоговую сумму находят из трех
составляющих. Каждую из них рассчитывают по сложным условиям. Чтобы код был
ближе к бизнес-логике, запишем его императивно:

\begin{english}
  \begin{clojure}
(defn calc-billing [data]
  (with-local-vars
    [a 0 b 0 c 0]
    ;; find a
    (when-let [usage ...]
      (when-let [days ...]
        (var-set a (* usage days))))
    ;; find b
    (when-let [vms ...]
      (when-let [limits ...]
        (var-set b (* limits vms))))
    ;; find c ...
    (+ (* @a @b) @c)))
  \end{clojure}
\end{english}

Расчет делится на три блока, каждый из которых считает составляющую. Каскад
\spverb|when-let| собирает переменные, и если они нашлись, завершается
\spverb|var-set|. Если исполнение не дошло до \spverb|var-set|, переменная
останется с первоначальным значением.

Локальные переменные не настолько продвинуты как атомы. Для переменных нет
аналога \spverb|swap!|, когда значение меняют функцией. Поэтому
\spverb|with-local-vars| не подходит для наращивания коллекций. Если
\spverb|user| это локальный словарь, добавить к нему новое поле будет
трудно. Функция \spverb|var-set| может задать только новый словарь, но
комбинация \spverb|var-set| и \spverb|var-get| выглядит неуклюже:

\begin{english}
  \begin{clojure}
(with-local-vars [user {:name "Ivan"}]
  ;; (var-set user assoc :age 33) ;; won't work
  (var-set user (assoc @user :age 33)) ;; ugly
  @user)
  \end{clojure}
\end{english}

Макросом \spverb|with-local-vars| пользуются, когда сложная логика завязана на
простых типах (числах, строках). На локальных переменных удобно писать конечные
автоматы и алгоритмы с состоянием. Техника редко встречается в Clojure, но в
нужный момент экономит время и код.

\section{Глобальные изменения в контексте}

\label{with-redefs}

Преимущество \spverb|binding| в том, что изменения протекают только в текущем
потоке. Говорят, что эффект \spverb|binding| потокобезопасный, что расценивают
как благо. И вс\"{е} же бывают случаи, когда изменения должны быть глобальными. Для
этого служит форма \spverb|with-redefs|.

Ее синтаксис похож \spverb|binding|: вектор связывания и произвольный блок
кода. Эффект \spverb|with-redefs| действует на все потоки. Представим
веб-сервер, который отвечает на запросы параллельно. Если одна из страниц
выполняет часть логики в \spverb|with-redefs|, это повлияет на соседние
запросы. Аналогично \spverb|binding| и \spverb|let|, изменения откатываются при
выходе из макроса.

Пример ниже объясняет принципы \spverb|with-redefs|. Мы подменяем функцию
\spverb|println| на суррогат, который печатает фиксированный текст. В теле
макроса запускают футуру с телом \spverb|(println 42)|.

Футура (или \emph{фьючер}, анг. \emph{future}, будущее) это объект из области
многопоточности. Футура принимает блок кода и исполняет его в пуле
тредов. Каждый тред не завершается, а только помечается как занятый или
свободный. Если тред свободен, он принимает код футуры, исполняет его и
возвращает результат. Футура это посредник между клиентом и многопоточностью.

Тело \spverb|(println 42)| будет выполнено в другом потоке. Оператор \spverb|@|
перед футурой означает ждать до тех пор, пока не придет результат из пула. Код
ниже напечатает <<fake print>>:

\begin{english}
  \begin{clojure}
(with-redefs
  [println (constantly (print "fake print"))]
  @(future (println 42)))
;; fake print
  \end{clojure}
\end{english}

Это произошло потому, что \spverb|with-redefs| повлиял в том числе и на тот
поток, в котором пул выполнил футуру.

Если убрать оператор \spverb|@|, эффект \spverb|with-redefs| пропадет: футура
напечатает 42. Причина в том, цикл футуры занимает хоть и малое, но время. Без
оператора \spverb|@| мы только запускаем футуру и сразу выходим из
\spverb|with-redefs|. Пул доберется до задачи \spverb|(println 42)| когда уже
эффект макроса закончится.

Документация \spverb|with-redefs| подчеркивает, что макрос полезен при
тестировании. Иногда приложение опирается на сторонние сервисы: геопоиск или
граф социальных связей. При тестировании возникает проблема доступа к этим
сервисам. Нельзя допустить, чтобы на каждый запуск приложение обращалось к
настоящему ресурсу. Это усложняет тесты, расходует квоты на доступ.

Идея в том, чтобы на время тестов подменить функции, которые обращаются в
сеть. Рассмотрим на практике, как это сделать.

\subsection{Практика: приложение с координатами}

Мобильное приложение шлет на сервер координаты пользователя. Это пара чисел:
долгота и широта. Позже пользователь изучает историю путешествий. Очевидно, он
ожидает не машинные цифры, а названия мест и фотографии. Для каждой пары
координат нужно найти данные об этом месте.

Страница \spverb|POST /location| принимает коорданаты в JSON-теле запроса. Чтобы
узнать данные о месте, мы обращаемся к стороннему геосервису. Извлекаем из
ответа поля и пишем в базу вместе с координатами. Возвращаем ответ \spverb|200 OK|.

Функция \spverb|geo/place-info| выполняет геопоиск. Считаем, что на выходе
словарь с ключами \spverb|:title|, \spverb|:country|, \spverb|:image_url| и
другими. Запишем эти поля и координаты в базу.

\begin{english}
  \begin{clojure}
(defn location-handler [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        place (geo/place-info point)]
    (db/create-location (merge place point))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

Во время поиска мобильное приложение ждет ответа. С машинной точки зрения это
долго, ведь сеть не гарантирует мгновенный отклик. Чем больше клиентов шлют
координаты на сервер, тем больше запросов мы посылаем геосервис. Растет число
открытых соединений, система замедляется.

Быстрое решение в том, чтобы записать координаты в базу и сразу же ответить
клиенту, а сбор данных о месте вынести в футуру. Тем самым мы сократим время
ожидания. Теперь приложение ждет только запись в базу, что быстрее, чем запрос в
сеть.

В новой версии функция \spverb|db/create-point| пишет коорданаты и возвращает
\spverb|id| новой записи. Ключ нужен, чтобы позже обновить локацию данными о
месте. Поиск данных и запись в базу протекают в футуре.

\begin{english}
  \begin{clojure}
(defn location-handler
  [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        row-id (db/create-point point)]
    (future
      (let [place (geo/place-info point)]
        (db/update-place row-id place)))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

Возможны и другие варианты: фоновый обработчик или очередь задач. Но они дольше
в реализации, а футура займет лишь три строки. Это дешевое временное решение,
которое даст время на поиск оптимального.

\subsection{Тесты}

Напишем тест для нового обработчика. Чтобы не порождать сетевых запросов,
временно заменим функцию \spverb|geo/place-info|. Для полноты картины проверим,
что случится, если \spverb|geo/place-info| бросит исключение.

Каждый тест начинается с выражения \spverb|with-redefs| для замены
\spverb|geo/place-info|. Чтобы уменьшить код, напишем макрос
\spverb|with-place-info|. Он принимает тело функции и блок кода:

\begin{english}
  \begin{clojure}
(defmacro with-place-info
  [result & body]
  `(with-redefs [geo/place-info
                 (fn [~'point] ~result)]
     ~@body))
  \end{clojure}
\end{english}

Вот как выглядит тест для положительного сценария. В макросе
\spverb|with-place-info| геопоиск вернет заданный словарь. Мы вызываем
обработчик и проверяем, что ответ положительный. Чтобы убедиться, что футура
записала данные в базу, немного ждем и читаем последнюю локацию. В ней должны
быть значения из геопоиска.

\begin{english}
  \begin{clojure}
(deftest test-place-ok
  (with-place-info
    {:title "test_title"
     :country "test_country"}
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location (db/get-last-location)
            {:keys [title country]} location]
        (is (= "test_title" title))
        (is (= "test_country" country))))))
  \end{clojure}
\end{english}

Негативный сценарий: пусть геопоиск бросит исключение с кодом 429. Такое
возможно, если превышен лимит на число запросов. Объявим исключение:

\begin{english}
  \begin{clojure}
(def ex-quota
  (ex-info "429 Quota reached"
           {:status 429
            :body {:error_code :QUOTA_REACHED
                   :error_message "..."}}))
  \end{clojure}
\end{english}

\noindent
Напишем тест. Проверим, что приложение вернет положительный статус, но в базе
нет данных о месте, потому что запрос не удался.

\begin{english}
  \begin{clojure}
(deftest test-place-quota-reached
  (with-place-info (throw ex-quota)
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status body]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location (db/get-last-location)
            {:keys [title country]} location]
        (is (nil? title))
        (is (nil? country))))))
  \end{clojure}
\end{english}

С помощью \spverb|with-place-info| можно задать любое исключение. Это полезно,
если \spverb|try/catch| ожидают конкретные классы. Пример ниже имитирует сбой в
сети:

\begin{english}
  \begin{clojure}
(deftest test-place-conn-err
  (with-place-info
    (throw (new java.net.ConnectException "test_timeout"))
    ...))
  \end{clojure}
\end{english}

Подмена функций и классов называется \emph{мок} или \emph{мокинг} (анг. mock~---
подделка). Позже мы рассмотрим тесты подробнее и познакомимся с другими
техниками \page{chapter-tests}. Пока что заметим, что макрос
\spverb|with-redefs| это простой способ что-то <<замокать>>, то есть подменить
на время тестов.

\subsection{Коротко о with-redefs-fn}

Макрос \spverb|with-redefs| это улучшенный вариант формы
\spverb|with-redefs-fn|. Отличие в синтаксисе: если \spverb|with-redefs| похож
на \spverb|let|, то \spverb|with-redefs-fn| принимает словарь и функцию без
аргументов. Ключи словаря это объекты \spverb|Var|. Функция запускается в
момент, когда каждая переменная получит новое значение.

Перепишем пример с \spverb|geo/place-info| на новый макрос. Напомним, что запись
\spverb|#'<something>| аналогична \spverb|(var <something>)|:

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  (fn []
    (geo/place-info {:lat 1 :lon 2})))
  \end{clojure}
\end{english}

Если тело макроса это одна большая форма, например, \spverb|let|, то не
обязательно оборачивать ее в \spverb|(fn [])|. Поставьте спереди знак
\spverb|#|, чтобы превратить форму в анонимную функцию.

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  #(let [point {:lat 1 :lon 2}
         place (geo/place-info point)]
     ...))
  \end{clojure}
\end{english}

Синтаксис \spverb|with-redefs-fn| выглядит непривычно из-за словаря и символов
\spverb|#'|. Легко забыть, что тело это не произвольный блок кода, а
функция. Макрос непохож на аналоги \spverb|let|, \spverb|binding| и другие из
поставки Clojure. \spverb|With-redefs| скрывает эти отличия; по возможности
пользуйтесь им.

\section{Заключение}

Clojure предлагает типы для изменения данных. В отличии от императивных языков,
где измененение занимает символ, в Clojure пользуются особыми формами. Язык
устроен так, что данные меняют редко. Это продвинутый уровень, к которому
приходят после азов неизменяемости.

Чтобы читатель не запутался, перечислим техники, которые мы рассмотрели и
случаи, когда они полезны.

\emph{Атом} это обертка вокруг значения. Чтобы получить содержимое, применяют
оператор \spverb|@| или функцию \spverb|(deref <atom>)|. Новое значение сообщают
функцией \spverb|reset!|. Чаще атом изменяют итеративно с помощью
\spverb|swap!|, которая рассчитывает новое значение из текущего.

В атомах хранят состояние частей проекта. Это счетчики, сессии, локальный кэш
для ускорения расчетов. Атомы подходят на роль переменных в императивном
коде. Иногда в атомах хранят состояние модуля, например, текущее подключение к
базе.

Объект \emph{volatile} это облегченный вариант атома. В отличии от него,
\spverb|volatile| не поддерживает валидаторы и вотчеры. Кроме того,
\spverb|volatile| не управляет доступом из разных потоков.

Переходные или \emph{транзиентные коллекции} получают из их постоянных
аналогов. Когда коллекция транзиентна, меняется ее содержимое. С ними работают
функции \spverb|conj!|, \spverb|assoc!| и другие с восклицательным знаком на
конце. Функция \spverb|persistent!| запечатывает коллекцию и возвращает ее
постоянную копию.

Транзиентные коллекции полезны на больших объемах данных, потому что быстрее
неизменяемых. Работать с коллекцией следует из одного потока. Другие части кода
не должны знать о том, что коллекция изменяется. Обмен переходными коллекциями
это грубая ошибка.

Функция \emph{alter-var-root} заменяет глобальную переменную. С ее помощью можно
вторгнутся в чужое пространство имен и что-то исправить. К \spverb|alter-var-root|
прибегают, чтобы изменить код, которым мы не владеем.

Форма \emph{set!} изменяет системную переменную Clojure. Это особые переменные с
<<ушками>>, которые влияют на поведение системы в целом. \spverb|Set!| редко
встречается в коде: чаще переменные указывают в настройках проекта.

Макрос \emph{binding} выполняет код в рамках временных изменений. Макрос
связывает динамическую переменную с новым значением. Чтобы переменная была
динамической, ей сообщают флаг \spverb|^:dynamic| и выделяют <<ушками>>.

\spverb|Binding| действует только в текущем потоке. К нему прибегают, чтобы
участок кода вел себя по-иному. Например, выводил текст не на экран, а в
файл. Динамические переменные легче спустить по стеку вызовов, как мы делали это
с локалью.

Макрос \emph{with-local-vars} выполняет тело с произвольными переменными. Они
похожи на атом с двумя действиями: прочитать и записать значение. Форма полезна,
когда имеем дело со сложной императивной логикой. При выходе из макроса
переменные исчезают.

Конструкция \emph{with-redefs} временно изменяет \spverb|def|-определения. В
отличии от \spverb|binding|, она действует глобально. Все фоновые сущности
(потоки, футуры, агенты) подхватят изменения. \spverb|With-redefs| это обертка
над низкоуровневой формой \spverb|with-redefs-fn|. Чаще всего ей используются в
тестах (мокинг).
