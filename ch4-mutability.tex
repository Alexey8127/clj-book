\chapter{Изменяемость}

\index{изменяемость}

\begin{teaser}
В классических языках данные меняются, а стандартная библиотека предлагает
ограничения: локи, атомарные действия, постоянные коллекции. В Clojure,
наоборот, данные не меняются, а мутабельные типы задвинуты на второй план. Это
сделано намеренно, потому что неизменяемость~--- центральная идея языка.
\end{teaser}

Руководства по Clojure учат постоянными коллекциям. Это правильный подход, но
когда появляется состояние, новички испытывают трудности. В этой главе мы займем
другую позицию: рассмотрим, как управлять состоянием в программах.

\section{Общие проблемы}

На Clojure трудно писать в императивном стиле, когда акцент сделан на изменении
данных. Скажем, чтобы получить список удвоенных чисел, выполняют шаги:

\index{итерация}

\begin{itemize}
\item
  создать пустой список;
\item
  пройти по всем элементам исходного списка;
\item
  на каждом шаге вычислить элемент;
\item
  добавить его к новому списку.
\end{itemize}

Базовые типы Clojure не меняются, и к ним нельзя применить алгоритм выше. Те,
кто пришел из императивных языков, поначалу не могут писать код с постоянными
коллекциями. Привычка менять данные укрепилась в них так сильно, что
иммутабельность кажется физическим ограничением.

Это сделано нарочно. Создатель Clojure полагает, что изменяемость~--- основная
проблема в разработке ПО. Когда мы пишем код, то видим его начальное состояние в
котором он будет первый такт процессора. Затем программа инициирует классы,
заполнит поля, и объекты изменятся.

Некоторые ошибки трудно расследовать, потому что код и состояние
расходятся. Чтобы исправить ошибку, е\"{е} повторяют в локальном окружении. Однако
привести его в конкретное состояние не так просто. Неизменяемые данные отсекают
целый пласт ошибок, от которых страдают императивные языки.

\index{языки!Python}

Рассмотрим примеры на Python. В модуле заданы параметры запроса по
умолчанию. Функция \spverb|api_call| принимает дополнительные параметры,
объединяет со стандартными и передает в HTTP-клиент:

\begin{english}
  \begin{python}
DEFAULT_PARAMS = {
    "allow_redirects": True,
    "timeout": 5,
    "headers": {"Content-Type": "application/json"},
    "auth": ("username", "password"),
}

def api_call(**params):
    api_params = DEFAULT_PARAMS # [1]
    api_params.update(params)   # [2]
    resp = requests.post("https://api.host.com", **api_params)
    return resp.json()
  \end{python}
\end{english}

\index{параметры!по ссылке}

В теле \spverb|api_call| грубая ошибка: переменная \spverb|api_params| получает
не копию глобальных параметров, а \emph{ссылку} на них \spverb|[1]|. Изменяя
\spverb|api_params|, мы на самом деле меняем \spverb|DEFAULT_PARAMS|
\spverb|[2]|. На каждый вызов глобальные параметры меняются, что ведет к
странному поведению программы. Код и состояние <<разъехались>>.

\index{собеседования}

На собеседованиях часто задают вопрос следующий. Представьте функцию с
сигнатурой ниже. Объясните, что в ней не так и приведите пример ошибки?

\begin{english}
  \begin{python}
def foo(bar=[]):
  \end{python}
\end{english}

Ответ: параметры функции по умолчанию создаются однажды. В данном случае
\spverb|bar| равен пустому списку. В Python список изменяется. Если в
\spverb|bar| ничего не передали, получим исходный список. Добавим в него
элемент, и в следующий раз \spverb|bar| будет уже не пустой:

\begin{english}
  \begin{python}
def foo(bar=[]):
    bar.append(1)
    return bar
  \end{python}
\end{english}

Вызов \spverb|foo| верн\"{е}т списки \spverb|[1]|, \spverb|[1, 1]| и так далее. Ещ\"{е}
хуже: если результат \spverb|foo| сохранить в переменную и добавить к ней
элемент, на самом деле изменится злосчастный \spverb|bar|.

Современные IDE проверяют код на неявные ошибки. Про список в сигнатуре знают
все анализаторы и линтеры. Но мы не можем целиком положиться на утилиты. Если
данные меняются постоянно, трудно понять, где ошибка, а где умысел.

Начинающих кложуристов выдает код:

\begin{english}
  \begin{clojure}
(let [result (atom [])
      data [1 2 3 4 5]]
  (doseq [item data]
    (let [new-item (* 2 item)]
      (swap! result conj new-item)))
  @result)
  \end{clojure}
\end{english}

\index{императивный стиль}

\noindent
Это привычка из императивного прошлого. Атом-аккумулятор лишний, достаточно
\spverb|map| или \spverb|for|:

\begin{english}
  \begin{clojure}
(map (partial * 2) [1 2 3 4 5])

(for [n [1 2 3 4 5]]
  (* n 2))
  \end{clojure}
\end{english}

Оба выражения короче и понятней. Не нужно создавать вектор и добавлять в него
элементы~--- это делают функции. Если обход коллекции завязан на
атоме, скорее всего это слабое решение.

Авторы Clojure сделали вс\"{е}, чтобы выделить состояние на общем фоне. К
состоянию прибегают только в крайних случаях. Если вы написали код на атомах без
уважительной причины, вам сделают замечание или не примут работу.

\index{состояние}

\subsection{В защиту состояния}

Мы говорили, что состояние несет потенциальные ошибки. Это слишком линейное
заявление: без состояния работают только небольшие программы. Например, скрипты,
которые запускают раз в день. Писать промышленный код без состояния невозможно.

\index{ресурсы}

Постоянные данные избавляют нас от ошибок с перезаписью полей. Это значимый
выигрыш, но кроме данных приложение полагается на \emph{ресурсы}. Для них
действует правило: дешевле работать с открытым ресурсом, чем постоянно открывать
и закрывать его. Состояние повышает скорость программы.

\index{веб-разработка}
\index{протоколы!CGI}

Много лет назад веб-серверы работали по протоколу CGI, Common Gateway
Interface\footurl{https://en.wikipedia.org/wiki/Common\_Gateway\_Interface}. На
каждый запрос сервер запускал скрипт или бинарный файл. Скрипт получал данные
запроса из переменных среды. Программа писала ответ в стандартный поток. Сервер
перехватывал его и выводил пользователю.

Схема была простой и удобной. Приложение могло быть скриптом на Perl или
программой на C\Plus\Plus. У сервера не было состояния. В любой момент
разработчик обновлял файл, и изменения вступали в силу немедленно.

За эти преимущества платили скоростью. Каждый запрос к серверу порождал новый
процесс. Даже если программа написана на C, запуск процесса занимает
время. Индустрия пришла к тому, что приложение должно работать постоянно, а не
по запросу.

\index{протоколы!FastCGI}

Приложение на FastCGI устроено как самостоятельный сервер. Его
производительность на два порядка выше, чем у CGI. В н\"{е}м появилось
состояние~--- открытый порт и цикл ввода-вывода. Цикл читает запрос и делегирует
отдельному потоку. Это усложнило разработку, что привело к новым парадигмам
и фреймворкам.

Похоже устроены соединения с базой данных. Представим, что на каждый запрос мы
открываем соединение, работаем с ним и закрываем. В машинном мире открыть
TCP-соединение это долгая операция. Так появились пулы соединений.

\index{пул соединений}

Пул это объект, который держит несколько открытых соединений. Пул знает, какое
из них занято или свободно. Чтобы работать с базой, мы занимаем одно из
свободных соединений, передаем по нему данные и возвращаем. Для потребителя пул
это примитивный объект, который выдает и забирает соединения.

Логика пула довольно сложна. Если соединений не хватает, он
увеличивает свою емкость, а при избытке сокращает. Для каждого соединения пул
считает время работы и сколько раз им пользовались. Он же решает, когда закрыть
соединение и заменить его новым. Пул работает в отдельном потоке, чтобы не
блокировать основную программу.

Столь сложное устройство компенсирует скорость доступа. Каждый запрос протекает
по заранее открытому соединению, что намного быстрее, чем открывать его каждый
раз.

Сама архитектура машин поощряет изменять данные. В школе нам объясняют память
компьютера как массив ячеек. Запись в ячейку по адресу дешева. И в C\Plus\Plus,
и в Python одинаково легко обновить элемент массива:

\begin{english}
  \begin{python}
items[i] = 5;
  \end{python}
\end{english}

Постоянные структуры хуже ложатся на эту модель памяти. Поэтому они сложнее:
неизменяемый список это не цепочка, а дерево узлов с указателем. Постоянные
коллекции умны и копируют данные не полностью, а частично. Все же на больших
объ\"{е}мах выгоднее работать с изменяемыми структурами.

Мы не призываем всюду внедрять состояние. Древовидность и замедление это цена,
которую платят за меньший риск ошибки. Инженер должен знать, на что ид\"{е}т, когда
добавляет состояние или избавляется от него. Далее мы изучим императивные
возможности Clojure~--- как ими пользоваться и когда это действительно нужно.

\section{Атомы}

\index{атом}

Clojure предлагает несколько способов менять данные. Самый простой из них~---
атом. Это объект, который прячет в себе другой объект. Атом получают одноим\"{е}нной
функцией с начальным значением:

\begin{english}
  \begin{clojure}
(def store (atom 42))
  \end{clojure}
\end{english}

\noindent
Если напечатать атом, увидим следующее:

\begin{english}
  \begin{clojure}
#<Atom@10ed2e87: 42>
  \end{clojure}
\end{english}

Чтобы извлечь значение, применяют оператор \spverb|@|. Запись \spverb|@store|
это укороченный вариант \spverb|(deref store)|. Функция \spverb|deref| принимает
атом и возвращает содержимое. Семантически это то же самое, что получить
значение по указателю. В русской литературе операцию называют
<<разыменование>>. В разговорном языке про оператор \spverb|@| говорят
<<дереф>>, <<дерефнуть>>.

\index{дереф}
\index{разыменование}
\index{синтаксис!@}
\index{clojure.core!deref}

\begin{english}
  \begin{clojure}
@store ;; 42
  \end{clojure}
\end{english}

В отличии от коллекций, атом меняет содержимое и остается тем самым
объектом. Это важное отличие от коллекций: если добавить к словарю ключ, получим
новый словарь, при этом старый не изменится. Если изменить содержимое атома, это
будет вс\"{е} тот же атом с номером \spverb|10ed2e87|.

\index{clojure.core!reset"!}

Наивный способ изменить атом~--- вызвать \spverb|reset!|. Функция принимает атом
и новое значение. Оно может быть любого типа, в том числе \spverb|nil|,
коллекцией, исключением:

\begin{english}
  \begin{clojure}
(reset! store nil)
(reset! store {:items [1 2 3]})
(reset! store (ex-info "error" {:id 42}))
  \end{clojure}
\end{english}

Если выполнить \spverb|@store| после каждого выражения, получим то, что передали
в \spverb|reset!|. Последний случай не бросит исключение, потому что нет
оператора \spverb|throw|.

\subsection{Приращение атома}

\index{сч\"{е}тчик}
\index{атом!приращение}

Мы назвали \spverb|reset!| наивным, потому что функция не учитывает текущее
значение атома. На практике атом изменяют, отталкиваясь от содержимого. Если это
сч\"{е}тчик, неважно, какое значение в нем сейчас. Атому посылают команду <<прибавь
единицу>>. Если это вектор, сообщение выглядит как <<добавь элемент>>.

Значение атома уходит на второй план; нас интересует \emph{действие}. Чтобы
обновить атом с учетом состояния, ему посылают функцию. Она принимает текущее
значение и возвращает новое, которое заменит содержимое. В функцию
\spverb|swap!| передают атом и функцию для расчета нового значения:

\index{clojure.core!swap"!}

\begin{english}
  \begin{clojure}
(def counter (atom 0))
(swap! counter inc) ;; 1
  \end{clojure}
\end{english}

Если повторять вызов \spverb|swap!|, значение \spverb|counter| каждый раз
увеличится на единицу.

\spverb|Swap!| принимает дополнительные параметры для расчета. Предположим, мы
хотим увеличить сч\"{е}тчик сразу на три позиции или отмотать назад. Вместо
\spverb|inc| возьмем сложение и вычитание: $+$ и $-$. Их первым аргументом
станет текущее значение атома, а второй аргумент передают в \spverb|swap!|:

\begin{english}
  \begin{clojure}
(swap! counter + 3) ;; increase by 3
(swap! counter - 2) ;; decrease by 2
  \end{clojure}
\end{english}

\noindent
Атом вычислит новое значение по правилу:

\begin{english}
  \begin{clojure}
(+ <current> 3)
(- <current> 2)
  \end{clojure}
\end{english}

\noindent
, где \spverb|<current>|~--- текущее значение.

Это был частный случай \spverb|swap!| с одним аргументом. В общем случае функция
принимает их произвольное количество:

\begin{english}
  \begin{clojure}
(swap! <atom> func arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

\noindent
Новое значение находят формой:

\begin{english}
  \begin{clojure}
(func <current> arg2 arg3 arg4 ...)
  \end{clojure}
\end{english}

До сих пор мы хранили в атомах сч\"{е}тчики. На практике редко считают одну
сущность. Гораздо чаще сч\"{е}тчики ведут в разрезе чего-то. Например, просмотры
страниц по адресам, число сообщений у пользователя и так далее.

Чтобы не создавать по атому на каждую сущность, их объединяют в
словарь. Рассмотрим подсчет системных ресурсов. Ключи словаря означают тип
ресурса, значения~--- степень потребления в байтах или процентах.

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))
  \end{clojure}
\end{english}

Отдельная функция вычисляет потребление диска. Чтобы записать новое значение в
атом по ключу \spverb|:store|, вызовем \spverb|swap!| следующим образом:

\begin{english}
  \begin{clojure}
(defn get-disk-usage []
  (rand-int 99999999))

(let [store (get-disk-usage)]
  (swap! usage assoc :store store))
  \end{clojure}
\end{english}

Эта форма перепишет значение в \spverb|:store| на новое. Возможен и другой
подход, когда мы не считаем все занятое место на диске, а фиксируем разницу на
каждое изменение. Скажем, если пользователь создал или удалил файл, мы читаем
событие и обновляем \spverb|:store| с приращением.

Функция \spverb|get-file-event| каким-то образом верн\"{е}т событие файловой
системы. Это словарь с ключами \spverb|:action| и \spverb|:size|. В зависимости
от \spverb|:action| мы наращиваем или уменьшаем потребление диска. Наша версия
\spverb|get-file-event| это заглушка, которая случайно верн\"{е}т одно из двух
событий:

\begin{english}
  \begin{clojure}
(defn get-file-event []
  (rand-nth
   [{:action :delete
     :path "/path/to/deleted/file.txt"
     :size 563467}
    {:action :create
     :path "/path/to/new/photo.jpg"
     :size 7345626}]))
  \end{clojure}
\end{english}

\noindent
Пересчет диска изменится:

\begin{english}
  \begin{clojure}
(let [{:keys [action size]} (get-file-event)]
  (case action
    :delete
    (swap! usage update :store - size)
    :create
    (swap! usage update :store + size)))
  \end{clojure}
\end{english}

\index{файлы}

Так считают ресурсы в облачных платформах. Обращение к диску это дорогая
операция: нельзя пробежаться по дереву папок и посчитать объем. Иногда файлы
одного клиента лежат на разных дисках и серверах. Поэтому ресурсы считают
итеративно и раз в интервал сверяют цифры.

\index{PID}
\index{процессы}

Усложним пример с ресурсами: теперь их считают в разрезе пользователей. Ключи
верхнего уровня означают номер пользователя, а значения~--- словари
ресурсов. Для каждого пользователя ведем список его процессов. Это множество
идентификаторов \spverb|PID|\footurl{https://en.wikipedia.org/wiki/Process\_identifier}.

\begin{english}
  \begin{clojure}
(def usage-all
  (atom {1005 {:cpu 35
               :store 63466734
               :memory 10442856
               :pids #{6266, 5426, 6542}}}))
  \end{clojure}
\end{english}

\noindent
Чтобы добавить процесс пользователю 1005, выполним \spverb|swap!|:

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] conj 9999)
  \end{clojure}
\end{english}

Это сложная комбинация: в \spverb|swap!| передали функцию, которая принимает
функцию. Разберем по шагам, что произошло.

\begin{itemize}

\item
  Получим множество старых процессов \spverb|<pids>|:\\
  \spverb|(get-in <current> [1005 :pids])|.

\item
  Добавим к нему новый процесс: \spverb|(conj <pids> 9999)|.\\
  Обозначим новое множество \spverb|<pids*>|.

\item
  Обновим \spverb|<current>| этим множеством по пути 1005 \arr{} \spverb|:pids|:\\
  \spverb|(assoc-in <current> [1005 :pids] <pids*>)|.

\end{itemize}

Чтобы удалить процесс, замените \spverb|conj| на \spverb|disj|. Это обратная
функция, которая удаляет элемент из множества.

\index{clojure.core!get-in}
\index{clojure.core!update-in}

\begin{english}
  \begin{clojure}
(swap! usage-all update-in [1005 :pids] disj 9999)
  \end{clojure}
\end{english}

В основном \spverb|reset!| нужен, чтобы сбросить атом в исходное состояние. В
других случаях важно знать текущее значение, чтобы вычислить новое. Поэтому
\spverb|swap!| мощнее и гибче \spverb|reset!|.

\subsection{Совместный доступ}

\index{чистые функции}
\index{атом!перезапуск}

Функция, которую передают в \spverb|swap!|, должна быть без побочных эффектов. В
функциональном программировании е\"{е} бы назвали \emph{чистой функцией}. Она не
должна обращаться к базе данных, файлам, выводу на экран. Технически это
возможно, но вы столкнетесь со странным поведением. Дело в том, что иногда
функция срабатывает \emph{несколько} раз за один \spverb|swap!|. Причина в
способе, которым атом обновляет содержимое.

Предположим, ресурсы считают в нескольких потоках. Один слушает события файловой
системы, а второй процессы. Возникает проблема совместного доступа. Возможна
ситуация, когда два потока обновляют одни и те же данные. Первый поток справился
быстрее и записал в атом свою версию данных. Второй поток рассчитал другой
вариант. Если он изменит атом, эффект первого аннулируется.

\index{терминал}

Это классическая задача про терминал и семейную пару. Муж и жена вносят наличные
на общий пустой счет. Жена вносит 100 рублей, терминал прибавляет эту сумму к
нулю и записывает в базу. Муж вносит 50 рублей, терминал делает то же
самое. Итого на счете 50 рублей, а 100 пропали.

Атом не допустит такого поведения. Он запоминает значение в момент вычисления
нового. Назовем его \emph{начальным}. Перед тем как обновить содержимое, атом
проверяет, что текущее значение совпадает с начальным. Если они не равны, атом
обновили из другого потока.

В этом случае атом повторяет цикл. Текущее становится начальным, и от него
вычисляют новое значение. Атом ещ\"{е} раз сравнивает текущее и начальное
значения. Цикл повторяется до тех пор, пока они не равны. Это значит, за время
вычислений атом не обновили. Атом меняет текущее значение на новое и выходит из
цикла.

Покажем сказанное на примере. Возьмем атом со словарем:

\begin{english}
  \begin{clojure}
(def sample (atom {:number 0}))
  \end{clojure}
\end{english}

Понадобится функция \emph{медленного} сложения. Она принимает текущее значение,
приращение и время простоя. Для ясности добавим вывод в консоль.

\begin{english}
  \begin{clojure}
(defn +slow
  [num delta timeout]
  (println (format "Current: %s, timeout: %s" num timeout))
  (Thread/sleep timeout)
  (+ num delta))
  \end{clojure}
\end{english}

\index{clojure.core!future}
\index{футуры}

Обновим атом одновременно из двух потоков. Для этого вызовем \spverb|swap!| в
футуре. В первой ждем две секунды, во второй пять:

\begin{english}
  \begin{clojure}
(do (future (swap! sample update :number +slow 1 2000))
    (future (swap! sample update :number +slow 2 5000)))
  \end{clojure}
\end{english}

\noindent
Проверим атом:

\begin{english}
  \begin{clojure}
@sample ;; {:number 3}
  \end{clojure}
\end{english}

\noindent
Это правильное значение: $0 + 1 + 2 = 3$. Вывод консоли:

\begin{english}
  \begin{text}
Current: 0, timeout: 2000
Current: 0, timeout: 5000
Current: 1, timeout: 5000
  \end{text}
\end{english}

Вторая функция сработала два раза, что и следует из алгоритма. Второй
\spverb|swap!| начал расчеты с начальным значением \spverb|{:number 0}|, а к
завершению значение оно стало \spverb|{:number 1}|~--- его записал первый
\spverb|swap!|. Чтобы избежать ошибки, атом запустил второй \spverb|swap!| ещ\"{е}
раз относительно \spverb|{:number 1}|.

Когда атом меняют из нескольких потоков, перезапуск может случиться больше двух
раз. Это недопустимо для функций, которые меняют окружение.

\subsection{Валидаторы и вотчеры}

\index{атом!валидация}
\index{валидация!в атоме}

Поведение атомов расширяют валидаторы и вотчеры (анг. \emph{watcher},
наблюдатель). Валидаторы это функции проверки. Они принимают новое значение
\emph{до того}, как оно записано в текущее. Если валидатор вернул ложь, вызов
\spverb|swap!| обернется ошибкой.

\index{clojure.core!set-validator"!}

Функция \spverb|set-validator!| добавляет валидатор к атому. Для сч\"{е}тчика
предположим, что он не может быть отрицательным. Попытка понизить его при нуле
вызовет исключение:

\begin{english}
  \begin{clojure}
(def counter (atom 2))
(set-validator! counter (complement neg?))
(swap! counter dec) ;; repeat 3 times...
;; Execution error (IllegalStateException)
;; Invalid reference state
  \end{clojure}
\end{english}

Вотчеры это побочные эффекты атома. Они срабатывают \emph{после того}, как атом
перешел в новое состояние. Вотчер задают уникальным ключом и функцией. Она
принимает четыре аргумента: ключ, атом, старое и новое значения. Одному атому
можно назначить несколько вотчеров.

Разбер\"{е}мся, когда полезны вотчеры. Вспомним подсчет ресурсов: система получает
события и обновляет атом. Если потребление диска превысило лимит, мы не можем
бросить исключение. В этом нет смысла, потому что события поступают из внешней
системы. Исключение на нашей стороне не остановит поток событий.

\index{атом!вотчер}
\index{clojure.core!add-watch}

Правильно задать \emph{реакцию} на превышение лимита. Например, уведомить
пользователя письмом, что ресурс исчерпан. Или отправить запрос в подсистему,
которая отвечает за доступ. Для этого нужен вотчер: он связывает изменение
атома и реакцию на него.

Если потребление вышло за лимит, запишем в лог сообщение. Объявим функцию
вотчера:

\index{логирование!в атоме}

\begin{english}
  \begin{clojure}
(def STORE_LIMIT (* 1024 1024 1024 25)) ;; 25 Gb

(defn store-watcher
  [_key _atom _old value]
  (let [{:keys [store]} value]
    (when (> store STORE_LIMIT)
      (log/errorf "Disk usage %s has reached the limit %s"
                  store STORE_LIMIT))))
  \end{clojure}
\end{english}

\index{синтаксис!\_}

Примечание: из четырех параметров нам нужен только последний~---
\spverb|value|. Это новое значение атома. В боевом коде мы бы назначили первым
трем символ подчеркивания. Оно затеняет лишние переменные и поэтому работает
быстрее. Однако мы оставили понятные имена, чтобы передать семантику.

Назначим вотчер атому с ключом \spverb|:store|:

\begin{english}
  \begin{clojure}
(def usage
  (atom {:cpu 35
         :store 63466734
         :memory 10442856}))

(add-watch usage :store store-watcher)
  \end{clojure}
\end{english}

\noindent
Если потребление диска превысит лимит, увидим запись в лог:

\begin{english}
  \begin{clojure}
(swap! usage update :store + STORE_LIMIT)
;; Disk usage 26907012334 has reached the limit 26843545600
  \end{clojure}
\end{english}

Валидацию и вотчеры рассматривают как пре- и постэффекты. Разница в том, что
первые могут прервать исполнение, а вторые нет. У них разные задачи:
предварительные эффекты проверяют то, что \emph{может случиться}, а
постэффекты~--- то, что \emph{уже случилось}. Поэтому на них реагируют
по-разному.

\subsection{Другие примеры}

\index{мемоизация}
\index{clojure.core!memoize}
\index{декораторы}

На атомы опираются некоторые функции Clojure, например \spverb|memoize|. Это
декоратор, который возвращает улучшенную версию функции. Она запоминает
результат относительно аргументов и записывает во внутреннюю таблицу. Если
вызвать функцию с теми же аргументами, получим результат из таблицы без
вычислений.

Роль таблицы играет атом. Функция-результат \spverb|memoize| замкнута на атоме,
который виден только ей. Вот как выглядит декоратор:

\begin{english}
  \begin{clojure}
(defn memoize [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
  \end{clojure}
\end{english}

\index{clojure.core!find}

Заметим, что для поиска в словаре используют \spverb|find| вместо
\spverb|get|. Разница в том, как функции трактуют пустое значение. Если по ключу
записан \spverb|nil|, \spverb|get| тоже верн\"{е}т \spverb|nil|, и форма
\spverb|if-let| выполнит ложную ветку. Функция \spverb|find| верн\"{е}т пару
\spverb|MapEntry|, значение из которой находят про помощи \spverb|val|.

Проверим декоратор на функции \spverb|+slow|, которую задали выше. Объявим е\"{е}
memoize-версию и замерим вызовы:

\begin{english}
  \begin{clojure}
(def +mem (memoize +slow))

(time (+mem 1 2 2000))
;; Elapsed time: 2004.699832 msecs

(time (+mem 1 2 2000))
;; Elapsed time: 0.078052 msecs
  \end{clojure}
\end{english}

\index{классы!Thread}

Первый вызов долгий, потому что срабатывает \spverb|Thread/sleep| в теле
\spverb|+slow|. Второй вызов получает результат из атома, что на порядки
быстрее.

\index{сч\"{е}тчики}

Атомы полезны в веб-разработке: это дешевый способ хранить состояние между
запросами. На атомах легко сделать сч\"{е}тчики просмотров, сессии, кэш. Сч\"{е}тчик
просмотренных страниц это комбинация атома и middleware:

\begin{english}
  \begin{clojure}
(def page-counter
  (atom {"/" 0}))

(defn wrap-page-counter
  [handler]
  (fn [request]
    (let [{:keys [request-method uri]} request]
      (when (= request-method :get)
        (swap! page-counter update uri (fnil inc 0)))
      (handler request))))
  \end{clojure}
\end{english}

\index{HTTP!GET}

На каждый GET-запрос мы увеличиваем сч\"{е}тчик для текущего адреса. Обратите
внимание на форму \spverb|fnil| в вызове \spverb|update|. Она возвращает версию
\spverb|inc|, которая не вызовет исключение, если первый аргумент
\spverb|nil|. Это возможно, если в словаре ещ\"{е} нет нужного ключа, и вместо
\spverb|nil| функция получит ноль.

\index{форматы!HTML}
\index{библиотеки!Hiccup}

Функция \spverb|page-seen| верн\"{е}т число просмотров по адресу страницы. Напишем
компонент для подвала сайта, где мелким шрифтом указано, сколько раз смотрели
страницу. Для HTML-разметки подойдет библиотека
Hiccup\footurl{https://github.com/weavejester/hiccup} и аналоги.

\begin{english}
  \begin{clojure}
(defn page-seen [uri]
  (get @page-counter uri 0))

(defn component-footer [uri]
  [:div {:class "footer"}
   (let [seen (page-seen uri)]
     [:p [:small "This page has been seen " seen " time(s)."]])])
  \end{clojure}
\end{english}

\subsection{Замечания к атому}

У решений на атомах есть недостатки. Атомы не связаны с другими экземплярами
программы. Когда приложение занимает несколько нод, каждая хранит свой
сч\"{е}тчик. Если запросы расходятся по ним равномерно, клиент увидит разные
данные. Чтобы избежать странностей, используют сетевые хранилища вроде Redis.

\index{базы данных!Redis}

Атомы непостоянны: если завершить программу, они теряют состояние. С другой
стороны, атом быстрее, чем файловая система или сетевой сервис. Встречаются
гибридные схемы, когда при создании атом читает ресурс и раз в интервал пишет в
него изменения.

\section{Volatile}

\index{volatile}

Атом устроен довольно сложно: он отвечает за параллельный доступ, вызывает
валидацию и следит за изменениями. Иногда эти возможности излишни, и пользуются
его упрощенной версией~--- \spverb|volatile|.

\index{clojure.core!volatile}
\index{clojure.core!vreset"!}

Объект \spverb|volatile| тоже хранит и изменяет значение. Одноим\"{е}нная функция
создает объект с состоянием. Функции \spverb|vreset!| и \spverb|vswap!|
аналогичным тем, что мы рассмотрели для атома. Префикс \spverb|v| означает, что
они работают с \spverb|volatile|.

Пример с ресурсами: вместо атома используем другой тип хранилища:

\begin{english}
  \begin{clojure}
(def vusage (volatile! nil))
(vreset! vusage
         {:cpu 35
          :store 63466734
          :memory 10442856})
(vswap! vusage update :store + (* 1024 1024 5))
(println "Disk usage is" (get @vusage :store))
;; Disk usage is 68709614
  \end{clojure}
\end{english}

\spverb|Volatile| отличается от атома тем, что не контролирует запись из
нескольких потоков. Перепишем пример с футурами:

\begin{english}
  \begin{clojure}
(def vsample (volatile! {:number 0}))
(do (future (vswap! vsample update :number +slow 1 2000))
    (future (vswap! vsample update :number +slow 2 5000)))
;; Current: 0, timeout: 2000
;; Current: 0, timeout: 5000
@vsample ;; {:number 2}
  \end{clojure}
\end{english}

\index{clojure.core!future}
\index{футуры}

Вывод говорит, что второе действие сработало один раз. Если для атома итог был
3, то с \spverb|volatile| получилось 2. Операцию \spverb|+1| мы потеряли. Из
этого следует, что \spverb|volatile| не подходит для многопоточного кода.

Однако в этом есть и плюсы. Из-за того, что \spverb|volatile| не ограничивает
доступ, изменения протекают быстрее. По той же причине он не поддерживает
валидаторы и вотчеры. В целом \spverb|volatile| нацелен на скорость.

\subsection{Применение}

\index{трансдьюсеры}

У \spverb|volatile| две области применения~--- трансдьюсеры и императивный
код. Трансдьюсеры это особый способ работы с коллекцией. Они оборачивают функции
\spverb|map|, \spverb|reduce| и другие таким образом, что их комбинация не
порождает промежуточных списков. Это возможно за счет внутреннего состояния. Для
трансдьюсера важна скорость записи, поэтому \spverb|volatile| подходит на роль
состояния лучше, чем атом.

\spverb|Volatile| полезен, когда пишут императивный код. Относитесь к нему
спокойно: иногда бизнес-требования слишком сложны, чтобы накладывать их на
функциональный стиль.

Представим, что нужно получить плоский список из дерева. Оно устроено по сложным
правилам: если в первой ветке одно значение, то рассматривать вторую, а иначе
третью. И дальше: если для первой и третьей веток выполняется условие $x$,
добавить в список произведение значений.

\index{императивный стиль}

Требования насквозь императивны, и выгодно задать их таким же образом. Так мы
сделаем код ближе к бизнес-логике и облегчим поддержку. Малая часть дерева:

\begin{english}
  \begin{clojure}
(def data
  {:items [{:result {:value 74}}
           {:result {:value 65}}]
   :records [{:usage 99 :date "2018-09-09"}
             {:usage 52 :date "2018-11-05"}]})
  \end{clojure}
\end{english}

Код разбивают на блоки, где каждый из них это каскад \spverb|when-let|. На
нижнем уровне мы изменяем коллекцию. Это императивный стиль, но в данном случае
он удобен. Если одно из правил станет лишним, блок удаляют. Удобно, когда над
блоком пишут комментарий или ссылку на документацию:

\begin{english}
  \begin{clojure}
(let [result (volatile! [])]

  ;; see section 5.4 from the doc
  (when-let [a (some-> data :items first :result :value)]
    (when-let [b (some-> data :records last :usage)]
      (when (> a b)
        (vswap! result conj (* a b)))))

  ;; more expressions...
  @result)
  \end{clojure}
\end{english}

\section{Переходные коллекции}

\index{коллекции!транзиентные}
\index{clojure.core!transient}

С помощью атома мы создали подобие изменяемых коллекций. Познакомьтесь с новой
техникой: Clojure предлагает \emph{настоящие} изменяемые коллекции. По-другому
они называются \spverb|transient| (анг. временный, переходный).

Изменяемые коллекции получают из постоянных аналогов. С ними работают лишь
несколько функций, буквально добавить и удалить элемент. Стадартные
\spverb|map|, \spverb|filter| и другие функции не поддерживают
\spverb|transient|-коллекции. Происходит своего рода обмен: мы теряем мощь
стандартной библиотеки, но обретаем скорость и императивный подход.

Транзиентные коллекции быстрее постоянных. Изменить ячейку памяти проще, чем
выделить новую и сдвинуть часть данных. Коллекция не должна пребывать в режиме
\spverb|transient| вс\"{е} время. Когда алгоритм закончил работу, е\"{е}
замораживают и получают неизменяемую версию.

\subsection{Примеры}

Функция \spverb|transient| порождает переходную коллекцию из исходной. Для
работы с ней используют особые функции \spverb|conj!|, \spverb|assoc!|,
\spverb|dissoc!| и другие. Восклицательный знак на конце предупреждает об
изменении данных. Функции меняют \emph{содержимое} коллекции, а не возвращают
новую копию, как это делают обычные \spverb|conj| и \spverb|assoc|.

\index{clojure.core!persistent"!}

Функция \spverb|persistent!| завершает работу с переходной коллекцией. Она
возвращает постоянную версию и одновременно <<запечатывает>> оригинал. После
\spverb|persistent!| коллекцию уже нельзя изменить.

Рассмотрим переходный вектор. На него действуют функции \spverb|conj!| и
\spverb|pop!|, добавить и убрать элемент из хвоста:

\begin{english}
  \begin{clojure}
(let [items* (transient [1 2 3])]
  (conj! items* :a)
  (conj! items* :b)
  (pop! items*)
  (persistent! items*))
;; [1 2 3 :a]
  \end{clojure}
\end{english}

\index{clojure.core!assoc"!}
\index{clojure.core!dissoc"!}

\noindent
Вариант со словарем, \spverb|assoc!| и \spverb|dissoc!|:

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (assoc! params* :c 3)
  (dissoc! params* :b)
  (persistent! params*))
;; {:a 1, :c 3}
  \end{clojure}
\end{english}

Примечание: в примерах выше мы обозначили переменную звездочкой. Это не нарушает
синтаксис Clojure. В отличии от других языков, в имени переменной могут быть
дефис, апостроф и другие символы. Особые переменные выделяют штрихом или
звездочкой. Переходные коллекции встречаются редко, поэтому их считают особыми.

После \spverb|persistent!| коллекцию нельзя изменить. Следующий пример бросит
исключение:

\begin{english}
  \begin{clojure}
(let [params* (transient {:a 1})]
  (assoc! params* :b 2)
  (persistent! params*)
  (assoc! params* :c 3))
;; IllegalAccessError: Transient used after persistent! call
  \end{clojure}
\end{english}

Форма \spverb|(persistent! <data*>)|, как правило, замыкает блок с изменяемой
переменной.

Переходные коллекции помогают там, где нужен императивный подход. Выше мы
работали с деревом и \spverb|volatile| для сбора данных. Перепишем код на
транзиентный вектор:

\begin{english}
  \begin{clojure}
(let [result* (transient [])
      push! (fn [item]
              (conj! result* item))]

  ;; see section 5.4 from the doc: http://...
  (when-let [a (some-> data :items first :result :value)]
    (when-let [b (some-> data :records last :usage)]
      (when (> a b)
        (push! (* a b)))))

  ;; more expressions
  (persistent! result*))
  \end{clojure}
\end{english}

\index{clojure.core!conj"!}

Чтобы не писать каждый раз \spverb|(conj! result* item)|, мы
вводим локальную функцию \spverb|push!|. Она замкнута на \spverb|result*| и
принимает только значение. Чтобы добавить элемент, достаточно вызвать
\spverb|(push! x)|. Это сокращает код и скрывает реализацию.

\subsection{Итерация с изменением}

\index{итерация}

Мы говорили, что переходные коллекции быстрее постоянных. Это заметно на долгих
итерациях через \spverb|loop/recur|. Как правило, одна из переменных
\spverb|loop| это коллекция-результат. В каждом \spverb|recur| мы передаем е\"{е}
копию, дополненную через \spverb|conj| или \spverb|assoc|.

Когда итераций много, прибегают к уловке: вместо постоянной коллекции передают
транзиентный вариант. Этим код ускоряют в 2-4 раза. Изменения в коде малы,
нужно лишь учесть следующее:

\begin{itemize}

\item
  изменить тип коллекции на \spverb|(transient <coll>)|;

\item
  вместо \spverb|conj| или \spverb|assoc| вызывать их аналоги: \spverb|conj!|,
  \spverb|assoc!|;

\item
  в конце вернуть постоянную коллекцию через \spverb|persistent!|.

\end{itemize}

Для экспериментов объявим переменную \spverb|nums|, список из миллиона чисел:

\begin{english}
  \begin{clojure}
(def nums (range 999999))
  \end{clojure}
\end{english}

\index{clojure.core!loop}

\noindent
Построим второй список обычным \spverb|loop|:

\begin{english}
  \begin{clojure}
(loop [result []
       [n & nums] nums]
  (if n
    (recur (conj result n) nums)
    result))
  \end{clojure}
\end{english}

\noindent
То же самое с изменяемым вектором:

\begin{english}
  \begin{clojure}
(loop [result* (transient [])
       [n & nums] nums]
  (if n
    (recur (conj! result* n) nums)
    (persistent! result*)))
  \end{clojure}
\end{english}

Число строк осталось прежним, изменилось имя переменной и некоторые
детали. Важно, что правки не выходят за пределы \spverb|loop|, что дает свободу
действий. На ранних стадиях код пишут без изменяемых коллекций. Если скорость
критична, цикл улучшают так, что данные меняются.

Макрос \spverb|time| принимает блок кода и печатает затраченное время. Если
обернуть в \spverb|time| оба примера, получим результаты:

\begin{english}
  \begin{text}
;; 166.688721 msecs (persistent)
;;  69.415038 msecs (transient)
  \end{text}
\end{english}

Точные цифры зависят от оборудования и среды, но разница в несколько раз
очевидна. Транзиентные коллекции действительно быстрее постоянных аналогов.

\index{clojure.core!reduce}
\index{fold}
\index{свертка}

Ускорение работает и для \spverb|reduce|. В других языках эта функция называется
\spverb|fold| или <<свертка>>. Центральная точка \spverb|reduce|~---
коллекция-аккумулятор. Им может быть любой тип, в том числе число или строка для
сложения и конкатенации. Однако чаще всего это список и словарь.

Различают два способа начать свертку. В первом аккумулятор это начальный
элемент коллекции. Для списка \spverb|(1, 2, 3)| и сложения им станет
единица. Во втором способе аккумулятор задают отдельно, например пустым вектором, куда в
будущем запишут данные.

Идея в том, чтобы передать сделать аккумулятор транзиентной коллекцей. На каждом
шаге \spverb|reduce| меняет е\"{е} функциями \spverb|conj!| и аналогами. Сравним
обычный \spverb|reduce|:

\begin{english}
  \begin{clojure}
(reduce
 (fn [result n]
   (conj result n))
 []
 nums)
  \end{clojure}
\end{english}

\noindent
и его мутабельную версию:

\begin{english}
  \begin{clojure}
(persistent!
 (reduce
  (fn [result* n]
    (conj! result* n))
  (transient [])
  nums))
  \end{clojure}
\end{english}

Второй \spverb|reduce| пришлось обернуть в \spverb|persistent!|. В случае с
\spverb|loop| мы втянули \spverb|persistent!| внутрь и изолировали изменения. В
этом плане \spverb|reduce| не такой гибкий: в анонимной функции мы не знаем,
достигли конца итерации или нет. Без \spverb|persistent!| второй пример верн\"{е}т
транзиентную коллекцию, что недоспустимо.

\subsection{Семантика и ограничения}

Изменяемые данные это продвинутая техника. Как только вы отказались от
постоянных коллекций, контроль за изменениями ложится на вас.

Выигрыш в скорости ещ\"{е} не значит, что их применяют на каждом шагу. Худшее, что
может сделать разработчик~--- написать код, где функции обмениваются такими
коллекциями. Если это ваш случай, задумайтесь, почему автор языка уделил так
много внимания неизменяемости. Будет ошибкой игнорировать его идеи.

\index{люди!Дональд Кнут}

Феномен, когда на раннем этапе пытаются выжать скорость, называется
преждевременной оптимизацией. Как заметил Дональд Кнут, это корень всех зол. Во
время оптимизации задавайте себе вопросы. Действительно важно ускорить этот
цикл? Это поможет проекту или вы действуете из любопытства?

Изолируйте транзиентные коллекции в небольших функциях. Тогда переход от
постоянных типов к изменяемым не повлияет на результат. Рефакторинг должен
касаться только функции, а не е\"{е} потребителей.

Изменяемая коллекция не имеет право быть глобальной. Воздержитесь от определений
\spverb|(def users* (transient []))| и подобных. Вы прид\"{е}те к тому, что
\spverb|users*| станет буфером обмена между функциями. Предсказать их результат
станет невозможно.

В отличии от атома, транзиентные типы не контроллируют обращение из разных
потоков. Следите, чтобы только один поток изменял коллекцию. Не передавайте их в
футуры.

\section{Переменные и alter-var-root}

\index{переменные}
\index{clojure.core!alter-var-root}

\label{alter-var-root}

Атомы и переходные коллекции меняют объект, а не переменную. Это не всегда то,
что мы ожидаем. Представим, переменная \spverb|size| это атом:

\begin{english}
  \begin{clojure}
(def size (atom 0))
  \end{clojure}
\end{english}

Чтобы изменить его, вызовем \spverb|reset!| или \spverb|swap!| как в примерах
выше. Однако \spverb|size| останется атомом. То же самое с переходными
коллекциями: легко добавить и удалить элемент, но это будет та же самая
коллекция. Невозможно присвоить ей \spverb|nil|.

Иногда переменную нужно изменить: сделать так, чтобы сперва она была
\spverb|nil|, затем словарем, затем снова \spverb|nil|. Авторы намеренно
усложнили этот сценарий. Менять переменные можно, но нежелательно с точки зрения
языка.

\index{языки!Python}
\index{языки!Java}

Clojure не поощряет стиль Python или Java, когда переменную меняют много
раз. Глобальная переменная без уважительной причины~--- признак плохого кода.
Программист должен понимать, зачем она понадобилась и можно ли от не\"{е}
избавиться.

\index{monkey patch}

Все же бывают случаи, когда глобальные переменные полезны. Это \emph{система} и
\emph{monkey patch}. Разберем новые термины.

Проект на Clojure состоит из отдельных компонентов или доменов. Это веб-сервер,
база данных, очередь сообщений. Каждый домен помещают в свой модуль:
\spverb|http.clj|, \spverb|db.clj| и так далее.

В модуле объявляют переменную, которая хранит состояние компонента. Например,
\spverb|server| в модуле сервера и \spverb|conn| в модуле базы. Возникает
проблема, как задать переменную. Начинающие делают это в лоб:

\begin{english}
  \begin{clojure}
(def server (jetty/run-jetty app {:port 8080}))
  \end{clojure}
\end{english}

Выражение запустит сервер при загрузке модуля. Это плохая практика, потому что в
загрузке не должно быть побочных эффектов. С кодом невозможно работать в REPL: он
делает то, о чем не просили.

Сервер, базы данных и другие компоненты должны включаться по требованию. Поэтому
их переменные вначале равны \spverb|nil|. Функция \spverb|start!| запускает
сервер и записывает его в \spverb|server|. Функция \spverb|stop!| останавливает
и меняет переменную на \spverb|nil|.

\subsection{Понятие переменной}

\index{переменные}
\index{clojure.core!alter-var-root}

\label{var-section}

Чтобы изменить \emph{переменную}, прибегают к \spverb|alter-var-root|. Функция
меняет объекты, которые задали через \spverb|def| и \spverb|defn|. Вызов похож
на \spverb|swap!| для атома: функция принимает объект \spverb|Var| и другую
функцию, которая вычислит новое значение из прежнего.

\index{классы!Var}

Рассмотрим, что такое \spverb|Var|. Это экземпляр класса \spverb|clojure.lang.Var|
из библиотеки Clojure. \spverb|Var| описывает переменную в пространстве имен.
Чтобы получить объект переменной, е\"{е} символ передают в макрос \spverb|var|,
например \spverb|(var server)|. Эта запись аналогична \spverb|#'server|,
что немного короче.

\index{символ}

\emph{Символ} переменной и е\"{е} \emph{объект} это разные сущности. Сам по себе
символ ничего не значит: он равен только самому себе. Представьте, что символ
это слово языка, комбинация букв. В языке не бывает одинаковых слов, однако у
слова может быть несколько значений.

\index{пространства имен}

Символ это посредник между пространством имен и переменными. Когда мы пишем
\spverb|(def num 42)|, это не значит, что переменная \spverb|num| равна числу
42. На самом деле мы создали объект \spverb|Var| со значением 42. Затем
поместили его в текущее пространство под символом \spverb|num|.

Пространство имен работает как словарь. Ключи это символы, а значения
переменные. Формы \spverb|def| и \spverb|defn| наполняют этот словарь. Можно
сказать, \spverb|def| зада\"{е}т слову смысл, и в момент компиляции Clojure
понимает это слово.

С символом связана операция \emph{вычисления}. Если в REPL ввести \spverb|num|,
он выполнит поиск с таким ключом в пространстве имен. Когда ключ найден, REPL
верн\"{е}т значение переменной, в нашем случае 42. В противном случае возникнет
ошибка.

Clojure намеренно скрывает от нас стадию переменной, и это правильно. Если бы
выражение \spverb|num| вернуло переменную, в этом бы не было смысла. \spverb|Var|~---
не цифра, а сложный объект. Значение 42 это лишь одно из множества его полей.
Как правило, переменные скрыты от пользователя. Разработчик видит либо их символ
(\spverb|num|), либо значение (\spverb|42|). Функция \spverb|alter-var-root|~---
тот случай, когда переменные вступают в игру.

\subsection{Запуск по требованию}

Вернемся к серверу. Объявим переменную, которая в будущем станет объектом
\spverb|jetty.server.Server|. По умолчанию это \spverb|nil|:

\begin{english}
  \begin{clojure}
(def server nil)
  \end{clojure}
\end{english}

Функция \spverb|start!| заменяет \spverb|server| результатом анонимной
функции. Она принимает текущее значение переменной. Когда это \spverb|nil|,
создаем и возвращаем новый сервер. Если нет, вернем текущий.

\begin{english}
  \begin{clojure}
(defn start! []
  (alter-var-root
   (var server)
   (fn [server]
     (if-not server
       (run-jetty app {:port 8080 :join? false})
       server))))
  \end{clojure}
\end{english}

\noindent
Аналогично работает \spverb|stop!|: если сервер включен (не \spverb|nil|),
остановим его и вернем \spverb|nil|.

\begin{english}
  \begin{clojure}
(defn stop! []
  (alter-var-root
   (var server)
   (fn [server]
     (when server
       (.stop server))
     nil)))
  \end{clojure}
\end{english}

Вызов \spverb|(start!)| запустит сервер в фоне. Браузер ответит на запросы по
адресу localhost:8080. Переменная \spverb|server| напечатает в REPL объект
сервера.

\index{пул соединений}

Похожим образом работают с базой. Чтобы не открывать подключение на каждый
запрос, применяют пулы соединений. В модуле объявляют переменную \spverb|pool|
со значением \spverb|nil|. Функция \spverb|start!| создает новый пул и обновляет
переменную.

\index{библиотеки!JDBC}

После запуска к базе посылают запросы. Функции \spverb|query|, \spverb|insert!|
и другие из пакета JDBC принимают подключение к базе или пул:

\begin{english}
  \begin{clojure}
(jdbc/query pool "select * from users")
(jdbc/insert! pool :users {:name "Ivan"})
  \end{clojure}
\end{english}

Функция \spverb|stop!| выключает пул, закрывает соединения и выставляет
\spverb|pool| в \spverb|nil|. Опустим код этих функций, потому что они
отличаются только именем глобальной переменной и выражением, где создают сервер
и пул.

\subsection{Коротко о системах}

\index{системы}

\label{systems-intro}

Техника \spverb|alter-var-root| сообщает модулю состояние: включен и выключен. С
таким подходом проект удобно включать по частям, а не вс\"{е} разом. Для отладки
базы не нужен веб-сервер, а кэширование не зависит от рассылки писем.

Модули с состоянием называют компонентами. Вместо они образуют систему. С
помощью \spverb|alter-var-root| строят системы в небольших проектах. В основном
это веб-приложение с сервером и базой данных. В шутку их называют системами для
бедных.

\index{системы!бедные}

<<Бедные>> системы не зависят от сторонних библиотек. Каждый модуль выставляет
универсальные <<ручки управления>>: функции \spverb|start!| и \spverb|stop!|,
которые обращаются к \spverb|alter-var-root|. Это простая и удобная схема.

С другой стороны, <<бедные>> системы не знают, как один компонент зависит от
другого. Со временем зависимости становятся проблемой, поэтому большие системы
строят с помощью библиотек. Некоторые из них тоже опираются на
\spverb|alter-var-root|. Мы подробно рассмотрим системы в отдельной
главе \page{chapter-systems}.

\subsection{Патчинг}

\index{clojure.core!alter-var-root}
\index{патчинг}

Выше мы изменили переменную в текущем модуле. Истинная мощь
\spverb|alter-var-root| в том, что функция работает с переменными любого
пространства. Под любым мы понимаем:

\begin{itemize}

\item
  текущий модуль;

\item
  соседние модули проекта;

\item
  сторонние библиотеки;

\item
  стандартные модули Сlojure, например \spverb|clojure.core|.

\end{itemize}

\index{monkey patch}

Это мощная техника, но к ней прибегают редко. Менять код в полете считается
сомнительной практикой. По-другому е\"{е} называют <<monkey
patch>>\footurl{https://en.wikipedia.org/wiki/Monkey\_patch}. Термин означает
изменение классов и функций не в коде, а когда программа уже запущена.

Если патчингом злоупотребляют, программа ведет себя неочевидным
образом. Коллегам будет трудно понять, почему в коде написано одно, а
выполняется другое. Это затрудняет поддержку и раздражает. К патчингу прибегают,
если сошлись несколько условий:

\begin{itemize}

\item
  без изменений нельзя двигаться дальше;

\item
  проблема в сторонней библиотеке или платформе;

\item
  на устранение проблемы уйдет время.

\end{itemize}

Патчинг оправдан, когда вы нашли ошибку в чужой библиотеке. Даже если изменения
примут сразу, выпуск новой версии займет время. Если ошибка задерживает релиз,
подмените проблемную функцию с помощью \spverb|alter-var-root|.

Представим, условная библиотека \spverb|yamler| парсит файлы YAML. Функция
\spverb|read-yaml-tag| отвечает за теги. Выяснилось, что в разбор тегов
закралась ошибка, а нам нужно расставить их файле. Если ошибку легко исправить,
напишем функцию со звездочкой и заменим оригинал:

\begin{english}
  \begin{clojure}
(defn read-yaml-tag* [stream tag]
  ...)

(alter-var-root
 (var yamler.tags/read-yaml-tag)
 (constantly read-yaml-tag*))
  \end{clojure}
\end{english}

В комментарии добавьте ссылку на артефакт (GitHub, Jira). Создайте задачу,
чтобы удалить патч по выходу новой версии библиотеки.

Патчинг полезен в разработке. Данные часто печатают на экран, чтобы исследовать
их. Недостаток \spverb|println| в том, что вывод не структурирован. Коллекции
слипаются в одну строку, поэтому их трудно читать.

\index{печать!с отступами}
\index{модули!clojure.pprint}

Пакет \spverb|clojure.pprint| (сокращение от анг. \textbf{p}retty \textbf{p}rinting)
решает эту проблему. Функция \spverb|pprint| выводит данные с отступами и переносами строк,
что удобно для вложенных словарей. Но писать \spverb|(clojure.pprint/pprint data)|
вместо \spverb|(println data)| долго. Чтобы сократить код, заменим \spverb|println|
на \spverb|pprint|. Для этого пропатчим функцию:

\begin{english}
  \begin{clojure}
(require 'clojure.pprint)

(alter-var-root
 (var println)
 (constantly clojure.pprint/pprint))
  \end{clojure}
\end{english}

Выполните этот патч один раз в любом месте проекта. Теперь вызов
\spverb|(println data)| напечатает данные как это делает \spverb|pprint|:

\begin{english}
  \begin{clojure}
(println <vector-of-dicts-of-vectors>)

[{:foo 42, :bar [1 2 3 4 5 {:foo 42, :bar [1 2 {#, #}]}]}
 {:foo 42, :bar [1 2 {:foo 42, :bar [1 2 {#, #}]}]}]
  \end{clojure}
\end{english}

Функция заменит вложенные участки на символ \spverb|#|, чтобы не обрушить на
вас лавину данных. Глубину и длину печати задают особые переменные. Позже мы
узнаем, как управлять ими.

\subsection{В боевом режиме}

\label{install-logger}

\index{логирование!исключений}
\index{исключения!логирование}
\index{логирование!бекенд}

Рассмотрим, когда \spverb|alter-var-root| полезен в промышленном запуске. В
главе об исключениях мы отметили проблему: макросы \spverb|log/info|,
\spverb|log/error| и другие принимают исключение \page{log-ex-param}. У нас нет
контроля за тем, как выглядит исключение в логе. Перевод исключения в текст
оста\"{е}тся на усмотрение бекенда (log4j, Logback и других).

Мы написали функцию \spverb|ex-print|, которая печатает исключение как нужно
нам. Функция не вываливает стек-трейс на весь экран, а обходит цепочку. Для
каждого звена выводит класс, сообщение и контекст:

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

\noindent
Минус в том, что вместо \spverb|(log/error e)| приходится писать:

\begin{english}
  \begin{clojure}
(log/error (with-out-str (ex-print e)))
  \end{clojure}
\end{english}

\noindent
Это долго и вынуждает импортировать \spverb|ex-print| в каждый модуль, где пишут
исключения. Будет удобней, если останется только \spverb|(log/error e)|, а
\spverb|ex-print| сработает где-то за кадром. Это возможно с помощью
\spverb|alter-var-root|.

Заметим, что \spverb|log/error|, \spverb|log/info| и аналоги это не функции, а
макросы. Макрос это эфемерная сущность, на которую нельзя сослаться через
\spverb|var|. Макрос живет \emph{до} компиляции программы. Позже на его месте
остается код, который он произвел. Нельзя изменить макрос, но можно подменить
функции, которые он вызывает.

\index{логирование}

Макросы \spverb|log/error| и другие сводится к функции \spverb|log/log*|. Это
бутылочное горлышко, через которое проходят все логи. Вот как выглядит е\"{е}
сигнатура:

\begin{english}
  \begin{clojure}
(defn log* [logger level throwable message])
  \end{clojure}
\end{english}

Параметр \spverb|throwable| это исключение или \spverb|nil|. Подменим
\spverb|log*| на анонимную функцию со следующей логикой:

\begin{itemize}

\item
  если \spverb|throwable| не \spverb|nil|, перевести исключение в текст;

\item
  добавить его к исходному сообщению через перенос строки;

\item
  вызвать оригинальный \spverb|log*| с новым сообщением и \spverb|nil| для
  \spverb|throwable|. В нем отпала потребность, поскольку теперь оно часть
  сообщения;

\item
  если \spverb|throwable| \spverb|nil|, вызвать \spverb|log*| с исходными
  аргументами.

\end{itemize}

\noindent
Реализация:

\index{функции!install-better-logging}

\begin{english}
  \begin{clojure/lines}
(defn install-better-logging []
  (alter-var-root
   (var clojure.tools.logging/log*)
   (fn [log*] ;; origin function
     (fn [logger level throwable message]
       (if throwable
         (let [ex-out (with-out-str (ex-print throwable))
               message* (str message \newline ex-out)]
           (log* logger level nil message*))
         (log* logger level throwable message))))))
  \end{clojure/lines}
\end{english}

Хитрость кроется в параметре \spverb|log*| \coderef{4}. Анонимная функция в
\spverb|alter-var-root| принимает текущее значение переменной. Это исходная
функция \spverb|clojure.tools.logging/log*|, и параметр \spverb|log*| ссылается
на не\"{е}. Новая функция замкнута на \spverb|log*| и может е\"{е} вызывать.

Получился декоратор: новая версия \spverb|log*| меняет входные параметры и
вызывает старую функцию. После вызова \spverb|(install-better-logging)| вывод
исключений изменится. Достаточно написать \spverb|(log/error e)|, чтобы ошибка
приняла нужный вид.

Преимущество в том, что мы управляем \emph{всем} на уровне Clojure. Чтобы
улучшить логи, доработаем \spverb|ex-print| в любой момент. Это удобнее, чем
наследовать условный класс \spverb|com.logging.ThrowableRenderer| и
переопределять методы.

Вред от необдуманного \spverb|alter-var-root| сводит на нет плюсы, что мы
рассмотрели. Функция нужна, чтобы точечно менять переменные в~особых
случаях. Прибегайте к патчингу только если другие варианты исчерпаны.

\section{Немного о set!}

\index{печать!с отступами}
\index{модули!clojure.pprint}

Вернемся к функции \spverb|pprint| для красивой печати. Она интересна тем, что
проверяет длину и уровень коллекций. Так мы не допустим ситуации, когда вывод
заливает несколько экранов. Проверка на длину особенно важна, потому что
некоторые коллекции не просто велики, а \emph{бесконечны}.

\index{бесконечность}
\index{коллекции!бесконечные}
\index{clojure.core!*print-length*}
\index{clojure.core!set"!}

Длину и вложенность вывода задают глобальные переменные \spverb|*print-length*|
и \spverb|*print-level*|. По умолчанию \spverb|*print-length*| равен 100. Это
довольно много, особенно если учесть, что элементами могут быть другие
коллекции. Результат запроса к базе это список словарей. Печатать сто
словарей расточительно, поэтому уменьшим \spverb|*print-length*| на старте
приложения. Для этого служит форма \spverb|set!|:

\begin{english}
  \begin{clojure}
(set! *print-length* 8)
  \end{clojure}
\end{english}

\noindent
Вывод бесконечной коллекции покажет только первые 8 элементов. Многоточие
означает, что остальные элементы отбросили.

\begin{english}
  \begin{clojure}
(println (repeat 1))
;; (1 1 1 1 1 1 1 1 ...)
  \end{clojure}
\end{english}

Вложенность или уровень коллекции это воображаемый индекс. Когда одна коллекция
становится элементом другой, е\"{е} индекс увеличивается на единицу. Объявим
вложенную структуру:

\begin{english}
  \begin{clojure}
(def data {:foo {:bar {:baz [42]}}})
  \end{clojure}
\end{english}

\noindent
Вывод при разных значениях \spverb|*print-level*|:

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
;; {:foo {:bar #}}

(set! *print-level* 2)
(println data)
;; {:foo #}
  \end{clojure}
\end{english}

\noindent
При нулевом уровне увидим только \spverb|#|.

\index{ушки}

В Clojure около десяти переменных с <<ушками>>. По другому их называют
системными, потому что они влияют на поведение языка в целом. Две переменных мы
уже рассмотрели: это \spverb|*print-length*| и \spverb|*print-level*| для
печати. Перечислим несколько других:

\begin{itemize}

\index{рефлексия}
\index{clojure.core!*warn-on-reflection*}

\item
  \spverb|*warn-on-reflection*|: если истина, компилятор предупреждает о местах,
  где он обратился к рефлексии. Проблему решают расстановкой тегов с типами.

\index{assert}
\index{clojure.core!*assert*}

\item
  \spverb|*assert*|: если ложь, отключает \spverb|assert|-макрос. Форма
  \spverb|assert| проверяет выражение на истинность. Когда оно ложно, макрос
  бросает исключение.  По умолчанию \spverb|assert|ы включены; ими пользуются в
  разработке и тестировании. В боевом режиме их выключают, чтобы не тратить
  ресурсы.

\index{метаданные}
\index{печать!метаданных}
\index{clojure.core!*print-meta*}
\index{библиотеки!Component}

\item
  \spverb|*print-meta*|: выводить или нет метаданные объекта при печати. По
  умолчанию их не видно. Иногда в метаданных хранят поля, которые влияют на
  работу программы. Например, библиотека Component управляет зависимостями
  компонентов через метаданные. Их будет легче увидеть, если установить
  \spverb|*print-meta*| в истину.

\end{itemize}

Эти и другие переменные изменяют формой \spverb|set!|. Рассмотрим несколько
примеров. Показать предупреждения, если компилятор не вывел тип:

\begin{english}
  \begin{clojure}
(set! *warn-on-reflection* true)
(def ms (System/currentTimeMillis))
(.toString ms)       ;; reflection warning
(.toString ^Long ms) ;; no warning
  \end{clojure}
\end{english}

\noindent
Отключить формы \spverb|assert|. Ложные выражения не вызовут ошибку:

\begin{english}
  \begin{clojure}
(set! *assert* false)
(assert (get {:foo 42} :bar))
;; won't throw an exception
  \end{clojure}
\end{english}

\noindent
Вывести объект с метаданными (приведем фрагмент):

\begin{english}
  \begin{clojure}
(set! *print-meta* true)
(var +)

^{:added "1.2"
  :name +
  :file "clojure/core.clj"
  :column 1
  :line 984
  :arglists ([] [x] [x y] [x y & more])
  :doc "Returns the sum of nums..."}
#'clojure.core/+
  \end{clojure}
\end{english}

\index{утилиты!lein}
\index{профили!lein}

Утилиты для управления проектами читают переменые с <<ушками>> из
словаря. Конфигурация \spverb|lein| учитывает ключ \spverb|:global-vars|. Ещ\"{е}
большей гибкости можно добиться, если указать переменные в профилях. Ниже мы
задаем разные переменные в зависимости от режима разработки (dev) и сборки
(uberjar).

\begin{english}
  \begin{clojure}
{:profiles
 :dev {:global-vars {*warn-on-reflection* true
                     *assert* true}}
 :uberjar {:global-vars {*warn-on-reflection* false
                         *assert* false}}}
  \end{clojure}
\end{english}

С помощью \spverb|set!| нельзя изменить свои переменные, даже если они с
<<ушками>> и помечены как динамические. Пример ниже бросит исключение:

\begin{english}
  \begin{clojure}
(def ^:dynaimc *data* nil)
(set! *data* {:user 1})
;; Unhandled java.lang.IllegalStateException
;; Can't change/establish root binding of: *data* with set
  \end{clojure}
\end{english}

\section{Изменения в контексте}

\index{контекст}
\index{изменения!в контексте}

При\"{е}мы, которые мы рассмотрели, похожи в следующем: их эффект длится до конца
программы. Изменения в атомах, транзиентных коллекциях и глобальных переменных
называют \emph{персистентными} (анг. persistent~--- постоянный).

Иногда изменения должны быть временными: глобальная переменная равна $x$, но
участок кода ожидает $y$. Можно сделать временные изменения на базе постоянных:
окружить код вызовом \spverb|alter-var-root| с новым и старым значениями. У
такого подхода две проблемы: изоляция и откат.

\index{clojure.core!alter-var-root}

Временные изменения протекают в одном потоке. Эффект \spverb|alter-var-root|
противоположный~--- функция меняет переменную для всех потоков. Если фрагмент
кода вызывает \spverb|alter-var-root|, он задевает всех участников. Это приводит
к странному поведению программы.

Проблема отката означает, при выходе из участка переменную нужно вернуть в
прежнее состояние. Когда код оборачивают в \spverb|alter-var-root| или
\spverb|set!|, одна из форм может потеряться или не получить управление из-за
ошибки.

Мы займемся временным изменением данных. Clojure предлагает несколько форм,
чтобы выполнить код в контексте переменных с другими значениями. Одна из них это
\spverb|binding| \eng{связывание}.

\index{связывание}
\index{clojure.core!binding}

Синтаксис \spverb|binding| похож на \spverb|let|: форма связывания и
произвольный код. Связывание это вектор, где указаны символы переменных и новые
значения. Символы ссылаются на уже объявленные переменные. Блок кода запускается
с новыми значениями у переменных. Результат \spverb|binding| это последнее
выражение блока. Изменения \spverb|binding| протекают в рамках текущего потока и
не влияют на соседние. При выходе переменные получат старые значения.

\subsection{Динамические переменные}

\index{переменные!динамические}

\label{dynamic-vars}

\spverb|Binding| работает только с динамическими переменными. Компилятор считает
переменную таковой, если ей назначили тег \spverb|^:dynamic|. Это сокращенная
форма \spverb|^{:dynamic true}|:

\begin{english}
  \begin{clojure}
(def ^:dynamic *server* nil)
;; or
(def ^{:dynamic true} *server* nil)
  \end{clojure}
\end{english}

Словарь с крышкой в \spverb|def| называют метаданными. Это дополнительные
параметры будущей переменной. В данном случае мы сообщаем компилятору, что
переменная динамическая и может быть изменена в будущем.

Глобальные переменные выделяют <<ушками>>, звездочками по краям. В
английском языке такую запись называют <<earmuffs syntax>>. Правило возникло в
старых диалектах Лиспа, и Clojure следует традиции.

\index{языки!Lisp}

Ушки и динамичность связаны между собой. Если переменная с~ушками, но не
динамическая, компилятор скажет о расхождении. Сами по себе ушки не делают
переменную динамической, это просто соглашение.

\begin{english}
  \begin{clojure}
(def *server* nil)
;; Warning: *server* not declared dynamic and thus [...]
;; Please either indicate ^:dynamic *server* or change the name.
  \end{clojure}
\end{english}

\noindent
Если переменная не динамическая, \spverb|binding| бросит исключение:

\begin{english}
  \begin{clojure}
(binding [*server* {:port 8080}]
  (println *server*))
;; Execution error (IllegalStateException)
;; Can't dynamically bind non-dynamic var: *server*
  \end{clojure}
\end{english}

\subsection{Отказ от set!}

Вспомним параметры длины и глубины печати. Чтобы обезапасить себя от больших
данных, мы писали что-то вроде:

\begin{english}
  \begin{clojure}
(set! *print-level* 4)
(println data)
  \end{clojure}
\end{english}

\index{печать!с отступами}

Это неудачный пример: он нарушает принципы изоляции и отката, которые мы
рассмотрели. Изменение \spverb|*print-level*| не изолировано и влияет на систему
глобально. Если другой поток что-то напечатает, мы увидим результат с уровнем 4,
что может нас не устроить. После \spverb|(println data)| нужно
восстановить значение \spverb|*print-level*|, но об этом легко забыть.

Код ниже избавлен от недостатков. Вне \spverb|binding| переменные получат
прежние значения, а соседние потоки ничего не заметят.

\begin{english}
  \begin{clojure}
(binding [*print-level* 8
          *print-length* 4]
  (println {:foo {:bar {:baz (repeat 1)}}}))
;; {:foo {:bar {:baz (1 1 1 1 ...)}}}
  \end{clojure}
\end{english}

\index{clojure.core!*out*}
\index{классы!Writer}

Чтобы направить печать в файл, свяжите переменную \spverb|*out*| с объектом
\spverb|Writer|:

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(with-open [out (io/writer "dump.edn")]
  (binding [*out* out]
    (clojure.pprint/pprint {:test 42})))
  \end{clojure}
\end{english}

Объединим эти примеры в функцию для сброса данных в файл. Функция полезна для
отладки больших данных. Она принимает путь к файлу и коллекцию. Функция
связывает вывод с открытым файлом и печатает данные. Чтобы увидеть все элементы,
повысим длину и глубину печати.

\begin{english}
  \begin{clojure}
(defn dump-data
  [path data]
  (with-open [out (io/writer path)]
    (binding [*out* out
              *print-level* 32
              *print-length* 512]
      (clojure.pprint/pprint data))))
  \end{clojure}
\end{english}

\noindent
Сброс данных в файл:

\begin{english}
  \begin{clojure}
(dump-data "sample.edn" {:foo [1 2 3 {:foo [1 2 3]}]})
  \end{clojure}
\end{english}

\noindent
и восстановление:

\begin{english}
  \begin{clojure}
(-> "sample.edn" slurp read-string)
;; {:foo [1 2 3 {:foo [1 2 3]}]}
  \end{clojure}
\end{english}

\index{clojure.core!*print-level*}
\index{clojure.core!*print-length*}

Доработайте функцию так, чтобы можно было задать \spverb|*print-level*| и
\spverb|*print-length*|. В идеале это необязательный словарь \spverb|opt|, в
котором функция ищет настройки.

\subsection{Практика: перевод строк}

Приведем пример с \spverb|binding| из реального проекта. Это веб-приложение на
разных языках. В зависимости от настроек клиент видит английский или русский
текст.

\index{перевод}

Переводы хранят в виде словаря. В нем два уровня: локаль и теги. Локаль это код
языка: \spverb|ru| и \spverb|en| другие. Локаль может быть с доменами, например
\spverb|en_US| или \spverb|en_GB|. Части \spverb|US| и \spverb|GB| означают
американский и британский диалекты. В редких случаях локаль бывает тройной,
чтобы указать алфавит или регион.

Под тегом понимают короткую машинную строку. Она описывает семантику фразы, на
которую позже е\"{е} заменят. По тегу \spverb|ui/add-to-cart| легко
угадать, что это надпись <<добавить в корзину>>.

Словари могут быть в коде или файлах, но принцип перевода не меняется. По локали
и тегу библиотека ищет перевод в словаре (<<совершает lookup>>). Напишем
наивный подход на Clojure:

%% \begin{english}
  \begin{clojure}
(def tr-map
  {:en {:ui/add-to-cart "Add to Cart"}
   :ru {:ui/add-to-cart "Добавить в корзину"}})

(defn tr [locale tag]
  (or (get-in tr-map [locale tag])
      (format "<%s%s>" locale tag)))
  \end{clojure}
%% \end{english}

\index{функции!tr}
\index{локализация}

Функция \spverb|tr| возвращает перевод то локали и тегу. Если перевод не найден,
получим машинное выражение, которое заметят локализаторы.

Недостаток функции в том, что каждый раз нужно указывать локаль. Это
утомительно, особенно с учетом того, что локаль не меняется в рамках
запроса. Между локалью и переводом большая физическая и ментальная
дистанция, и хотелось бы е\"{е} сократить.

\index{стек вызовов}

Под физическим расстоянием понимают стек вызовов. Обычно локаль вычисляют в
middleware в начале запроса. Перевод текста, напротив, работает ближе к его
концу. Если не сделать локаль глобальной, прид\"{е}тся спускать е\"{е} в аргументах по
стеку вызовов, что усложняет код.

\index{фреймворки!Django}

Ментальная дистанция означает, что в момент перевода нам не важно, откуда пришла
локаль. Эти сведения избыточны. Хотелось бы примитивную операцию <<перевести
тег>>, и не больше. Польза упрощения видна на примере шаблонной системы,
устроенной по принципу Django\footurl{https://docs.djangoproject.com/en/2.2/topics/templates/}.

\index{библиотеки!Selmer}
\index{шаблоны}

Аналог такой системы в Clojure называется
Selmer\footurl{https://github.com/yogthos/Selmer}. Е\"{е} шаблоны похожи на
обычные HTML-файлы со вставками в фигурных скобках. Код в скобках это значения
или выражения. Вертикальные линии означают фильтры, функции
преобразования. Например, запись:

\begin{english}
  \begin{htmldjango}
<p>{{ user.email|lower }}</p>
  \end{htmldjango}
\end{english}

\noindent
означает, что между тегами параграфа находится поле \spverb|:email| из словаря
\spverb|user|. Регистр поля меняют на нижний фильтром \spverb|lower|. То же
самое на Clojure:

\begin{english}
  \begin{clojure}
(str/lower-case (:name user))
  \end{clojure}
\end{english}

Фильтром может быть любая функция, в том числе \spverb|tr|. Хотелось бы,
чтобы шаблон выглядел как можно проще:

\begin{english}
  \begin{htmldjango}
<div class="widget">
  <a href="/login">{{ "ui/log-in"|tr }}</a>
  <a href="/help">{{ "ui/help"|tr }}</a>
</div>
  \end{htmldjango}
\end{english}

Фильтр \spverb|tr| это функция одной переменной. Она принимает строку тега и
возвращает перевод. Очевидно, локаль должна быть известна заранее. Сделаем так,
чтобы фильтр читал е\"{е} из middleware, и при этом не влиял на перевод в параллельных
запросах.

Поможет связывание через \spverb|binding|. Определим переменную
\spverb|*locale*| без значения. В Clojure такая переменная называется
несвязанной. Считайте е\"{е} ячейкой, в которой нет данных.

Изменим функцию \spverb|tr|: теперь она принимает только тег, а в качестве
локали ссылается на глобальную \spverb|*locale*|:

\begin{english}
  \begin{clojure}
(def ^:dynamic *locale*)

(defn tr [tag]
  (get-in tr-map [*locale* tag]))
  \end{clojure}
\end{english}

\index{макросы!with-locale}

Чтобы изолировать \spverb|*locale*| от внешнего кода, предоставим макрос
\spverb|with-locale|. Он выполняет тело, пока переменная связана с заданной
локалью. Внутри макроса любой перевод сработает для этой локали:

%% \begin{english}
  \begin{clojure}
(defmacro with-locale
  [locale & body]
  `(binding [*locale* ~locale]
     ~@body))

(with-locale :en
  (tr :ui/add-to-cart))
;; "Add to Cart"

(with-locale :ru
  (tr :ui/add-to-cart))
;; "Добавить в корзину"
  \end{clojure}
%% \end{english}

\index{middleware!wrap-locale}

Напишем middleware, чтобы определить локаль. Для простоты решим, что это
параметр \spverb|lang| из адресной строки. Если параметра нет, берем локаль по
умолчанию. Код ниже по стеку обернут в макрос \spverb|with-locale|:

\begin{english}
  \begin{clojure}
(defn request->locale [request]
  (-> request
      (get-in [:params "lang"])
      (#{"en" "ru"})
      (some-> keyword)
      (or :en)))

(defn wrap-locale [handler]
  (fn [request]
    (with-locale (request->locale request)
      (handler request))))
  \end{clojure}
\end{english}

Напишем фильтр \spverb|tr| для шаблонов. В Selmer нельзя указать кейворд,
поэтому вместо \spverb|{{ :ui/sign-in }}| пишут \spverb|{{ "ui/sign-in"}}|.
Фильтр \spverb|tr| переводит строку в ключ, а затем ищет по нему
перевод. Функция \spverb|add-filter!| добавляет \spverb|tr| в регистр фильтров.

\begin{english}
  \begin{clojure}
(require '[selmer.filters :refer [add-filter!]])

(add-filter! :tr
 (fn [line]
   (-> line keyword tr)))
  \end{clojure}
\end{english}

Теперь нам не важен источник локали в переводах. В любой момент мы изменим код
\spverb|with-locale| и \spverb|wrap-locale|, но это не отразится на
шаблонах. Запись \spverb={{ "ui/log-in"|tr }}= останется прежней, даже если
механизм переводов изменится.

\section{Локальные переменные в контексте}

\index{clojure.core!with-local-vars}
\index{clojure.core!let}
\index{clojure.core!var-get}
\index{clojure.core!var-set}
\index{переменные!локальные}

Макрос \spverb|with-local-vars| зада\"{е}т локальные переменные. Внутри макроса они
ведут себя как маленькие атомы. В переменную можно записать значение и
<<дерефнуть>>, чтобы его получить. Локальные переменные полезны для запутанной
бизнес-логики. Блок с ними выглядит линейно, его проще читать.

Форма \spverb|with-local-vars| похожа на \spverb|let|: это вектор связывания и
произвольный код. Разница в том, что внутри макроса работают функции
\spverb|var-get| и \spverb|var-set|. С их помощью переменые читают и
записывают. Если макрос задал переменную \spverb|a|, форма
\spverb|(var-set a 9)| установит е\"{е} содержимое в 9.

Важно: символ переменной верн\"{е}т е\"{е} \emph{объект}, а не значение. В примере ниже
получим не ноль, а объект типа \spverb|Var|. Запись \spverb|(+ a 1)| приведет к
ошибке типов.

\begin{english}
  \begin{clojure}
(with-local-vars [a 0] a)
;; #<Var: --unnamed-->
  \end{clojure}
\end{english}

Функция \spverb|var-get| получает значение из переменной. Для краткости
прибегают к оператору \spverb|@|: \spverb|(+ @a 1)|.

Представим, нужно найти в дереве несколько величин и вернуть их композицию. В
прошлый раз мы работали с атомом, теперь решим задачу на локальных переменных.

Функция \spverb|calc-billing| рассчитывает сумму к оплате для клиента. Параметр
\spverb|data| это данные о потреблении ресурсов. Итоговую сумму находят из трех
составляющих. Каждую из них рассчитывают по сложным условиям. Чтобы код был
ближе к бизнес-логике, запишем его императивно:

\begin{english}
  \begin{clojure}
(defn calc-billing [data]
  (with-local-vars
    [a 0 b 0 c 0]
    ;; find a
    (when-let [usage ...]
      (when-let [days ...]
        (var-set a (* usage days))))
    ;; find b
    (when-let [vms ...]
      (when-let [limits ...]
        (var-set b (* limits vms))))
    ;; find c ...
    (+ (* @a @b) @c)))
  \end{clojure}
\end{english}

Расчет делится на три блока, каждый из которых считает составляющую. Каскад
\spverb|when-let| собирает переменные, и если они нашлись, завершается
\spverb|var-set|. Если исполнение не дошло до \spverb|var-set|, переменная
останется нул\"{е}м.

Локальные переменные не настолько продвинуты как атомы. Для переменных нет
аналога \spverb|swap!|, когда значение меняют функцией. \spverb|With-local-vars|
не подходит для наращивания коллекций. Если \spverb|user| это локальный словарь,
добавить к нему новое поле трудно. Функция \spverb|var-set| зада\"{е}т только
новый словарь, но комбинация \spverb|var-set| и \spverb|var-get| выглядит
неуклюже:

\begin{english}
  \begin{clojure}
(with-local-vars [user {:name "Ivan"}]
  ;; (var-set user assoc :age 33) ;; won't work
  (var-set user (assoc @user :age 33)) ;; ugly
  @user)
  \end{clojure}
\end{english}

Макрос \spverb|with-local-vars| полезен, когда логика завязана на простых типах
(числах, строках). На локальных переменных удобно писать конечные автоматы и
алгоритмы с состоянием. Техника редко встречается в Clojure, но в нужный момент
экономит время и код.

\section{Глобальные изменения в контексте}

\index{clojure.core!binding}
\index{изменения!глобальные}

\label{with-redefs}

Преимущество \spverb|binding| в том, что изменения протекают только в текущем
потоке. Говорят, что эффект \spverb|binding| потокобезопасный, что расценивают
как благо. И вс\"{е} же бывают случаи, когда изменения должны быть глобальными. Для
этого служит форма \spverb|with-redefs|.

Е\"{е} синтаксис похож \spverb|binding|: вектор связывания и произвольный
код. Эффект \spverb|with-redefs| действует \emph{на все} потоки. Представим
веб-сервер, который отвечает на запросы параллельно. Если одна из страниц
выполняет логику в \spverb|with-redefs|, это повлияет на соседние
запросы. Аналогично \spverb|binding| и \spverb|let|, изменения откатываются при
выходе из макроса.

Пример ниже объясняет принципы \spverb|with-redefs|. Мы подменяем функцию
\spverb|println| на суррогат, который печатает постоянный текст. В теле макроса
запускают футуру с телом \spverb|(println 42)|.

\index{clojure.core!future}
\index{футуры}

Футура (или \emph{фьючер}, анг. \emph{future}, будущее) это посредник между
клиентом и многопоточностью. Футура принимает блок кода и передает его
исполнителю (executor). Чаще всего исполнитель занимает несколько тредов
(потоков процессора) и распределяет по ним задачи. Когда задача выполнена,
клиент получает результат <<дерефом>> футуры.

Тело \spverb|(println 42)| выполнится в другом потоке. Оператор \spverb|@|
перед футурой означает ждать до тех пор, пока не придет результат из пула. Код
ниже напечатает <<fake print>>:

\index{clojure.core!constantly}

\begin{english}
  \begin{clojure}
(with-redefs
  [println (constantly (print "fake print"))]
  @(future (println 42)))
;; fake print
  \end{clojure}
\end{english}

Это произошло потому, что \spverb|with-redefs| повлиял в том числе и на тот
поток, в котором пул выполнил футуру.

Если убрать оператор \spverb|@|, эффект \spverb|with-redefs| пропадет: футура
напечатает 42. Причина в том, цикл футуры занимает хоть и малое, но время. Без
оператора \spverb|@| мы только запускаем футуру и сразу выходим из
\spverb|with-redefs|. Пул доберется до задачи \spverb|(println 42)| когда уже
эффект макроса закончится.

Документация \spverb|with-redefs| подчеркивает, что макрос полезен при
тестировании. Иногда приложение опирается на сторонние сервисы: геопоиск или
граф социальных связей. При тестировании возникает проблема доступа к
сервисам. Приложение не должно обращаться к ним: это усложняет тесты и расходует
квоты на доступ.

Идея в том, чтобы на время тестов подменить функции, которые обращаются в
сеть. Рассмотрим на практике, как это сделать.

\subsection{Практика: приложение с координатами}

\index{практика}
\index{HTTP!POST}
\index{координаты}
\index{геолокация}

Мобильное приложение шлет на сервер координаты пользователя. Это пара чисел:
долгота и широта. Позже пользователь изучает историю путешествий. Очевидно, он
ожидает не машинные цифры, а названия мест. Для каждой пары координат нужно
найти данные об этом месте.

Страница \spverb|POST /location| принимает коорданаты в JSON-теле запроса. Чтобы
узнать данные о месте, мы обращаемся к стороннему сервису. Из ответа бер\"{е}м
поля и пишем в базу вместе с координатами. Возвращаем ответ \spverb|200 OK|.

Функция \spverb|geo/place-info| выполняет геопоиск. Считаем, что на выходе
словарь с ключами \spverb|:title|, \spverb|:country|, \spverb|:image_url| и
другими. Обработчик запроса:

\begin{english}
  \begin{clojure}
(defn location-handler [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        place (geo/place-info point)]
    (db/create-location (merge place point))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

Во время поиска мобильное приложение ждет ответа. С машинной точки зрения это
долго, ведь сеть не гарантирует мгновенный отклик. Чем больше клиентов шлют
координаты, тем больше запросов мы посылаем геосервису. Растет число
открытых соединений, система замедляется.

\index{clojure.core!future}

Быстрое решение в том, чтобы записать координаты в базу и сразу ответить
клиенту, а сбор данных о месте вынести в футуру. Этим мы сократим ожидание:
теперь приложение ждет только запись в базу, что быстрее, чем запрос в сеть.

В новой версии функция \spverb|db/create-point| пишет коорданаты и возвращает
\spverb|id| новой записи. Ключ нужен, чтобы позже обновить локацию данными о
месте. Поиск данных и запись в базу протекают в футуре.

\begin{english}
  \begin{clojure}
(defn location-handler
  [request]
  (let [{:keys [params]} request
        point (select-keys params [:lat :lon])
        row-id (db/create-point point)]
    (future
      (let [place (geo/place-info point)]
        (db/update-place row-id place)))
    {:status 200 :body "OK"}))
  \end{clojure}
\end{english}

Возможны и другие варианты: фоновый обработчик или очередь задач. Но они дольше
в реализации, а футура займет пару строк. Это дешевое решение, которое даст
время на поиск оптимального.

\subsection{Тесты}

\index{тесты}
\index{clojure.core!with-redefs}

Напишем тест для нового обработчика. Чтобы не порождать сетевых запросов,
временно заменим функцию \spverb|geo/place-info|. Для полноты картины проверим,
что случится, если геопоиск бросит исключение.

Каждый тест начинается с выражения \spverb|with-redefs| для замены
\spverb|geo/place-info|. Чтобы уменьшить код, напишем макрос
\spverb|with-place-info|. Он принимает тело функции и блок кода:

\begin{english}
  \begin{clojure}
(defmacro with-place-info
  [result & body]
  `(with-redefs [geo/place-info
                 (fn [~'point] ~result)]
     ~@body))
  \end{clojure}
\end{english}

Ниже тест для положительного сценария. В макросе \spverb|with-place-info|
геопоиск верн\"{е}т заданный словарь. Мы вызываем обработчик и проверяем, что ответ
положительный. Чтобы убедиться, что футура записала данные в базу, немного ждем
и читаем последнюю локацию. В ней должны быть значения из геопоиска.

\begin{english}
  \begin{clojure}
(deftest test-place-ok
  (with-place-info
    {:title "test_title"
     :country "test_country"}
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location (db/get-last-location)
            {:keys [title country]} location]
        (is (= "test_title" title))
        (is (= "test_country" country))))))
  \end{clojure}
\end{english}

\index{HTTP!429}
\index{квоты}

Негативный сценарий: пусть геопоиск бросит исключение с кодом 429. Это
возможно, если превышен лимит на число запросов. Объявим исключение:

\begin{english}
  \begin{clojure}
(def ex-quota
  (ex-info "429 Quota reached"
           {:status 429
            :body {:error_code :QUOTA_REACHED
                   :error_message "..."}}))
  \end{clojure}
\end{english}

\noindent
Проверим, что приложение верн\"{е}т положительный статус, но в базе нет данных о
месте, потому что запрос не удался.

\begin{english}
  \begin{clojure}
(deftest test-place-quota-reached
  (with-place-info (throw ex-quota)
    (let [request {:params {:lat 11.111 :lon 22.222}}
          {:keys [status body]} (location-handler request)]
      (is (= 200 status))
      (Thread/sleep 100)
      (let [location (db/get-last-location)
            {:keys [title country]} location]
        (is (nil? title))
        (is (nil? country))))))
  \end{clojure}
\end{english}

С помощью \spverb|with-place-info| можно спровоцировать любое исключение. Это
полезно, когда \spverb|try/catch| ожидает конкретные классы. Следующий пример
имитирует сбой в сети:

\index{тесты!ошибки}

\begin{english}
  \begin{clojure}
(deftest test-place-conn-err
  (with-place-info
    (throw (new java.net.ConnectException "test_timeout"))
    ...))
  \end{clojure}
\end{english}

\index{мок}

Подмена функций и классов называется \emph{мок} или \emph{мокинг} (анг. mock~---
подделка). Мы подробно рассмотрим тесты ближе к концу
книги \page{chapter-tests}. Пока что заметим, что макрос \spverb|with-redefs|
это простой способ что-то <<замокать>>, то есть подменить на время тестов.

\subsection{Коротко о with-redefs-fn}

\index{clojure.core!with-redefs-fn}

Макрос \spverb|with-redefs| это улучшенный вариант формы
\spverb|with-redefs-fn|. Отличие в синтаксисе: если \spverb|with-redefs| похож
на \spverb|let|, то \spverb|with-redefs-fn| принимает словарь и функцию без
аргументов. Ключи словаря это объекты \spverb|Var|. Функция сработает в момент,
когда переменные получили новые значения.

Перепишем пример с \spverb|geo/place-info| на новый макрос. Напомним, что запись
\spverb|#'<something>| аналогична \spverb|(var <something>)|:

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  (fn []
    (geo/place-info {:lat 1 :lon 2})))
  \end{clojure}
\end{english}

\index{синтаксис!\#}

Если тело макроса это одна большая форма (\spverb|let|, \spverb|do|), то не
обязательно оборачивать е\"{е} в \spverb|(fn [])|. Поставьте спереди знак
\spverb|#|, чтобы превратить форму в анонимную функцию.

\begin{english}
  \begin{clojure}
(with-redefs-fn
  {#'geo/place-info (fn [point] {:title "test"})}
  #(let [point {:lat 1 :lon 2}
         place (geo/place-info point)]
     ...))
  \end{clojure}
\end{english}

Синтаксис \spverb|with-redefs-fn| выглядит непривычно из-за словаря и символов
\spverb|#'|. Легко забыть, что тело это не блок кода, а функция. Макрос непохож
на аналоги \spverb|let|, \spverb|binding| и другие из поставки Clojure.
\spverb|With-redefs| скрывает эти отличия; по возможности пользуйтесь им.

\section{Заключение}

Clojure предлагает типы для изменения данных. В отличии от императивных языков,
где измененение занимает символ, в Clojure пользуются особыми формами. Язык
устроен так, что данные меняют редко. Это продвинутый уровень, к которому
приходят после азов неизменяемости.

Перечислим техники, которые мы рассмотрели и случаи, когда они полезны.

\emph{Атом} это об\"{е}ртка вокруг значения. Чтобы получить содержимое, применяют
оператор \spverb|@| или функцию \spverb|(deref <atom>)|. Новое значение сообщают
функцией \spverb|reset!|. Чаще атом изменяют итеративно с помощью
\spverb|swap!|, которая рассчитывает новое значение из текущего.

В атомах хранят состояние частей проекта. Это сч\"{е}тчики, сессии, локальный кэш
для ускорения расчетов. Атомы подходят на роль переменных в императивном
коде. Иногда в атомах хранят состояние модуля, например, текущее подключение к
базе.

Объект \emph{volatile} это облегченный вариант атома. В отличии от него,
\spverb|volatile| не поддерживает валидаторы и вотчеры и не управляет доступом
из разных потоков.

Переходные или \emph{транзиентные коллекции} получают из постоянных
аналогов. Когда коллекция транзиентна, меняется е\"{е} содержимое. С ними работают
функции \spverb|conj!|, \spverb|assoc!| и другие с восклицательным знаком на
конце. Функция \spverb|persistent!| запечатывает коллекцию и возвращает
постоянную копию.

Транзиентные коллекции полезны на больших данных, потому что быстрее
неизменяемых. Работайте с ними из одного потока. Другие части кода не должны
знать о том, что коллекция изменяется. Обмен переходными коллекциями это грубая
ошибка.

Функция \emph{alter-var-root} заменяет глобальную переменную. С е\"{е} помощью можно
вторгнутся в чужое пространство и что-то исправить. К \spverb|alter-var-root|
прибегают, чтобы изменить код, которым не владеют. Другое е\"{е} применение~---
модули с состоянием, из которых собирается система.

Форма \emph{set!} изменяет системную переменную Clojure. Это особые переменные с
<<ушками>>, которые влияют на поведение системы в целом. \spverb|Set!| редко
встречается в коде: чаще переменные указывают в настройках проекта.

Макрос \emph{binding} выполняет код в рамках временных изменений. Макрос
связывает динамическую переменную с новым значением. Чтобы переменная была
динамической, ей сообщают флаг \spverb|^:dynamic| и выделяют <<ушками>>.

\spverb|Binding| действует только в текущем потоке. К нему прибегают, чтобы
участок кода вел себя по-иному. Например, выводил текст не на экран, а в
файл. Динамические переменные легче спустить по стеку вызовов, как в примере с
локалью.

Макрос \emph{with-local-vars} выполняет тело с произвольными переменными. Они
похожи на атом с двумя действиями: прочитать и записать значение. Форма полезна,
когда имеем дело со сложной императивной логикой. При выходе из макроса
переменные исчезают.

Конструкция \emph{with-redefs} временно изменяет \spverb|def|-определения. В
отличии от \spverb|binding|, она действует глобально. Все фоновые сущности
(футуры, агенты) подхватят изменения. \spverb|With-redefs| это об\"{е}ртка над
низкоуровневой формой \spverb|with-redefs-fn|. В основном ей пользуются в тестах
(<<мокинг>>).
