\chapter{Системы}

\begin{teaser}
В этой главе мы поговорим о системах. Рассмотрим, как составить проект из
отдельных частей и заставить работать их вместе.
\end{teaser}

%% TODO link

Понятие системы тесно связано с конфигурацией, которую мы обсудили
недавно. Конфигурация учит, как принять параметры из внешнего мира. Система
задает внутреннее устройство программы. Это набор компонентов со связями и
иерархией.

Система зависит от конфигурации, но не строго один к одному. Для одной и той же
конфигурации бывают разные системы и наоборот. Главное отличие в следующем:
конфигурация отвечает на вопрос как получить параметры, а система знает, как ими
распорядиться.

\section{Подробнее о системе}

Понятие системы появилось в момент, когда возник спрос на долгоиграющие
приложения. При разработке скриптов или утилит вопрос не стоял остро. Время
работы скрипта обычно коротко, и его состояние тоже живет недолго. При
завершении программы ресурсы освобождаются, поэтому нет смысла в особом контроле
за ними.

Все по-другому с серверными приложениями. Они работают постоянно и потому
устроены иначе, чем разовые скрипты. Приложение состоит из компонентов, которые
работают в фоне. Каждый компонент выполняет узкую задачу. При запуске приложение
включает компоненты в правильном порядке и строит между ними связи.

Компонент это объект, который несет состояние. На него действуют две операции:
включить и выключить. Как правило, включить компонент означает установить
соединение с каким-либо ресурсом, а выключить~--- закрыть его.

Типичные компоненты веб-приложения это HTTP-сервер, база данных, кэш. Чтобы не
открывать соединение на каждый запрос к базе, понадобится пул соединений. Но
создавать его вручную и передавать в функции это слишком рутинная задача. Должен
быть компонент, который при включении открывает пул и хранит его. Для сторонних
потребителей компонент предлагает функции для работы с базой. Внутри функции
опираются на открытый пул.

На первый взгляд схема напоминает ООП и принцип инкапсуляции. Не торопитесь с
выводами: в Clojure компоненты работают иначе. Ниже мы рассмотрим техническую
разницу между объектами и компонентами.

\section{Зависимости}

Главная проблема системы это зависимости компонентов. В примере выше все
компоненты~--- сервер, база и кэш~--- работают обособленно. Подключение к базе
нужно только для отдельных страниц, а недоступность кэша не ломает
приложение. Это базовые компоненты системы.

Компоненты высокого уровня опираются на базовые. Это может быть фоновый поток,
который читает базу и отправляет письма. Будет неправильно, если компонент
откроет свои подключения к базе и почте. Вместо этого он принимает уже
запущенные компоненты и работает с ними как с черным ящиком.

Система это комбинация компонентов с учетом зависимостей. Ключевая обязанность
системы~--- запустить и остановить компоненты в верном порядке. Например, если
компонент A зависит от B и C, то к моменту запуска A последние два должны быть
запущены. При завершении программы компоненты B и C нельзя выключить до тех пор,
пока работает~A.

Система строит граф зависимостей между компонентами. Нужно обойти граф так,
чтобы удовлетворить запросы каждого компонента.

Система не должна быть запущена частично. Это случается, когда один из
компонентов бросил исключение: включились сервер и очередь задач, но база
недоступна. Это досадная ситуация, потому что мы застряли в пограничном
состоянии. Если включить систему второй раз, получим конфликты портов или
компоненты-дубли. Позже мы узнаем, как с этим бороться.

Будет правильно, если дойдя до проблемного компонента, загрузчик системы не
бросит исключение, а поместит его в переменную. Затем пойдет в обратном порядке
и выключит все, что успел включить. И только потом бросит исключение, которое
поймал.

В систему должно легко добавить новый компонент. Для этого систему описывают
декларативно. В идеальном случае система это данные~--- комбинация словарей и
списков. Код загрузки пробегает по ним и включает компоненты. Расширить систему
означает добавить новый узел в коллекцию.

Когда система знает о зависимостях компонентов, можно запустить ее
подмножество. Например, нужно отладить фоновый обработчик почты. Это компонент,
который зависит от базы и SMTP-сервера. Веб-сервер и кэш в данном случае не
нужны, и запуск всей системы лишним. Продвинутые системы предлагают функцию с
семантикой <<запусти это компонент и все его зависимости>>.

\section{Преимущества}

На первый взгляд кажется, что система~--- лишнее усложнение. Это новая
библиотека, соглашения в команде, рефакторинг и ограничения. Но первичные
неудобства окупаются со временем.

Система приводит проект в порядок. С ростом кодовой базы становится важно, чтобы
разные части проекта были в едином стиле. Удобно, когда продукт состоит из
отдельных сервисов с общими библиотеками. Разработчика выручит повторное
использование кода, в том числе банальное копирование.

Системы полезны на всех стадиях производства, особенно тестировании. Для тестов
запускают измененную версию системы, где некоторые компоненты работают
по-другому. Например, для отправки смс в подкладывают компонент, который пишет
сообщения в файл.

Подобно конфигурации, у системы свой жизненный цикл. Понимая этот цикл, можно
внести в систему корректировки. Например, внедрить операторы \spverb|if| или
\spverb|cond->|, чтобы добавить или убрать компоненты по условию.

\section{Подготовка к обзору}

%% TODO ref

В главе об изменяемых данных мы упоминали о системах. Мы узнали, как с помощью
\spverb|alter-var-root| менять глобальные переменные. Идея в том, чтобы вынести
компонент в модуль и снабдить его функциями \spverb|start!| и
\spverb|stop!|. Функции переключают состояние модуля. Запуск системы сводится к
вызову функций в верном порядке.

Это слабое, любительское решение. Такая система не знает о зависимостях между
компонентами. Она хрупкая, работает в ручном режиме, и каждое изменение требует
проверки.

Clojure предлагает несколько библиотек для систем. Мы рассмотрим \spverb|mount|,
\spverb|component| и \spverb|integrant|. Библиотеки различаются идеологией в
построении систем. Они по-разному описывают компоненты и связи между ними. Так
мы рассмотрим проблему с разных сторон.

Библиотеки нарочно следуют в таком порядке. С \spverb|mount| легче начать, он
будет удачным выбором для новичков. \spverb|Component| стал промышленным
стандартом. Мы уделим ему больше внимания и поэтому ставим в
середину. \spverb|Integrant| замыкает обзор. Его рассматривают как альтернативу
\spverb|component|, с котором читатель должен быть знаком.

В примерах нам бы хотелось избежать банальности. Вместо наивных \spverb|foo| и
\spverb|bar| построим настоящую систему, похожую на то, с чем вы столкнетесь на
практике. Система состоит из веб-сервера, базы данных и фонового процесса,
который обновляет записи в базе. Мы специально добавили его, чтобы научиться
работать с зависимостями. Нарисуем топологию системы:

\vspace{1em}
\begin{tikzpicture}[auto, node distance=1.5cm]

\node (cfg) [entity] {Config};
\node (srv) [entity, below left = of cfg, yshift=0.5cm, xshift=2cm] {Server};
\node (dtb) [entity, below right = of cfg, yshift=0.5cm, xshift=-2cm] {Database};
\node (wrk) [entity, below right = of dtb, yshift=0.5cm, xshift=-2cm] {Worker};

\draw [arrow] (srv) |- (cfg);
\draw [arrow] (dtb) -| (cfg);
\draw [arrow] (wrk) -| (dtb);
\draw [arrow] (wrk) |- (cfg);

\end{tikzpicture}
\vspace{1em}

Стрелки на схеме означают отношения между компонентами. Выражение $A \to B$
означает <<А зависит от В>>. В нашей системе все компоненты зависят от
конфигурации. Дополнительно фоновый обработчик зависит от базы данных. Над этой
системой мы и будем работать до конца главы.

\section{База и воркер}

Мы упоминали, что открывать соединение на каждый запрос неоптимально. В
настоящих проектах с базой работают через пул. Это сущность с состоянием,
поэтому его тоже <<включают и выключают>>.

Некоторые базы хранят данные в памяти, например SQLite или H2. Преимущество в
том, что их не нужно запускать в отдельном процессе. База подключается как
библиотека и хранит данные в памяти приложения.

База в памяти удобна для быстрого старта, но не отражает реалии производства~---
то, к чему мы стремимся в этой книге. Для in-memory-баз не используют пулы
соединений. В этом нет смысла, потому что данные лежат в памяти, а не в
сети. Поэтому будем работать с реляционной БД PostgreSQL с пулом HikariCP.

В системе работает фоновый процесс, воркер. Он дополняет записи в базе данными
из сети. Предположим, фирма ведет аналитику посещений. Каждый раз, когда кто-то
открывает страницу, приложение пишет в базу адрес и данные запроса: заголовок
User-Agent и IP-адрес клиента. Чтобы строить отчеты по странам и городам, нужно
узнать их через сторонние сервисы. Это дорогая операция, поэтому записи ставят
статус <<ждет обработки>> и выносят логику в фон.

\section{Подготовка Docker}

Возможно, у вас уже установлен PostgreSQL. Тогда останется создать новую базу и
таблицу в ней. Если нет, самое время попробовать Docker. Это программа для
запуска приложений из образов. Под образом понимают специальный файл, в котором
приложение со всем необходимым для запуска. Запущенный образ называют
контейнером.

У контейнеров несколько преимуществ. Приложение стартует в изолированной среде и
поэтому отделено от основной системы. Кроме безопасности, это решает проблему
\emph{чистоты}~--- контейнер не оставляет следов работы, если это не настроено
специально.

В сети работает публичный репозиторий, откуда Docker качает образы. В нем
публикуют программы разных версий и комплектации. Например, если нужен
PostgreSQL строго 9.3, просто скачайте образ. Установка этой версии в систему,
скорее всего, обернется конфликтом с уже работающей базой.

Некоторые образы можно настроить переменными среды или файлами. Образ PostgreSQL
устроен так, что при старте он загружает все \spverb|*.sql| файлы из папки
\spverb|/docker-entrypoint-initdb.d|. Если назначить этой папке локальный путь с
sql-миграциями, получим готовую базу без строчки кода.

В комплекте с Docker идет утилита \spverb|docker-compose|. Она запускает из
файла конфигурации. По умолчанию файл называется
\spverb|docker-compose.yaml|. Это YAML-документ, где указаны образы и параметры
их запуска. В примере ниже один контейнер \spverb|postgres|, которому заданы
порты, пути и переменные среды.

\begin{verbatim}
version: '2'
services:
  postgres:
    image: postgres
    volumes:
      - ./initdb.d:/docker-entrypoint-initdb.d
    ports:
      - 5432:5432
    environment:
      POSTGRES_DB: book
      POSTGRES_USER: book
      POSTGRES_PASSWORD: book
\end{verbatim}

В папке \spverb|initdb.d| лежат sql-файлы для старта базы. Достаточно файла
\spverb|01.init.sql| с одной таблицей:

\begin{verbatim}
drop table if exists requests;
create table requests (
    id            serial primary key,
    path          text not null,
    ip            inet not null,
    is_processed  boolean not null default false,
    zip           text,
    country       text,
    city          text,
    lat           float,
    lon           float
);
\end{verbatim}

Если запустить \spverb|docker-compose up|, поднимется сервер PostgreSQL на порту
5432 с базой \spverb|book|. Этого хватит для дальнейшей работы. Больше мы не
будем говорить о Docker, поскольку эта тема заслуживает отдельной книги. Всю
информацию вы найдете на официальном сайте
проекта\footurl{https://docker.com}.

\section{Mount}

Библиотека \spverb|mount|\footurl{https://github.com/tolitius/mount} описывает
сущности с двумя состояниями: запуск и остановка. По команде сущность
<<включается>> и принимает значение, которое вернул код из фазы запуска. При
выключении сработает код из фазы остановки.

\spverb|Mount| идет на трюки, чтобы упростить работу программисту. Сущности
напоминают глобальные переменные, которые меняют значение по команде. Внешне
\spverb|mount| прост, поэтому удобен для начинающих.

Макрос \spverb|defstate| задает новую сущность. Макрос похож на форму
\spverb|def|: он тоже создает переменную в текущем пространстве. Вместо значения
\spverb|defstate| принимает два выражения для старта и остановки.

Пока сущность не включена, переменая хранит особое значение
\spverb|DerefableState|. Когда ее включили, переменная станет тем, что вернуло
выражение старта. При выключении срабатывает код останова, и переменная
становится \spverb|NotStartedState|.

\subsection{Первая сущность}

Напишем с помощью \spverb|mount| компонент веб-сервера. Поместим его в модуль
\spverb|src/book/systems/mount/server.clj|. \spverb|App| это примитивное
приложение, которое всегда вернет статус 200.

\begin{verbatim}
(ns book.systems.mount.server
  (:require
   [mount.core :as mount :refer [defstate]]
   [ring.adapter.jetty :refer [run-jetty]]))

(def app (constantly {:status 200 :body "Hello"}))

(defstate server
  :start (run-jetty app {:join? false :port 8080})
  :stop (.stop server))
\end{verbatim}

В макросе \spverb|defstate| фазы отделены ключами \spverb|:start| и
\spverb|:stop|. Пока что мы только объявили состояние, но ничего не
включили. Если выполнить \spverb|server|, увидим следующее:

\begin{verbatim}
#DerefableState[{:status :pending, :val nil}]
\end{verbatim}

Чтобы запустить компонент, выполните \spverb|(mount/start)|. Функция пробегает
по всем сущностями и включает их. Выражение \spverb|(run-jetty ...)| под ключом
\spverb|:start| вернет сервер, который работает в фоне. После запуска браузер
покажет приветствие по адресу \spverb|http://127.0.0.1:8080|. Переменная
\spverb|server| станет эксемпляром \spverb|Server| из пакета \spverb|jetty|:

\begin{verbatim}
(type server)
org.eclipse.jetty.server.Server
\end{verbatim}

Чтобы выключить систему, выполните \spverb|(mount/stop)|. Обратите внимание, что
в выражении \spverb|(.stop server)| сущность обращается к самой себе. После
остановки \spverb|server| станет особым значением, которое означает завершение.

\begin{verbatim}
(mount/stop)
(type server)
mount.core.NotStartedState
\end{verbatim}

Так строят систему. Сперва находят сущности, которые работают на протяжении всей
программы. В основном это сетевые подключения или фоновые задачи. Затем выносят
их в модули, где описывают логику запуска и остановки.

\subsection{Связь с конфигурацией}

Выше мы допустили ошибку: параметры сервера <<захардкожены>> в теле
компонента. Мы уже обсудили чем это плохо; параметры должны быть в
конфигурации. Поскольку мы строим систему, вынесем конфигурацию в компонент. При
запуске он читает файл или переменные среды, выводит типы, валидирует данные.

%% TODO file paths

Напишем модуль \spverb|config.clj|. Для краткости не будем расписывать спеку
\spverb|::config|: оставим только проверку на словарь. Фаза \spverb|:start|
читает EDN-файл, проверяет спекой и возвращает данные. Замените \spverb|:start|
на вызов \spverb|Yummy|, \spverb|Aero| или свое решение.

\begin{verbatim}
(ns book.systems.mount.config
  (:require
   [mount.core :as mount :refer [defstate]]
   [clojure.spec.alpha :as s]
   [clojure.edn :as edn]))

(s/def ::config map?)

(defstate config
  :start
  (-> "system.config.edn"
      slurp
      edn/read-string
      (as-> config
          (s/conform ::config config))))
\end{verbatim}

Компоненту не нужна фаза \spverb|:stop|, потому что он не хранит открытые
ресурсы. Улучшим сервер так, чтобы он зависел от конфигурации. Для этого заменим
его параметры ссылкой на словарь \spverb|config|.

Пусть файл \spverb|system.config.edn| содержит словарь, где ключ это имя
компонента, а значение~--- его параметры. Поместим сервер под ключ
\spverb|:jetty|:

\begin{verbatim}
{:jetty {:join? false :port 8088}}
\end{verbatim}

Обновим модуль сервера. В список \spverb|:require| добавим импорт конфигурации:

\begin{verbatim}
(:require
  [book.systems.mount.config :refer [config]])
\end{verbatim}

\noindent
Перепишем компонент, чтобы параметры приходили из словаря:

\begin{verbatim}
(defstate
  server
  :start
  (let [{jetty-opt :jetty} config]
    (run-jetty app jetty-opt))
  :stop (.stop server))
\end{verbatim}

На этом этапе у нас уже система из двух компонентов, где один зависит от
другого. Убедитесь, что после вызова \spverb|(mount/start)| сервер работает как
ожидалось.

\subsection{База данных}

Подготовим компонент базы данных. Понадобяться две библиотеки:
\spverb|clojure.java.jdbc| и \spverb|hikari-cp|. Первая предлагает доступ к
реляционным базам данных. Это набор функций, которые работают одинаково для
разных баз. Например, выражения:

\begin{verbatim}
(jdbc/get-by-id db :users 42)
(jdbc/insert! db :users {:name "Ivan" :email "ivan@test.com"})
\end{verbatim}

\noindent
прочитают и запишут пользователя в PostgreSQL, MySQL или Oracle. Для каждого
бекенда строится SQL с учетом его особенностей.

JDBC-функции принимают первым параметром т.н. \emph{JDBC-спеку}. Обычно это
словарь параметров подключения: адрес и порт сервера, имя базы, пользователь и
пароль. На каждый запрос JDBC создает новый источник данных, открывает
соединение, обменивается данными и закрывает его.

В спеке может быть ключ \spverb|:datasource| с уже подготовленным
источником. Тогда JDBC игнорирует другие ключи и работает напрямую с
\spverb|:datasource|. Библиотека \spverb|hikari-cp| предлагает функцию, чтобы
построить источник с пулом соединений. Каждый раз, когда мы запрашиваем
соединение у источника, получаем одно из открытых ранее.

%% TODO path

Пул это объект с жизненным циклом, поэтому вынесем его в компонент. Подготовим
модуль \spverb|db.clj|:

\begin{verbatim}
(ns book.systems.mount.db
  (:require
   [mount.core :as mount :refer [defstate]]
   [hikari-cp.core :as cp]
   [book.systems.mount.config :refer [config]]))

(defstate db
  :start
  (let [{pool-opt :pool} config
        store (cp/make-datasource pool-opt)]
    {:datasource store})
  :stop
  (-> db :datasource cp/close-datasource))
\end{verbatim}

На старте мы возвращаем JDBC-спеку~--- словарь с ключом \spverb|:datasource|,
внутри которого пул. При выключении функция \spverb|close-datasource| закрывает
его и все открытые соединения. Добавим в конфигурацию настройки пула:

\begin{verbatim}
{:pool {:minimum-idle       10
        :maximum-pool-size  10
        :adapter            "postgresql"
        :username           "book"
        :password           "book"
        :database-name      "book"
        :server-name        "127.0.0.1"
        :port-number        5432}}
\end{verbatim}

Для экономии обозначим только основные параметры. Это свойства подключения
(хост, порт, пользователь, пароль) и размерность пула. Дополнительно можно
настроить каждую стадию его работы. Полный список опций смотрите на странице
проекта\footurl{https://github.com/tomekw/hikari-cp}.

Запустите систему и выполните запрос:

\begin{verbatim}
(mount/start)
(require '[clojure.java.jdbc :as jdbc])
(jdbc/query db "select 42 as answer")
;; ({:answer 42})
\end{verbatim}

\subsection{Фоновая задача}

Все готово для последнего компонента системы. Это воркер, который работает в
отдельном потоке. Он выбирает из базы необработанные записи и дополняет их из
стороннего сервиса.

В таблице \spverb|requests| мы храним адрес страницы и IP-адрес клиента. Флаг
\spverb|is_processed| это признак того, была ли уже обработана запись. Поля
\spverb|city|, \spverb|country| и другие по умолчанию равны \spverb|null|.

Задача воркера состоит из шагов:

\begin{itemize}

\item
  раз в интервал запрашивать запись с флагом \spverb|NOT is_processed|;

\item
  сделать запрос к сервису, который вернет гео-данные по IP;

\item
  обновить запись в транзакции.

\end{itemize}

Выразим воркер в терминах \spverb|mount|. Поскольку задача работает в отдельном
потоке, очевидно это тред или футура с бесконечным циклом. Но мы бы хотели
остановить воркер по запросу. Значит, цикл не бесконечный, а с
условием. Например, проверкой состояния на каждом шаге. Это состояние должно
быть доступно и воркеру, и тому, кто им управляет.

В Clojure это решается футурой и атомом. В атоме хранят логический флаг~---
признак продолжения цикла. На каждом шаге футура проверяет флаг, и если он
истина, то в очередной раз выполняет задачу. Чтобы завершить футуру, совершают
два действия. Первое~--- устанавливают флаг в ложь. Второе~--- ждут до тех пор,
пока футура не станет \emph{реализованной} (анг. realized). В терминах Clojure
это значит, что футура остановилась.

Подготовим модуль воркера. Понадобится конфигурация, компонент базы, логирование
и HTTP-клиент:

\begin{verbatim}
(ns book.systems.mount.worker
  (:require
   [mount.core :as mount :refer [defstate]]
   [clojure.java.jdbc :as jdbc]
   [clj-http.client :as client]
   [clojure.tools.logging :as log]
   [book.systems.mount.db :refer [db]]
   [book.systems.mount.config :refer [config]]))
\end{verbatim}

Воркер это словарь с полями \spverb|:flag| и \spverb|:task|, состояние и
футура. Фаза \spverb|:start| готовит этот словарь. Функции \spverb|make-task|
пока что не существует, но считаем, что она вернет футуру. В фазе \spverb|:stop|
флаг становится ложью, и мы ждем, пока футура не остановится.

\begin{verbatim}
(defstate worker
  :start
  (let [{task-opt :worker} config
        flag (atom true)
        task (make-task flag task-opt)]
    {:flag flag :task task})
  :stop
  (let [{:keys [flag task]} worker]
    (reset! flag false)
    (while (not (realized? task))
      (log/info "Waiting for the task to complete")
      (Thread/sleep 300))))
\end{verbatim}

Код компонента должен быть небольшим. Чтобы упростить его, технические шаги
выносят в функции. Можно описать футуру прямо внутри \spverb|defstate|, но это
займет лишних десять строк, и логику станет труднее понять.

Добавим в EDN-файл параметры воркера. Достаточно одного поля~--- сколько
миллисекунд ждать на каждом шаге цикла.

\begin{verbatim}
{:worker {:sleep 1000}}
\end{verbatim}

Опишем функцию \spverb|make-task|. Она принимает состояние и параметры из EDN.

\begin{verbatim}
(defn make-task
  [flag opt]
  (let [{:keys [sleep]} opt]
    (future
      (while @flag
        (try
          (task-fn)
          (catch Throwable e
            (log/error e))
          (finally
            (Thread/sleep sleep)))))))
\end{verbatim}

\spverb|(Task-fn)| это функция, которая выполняет бизнес-логику
приложения. Недостаточно просто вызвать функцию; нужно обернуть ее в цикл с
условием и перехватом ошибок, чтобы футура не завершилась аварийно. Если была
ошибка, пишем ее в лог и переходим на следующую итерацию.

Тем временем кто-то мог установить \spverb|flag| в ложь. Если это произошло,
выходим из цикла \spverb|while|, и футура завершается.

Теперь опишем \spverb|task-fn|. Функция читает из базы записи, которые ждут
обработки. Для каждой записи ищем гео-данные по IP с помощью
\spverb|get-ip-info|. Пока что мы не знаем, как работает поиск, но известно, что
это словарь с полями \spverb|:city|, \spverb|:country| и другими.

\begin{verbatim}
(defn task-fn []
  (jdbc/with-db-transaction [tx db]
    (when-let [request (first (jdbc/query tx query))]
      (let [{:keys [id ip]} request
            info   (get-ip-info ip)
            fields {:is_processed true
                    :zip (:postal_code info)
                    :country (:country_name info)
                    :city (:city info)
                    :lat (:lat info)
                    :lon (:lng info)}]
        (jdbc/update! tx :requests
                      fields
                      ["id = ?" id])))))
\end{verbatim}

Запрос на чтение мы вынесли в переменную \spverb|query|, чтобы сократить код
\spverb|task-fn|. Это SQL-выражение с оператором \spverb|FOR UPDATE|. Оператор
означает, что запись блокируется на изменение в других соединениях.

\begin{verbatim}
(def query
  "SELECT * FROM requests
   WHERE NOT is_processed
   LIMIT 1 FOR UPDATE;")
\end{verbatim}

\spverb|FOR UPDATE| работает только в транзакции, поэтому тело функции обернуто
в \spverb|(jdbc/with-db-transaction)|. Это макрос, внутри которого доступно
\emph{транзакционное} соединение с базой. На него указывает символ
\spverb|tx|. Всем JDBC-функциям мы передаем \spverb|tx|, а не \spverb|db|.

Осталось написать \spverb|get-ip-info|. Функция обращается стороннему
API. Подойдет любой сервис, который принимает \spverb|IP|-адрес и возвращает
сведения о нем в JSON. В промышленных системах это может быть API Google или
локальная база адресов.

\begin{verbatim}
(defn get-ip-info [ip]
  (:body (client/post "https://iplocation.com"
                      {:form-params {:ip ip}
                       :as :json})))
\end{verbatim}

Если вызвать \spverb|get-ip-info| с адресом Берлина, получим словарь:

\begin{verbatim}
(get-ip-info "85.214.132.117")

{:postal_code "12529"
 :continent_code "EU"
 :region_name "Land Berlin"
 :city "Berlin"
 :isp "Strato AG"
 :region "BE"
 :country_code "DE"
 :country_name "Germany"
 :time_zone "Europe/Berlin"
 :lat 52.5167
 :company "Strato AG"
 :lng 13.4}
\end{verbatim}

Мы описали последний элемент воркера, и он готов к работе. Добавим в базу
несколько записей, запустим воркер и через некоторое время прочтем их снова.

\begin{verbatim}
(jdbc/insert! db :requests {:path "/help" :ip "31.148.198.0"})
(mount/start)
;; wait for a while
(jdbc/query db "select * from requests")
({:path "/help" :ip "31.148.198.0" :is_processed true
  :city "Pinsk" :zip "225710" :id 1
  :lon 26.0728 :lat 52.1214 :country "Belarus"})
\end{verbatim}

Все верно, и мы переходим к последнему этапу.

\subsection{Все вместе}

Компоненты готовы и работают по отдельности; осталось собрать их в единое
целое. Напишем модуль, который импортирует компоненты. Вызов
\spverb|(mount/start)| из этого модуля запустит их все.

Мы упоминали, что функции \spverb|start| и \spverb|stop| работают только с теми
компонентами, которые известны \spverb|mount|. Если загрузить модуль воркера, то
\spverb|mount| узнает о компонентах \spverb|worker|, \spverb|db| и
\spverb|config|. Модуль сервера не будет загружен, и система не узнает про его
компонент. Общий модуль решает эту проблему.

\begin{verbatim}
(ns book.systems.mount.core
  (:require
   [mount.core :as mount]
   book.systems.mount.server
   book.systems.mount.worker))

(defn start []
  (mount/start))
\end{verbatim}

Мы не указали модули \spverb|db| и \spverb|config| в импорте. Это не
обязательно: \spverb|server| и \spverb|worker| зависят от них, и компилятор
загрузит их автоматически.

\subsection{Зависимости}

В начале главы мы говорили о главной проблеме систем. Это зависимости между
компонентами, их разрешение и порядок обхода. Рассмотрим, как \spverb|mount|
решает эти задачи.

Читатель заметил, что при объявлении компонента мы не указываем его
зависимости. \spverb|Worker| нуждается в \spverb|config| и \spverb|db|, но об
этом нигде не сказано. Когда мы вызываем \spverb|(mount/start)|, система
угадывает порядок запуска: \spverb|config|, \spverb|db|, \spverb|worker|. Если
переставить любые два элемента, система не запустится. Как это работает?

Чтобы вычислить порядок, \spverb|mount| полагается на компилятор
Clojure. Пространства имен зависят друг от друга, как компоненты в
системе. Компилятор ищет в теле \spverb|ns| ссылки на другие модули и загружает
их первыми. Вспомним, как выглядит \spverb|ns| воркера:

\begin{verbatim}
(ns book.systems.mount.worker
  (:require
   [book.systems.mount.db :refer [db]]
   [book.systems.mount.config :refer [config]]))
\end{verbatim}

Начертим граф зависимостей:

\vspace{1em}

\begin{tikzpicture}[auto, node distance=0.5cm]

\node (wrk) [entity] {Worker};
\node (dtb) [entity, below right = of wrk, xshift=-1cm] {Database};
\node (cfg) [entity, below = of dtb] {Config};

\draw [arrow] (wrk) |- (dtb);
\draw [arrow] (wrk) |- (cfg);

\end{tikzpicture}

\vspace{1em}

Компилятор не загрузит \spverb|mount.worker| до тех пор, пока не разрешит
зависимости. Он начнет с модуля \spverb|mount.db|. Его упрощенное определение:

\begin{verbatim}
(ns book.systems.mount.db
  (:require
   [book.systems.mount.config :refer [config]]))
\end{verbatim}

Что с точки зрения компилятора:

\vspace{1em}

\begin{tikzpicture}[auto, node distance=0.5cm]

\node (wrk) [entity] {Database};
\node (dtb) [entity, below right = of wrk, xshift=-1cm] {Config};

\draw [arrow] (wrk) |- (dtb);

\end{tikzpicture}

\vspace{1em}

Прежде чем загрузить \spverb|db|, компилятор займется \spverb|config|. Он не
зависит других модулей будет и загружен первым. Затем компилятор вернется к
\spverb|db| и загрузит его. Дальше он поднимется на уровень
\spverb|worker|. Модуль \spverb|db| загружен, следующий по списку
\spverb|config|. Конфигурация уже загружена на этапе \spverb|db|. В Clojure
модуль не может быть загружен дважды, поэтому компилятор пропустит его. На
последнем шаге загрузится \spverb|worker|.

Мы вывели порядок загрузки \emph{пространств}: \spverb|config|, \spverb|db|,
\spverb|worker|. Каждая форма \spverb|defstate| выполняется в той же очереди. В
этом и заключается трюк: вызов \spverb|defstate| увеличивает внутренний счетчик
\spverb|mount|. В момент создания компонент запоминает это число. Сущности
\spverb|config|, \spverb|db| и \spverb|worker| получат номера 1, 2 и 3. Чтобы
запустить систему, Mount сортирует компоненты по возрастанию номера, а для
остановки~--- по убыванию.

\subsection{Внутреннее устройство}

\spverb|Mount| хранит сведения о компонентах в приватных атомах. Они недоступны
сторонним модулям, но Clojure оставляет возможность добраться до них. Когда
компоненты загружены, выполните выражение:

\begin{verbatim}
(def _state @@(resolve 'mount.core/meta-state))
\end{verbatim}

В переменной \spverb|_state| окажется словарь компонентов. Двойной оператор
\spverb|@| играет следующую роль. Функция \spverb|resolve| по символу возвращает
объект \spverb|Var|. Из прошлых глав мы помним, что это контейнер, который
хранит значение. Первый \spverb|@| извлекает значение из \spverb|Var|; это атом
со словарем. Второй \spverb|@| извлекает словарь из атома.

Ключ словаря это \emph{текстовая} ссылка на компонент, например
\spverb|#'book.systems.mount.config/config|. Ей назначен другой словарь с
информацией о состоянии компонента. Нас интересует поле \spverb|:order|~--- тот
самый счетчик, по возрастанию которого нужно включить компоненты.

Расставим компоненты вручную. Видим, что порядок их загрузки верный:

\begin{verbatim}
(->> _state
     vals
     (sort-by :order)
     (map #(-> % :var meta :name)))
;; (config server db worker)
\end{verbatim}

Выражение ниже вернет словарь запущенных компонентов с похожей структурой:

\begin{verbatim}
@@(resolve 'mount.core/running)
\end{verbatim}

Атом \spverb|state-seq| хранит глобальный счетчик компонентов. Чтобы прочитать
его, выполните:

\begin{verbatim}
@@(resolve 'mount.core/state-seq)
\end{verbatim}

Получится 4, что верно: значения от 0 до 3 уже заняты другими компонентами.

При работе с \spverb|mount| вы не должны менять его внутренние атомы. Примеры
выше нужны для того, чтобы читатель лучше понял устройство библиотеки.

\subsection{Состояние}

Легкость, с которой компонент изменяется при вызове \spverb|start| и
\spverb|stop|, похожа магию. Макрос \spverb|defstate| скрывает технические шаги,
которые срабатывают в момент его работы. На нижнем уровне состояние работает на
функции \spverb|alter-var-root|, которую мы рассмотрели в главе про
изменяемость.

%% TODO ref

Вспомним компонент сервера:

\begin{verbatim}
(defstate server
  :start (let [{jetty-opt :jetty} config]
           (run-jetty app jetty-opt))
  :stop (.stop ^Server server))
\end{verbatim}

В общих словах, \spverb|defstate| разворачивается в несколько определений. Это
глобальная переменная без значения

\begin{verbatim}
(def server)
\end{verbatim}

\noindent
и две анонимные функции старта и останова. Тела функций это формы
\spverb|:start| и \spverb|:stop|.

\begin{verbatim}
(fn start []
  (alter-var-root #'server
   (fn [_]
     (let [{jetty-opt :jetty} config]
       (run-jetty app jetty-opt)))))

(fn stop []
  (alter-var-root #'server
   (fn [_]
     (.stop ^Server server))))
\end{verbatim}

\spverb|Mount| помещает ссылки на эти функции в атом \spverb|meta-state|. Чтобы
включить компонент, нужно найти в словаре функцию включения и вызвать
ее. Функция назначит переменной \spverb|#'server| новое значение. Остановка
работает аналогично.

\subsection{Выборочный запуск}

До сих пор мы запускали систему целиком. Вызов \spverb|(mount/start)| без
параметров пробегает по \spverb|meta-state| и включает все компоненты. Это не
всегда удобно. Предположим, мы работаем над воркером и хотели бы запустить
только его и зависимости. В этом случае веб-сервер не нужен.

Чтобы запустить только нужные компоненты, их передают в функцию. Важно:
компонент должен быть не значением, а объектом \spverb|Var|.

\begin{verbatim}
(mount/start #'book.systems.mount.config/config
             #'book.systems.mount.db/db
             #'book.systems.mount.worker/worker)
\end{verbatim}

Если передать значение, \spverb|mount| не запустит компонент. В примере ниже не
будет ошибки или сообщения, просто ничего не произойдет:

\begin{verbatim}
;; does nothing
(mount/start book.systems.mount.config/config
             book.systems.mount.db/db
             book.systems.mount.worker/worker)
\end{verbatim}

Тот факт, что функция ожидает именно \spverb|Var|, а не значение, сбивает с
толку новичков. Это не очевидно, поскольку в Clojure мы редко прибегаем к
переменным.

Минус ручного запуска в том, что он не контролирует зависимости. \spverb|Mount|
не хранит зависимости; библиотека знает только порядок компонентов, но не как
они связаны. Предположим, мы забыли, что базе и воркеру требуется конфигурация:

\begin{verbatim}
(mount/start #'book.systems.mount.db/db
             #'book.systems.mount.worker/worker)
\end{verbatim}

Выражение бросит странное исключение. Оно возникнет в компоненте \spverb|db|,
где создается пул. Объект \spverb|config| не запущен, и выражение
\spverb|(:pool config)| вернет \spverb|nil|. При попытке создать пул из \spverb|nil| получим
исключение.

С ростом системы становится сложнее отслеживать зависимости. Это слабое место
\spverb|mount|~--- чтобы запустить подсистему, компоненты перечисляют
вручную. Чтобы облегчить этот сценарий, библиотека предлагает \emph{селекторы}
компонентов: \spverb|only|, \spverb|except| и другие.

\spverb|Except| вернет имена компонентов \emph{кроме} перечисленных. Если
передать результат в start, получим систему без указанных компонентов. Пример
ниже запустит подмножество без веб-сервера:

\begin{verbatim}
(-> [#'book.systems.mount.server/server]
    mount/except
    mount/start)
\end{verbatim}

Другие селекторы и их комбинации описаны на странице проекта в GitHub.

\subsection{Проблема перезагрузки}

В режиме разработки редактор подключен к сеансу REPL. Когда мы меняем код,
редактор отправляет изменения серверу. Возникает вопрос: что случится, если
внести правки в уже написанный компонент? Как \spverb|mount| отреагирует на
перезагрузку модуля?

Если вы работаете в Emacs и Cider, подключитесь к проекту через
\spverb|M-x cider-connect|. Запустите систему, как мы делали это выше. Откройте модуль
сервера и выполните \spverb|M-x cider-eval-buffer| (или клавишами
\spverb|C-c C-k|). Команда выполнит файл на сервере. Все определения, включая \spverb|ns|,
\spverb|def|, и \spverb|defstate| сработают повторно.

Вы увидете логи с текстом, что сервер был перезагружен. \spverb|Mount| учитывает
этот сценарий. Макрос \spverb|defstate| проверяет, что такой компонент уже
объявлен и перезагружает его.

Перезагрузка это не всегда желаемое поведение. При частых изменениях может
случиться <<рассинхрон>>~--- ситуация, когда компонент считается выключенным, но
его ресурс занят. Например, в блоке \spverb|:stop| мы не вызвали метод
\spverb|(.stop)|. Если перезагрузить такой компонент, получим ошибку о том, что
порт занят.

Поведение компонента при перезагрузке задают в метаданных. Это поле
\spverb|:on-reload|, которое по умолчанию равно \spverb|:restart|. С ним
компонент перезагружает себя при повторном вызове \spverb|defstate|. Если задать
\spverb|:stop|, компонент остановится. Наиболее удобно значение \spverb|:noop|,
что значит не делать ничего. Компонент с метаданными выглядит так:

\begin{verbatim}
(defstate ^{:on-reload :noop} server
  :start (run-jetty app {:join? false :port 8080})
  :stop (.stop server))
\end{verbatim}

Старайтесь указывать \spverb|:on-reload| своим компонентам. \spverb|:Noop|
удобен тем, что освобождает от побочных эффектов. Возможно, вы не меняли
компонент, а только исправили опечатку в комментарии. Перезагружать компонент в
таком случае не требуется. Но даже если вы исправили компонент, перезагрузите
его вручную.

\subsection{Самостоятельная работа}

Вернемся к функции \spverb|get-ip-info| из модуля воркера. Для каждого IP-адреса
она выполняет HTTP-запрос. На низком уровне мы открываем TCP-соединение,
работаем с ним и закрываем. Это не оптимально, и проблему решают так же, как и с
базами данных~--- пулом соединений. Изучите пример из библиотеки
clj-http:\footurl{https://github.com/dakrone/clj-http}

\begin{verbatim}
;; create a new pool
(def cm (clj-http.conn-mgr/make-reusable-conn-manager
         {:timeout 2 :threads 3}))

;; make a request within the pool
(client/get "http://example.org/"
            {:connection-manager cm})

;; shut down the pool
(clj-http.conn-mgr/shutdown-manager cm)
\end{verbatim}

Напишите компонент, который шлет запросы через пул. Параметры компонента
(тайминг, число потоков) приходят из конфигурации. На старте компонент запускает
пул, при остановке закрывает его. Перепишите воркер так, чтобы он зависел от
нового компонента.

\section{Component}

Библиотека \spverb|component|\footurl{https://github.com/stuartsierra/component}
тоже служит для описания компонентов и систем. Это небольшой фремворк, в котором
главную роль играет не объем кода, а идея. Дизайн Component в корне отличаются
от техники mount, которую мы рассмотрели выше.

Разница в том, что сущности Component это не глобальные переменные, а обычные
объекты. В библиотеке нет скрытых атомов, которые хранят информацию о
компонентах. Программист выстраивает систему явно, подобно тому как мы описываем
структуру данных.

Как и в Mount, на компонент действуют две операции: \spverb|start| и \spverb|stop|. Каждая их
них возвращает копию компонента в другом состоянии. Функции не меняют исходный
компонент. Можно сказать, что компоненты неизменяемы. Это отсекает целый пласт
ошибок, связанных с состоянием.

Система это комбинация компонентов с указанием зависимостей. Каждый компонент в
системе носит машинное имя. На первом этапе программист составляет систему в
состоянии покоя. Она состоит из компонентов, которые еще не были запущены.

В момент запуска специальный код обходит компоненты и запускает их. В результате
получится запущенная копия системы. Она аналогична исходной, но каждый компонент
в ней заменен на включенную копию себя. Остановка работает аналогично: вы
получите выключенную копию системы.

Идеи Component не терпят глобального состояния. Один компонент может работать с
другим только если это указано в зависимостях. Компонент не должен хранить
внутреннее состояние в атоме или другой изменяемой сущности. На каждое действие
он возвращает новую копию себя.

\subsection{Устройство}

Технически компонент это объект, который реализует протокол
\spverb|Lifecycle|. Протокол несет две операции: \spverb|start| и \spverb|stop|. Компоненты удобно
описывать типизированными словарями. Это сущности, которые объявляют формой
\spverb|defrecord|. По-другому их называют типизированными записями или "рекорды" с
ударением на первый слог.

Обычный словарь может содержать любые поля. Запись перечисляет возможные поля в
момент объявления. Эти поля называют слотами записи. Доступ к ним работает
быстрее, чем у обычного словаря. Компонент резервирует несколько слотов для
входных и внутренних параметров.

Форма \spverb|defrecord| работает в паре с протоколом. При объявлении записи можно
сразу расширить ее протоколом. Преимущество этого подхода в том, что слоты
записи доступны протоколу как локальные переменные. Это уменьшает код и держит
наше внимание на главном.

Компонент таит в себе состояние, и только он знает, как им управлять. Будет
грубой ошибкой "вынимать" из него отдельные поля и передавать их функции. Для
внешних потребителей компонент реализует еще один протокол, в котором
перечислены операции над компонентом.

Программирование на Component отдаленно напоминает ООП. Компонент это объект с
данными и фиксированным набором операций над ним. Как и классы, компонент
инициируют, запускают и останавливают. Разница в том, что, во-первых, компоненты
неизменяемы. Переход к новому состоянию не изменяет слоты объекта, в то время
как в промышленных ОО-языках мы их перезаписываем.

Во-вторых, принцип \spverb|SOLID| и классическая тройка инкапсуляция, наследование,
полиморфизм не имеют той же силы в Clojure. Большая часть этих принципов
отпадает за ненадобностью. Программируя на Clojure, мы не волнуемся о том, что
нарушили правила ООП. Код исходит из здравого смысла.

\subsection{Первый компонент}

Перейдем к практике: перепишем систему из прошлого раздела на Component. Начнем
с веб-сервера. Поместим его в файл \spverb|src/book/systems/comp/server.clj|. Объявим
пространство имен:

\begin{verbatim}
(ns book.systems.comp.server
  (:require
   [com.stuartsierra.component :as component]
   [ring.adapter.jetty :refer [run-jetty]]))
\end{verbatim}

Компонент это запись с двумя слотами: \spverb|options| и \spverb|server|. В опциях записаны
параметры Jetty-сервера, в server~--- его экземпляр. Строка \spverb|component/Lifecycle|
означает протокол, который реализует запись. Ниже следует реализация протокола.

\begin{verbatim}
(defrecord Server
    [options server]
  component/Lifecycle
  (start [this]
    (let [server (run-jetty app options)]
      (assoc this :server server)))
  (stop [this]
    (.stop server)
    (assoc this :server nil)))
\end{verbatim}

Метод \spverb|start| вернет ту же запись, но с непустым слотом \spverb|:server|. В него
записан объект сервера. Метод \spverb|stop| принимает запущенный компонент. Он
выключает сервер и возвращает новый компонент, где слот \spverb|:server| установлен в
nil.

Обратите внимание: внутри методов мы свободно обращаемся к слотам записи, словно
это локальные переменные. Это работает только в тех случаях, когда методы
расположены внутри \spverb|defrecord|. Если мы расширяем запись в отдельной форме,
например через extend, доступ к слотам теряется. Приходится извлекать слоты из
переменной \spverb|this|.

Запустим компонент вручную. Сущность \spverb|Server| это еще не компонент, а его
абстрактное описание. На первом шаге его инициируют, то есть получают экземпляр
записи. Чтобы создать экземпляр, вызывают функцию \spverb|map-><Record>|, где
\spverb|<Record>| это имя записи. Макрос \spverb|defrecord| автоматически порождает эту
функцию. В нашем случае это \spverb|map->Server|. Функция принимает обычный словарь и
возвращает его типизированную версию. Ключи словаря должны совпадать со слотами
записи. Если ключ не найден, слот равен nil.

\begin{verbatim}
(def s-created
  (map->Server
   {:options {:port 8080 :join? false}}))
\end{verbatim}

Переменная \spverb|s-created| это экземпляр записи \spverb|Server|. При инициализации мы
указали слот options, но не server. В этом нет смысла, потому что server будет
заполнен автоматически в процессе жизненного цикла.

\begin{verbatim}
(def s-started (component/start s-created))
\end{verbatim}

Эта строка вернет запущенную версию компонента. Откройте браузер по адресу
http://127.0.0.1:8080/ и проверьте, что сервер работает. На этот раз у записи
\spverb|s-started| слот \spverb|:server| заполнен:

\begin{verbatim}
(-> s-started :server type)
org.eclipse.jetty.server.Server
\end{verbatim}

Остановите компонент. Проверьте браузер и слоты \spverb|s-stopped|:

\begin{verbatim}
(def s-stopped (component/stop s-started))
\end{verbatim}

Мы прошли жизненный цикл одного компонента. Это инициирование, запуск и
остановка. Переход на каждую стадию возвращает новую копию. В промышленных
системах вам не придется управлять компонентами поштучно. Этим занимается
система.

\subsection{Конструктор}

Вспомним, как мы создали экземпляр \spverb|Server|:

\begin{verbatim}
(def s-created
  (map->Server
   {:options {:port 8080 :join? false}}))
\end{verbatim}

У такой записи есть недостаток. Мы вынуждены помнить, какие слоты нужны для
инициализации, а какие для внутреннего использования. Для простых записей это не
критично, но в боевых системах встречаются компоненты с десятью и более
слотами. Чтобы программист не запутался, объявляют функцию-конструктор.

Конструктор принимает только те аргументы, которые нужны для инициализации
компонента. В нашем случае это options, поэтому функция выглядит так:

\begin{verbatim}
(defn make-server
  [options]
  (map->Server {:options options}))

(def s-created (make-server {:port 8080 :join? false}))
\end{verbatim}

Конструктор упрощает создание сервера. С таким подходом невозможно передать в
\spverb|map->Server| что-то лишнее. Дополняйте каждый компонент системы конструктором
даже в тривиальных случаях.

\subsection{Особенность слотов}

При остановке компонента мы совершаем два действия: физически выключаем сервер и
замещаем его слот значением nil. Читатель заметит, почему бы не заменить \spverb|assoc|
на \spverb|dissoc?| Зачем хранить nil, когда можно отсоединить поле?

\begin{verbatim}
(assoc this :server nil)
;; should have become
(dissoc this :server)
\end{verbatim}

Причина в том, как устроены записи и слоты. Запись сохраняет свои уникальные
свойства до тех пор, пока все ее слоты на месте. Если забрать у записи слот
через \spverb|dissoc|, получим обычный словарь. Покажем это на примере:

\begin{verbatim}
(-> s-stopped (assoc :server nil) type)
book.systems.comp.server.Server

(-> s-stopped (dissoc :server) type)
clojure.lang.PersistentArrayMap
\end{verbatim}

Если один компонентов вызывает \spverb|dissoc| на самом себе, при переходе на новую
стадию мы получим не компонент, а словарь. Это досадная ошибка, которая ведет к
странному поведению системы. Например, при попытке выключить компонент он
продолжает работу.

Когда запись расширяют протоколом, тем самым устанавливают связь между типом
первого аргумента и логикой. Для аргумента с типом \spverb|Server| методы \spverb|start| и
\spverb|stop| выполнят одно, для типов \spverb|DB| или \spverb|Worker|~--- другое. На другие типы
действует реализация по умолчанию, которая возвращает this. Это значит, что если
метод start вернул не компонент, а словарь, мы не сможем вызвать правильный stop
для этого словаря.

Приведем неудачный пример компонента. Его метод \spverb|start| Возвращает словарь с
одноименным полем \spverb|server|:

\begin{verbatim}
(defrecord BadServer
  [options server]
  component/Lifecycle
  (start [this]
    {:server (run-jetty app options)})
  (stop [this]
    (.stop server)
    nil))
\end{verbatim}

Запуск такого компонента сработает без ошибок. Выполнив два выражения ниже,
переключитесь браузер и проверьте сервер:

\begin{verbatim}
(def bs-created (map->BadServer {:options {:port 8080 :join? false}}))
(def bs-started (component/start bs-created))
\end{verbatim}

Но переменная \spverb|bs-started| уже не запись, а словарь. Реализация \spverb|stop| для
словаря вернет его же без каких либо действий. Можно сколько угодно вызывать
\spverb|component/stop|, но сервер не будет остановлен.

\begin{verbatim}
(type bs-started)
clojure.lang.PersistentArrayMap
(def bs-stopped (component/stop bs-started))
;; does nothing, the server still works
\end{verbatim}

Похожие трудности возникнут, если исправить \spverb|start| без учета \spverb|stop|. При
остановке плохой компонент выключит сервер, но вернет nil. При запуске nil
получим исключение, что тип не реализует протокол \spverb|Lifecycle|.

Следите за тем, чтобы компонент менял только значения слотов, но не их состав.

\subsection{Компонент базы}

Напишем компонент для работы с базой данных. Концепция пула соединений уже
известна читателю из прошлых разделов. Компонент содержит два слота: \spverb|options| и
\spverb|db-spec|. Первый это словарь опций будущего пула. Слот \spverb|db-spec| предназначен
для внутреннего использования. Он хранит JDBC-спеку с открытым пулом.

\begin{verbatim}
(defrecord DB
    [options db-spec]

  component/Lifecycle

  (start [this]
    (let [pool (cp/make-datasource options)]
      (assoc this :db-spec {:datasource pool})))

  (stop [this]
    (-> db-spec :datasource cp/close-datasource)
    (assoc this :db-spec nil)))
\end{verbatim}

Добавим функцию-конструктор:

\begin{verbatim}
(defn make-db [options]
  (map->DB {:options options}))
\end{verbatim}

%% TODO https://tex.stackexchange.com/questions/229289/arrow-in-text-mode
Компонент готов к запуску, и его можно прогнать через функции \spverb|make-db| %% &rarr;
\spverb|component/start| %% &rarr;
\spverb|component/stop|.

Пока что неясно, как выполнять запросы через этот компонент. Нас интересует слот
\spverb|db-spec|, который хранит спеку. Технически возможно вычленить его и передать в
jdbc-функцию:

\begin{verbatim}
(let [{:keys [db-spec]} db-started
      users (jdbc/query db-spec "select * from users")]
  (process-users users))
\end{verbatim}

Но это варварский подход. Мы не должны вторгаться во внутренности компонента,
даже если язык предлагает такую возможность. Этим мы нарушаем концепцию
компонента, который неделим с точки зрения стороннего наблюдателя. В этом плане
компоненты близки к объектам в современных языках.

Дополним DB методами для работы с базой. Сначала определим протокол с методами
запроса и обновления. Сигнатуры аналогичны их jdbc-версиям с той разницей, что
первый параметр это не \spverb|db-спека|, а \spverb|this|, компонент:

\begin{verbatim}
(defprotocol IDB
  (query [this sql-params])
  (update! [this table set-map where-clause]))
\end{verbatim}

В теле \spverb|defrecord|, сразу после \spverb|stop|, поместим реализацию этого
протокола. Реализация сводится к jdbc-функциям, в которые мы передаем слот
\spverb|:db-spec| и аргументы метода.

\begin{verbatim}
(;; ........

  (stop [this]
    (-> db-spec :datasource cp/close-datasource)
      (assoc this :db-spec nil))

  IDB

  (query [this sql-params]
    (jdbc/query db-spec sql-params))

  (update! [this table set-map where-clause]
    (jdbc/update! db-spec table set-map where-clause)))
\end{verbatim}

На этом этапе компонент уже готов к запросам. Обратите внимание, что мы вызываем
не jdbc-функции, а методы протокола. Тем самым мы изолируем зависимость от JDBC
внутри компонента.

\begin{verbatim}
(def db-created (make-db options))
(def db-started (component/start db-created))
(query db-started "select * from requests")
(update! db-started :requests {:is_processed false} ["id = ?" 42])
(def db-stopped (component/stop db-started))
\end{verbatim}

\subsection{Транзакционный компонент}

Из прошлого раздела мы помним, что для согласованных изменений в базе нужны
транзакции. Раньше мы пользовались \spverb|jdbc/with-db-transaction|. Он связывает
символ с транзакционным соединением, полученным из обычного.

Напишем одноименный макрос с такой же сигнатурой. В отличии от JDBC-версии, наш
макрос работает с компонентами. Он принимает обычный компонент БД и связывает с
символом его транзакционную версию. Технически макрос сводится к следующим
шагам:

- получить из компонента текущее соединение;
- обернуть тело в макрос jdbc, получить транзакционное соединение;
- связать с символом \spverb|comp-tx| компонент, у которого слот :db-spec заменен на
  транзакционное соединение.

\begin{verbatim}
(defmacro with-db-transaction
  [[comp-tx comp-db & trx-opt] & body]
  `(let [{db-spec# :db-spec} ~comp-db]
     (jdbc/with-db-transaction
       [t-conn# db-spec# ~@trx-opt]
       (let [~comp-tx (assoc ~comp-db :db-spec t-conn#)]
         ~@body))))
\end{verbatim}

Читатель заметит, что в макросе мы нарушаем принцип закрытости
компонента. Например, мы вручную читаем и заменяем его приватный слот. В случае
с макросом это нормально. Подобно компоненту, макрос изолирует низкоуровневые
действия, поэтому сторонний потребитель не заметит манипуляций со слотами.

Пример работы макроса:

\begin{verbatim}
(with-db-transaction
  [db-tx db-started]
  (let [requests (query db-tx "select * from requests limit 1 for update")]
    (when-let [request (first requests)]
      (update! db-tx :requests {:is_processed false} ["id = ?" (:id request)]))))
\end{verbatim}

В логах PostgreSQL мы увидим следующие записи:

\begin{verbatim}
BEGIN
select * from requests limit 1 for update
UPDATE requests SET is_processed = $1 WHERE id = $2
DETAIL:  parameters: $1 = 'f', $2 = '3'
COMMIT
\end{verbatim}

Выражения \spverb|select| и \spverb|update| действительно выполнены в транзакции.

\subsection{Воркер}

Напишем компонент воркера. Для этого объявим новый модуль и подключим
зависимости:

\begin{verbatim}
(ns book.systems.comp.worker
  (:require
   [com.stuartsierra.component :as component]
   [book.systems.comp.db :as db]
   [clj-http.client :as client]
   [clojure.tools.logging :as log]))
\end{verbatim}

Воркер это запись, которая реализует два протокола: \spverb|Lifecycle| и
\spverb|IWorker|. Протокол \spverb|Lifecycle| уже знаком читателю: это функции \spverb|start| и
\spverb|stop|. Они опираются на методы \spverb|IWorker|, который выглядит так:

\begin{verbatim}
(defprotocol IWorker
  (make-task [this])
  (task-fn [this]))
\end{verbatim}

Мы ожидаем, что \spverb|task-fn| это функция, которую воркер вызывает на каждом шаге
цикла. Метод \spverb|make-task| оборачивает ее в цикл и \spverb|try/catch|.

Запись хранит четыре слота: входные опции, флаг продолжения цикла, футура с
циклом и база данных. Это зависимый компонент, который мы описали на предыдущем
шаге. Для начала реализуем \spverb|Lifecycle|:

\begin{verbatim}
(defrecord Worker
    [options flag task db]

  component/Lifecycle

  (start [this]
    (let [flag (atom true)
          this (assoc this :flag flag) ;; note
          task (make-task this)]
      (assoc this :task task)))

  (stop [this]
    (reset! flag false)
    (while (not (realized? task))
      (log/info "Waiting for the task to complete")
      (Thread/sleep 300))
    (assoc this :flag nil :task nil))

  ;; to be continued
  )
\end{verbatim}

Отдельно прокомментируем строку с меткой \spverb|;; note|. Мы заменяем \spverb|this| на его же
версию с флагом состояния. Это нужно для того, чтобы \spverb|make-task| смог прочитать
флаг из переданного \spverb|this|. Если строку убрать, \spverb|make-task| получит запись с
флагом nil, что приведет к ошибке.

Опишем протокол \spverb|IWorker|. Код \spverb|make-task| и \spverb|task-fn| уже знаком читателю из
прошлого раздела про Mount. Разница в том, что теперь мы работаем не с
функциями, а методами. Поскольку метод имеет прямой доступ к слотам, нет смысла
передавать \spverb|db|, \spverb|flag| и другие параметры, как мы делали это с
функциями. Каждый метод принимает только \spverb|this|.

\begin{verbatim}
(defrecord Worker
  ;; skipped
  IWorker

  (make-task [this]
    (future
      (while @flag
        (try (task-fn this)
             (catch Throwable e
               (log/error e))
             (finally
               (Thread/sleep (:sleep options)))))))

  (task-fn [this]
    (db/with-db-transaction [tx db]
      (when-let [request (first (db/query tx query))]
        (let [{:keys [id ip]} request
              info (get-ip-info ip)
              fields {:is_processed true
                      :zip (:postal_code info)
                      :lat (:lat info)
                      :lon (:lng info)}]
          (db/update! tx :requests fields ["id = ?" id]))))))
\end{verbatim}

Добавим конструктор, и компонент готов:

\begin{verbatim}
(defn make-worker
  [options]
  (map->Worker {:options options}))
\end{verbatim}

\subsection{Ручные зависимости}

Воркер отличается от других компонентов тем, что имеет зависимости. Пока что не
ясно, как воркер узнает о базе данных, потому что его конструктор принимает
только опции. Забегая вперед скажем, что эту проблему решает система, а не
разработчик. Мы не должны передавать компоненты друг другу в момент их создания.

Хотелось бы проверить воркер до того, как мы двинемся дальше. Во время
разработки это правило можно нарушить. Мы вручную соберем мини-систему из двух
компонентов. Так мы проверим код, который написали и поймем, как работает
система.

Проведем эксперимент с системой в отдельном модуле core. Импортируйте в него
конструкторы и библиотеку Component:

\begin{verbatim}
(ns book.systems.comp.core
  (:require
   [com.stuartsierra.component :as component]
   [book.systems.comp.server :refer [make-server]]
   [book.systems.comp.worker :refer [make-worker]]
   [book.systems.comp.db :refer [make-db]]))
\end{verbatim}

Наивная система приведена ниже. Это функция, которая принимает конфигурацию. Мы
вручную запускаем базу и воркер и возвращаем словарь компонентов. В строке с
комментарием вы передаем воркеру слот с компонентом базы. Важен момент, в
который мы это делаем. Компонент базы уже должен быть включен, а воркер еще нет.

\begin{verbatim}
(defn my-system-start
  [config]
  (let [{db-opt :pool
         worker-opt :worker} config
        db (-> db-opt
               make-db
               component/start)
        worker (-> worker-opt
                   make-worker
                   (assoc :db db) ;; note
                   component/start)]
    {:db db :worker worker}))
\end{verbatim}

Чтобы запустить систему, передайте в функцию словарь с параметрами пула и
воркера. Сохраните систему в переменной, чтобы выключить ее позже.

\begin{verbatim}
(def _sys (my-system-start {:pool {...} :worker {...}}))
\end{verbatim}

Пока система работает, проверьте ее, как мы делали это в прошлом
разделе. Добавьте несколько записей в таблицу \spverb|requests| и убедитесь, что воркер
дополняет поля.

Функция выключения останавливает компоненты в верном порядке.

\begin{verbatim}
(defn my-system-stop
  [system]
  (-> system
      (update :worker component/stop)
      (update :db component/stop)))

(my-system-stop _sys)
\end{verbatim}

\subsection{Промышленная система}

Рассмотрим, как работает настоящая, промышленная система. Функция \spverb|system-map|
принимает цепочку значений, где каждый нечетный элемент это ключ, машинное имя
компонента в системе. Четные элементы это инициированные компоненты (т.е. вызовы
их конструкторов). Функция возвращает систему в состоянии покоя.

Построение системы не должно носить побочных эффектов. Технически вызов
\spverb|system-map| аналогичен объявлению структуры данных. Конструкторы компонентов
только возвращают экземпляры записей с заполненными слотами. Если конструктор
обращается к консоли, диску и глобальному состоянию, это грубая ошибка.

Поскольку система зависит от конфигурации, ее построение оборачивают в отдельную
функцию \spverb|make-system|. Эта функция принимает словарь конфигурации и разделяет
его на составные части. Каждый конструктор вызывается со своей
под-конфигурацией. Удобно, когда конфигурация повторяет топологию системы: на
верхнем уровне ключи компонентов, а под ними словари опций.

Чтобы сообщить компоненту зависимости, его оборачивают в функцию
\spverb|component/using|. Вторым аргументом передают ключи компонентов, которые
необходимо сообщить целевому компоненту до его старта. Ключи могут быть вектором
или словарем. Если имя слота совпадает с именем компонента в системе, это
вектор. Если имена отличаются, передают словарь вида `{:slot-name
:system-name}`.

В примере ниже функция \spverb|make-system| строит систему, о которой мы договаривались
в начале главы. Компонент \spverb|worker|, который зависит от базы данных, обернут в
\spverb|component/using|. Поскольку имя слота \spverb|:db| совпадает с именем компонента в
системе, мы передали вектор \spverb|[:db]|.

\begin{verbatim}
(defn make-system
  [config]
  (let [{:keys [jetty pool worker]} config]
    (component/system-map
     :server (make-server jetty)
     :db     (make-db pool)
     :worker (component/using
              (make-worker worker)
              [:db]))))
\end{verbatim}

Если бы имя компонента в системе было \spverb|:storage|, мы бы передали словарь
соответствия имен:

\begin{verbatim}
(component/system-map
 :server  (make-server jetty)
 :storage (make-db pool)
 :worker  (component/using
           (make-worker worker)
           {:db :storage}))
\end{verbatim}

Вариант со словарем полезен, когда вы подключаете сторонние компоненты. Их
разработчики не знают наверняка, как именуют сущности в вашем проекте. Например,
чужой компонент зависит от некого \spverb|:storage|. Это слишком абстрактное имя: в
системе бывает несколько хранилищ данных: \spverb|:postgres|, \spverb|:cassandra|,
\spverb|:redis|. Система маппинга снимает проблему расхождения имен.

Чтобы запустить систему, ее передают в \spverb|component/start|. Система реализует
протокол \spverb|Lifecycle| и с технической точки зрения ведет себя как
компонент. Разница в том, что система аккумулирует другие компоненты и управляет
их жизненным циклом.

В момент запуска алгоритм обходит компоненты и строит граф зависимостей. Из
этого графа система выводит порядок обхода. Перед тем как запустить компонент с
зависимостями, система сообщает их компоненту через assoc, как мы делали это
выше. Аналогично работает выключение системы.

\begin{verbatim}
(def config {...})
(def sys-init (make-system config))
(def sys-started (component/start sys-init))
(def sys-stopped (component/stop sys-started))
\end{verbatim}

\subsection{Хранение системы}

Выше мы определили систему через \spverb|def|, что не совсем правильно. Система это
сущность, которая включается по требованию. Считается грубой ошибкой, если форма
def срабатывает в функции, а не на верхнем уровне модуля. Поэтому с системой
обращаются как глобальной переменной, которая меняет значение. С технической
стороны для этого подходит \spverb|alter-var-root|.

В главном модуле приложения выделяют переменную для глобальной системы. Ее
объявляют через defonce, чтобы случайно не переопределить ее при перезагрузке
модуля. Функция alter-system это сокращенная версия \spverb|(alter-var-root #'system...)|.
Код с ней получается короче.

Как мы выяснили, компонент может находиться в трех состояниях: покой, запуск и
остановка. То же самое применимо к системе. Функции \spverb|system-init|,
\spverb|system-start| и \spverb|system-stop| устанавливают глобальную систему в нужное
состояние. Первая функция принимает словарь конфигурации.

\begin{verbatim}
(defonce system nil)

(def alter-system (partial alter-var-root #'system))

(defn system-init [config]
  (alter-system (constantly (make-system config))))

(defn system-start []
  (alter-system component/start))

(defn system-stop []
  (alter-system component/stop))
\end{verbatim}

Этот простой код дает все необходимое, чтобы управлять приложением. Функция
\spverb|-main| приложения сводится к трем шагам: чтению конфигурации, подготовке
системы и ее запуску.

\begin{verbatim}
(defn -main [& args]
  (let [config (load-config "config.edn")]
    (system-init config)
    (system-start)))
\end{verbatim}

Заметим, что хотя система и глобальна, к ней нельзя обращаться напрямую. Если
один компонент извлекает другой из недр системы, это провал разработчика. Такой
подход сводит на нет саму идею системы и компонентов. Обращаться к системе
напрямую можно только в режиме разработки или тестов.

Для большей надежности переменную системы делают приватной:

\begin{verbatim}
(defonce ^:private system nil)
\end{verbatim}

Этим мы обезопасим систему от обращения извне. В режиме разработки нам все еще
доступен трюк с resolve и символом переменной, чтобы сослаться на нее.

\subsection{Корректное завершение}

Подход с глобальной переменной идет вразрез с тем, что пишет автор
библиотеки. На странице проекта в его описании встречается следующая фраза:

> In production, the system map is ephemeral. It is used to start all the
> components running, then it is discarded.

Что в переводе:

> В промышленном запуске система эфемерна. Она запускает все компоненты и затем
> исчезает.

Это редкий случай, когда мы не согласимся с автором. Даже в боевом режиме вам
нужна ссылка на систему. Без ссылки невозможно выполнить т.н. "graceful
shutdown", что значит корректно завершить программу. Под корректностью понимают
факт того, что все ресурсы были закрыты.

Система управляет состоянием приложения. Некоторые его части бывают очень
сложны: это очереди задач, каналы данных, транзакции. При завершении программы
мы не можем полагаться на стандартные средства JVM. Например, если вынужденно
заверить компонент очереди, мы потеряем сообщение или обработаем его дважды. Мы
обязаны закрыть ресурсы правильно, даже если придется подождать.

В боевом режиме приложение перехватывает \spverb|POSIX|-сигналы и реагирует на них
должным образом. Например, если поступил \spverb|SIGTERM|, приложение останавливает
систему, дожидается ее остановки и только потом завершается.

%% TODO footnote
Библиотека \spverb|spootnik/signal| предлагает изящный макрос, чтобы связать сигнал с
реакцией на него. Подключите библиотеку в проект и модуль core:

\begin{verbatim}
;; project.clj
[spootnik/signal "0.2.2"]

;; src/book/systems/comp/core.clj
(ns ...
  (:require [signal.handler :refer [with-handler]]))
\end{verbatim}

Расширьте функцию \spverb|-main|: сразу после запуска системы добавьте обработчики
сигналов \spverb|SIGTERM|, \spverb|SIGINT| и \spverb|SIGHUP|. На первые два мы завершаем систему и
выходим из программы. Сигнал \spverb|SIGHUP| мы расцениваем как сигнал к перезагрузке
системы. В примере ниже функция \spverb|(exit)| это аналог \spverb|(System/exit)| с
дополнительной логикой.

\begin{verbatim}
(with-handler :term
  (log/info "caught SIGTERM, quitting")
  (system-stop)
  (log/info "all components shut down")
  (exit))

(with-handler :int
  (log/info "caught SIGINT, quitting")
  (system-stop)
  (log/info "all components shut down")
  (exit))

(with-handler :hup
  (log/info "caught SIGHUP, reloading")
  (system-stop)
  (system-start)
  (log/info "system reloaded"))
\end{verbatim}

Заметим, что обработка сигналов не работает, когда проект запущен через `lein
run` или вручную в REPL-сеансе. Чтобы проверить сигналы, скомпилируйте uberjar и
запустите его как java-приложение.

\begin{verbatim}
lein uberjar
java -jar target/myproject.jar
\end{verbatim}

После запуска нажмите \spverb|Ctrl-C|. Приложение завершится не сразу, и вы увидите
логи о том, что система остановлена.

При работе с системой позаботьтесь о том, чтобы безопасно остановить ее даже в
аварийном случае.

\subsection{Ожидание системы}

Вспомним функцию \spverb|-main| приложения. Это входная точка старта Java-программы:

\begin{verbatim}
(defn -main [& args]
  (let [config (load-config "config.edn")]
    (system-init config)
    (system-start)))
\end{verbatim}

У читателя, не знакомого с тонкостями JVM, возникнет вопрос. Что помешает
программе завершиться после вызова \spverb|(system-start)|? Ниже этой формы нет
какого-то бесконечного цикла, хука или события. Почему платформа продолжит
работу?

Это стандартное поведение JVM. Если программа завершается не аварийно, главный
тред ожидает, пока не остановятся остальные. Запуск системы порождает состояние
в новых потоках (сервер, пул соединений). Поэтому после \spverb|(system-start)|
основной поток повиснет в ожидании их завершения. Он будет ждать до тех пор,
пока систему не выключит кто-то другой и параллельного треда или не придет
\spverb|POSIX|-сигнал. Как приложению реагировать на сигналы мы рассмотрели выше.

\subsection{Улучшаем зависимости}

Когда мы объявили систему, то сообщили компоненту \spverb|:worker| о его
зависимостях. В примере ниже мы буквально говорим компоненту: ты зависишь от
базы данных.

\begin{verbatim}
(component/system-map
 ;; ...
 :worker (component/using
          (make-worker worker) [:db]))
\end{verbatim}

Когда компонентов много, перечисление их зависимостей занимает место и зашумляет
код. Помогает следующий трюк: зависимости компонента выносят в конструктор.

В примере выше \spverb|(make-worker {...})| возвращает наивную версию компонента,
которая не знает о зависимостях. Наивная версия попадает в \spverb|component/using|,
которая сообщает их. Мы могли бы втянуть \spverb|component/using| в конструктор, чтобы
новый компонент был сразу "заряжен" зависимостями. Тогда на уровне системы шаг
\spverb|component/using| станет не нужен.

Перепишем конструктор воркера:

\begin{verbatim}
(defn make-worker [config]
  (-> config
      map->Worker
      (component/using [:db])))
\end{verbatim}

Теперь система выглядит чище:

\begin{verbatim}
(component/system-map
 :server (make-server jetty)
 :db     (make-db pool)
 :worker (make-worker worker))
\end{verbatim}

Такой подход требует, чтобы имена в системе совпадали с зависимыми слотами. Если
это ваши компоненты, достаточно один раз договориться с командой об
именовании. Для сторонних компонентов легко написать свой конструктор.

Коротко рассмотрим, как хранятся данные о зависимостях. Очевидно, что вызов
\spverb|component/using| сообщает компоненту новые сведения, однако сам компонент от
этого не меняется. У него не появляется нового поля \spverb|:deps| или что-то в этом
роде. Компонент хранит зависимости в метаданных.

Метаданные это словарь дополнительных сведений об объекте. Метаданные работают с
коллекциями и некоторым другим типам Clojure, например, символом или
переменной. К метаданным прибегают, когда нужно сообщить добавочные сведения об
объекте, не изменяя его. Зависимости компонента подходят на роль таких сведений.

Функция meta возвращает словарь метаданных объекта. Пример ниже показывает, что
конструктор порождает компонент с заполненными зависимостями:

\begin{verbatim}
(-> {...} make-worker meta)
#:com.stuartsierra.component{:dependencies {:db :db}}
\end{verbatim}

Чтобы увидеть метаданные другим способом, установите глобальную переменную
*print-meta* в истину. Тогда при выводе объекта в REPL он будет дополнен
метаданными:

\begin{verbatim}
(set! *print-meta* true)
(make-worker {...})
^#:com.stuartsierra.component{:dependencies {:db :db}}
#book.systems.comp.worker.Worker{...}
\end{verbatim}

\subsection{Группировка слотов}

Слоты компонента делятся на три группы. Это параметры инициализации, поля
внутреннего состояния и зависимости. Вспомним, как мы объявили компонент
воркера:

\begin{verbatim}
(defrecord Worker
    [options flag task db])
\end{verbatim}

В этом примере слот \spverb|options| относится к инициализации, \spverb|flag| и \spverb|task| к
состоянию, \spverb|db|~--- зависимость. Чем сложнее компонент, тем больше у него слотов в
каждой группе. Когда слоты перечислены беспорядочно, трудно понять их
семантику. Поэтому хорошей практикой считается группировать слоты вручную и
разделять их комментарием:

\begin{verbatim}
(defrecord Worker
    [;; init
     options
     ;; runtime
     flag task
     ;; deps
     db])
\end{verbatim}

Первой идет группа \spverb|init|, входящие параметры. Это слоты, необходимые для нового
компонента. Ожидается, что конструктор принимает такие же параметры. Группа
\spverb|runtime| перечисляет слоты, которые компонент заполнит сам в момент старта. В
\spverb|deps| указаны зависимости. Вектор этих зависимостей передают в
\spverb|component/using| в конструкторе.

Сортировка слотов облегчает работу с кодом. Договоритесь с членами команды,
чтобы внедрить эту практику. Но когда слотов слишком много, это говорит о том,
что компонент излишне сложен. Тогда часть слотов и логики выносят в отдельный
компонент и подключают его как зависимость.

В последующих примерах мы не группируем слоты, потому что иначе код займет
слишком много места. В вашем коде слоты должны быть сгруппированы.

\subsection{Условная система}

В главе про конфигурацию мы писали про т.н. feature flags. Это логические
параметры, которые включают или отключают целые пласты логики. Флаги удобны тем,
что быстро отключают функциональность без пересборки приложения. Достаточно
поменять конфигурацию и перезагрузить сервис.

Система компонентов может быть построена не линейно, а по условиям. Вспомним,
что технически задача сводится к тому, чтобы передать ключи и компоненты в
функцию \spverb|system-map|. Если список аргументов предварительно обработать, получим
нужную функциональность.

Предположим, компонент воркера все еще в испытательном режиме. Пусть в
конфигурации будет поле, которое означает "включить воркер". Если оно ложь,
система должна запуститься без этого компонента.

Выделим в конфигурации группу \spverb|:features|. Это словарь флагов для "фич", которые
под вопросом:

\begin{verbatim}
{:features {:worker true}
 :jetty {:join? false :port 8088}
 ;; etc
}
\end{verbatim}

Перепишем функцию \spverb|make-system|. Теперь компоненты, перед тем как попасть в
system-map проходят предварительный просев. Макрос \spverb|cond->| "пробрасывает"
вектор базовых компонентов через цепочку условий и форм. Если выражение
\spverb|(:worker features)| вернет истину, следующая за ней форма добавит в вектор
значения \spverb|:worker| и \spverb|(make-worker {...})|. Ниже могут располагаться другие
флаги или проверки.

\begin{verbatim}
(defn make-system
  [config]
  (let [{:keys [features jetty pool worker]} config

        components
        (cond-> [:server (make-server jetty)
                 :db     (make-db pool)]

          (:worker features)
          (conj :worker (make-worker worker)))]

    (apply component/system-map components)))
\end{verbatim}

Убедимся, что механизм флагов работает. Поскольку система это запись, функция
keys вернет список ее слотов. В примерах ниже видно, что слот \spverb|:worker|
появляется в зависимости от конфигурации:

\begin{verbatim}
(keys (make-system {:features {:worker false}}))
(:server :db)

(keys (make-system {:features {:worker true}}))
(:server :db :worker)
\end{verbatim}

Система флагов облегчает работу с проектом. Некоторые компоненты очень сложны и
требуют специального окружения. Если такой компонент нельзя отключить, это
станет проблемой для ваших коллег. И наоборот, если компонент регулируется
галочкой, вы сэкономите их время и нервы.

\subsection{Спуск системы}

Пока сущности приложения это компоненты, они свободно общаются друг с
другом. Если одному компоненту понадобился другой, мы указываем зависимость и
добавляем слот. Проблемы начинаются, когда к системе обращается не компонент, а
другая сущность.

Чаще всего это функция-обработчик HTTP-запроса. Мы подробно говорили о них в
первой главе. По своей природе функция не ложится на концепцию
компонента. Компонент хранит состояние, а функция, напротив, избегает
его. Запуск и остановка функции это бессмысленная операция. Это не хорошо и не
плохо, просто функция и компонент противоположны друг другу.

Рассмотрим случай, когда обработчик HTTP-запроса нуждается в компоненте базы
данных. Возникает вопрос: как спустить отдельные части системы в функции, не
нарушив принципы библиотеки? Обращение к системе как глобальной переменной мы не
рассматриваем, потому что это плохая практика. В промышленных решениях прибегают
к двум способам: пробросу и замыканию.

Проброс означает, что отдельные компоненты передают в объекте запроса. Этот
вариант имеет право на жизнь, потому что запрос это часть сервера, а сервер это
компонент. Поэтому сервер имеет право сообщать дополнительные поля запросу.

Чтобы компонент базы стал доступен серверу, подключим его в
зависимостях. Добавим слот в запись сервера и зависимости в конструктор:

\begin{verbatim}
(defrecord Server
    [options server db])

(defn make-server
  [options]
  (-> (map->Server {:options options})
      (component/using [:db])))
\end{verbatim}

Расширим метод сервера \spverb|start|. Если раньше мы передавали app напрямую в
\spverb|run-jetty|, то теперь мы вводим дополнительный шаг. Функция \spverb|make-handler|
оборачивает app таким образом, что каждый запрос в app дополнен компонентом
базы.

\begin{verbatim}
(defn make-handler [app db]
  (fn [request]
    (app (assoc request :db db))))

(start [this]
  (let [handler (make-handler app db)
        server (run-jetty handler options)]
    (assoc this :server server)))
\end{verbatim}

Представим, что главная страница приложения выводит данные из базы. Пример ниже
показывает, как выполнить запрос к базе из обработчика HTTP-запроса. Чтобы не
усложнять пример версткой HTML, мы возвращаем данные в виде текста.

\begin{verbatim}
(defn app
  [request]
  (let [{:keys [db]} request
        data (db/query db "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint data))}))
\end{verbatim}

Со временем приложению могут понадобиться другие компоненты, например очередь
задач или кэш. Их добавляют аналогично: сперва вводят новый компонент в систему,
указывают зависимости в сервере и пробрасывают в \spverb|make-handler|.

Когда компонентов все больше, хранить их на верхнем уровне запроса становится
неудобно: возникает риск конфликта ключей. Будет логично записывать их во
вложенный словарь \spverb|:system| или \spverb|:engine|. Важно понимать, что \spverb|:system|
содержит не глобальную систему, а ее минимальное подмножество, необходимое для
веб-части приложения.

Замыкание отличается от проброса способом передачи аргументов. В случае с
замыканием компоненты передают отдельным аргументом. С таким подходом
функция-HTTP обработчик принимает не один, а два аргумента: подмножество системы
и текущий запрос.

Чтобы собрать нужные компоненты в одну структуру, в систему вводят особый
группировочный компонент. Он ничего не делает при запуске и остановке, а только
аккумулирует зависимости. Компонент сервера зависит от этого группировочного
компонента. На базе него мы строим дерево маршрутов (роутер), где каждый
обработчик принимает компонент первым аргументом.

Введем группировочный компонент \spverb|:web|. Пока что он зависит в только от базы
данных, но в будущем, возможно, потребует и другие компоненты:

\begin{verbatim}
(defrecord Web [db])

(defn make-web []
  (-> (map->Web {})
      (component/using [:db])))
\end{verbatim}

В функции make-system подключим его в систему:

\begin{verbatim}
(component/system-map
 :web    (make-web)
 :server (make-server jetty)
 :db     (make-db pool)
 :worker (make-worker worker))
\end{verbatim}

Переключим зависимости сервера: теперь он зависит не от базы данных, а от
группировочного \spverb|web|:

\begin{verbatim}
(defrecord Server
    [options server web])

(defn make-server
  [options]
  (-> (map->Server {:options options})
      (component/using [:web])))
\end{verbatim}

Из первой главы про веб-разработку вспомним, как мы строили роуты. Проще всего
это сделать макросом \spverb|defroutes| из пакета Compojure. Макрос возвращает функцию,
которая принимает запрос и возвращает ответ.

\begin{verbatim}
(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
\end{verbatim}

Но теперь дерево маршрутов не статично, а строится по запросу. Функция
make-routes принимает группировочный компонент и возвращает маршруты, замкнутые
на нем. В функции \spverb|page-index| и другие приходят два аргумента: компонент и
текущий запрос. Компонент будет постоянным, в том состоянии, что он пришел в
make-routes:

\begin{verbatim}
(defn make-routes [web]
  (routes
   (GET "/"      request (page-index web request))
   (GET "/hello" request (page-hello web request))))
\end{verbatim}

Метод \spverb|start| сервера строит маршруты и передает в \spverb|run-jetty|:

\begin{verbatim}
(start [this]
  (let [routes (make-routes web)
        server (run-jetty routes options)]
    (assoc this :server server)))
\end{verbatim}

Рассмотрим, как может выглядеть обработчик \spverb|page-index|, который обращается к
базе данных. Поскольку первый аргумент интересует нас только как хранилище
компонентов, мы распакуем его на уровне сигнатуры.

\begin{verbatim}
(defn page-index
  [{:keys [db]} request]
  (let [data (db/query db "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint data))}))
\end{verbatim}

Проброс и замыкание в целом похожи: они решают одну и ту же задачу. Разница в
том, как технически передать аргументы в функцию. Вариант с пробросом удобен
тем, что обычно HTTP-функции принимают один аргумент, и нам не придется менять
все сигнатуры.

С другой стороны, передача данных через запрос не всегда очевидна. Когда в
запросе слишком много полей, становится трудно его конструировать при разработке
или в тестах. При записи запроса в лог или на экран возникает риск получить
слишком большой выхлоп. Вариант с замыканием и двумя аргументами в целом
выглядит понятнее. Сигнатура функции прямо говорит о том, какие данные ожидают
на входе.

Выбор конкретного способа зависит от соглашений в команде.

\subsection{Идемпотентность}

До сих пор мы писали компоненты так, что их повторный запуск или остановка
приводили к ошибке. Покажем это на примере веб-сервера:

\begin{verbatim}
(def s (-> {:port 8088 :join? false}
           make-server
           component/start))

(component/start s)

Execution error (BindException) at ...
Address already in use
\end{verbatim}


В теле \spverb|start| мы не проверяем, что сервер уже работает. При попытке включить
уже запущенный компонент получим исключение о том, что порт уже занят. Это
правильное поведение системы: мы бы не хотели, чтобы запустилось два сервера. Но
для других компонентов исключения может и не быть. Например, если повторно
запустить базу данных, получим новый пул соединений. Старый пул останется где-то
в памяти и будет работать и писать логи. Так происходит утечка ресурсов.

Свойство, когда повторная операция над объектом возвращает тот же результат, что
и в начале, называется идемпотентность. Чтобы избежать утечки ресурсов,
компонент должен быть идемпотентен. Повторный вызов start или stop срабатывают
только один раз для данного состояния.

На уровне кода это сводится к проверке слотов перед тем, как открывать
ресурс. Например, если слот сервера nil, мы порождаем новый сервер и записываем
его в слот. Если не nil, это значит, что сервер уже запущен, и возвращают
\spverb|this|.

\begin{verbatim}
(start [this]
  (if server
    this
    (let [server (run-jetty app options)]
      (assoc this :server server))))
\end{verbatim}

Аналогично работает \spverb|stop|: перед тем, как закрыть ресурс, слот проверяют на
заполненность:

\begin{verbatim}
(stop [this]
  (when server
    (.stop server))
  (assoc this :server nil))
\end{verbatim}

Вариант с макросом or выглядит декларативнее. При запуске мы всегда записываем
слот, но значение это либо новый сервер, либо текущий.

\begin{verbatim}
(start [this]
  (let [server (or server (run-jetty app options))]
    (assoc this :server server)))
\end{verbatim}

\section{Integrant}

Библиотека \spverb|integrant|\footurl{https://github.com/weavejester/integrant}
это следующий виток мысли о том, как строить системы. Мы поместили ее последней
в обзоре по нескольким причинам. Integrant отталкивается от идей Component,
которые мы только что рассмотрели. Библиотека устроена гибче и в целом более
продвинута, чем Component. Читатель должен подойти к ней с некоторым
практическим опытом.

Как и в случае с Component, основная задача библиотеки~--- избежать глобального
состояния. Вместе с тем Integrant исправляет слабые моменты Component. Кратко
перечислим тезисы, которые предложил автор Integrant.

Сущности Component напоминают классы и ООП. В мире Clojure, где в основном
работают с данными и функциями, это выглядит усложнением. Пусть компоненты будут
функциями. Функция проще объекта, потому что над ней определена только одна
операция~--- вызов.

Component выделяет только два состояния компонента~--- запущен и
остановлен. Integrant предлагает дополнительные стадии, например, приостановка и
возобновление, валидация спекой, подготовка параметров. По умолчанию эти стадии
пустые, но любой компонент может подписаться на них. С этим подходом система
становится гибче и удобней в поддержке.

Integrant делает ставку на декларативность системы. Технически возможно описать
систему в edn-файле и считать одной функцией. Это выгодно отличает Integrant от
Component с ручным вызовом конструкторов.

Integrant лоялен к зависимостям. Если в Component зависимость требует два
действия~--- добавить слот и метаданные,~--- то в Integrant это один шаг. В
Component зависимость может быть только другим компонентом. Иногда объект
оборачивают в компонент только чтобы выполнить это требование. В Integrant
зависимостью может быть что угодно: словарь, объект, функция.

В целом Integrant выглядит легче и удобнее Component. Он решает задачи простым
способом, как это принято в мире Clojure.

\subsection{Базовое устройство}

Работу с Integrant начинают с описания будущей системы. Это структура данных,
каркас, за который цепляется дальнейшая логика. На уровне кода система это
словарь. Вот так мы бы описали систему из веб-сервера и пула для базы данных:

\begin{verbatim}
(def config
  {::server {:port 8080 :join? false}
   ::db {:username      "book"
         :password      "book"
         :database-name "book"
         :server-name   "127.0.0.1"
         :port-number   5432}})
\end{verbatim}

Ключ словаря это машинное имя компонента, а значение~--- параметры запуска. Уже на
этом этапе видно одно из преимуществ Integrant~--- его декларативность. Эту
структуру можно скопировать или считать из файла.

Система и компоненты связаны через мультиметоды. Чтобы добавить реакцию на
определенное событие, мы расширяем нужный мультиметод по ключу
компонента. Например, при старте система вызывает метод \spverb|init-key| для каждого
ключа. Чтобы объяснить системе, как запускать сервер, метод предварительно
расширяют ключом \spverb|::server|.

Integrant ожидает, что ключ реализует минимум два метода: запуск и
остановка. Это ключевые операции для работы с системой, поэтому для них не
предусмотрены действия по умолчанию. Другие события опциональны и остаются на
усмотрение разработчика.

\subsection{Первые компоненты}

Как и в прошлых разделах, мы начнем практику с описания компонентов сервера и
базы. Они просты и не имеют зависимостей. Подготовьте модуль
\spverb|src/book/integrant.clj| со следующей шапкой:

\begin{verbatim}
(ns book.integrant
  (:require [integrant.core :as ig]))
\end{verbatim}

Для краткости мы опустим импорты Jetty, HikariCP и других библиотек. Они
аналогичны тем, что мы писали в упражнениях с Mount и Component.

Начнем с сервера. Метод init-key принимает два параметра: ключ и словарь его
опций. Для конфигурации выше это значения \spverb|::server| и `{:port 8080 :join?
false}`. Метод должен вернуть объект-состояние компонента. Достаточно передать в
функцию \spverb|run-jetty| обработчик запроса, объявленный где-то выше, и словарь
опций.

\begin{verbatim}
(defmethod ig/init-key ::server
  [_ options]
  (run-jetty app options))
\end{verbatim}

Поскольку ключ известен из определения метода, первый параметр затеняют символом
подчеркивания. По аналогии опишем базу данных. Состояние компонента это
JDBC-спека, которую передают в функции из пакета clojure.java.jdbc.

\begin{verbatim}
(defmethod ig/init-key ::db
  [_ options]
  {:datasource (cp/make-datasource options)})
\end{verbatim}

Функция \spverb|init| пробегает по каркасу системы и вызывает для каждого ключа
мультиметод \spverb|init-key|. В результате получим словарь-систему, где ключ это имя
компонента, а значение~--- его состояние:

\begin{verbatim}
(def _sys (ig/init config))

(keys _sys)
(:book.integrant/db :book.integrant/server)
\end{verbatim}

В терминах Integrant остановка системы называется \spverb|halt|. Метод \spverb|halt-key!|
определяет, как выключить определенный ключ. Он принимает два параметра: ключ и
состояние, которые мы вернули из метода \spverb|init-key|. Определим эти события для
сервера и базы:

\begin{verbatim}
(defmethod ig/halt-key! ::server [_ server]
  (.stop server))

(defmethod ig/halt-key! ::db [_ db-spec]
  (-> db-spec :datasource cp/close-datasource))
\end{verbatim}

Функция halt! останавливает систему целиком:

\begin{verbatim}
(ig/halt! _sys)
\end{verbatim}

\subsection{Зависимости}

Чтобы указать ключу зависимости, в его опции добавляют специальный ссылочный
параметр. При запуске Integrant просматривает каркас системы на наличие таких
параметров и строит по ним граф зависимостей. Ссылочный параметр задают функцией
\spverb|ig/ref|. Она принимает ключ, на который следует сослаться.

Рассмотрим зависимость на примере воркера. Добавьте в конфигурацию новый ключ:

\begin{verbatim}
{::worker {:options {:sleep 1000}
           :db (ig/ref ::db)}}
\end{verbatim}

Чтобы \spverb|:db| не слиплось с общими настройками воркера, мы вынесли их в отдельное
поле \spverb|:options|.

Теперь когда метод \spverb|init-key| дойдет до ключа \spverb|::worker|, в поле \spverb|:db| будет
значение, которое \spverb|init-key| вернул для этого ключа. В нашем случае это
JDBC-спека с пулом соединений.

Код запуска и остановки воркера аналогичен тому, что мы писали для Mount и
Component. Для экономии места приведем только реализации \spverb|init-key| и
\spverb|halt-key!|. Если вдруг вы забыли, как устроен воркер, обратитесь к прошлым
разделам главы.

\begin{verbatim}
(defmethod ig/init-key ::worker
  [_ {:keys [db options]}]
  (let [flag (atom true)
        task (make-task db flag options)]
    {:flag flag :task task}))

(defmethod ig/halt-key! ::worker
  [_ {:keys [flag task]}]
  (reset! flag false)
  (while (not (realized? task))
    (Thread/sleep 300)))
\end{verbatim}

\subsection{Параллели с Component}

Многие из приемов, которые мы рассмотрели для Component, работают и в Integrant
Вспомним некоторые их них.

\emph{Глобальное хранилище.} Чтобы управлять системой, нужно где-то ее
хранить. Проще всего добавить глобальную переменную и вспомогательные функции
для запуска и остановки.

\begin{verbatim}
(defonce ^:private system nil)

(def alter-system (partial alter-var-root #'system))

(defn system-start []
  (alter-system (constantly (ig/init config))))

(defn system-stop []
  (alter-system ig/halt!))
\end{verbatim}

Как и в Component, система должна быть приватной. Недопустимо, чтобы компоненты
свободно обращались к ней.

\emph{Ожидание и сигналы.} Перед тем как закончить работу, приложение ожидает, пока
все компоненты корректно остановятся. Пример с макросом \spverb|with-handler| и
перехватом сигналов работает аналогично для Integrant:

\begin{verbatim}
(with-handler :term
  (log/info "caught SIGTERM, quitting")
  (system-stop)
  (log/info "all components shut down")
  (exit))
\end{verbatim}

\emph{Спуск системы и маршруты.} В Integrant легче решить проблему доступа к
системе из HTTP-обработчика. Достаточно выразить обработчик в виде компонента с
нужными зависимостями. Представим, что главная страница веб-сервера выводит
число записей в базе. Добавим в систему новый ключ, который зависит от базы:

\begin{verbatim}
{::handler {:db (ig/ref ::db)}}
\end{verbatim}

При запуске ключа вернем функцию-обработчик, замкнутую на \spverb|db|:

\begin{verbatim}
(defmethod ig/init-key ::handler
  [_ {:keys [db]}]
  (fn [request]
    (let [query "select count(*) as total from requests"
          result (jdbc/query db query)
          total (-> result first :total)]
      {:status 200
       :body (format "You've got %s requests." total)})))
\end{verbatim}

Доработаем сервер так, чтобы он зависел от обработчика:

\begin{verbatim}
{::server {:options {:port 8080 :join? false}
           :handler (ig/ref ::handler)}}

(defmethod ig/init-key ::server
  [_ {:keys [handler options]}]
  (run-jetty handler options))
\end{verbatim}

Теперь браузер покажет фразу "You've got N requests.", где N~--- число записей в
базе. Как и в примере с Component, \spverb|::handler| может вернуть дерево маршрутов,
построенное с помощью Compojure.

\emph{Условное построение.} Конфигурация системы это словарь, поэтому в него можно
добавить или удалить ключи по каким-либо условиям, как мы делали это в
Component. Например, специальная функция определяет, будет ли запущен воркер или
нет. Если будет, мы добавляем в систему ключ и его настройки.

\begin{verbatim}
(cond-> sys-config
  (is-worker-supported?)
  (assoc ::worker {:options {:sleep 1000}
                   :db (ig/ref ::db)}))
\end{verbatim}

Есть и другой способ запустить подмножество системы, аналогичный Mount. Функция
\spverb|init| принимает необязательный список ключей. Этот список, а еще лучше
множество, можно подготовить заранее на базе определенной логики.

\begin{verbatim}
(let [components (-> config keys set)
      components (cond-> components
                   (not (is-worker-supported?))
                   (disj ::worker))]
  (ig/init config components))
\end{verbatim}

\subsection{Проблема потери ключей}

Обратите внимание, что мы указываем полные (квалифицированные) ключи для
компонентов, например \spverb|::server| или \spverb|::db|. Двойное двоеточие означает текущее
пространство имен, в котором объявлен ключ. Запись \spverb|::db| это краткий вариант
\spverb|:book.integrant/db|.

Когда ключ полный, то есть с пространством, легко определить, в каком модуле он
объявлен. В промышленных системах бывает несколько десятков
компонентов. Представьте, что возникла проблема с ключом \spverb|:queue|. Как понять, в
каком месте мы расширили мультиметод этим ключом? Наоборот, ключ
\spverb|:my-project.utils.queue/queue| несет эту информацию. Всегда используйте полные
ключи.

Возможна ситуация, когда вы забыли импортировать модуль, в котором расширяете
мультиметод. Иногда трудно понять, почему возникла ошибка: вы точно помните, что
писали этот код. Чтобы избежать ошибки, добавьте эти модули в заголовок \spverb|ns|
главного модуля, который загружается всегда. Пусть это будет модуль, в котором
вы собираете систему.

\begin{verbatim}
(ns project.system
  (:require project.db
            project.server
            project.worker
            project.utils.queue))
\end{verbatim}

Возможно, утилиты для проверки синтаксиса (линтеры) будут выдавать
предупреждение для этих модулей. С их точки зрения утилиты вы добавили модуль,
но не используете его, потому что в коде нет ни одного выражения
\spverb|project.db/<something>|. Чтобы подавить эти предупреждения, добавьте модули в
конфигурацию линтера в секцию "known namespaces" или аналогичную.

Integrant предлагает функцию \spverb|load-namespaces| для автоматической загрузки
модулей. На вход подают конфигурацию системы. Для каждого ключа функция
вычисляет его пространство и загружает его. Вот как выглядит промышленная
система с ключами из разных модулей:

\begin{verbatim}
(def config
  {:project.server/server {:options {:port 8080 :join? false}
                           :handler (ig/ref :project.handlers/index)}
   :project.db/db {...}
   :project.worker/worker {:options {:sleep 1000}
                           :db (ig/ref :project.db/db)}
   :project.handlers/index {:db (ig/ref :project.db/db)}})
\end{verbatim}

Чтобы загрузить все модули, которые участвуют в этой системе, добавьте
выражение:

\begin{verbatim}
(ig/load-namespaces config)
\end{verbatim}

Заметим, что явная загрузка модулей все же предпочтительнее. Мы советуем
начинающим воздержаться от автоматических импортов. Размещайте их явно в блоке
\spverb|ns|: этот вариант хоть и многословен, но зато очевиден. Прибегайте к помощи
\spverb|load-namespaces| только если точно знаете, как работает система пространств в
Clojure.

\subsection{Система в файле}

Выше мы упоминали, что Integrant делает ставку на декларативность. В идеале
конфигурация системы это статичная структура данных, словарь. Для экономии места
систему можно вынести в EDN-файл и прочитать функцией из модуля \spverb|clojure.edn|.

Читатель заметит, что мы указываем зависимости через функцию \spverb|ig/ref|, и не
совсем ясно, как поместить это выражение в файл. Вспомним систему тегов: при
чтении EDN-данных мы указываем связь между тегом и функцией, которая обработает
следующее за тегом значение. Для зависимостей Integrant предлагает тег
\spverb|#ig/ref|. В примере ниже мы выразили зависимость тегом:

\begin{verbatim}
{:project.worker/worker {:options {:sleep 1000}
                         :db #ig/ref :project.db/db}}
\end{verbatim}

Integrant предлагает функцию \spverb|read-string| что чтения EDN-данных. Это обертка
вокруг \spverb|clojure.edn/read-string|, заряженная дополнительными тегами. Чтобы
прочитать систему из файла, выполните:

\begin{verbatim}
(def config
  (-> "config.edn" slurp ig/read-string))
\end{verbatim}

Из главы про конфигурацию мы помним, что нежелательно хранить в файле пароли и
ключи доступа. Этот принцип нарушает компонент \spverb|:project.db/db|: пароль к базе
данных записан открыто. Сделаем так, чтобы парсер читал пароль из переменной
среды.

Вынесем конфигурацию в файл \spverb|integrant.test.edn| (ниже ее фрагмент):

\begin{verbatim}
{:project.db/db {:password #env DB_PASSWORD}
 :project.worker/worker {:options {:sleep 1000}
                         :db #ig/ref :project.db/db}}
\end{verbatim}

Обернем чтение конфигурации в функцию. Первым аргументом в \spverb|ig/read-string|
укажем словарь с тегами. Функцию \spverb|tag-env| для тега \spverb|#env| мы перенесли из
прошлой главы. На нижнем уровне Integrant дополнит наш словарь тегов
собственными, поэтому оба \spverb|#ig/ref| и \spverb|#env| будут работать.

Теперь система хранится в файле, а теги описывают ее точнее и гибче.

\begin{verbatim}
(defn load-config
  [filename]
  (ig/read-string {:readers {'env tag-env}}
                  (slurp filename)))

(load-config "integrant.test.edn")
{:project.db/db {:password "c8497b517da25"}
 :project.worker/worker {:options {:sleep 1000}
                         :db #integrant.core.Ref{:key :project.db/db}}}
\end{verbatim}

\subsection{Наследование ключей}

В Clojure ключи могут выстраиваться в иерархию. Функция \spverb|derive| принимает два
ключа и задает превосходство первого над вторым.

\begin{verbatim}
(derive ::postgresql ::database)
\end{verbatim}

Когда мультиметод разрешает действие по ключу, он учитывает его
иерархию. Например, если мультиметод реализован для \spverb|::database|, вызов с
\spverb|::postgresql| не приведет к ошибке: сработает реализация \spverb|::database|.

Поскольку Integrant устроен на мультиметодах, из наследования ключей можно
извлечь пользу. Например, нагруженные проекты работают с двумя базами данных:
мастер для записи и реплика для чтения. Пусть это будут компоненты \spverb|::db-master|
и \spverb|::db-replica|. Технически они одинаковы и отличаются только входными
параметрами.

Если бы мы не знали про наследование, то расширили бы \spverb|ig/init-key| и
\spverb|ig/halt-key!| каждым ключом. Пришлось бы копировать код каждой реализации, что
не гибко и считается плохой практикой. Вспомним, что мы уже описали поведение
базы компонентом \spverb|::db|. Унаследуем от него две других базы:

\begin{verbatim}
(derive ::db-master ::db)
(derive ::db-replica ::db)
\end{verbatim}

Изменим конфигурацию так, что в ней две базы данных: мастер и реплика. Для
реплики мы выставили флаг \spverb|:read-only| true, чтобы обезопасить себя от записи не
в тот источник. Обратите внимание от какой базы зависит каждый
компонент. Поскольку воркер пишет данные в базу, он зависит от
\spverb|::db-master|. Компонент \spverb|::hander| только читает данные, поэтому зависит от
\spverb|::db-replica|.

\begin{verbatim}
(def config
  {::server {:options {:port 8080 :join? false}
             :handler (ig/ref ::handler)}
   ::db-master {;; other fields
                :read-only false}
   ::db-replica {;; other fields
                 :read-only true}
   ::worker {:options {:sleep 1000}
             :db (ig/ref ::db-master)}
   ::handler {:db (ig/ref ::db-replica)}})
\end{verbatim}

Функция \spverb|ig/refset| и одноименный тег вернут множество зависимостей с учетом
иерархии. Предположим, что один из компонентов ожидает все базы данных для
какой-то ручной синхронизации. Чтобы не ссылаться на каждую базу вручную, укажем
ее корневой ключ.

Добавим в конфигурацию компонент \spverb|::sync| с зависимостью через \spverb|refset|. Объявим
пустой \spverb|init-key| для этого компонента: он ничего не делает, а только возвращает
параметры. При запуске компонент получит множество баз в поле \spverb|:dbs|

\begin{verbatim}
{::sync {:dbs (ig/refset ::db)}}

(defmethod ig/init-key ::sync
  [_ opt] opt)

(system-start config)
(-> system ::sync :dbs count)
2
\end{verbatim}

\subsection{Другие стадии компонента}

Кроме запуска и остановки, Integrant выделяет дополнительные стадии, которые
проходит компонент. В отличии от запуска, они не обязательны к
реализации. Дополнительные стадии устроены как мультиметоды, которым задано
действие по умолчанию (вернуть nil или исходный объект). Чтобы подписать
компонент на событие, расширите мультиметод его ключом. Ниже мы рассмотрим
несколько полезных стадий.

\subsection{Подготовка}

Метод \spverb|ig/prep-key| служит для предварительной подготовки параметров. Чаще всего
это объединение параметров по умолчанию с теми, что мы получили из
конфигурации. Например, мы выяснили, что для нашей инфраструктуры важны именно
такие метрики пула БД. Чтобы не указывать в конфигурации все поля, вынесем их
фиксированную часть в словарь опций по умолчанию.

\begin{verbatim}
(def db-defaults
  {:auto-commit        false
   :read-only          false
   :connection-timeout 30000
   :validation-timeout 5000
   :idle-timeout       600000
   :max-lifetime       1800000
   :minimum-idle       10
   :maximum-pool-size  10})

(defmethod ig/prep-key ::db
  [_ options]
  (merge db-defaults options))
\end{verbatim}

Метод \spverb|prep-key| объединяет этот словарь с параметрами. Теперь в конфигурации
достаточно указать только параметры подключения и, если требуется,
переопределения:

\begin{verbatim}
{::db {:auto-commit   true ;; override the default
       :adapter       "postgresql"
       :username      "book"
       :password      "book"
       :database-name "book"
       :server-name   "127.0.0.1"
       :port-number   5432}}
\end{verbatim}

Функция \spverb|ig/prep| принимает конфигурацию и запускает метод для каждого
ключа. Чтобы не забыть этот шаг, сделайте его частью функции \spverb|load-config|,
которую мы описали выше.

\subsection{Спека}

Метод \spverb|ig/pre-init-spec| связывает параметры компонента со спекой. Если метод
вернул спеку для определенного ключа, параметры проходят проверку. Например, для
базы данных обязательны параметры подключения. Проверим их перед запуском пула:

\begin{verbatim}
(require '[clojure.spec.alpha :as s])

(s/def :db/username string?)
;; other db fields

(defmethod ig/pre-init-spec ::db
  [_]
  (s/keys :req-un [:db/username
                   :db/password
                   :db/database-name
                   :db/server-name
                   :db/port-number]))
\end{verbatim}

Если запустить систему с неверными параметрами, получим ошибку spec:

\begin{verbatim}
Execution error (ExceptionInfo) at integrant.core/spec-exception (core.cljc:385).
Spec failed on key :book.integrant/db when building system
"book" - failed: string? in: [:username] at: [:username] spec: :db/username
\end{verbatim}

\subsection{Приостановка}

Кроме \spverb|init| и \spverb|halt|, Integrant выделяет третье состояние системы~---
\spverb|suspended|. Приостановленный компонент не теряет состояние, а только ставит на
паузу внутренние процессы. Например, если это потребитель сообщений из очереди
\spverb|(KafkaConsumer)|, он не закрывает соединение с очередью, а временно перестает
читать сообщения (вызывать метод \spverb|poll|). Обратная операция называется
resume. При возобновлении компонент, не порождая новых тредов или соединений,
продолжает работу.

По умолчанию приостановка и возобновление работают как \spverb|halt| и \spverb|init|. Это
значит, что если компонент не реализует эти события, он останавливается и
запускается заново. Чтобы задать верную реакцию на suspend и resume, реализуйте
методы \spverb|ig/suspend-key!| и \spverb|ig/resume-key|. Это потребует углубленного внимания
и чтения документации. Мы оставим этот раздел читателю на самостоятельное
изучение.

\section{Заключение}

Подобно тому, как машина складывается из деталей, программа состоит из
компонентов. Система управляет компонентами. Это соглашение о том, как они
устроены и связаны друг с другом.

Любой проект нуждается в системе, и чем дальше он развивается, тем сильнее
потребность. Если в проекте нет соглашения о том, как проектировать составные
части, он начинает буксовать. Поддержка проекта становится слишком затратной.

Clojure предлагает разные подходы для систем. Наиболее популярные из них~---
Mount, Compojure и Integrant~--- мы рассмотрели в этой главе. Библиотеки
исповедуют разный подход, и скорее всего разработчик найдет то, что ему по душе.

Проект Mount отталкивается от глобальных переменных. Если проект написан в таком
стиле:

\begin{verbatim}
(def server (run-jetty app {:port 8080}))
\end{verbatim}

, то портировать его на Mount будет легко. Переменная server станет сущностью,
которая меняет значение по команде. Mount подойдет тем, кто только начал
знакомство с Clojure.

Библиотека Component это шаг в сторону настоящих компонентов. Такие компоненты
это отдельные сущности, которые изолируют состояние. Компоненты и протоколы
напоминают классы и объекты и из современных языков программирования. По этой
причине некоторые разработчики недолюбливают Component и обвиняют его в излишней
раздутости, "энтерпрайзности".

Действительно, иногда решение на компонентах занимает больше места, чем на
атомах и функциях. С другой стороны, именно Component дает понимание того, как
строить устойчивые системы. Читатель заметит, что большую часть вопросов мы
обсудили в разделе именно про Component.

Проект Integrant ставит цель исправить некоторые недостатки Component. Он лишен
ООП-тяжести и целом более "кложурный". Integrant опирается на идиомы и техники,
принятые в Clojure, и тем самым подкупает опытных разработчиков.

Эта глава не ставит цель выяснить, какая из библиотек лучше. Не бросайтесь
переписывать проект с условного Mount на Component. Архитектура библиотек
слишком отличается друг от друга. Это изнуряющий труд, и вы не поймете, каких
преимуществ достигли, пока не ощутите в них потребность.

Вопрос о том, какая система лучше ниже рангом другого, более важного вопроса:
зачем система нужна проекту. Когда вы понимаете важность системного подхода,
технические решения найдутся сами.
