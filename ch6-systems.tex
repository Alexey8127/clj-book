\chapter{Системы}

\label{chapter-systems}

\begin{teaser}
В этой главе мы поговорим о системах. Рассмотрим, как составить проект из
отдельных частей и заставить работать их вместе.
\end{teaser}

Понятие системы связано с конфигурацией, которую мы только что
обсудили. Конфигурация учит, как принять параметры из внешнего мира. Система
задает внутреннее устройство программы. Это набор компонентов со связями и
иерархией. Отличие в том, что конфигурация отвечает на вопрос как
\emph{получить} параметры, а система знает, как ими \emph{распорядиться}.

\section{Подробнее о системе}

Системы появились, когда возник спрос на долгоиграющие приложения. При
разработке скриптов и утилит вопрос не стоял остро. Время работы скрипта
коротко, и его состояние тоже живет недолго. При завершении ресурсы
освобождаются, поэтому нет смысла в особом контроле за ними.

С серверными приложениями все по-другому: они работают постоянно и потому
устроены иначе, чем разовые скрипты. Приложение состоит из компонентов, которые
работают в фоне. Каждый компонент выполняет узкую задачу. При запуске приложение
включает компоненты в правильном порядке и строит между ними связи.

Компонент это объект, который несет состояние. На него действуют операции
включить и выключить. Как правило, включить компонент означает открыть ресурс, а
выключить~--- закрыть его.

Типичные компоненты веб-приложения это сервер, база данных, кэш. Чтобы не
открывать соединение на каждый запрос к базе, понадобится пул
соединений. Создавать его вручную и передавать в функции это рутинная
задача. Должен быть компонент, который при включении открывает пул и хранит
его. Для потребителей компонент предлагает функции для работы с базой. Внутри
функции опираются на открытый пул.

На первый взгляд схема напоминает ООП и принцип инкапсуляции. Не торопитесь с
выводами: компоненты в Clojure работают иначе. Ниже мы рассмотрим разницу между
объектами и компонентами.

\subsection{Зависимости}

Главная точка системы это зависимости компонентов. В примере выше сервер, база и
кэш не зависят друг от друга. Это базовые компоненты системы; на них опираются
другие уровнем выше. Например, фоновый поток, который читает базу и отправляет
письма. Будет неправильно, если компонент откроет свои подключения к базе и
почте. Вместо этого он принимает включенные компоненты и работает с ними как с
черным ящиком.

Ключевая обязанность системы~--- запустить и остановить компоненты в верном
порядке. Например, если компонент A зависит от B и C, то к моменту запуска A
последние два должны быть запущены. При завершении компоненты B и C нельзя
выключить до тех пор, пока работает~A. Система строит граф зависимостей между
компонентами. Граф обходят так, чтобы удовлетворить нужды каждой вершины.

В систему должно быть легко добавить новый компонент. В идеальном случае система
это комбинация словарей и списков. Код загрузки пробегает по ней и включает
компоненты. Расширить систему означает добавить новый узел в дерево.

Когда система знает о зависимостях, можно велючить ее подмножество. Например,
нужно отладить обработчик почты, который зависит от базы и
SMTP-сервера. Веб-сервер и кэш в данном случае не нужны, и запуск всей системы
избыточен. Продвинутые системы предлагают функцию с семантикой <<запусти этот
компонент и все его зависимости>>.

\subsection{Преимущества}

На первый взгляд кажется, что система~--- лишнее усложнение. Это новая
библиотека, соглашения в команде, рефакторинг и ограничения. Но первичные
неудобства окупаются со временем.

Система приводит проект в порядок. С ростом кодовой базы становится важно, чтобы
части проекта были в одном стиле. Если соблюдать это требование, служебные
компоненты уйдут в библиотеки, а в проекте останется только логика. Будет проще
начать новый проект, имея под рукой базу внутренних компонентов фирмы.

Системы полезны на всех стадиях производства, особенно тестировании. Для тестов
запускают систему, где некоторые компоненты работают по-другому. Например, для
отправки смс подкладывают компонент, который пишет сообщения в файл.

\section{Подготовка к обзору}

В главе об изменяемых данных мы упоминали о системах \page{systems-intro}. Мы
узнали, как с помощью \spverb|alter-var-root| менять глобальные переменные. Идея
в том, чтобы вынести компонент в модуль и снабдить его функциями \spverb|start!|
и \spverb|stop!|. Функции переключают состояние модуля. Запуск системы сводится
к их вызову в верном порядке.

Это любительское решение. Такая система не знает о зависимостях между
компонентами. Она хрупкая, работает в ручном режиме, и каждое изменение требует
проверки.

Clojure предлагает несколько библиотек для систем. Мы рассмотрим Mount,
Component и Integrant. Библиотеки различаются идеологией в построении
систем. Они по-разному описывают компоненты и связи между ними. Так мы
рассмотрим проблему с разных сторон.

Библиотеки нарочно следуют в таком порядке. С Mount легче начать, поэтому
рассмотрим его первым. Component стал промышленным стандартом. Мы уделим ему
больше внимания и поэтому ставим в середину. Integrant замыкает обзор: его
рассматривают как альтернативу Component, с котором читатель должен быть знаком.

Мы построим настоящую систему, похожую на то, с чем вы столкнетесь на
практике. Система состоит из веб-сервера, базы данных и фонового процесса,
который обновляет записи в базе. Мы специально добавили его, чтобы научиться
работать с зависимостями. Нарисуем топологию системы:

\chart{chart-sys-1}

Стрелки на схеме означают отношения между компонентами. Выражение A \arr B
означает <<А зависит от В>>. В нашей системе все компоненты зависят от
конфигурации. Дополнительно фоновый обработчик зависит от базы данных. Над этой
системой мы и будем работать до конца главы.

\subsection{База и воркер}

Мы упоминали, что открывать соединение на каждый запрос неоптимально. В
настоящих проектах с базой работают через пул. Это сущность с состоянием,
поэтому его тоже <<включают и выключают>>.

Некоторые базы хранят данные в памяти, например SQLite или H2. Это удобно для
быстрого старта, но не отражает реалии производства~--- то, к чему мы стремимся
в этой книге. Для \emph{in-memory}-баз не используют пулы соединений: в этом нет
смысла, потому что данные лежат в памяти, а не в сети. Будем работать с
реляционной БД PostgreSQL с пулом HikariCP.

Фоновый процесс или воркер дополняет записи в базе данными из сети. Предположим,
фирма ведет аналитику посещений. Когда кто-то открывает страницу, приложение
пишет в базу адрес и данные запроса: заголовок User-Agent и IP-адрес
клиента. Чтобы строить отчеты по странам и городам, нужно извлечь эти поля из
сторонних сервисов. Это дорогая операция, поэтому записи ставят флаг <<ждет
обработки>> и выносят логику в фон.

\subsection{Docker}

Если у вас установлен PostgreSQL, создайте новую базу и таблицу в ней. Если нет,
самое время попробовать Docker. Это программа для запуска приложений из
образов. Под образом понимают специальный файл, в котором упаковано приложение
со всем необходимым для запуска. Запущенный образ называют контейнером.

У контейнеров несколько преимуществ. Приложение живет в изолированной среде и
поэтому отделено от основной системы. Кроме безопасности, это решает проблему
\emph{чистоты}~--- контейнер не оставляет следов работы, если это не настроено
специально.

В сети работает публичный репозиторий, где Docker ищет образы. В нем публикуют
программы разных версий и комплектации. Например, если нужен PostgreSQL строго
9.3, просто скачайте образ. Установка этой версии в систему, скорее всего,
обернется конфликтом с уже работающей базой.

Некоторые образы можно настроить переменными среды или файлами. Образ PostgreSQL
устроен так, что при старте он загружает все \spverb|*.sql| файлы из папки
\spverb|/docker-entrypoint-initdb.d|. Если назначить этой папке локальный путь с
sql-миграциями, получим готовую базу без строчки кода.

В комплекте с Docker идет утилита \spverb|docker-compose|. Она запускает из
контейнер из файла конфигурации. По умолчанию файл называется
\spverb|docker-compose.yaml|. Это YAML-документ, где указан образ и параметры их
запуска. Ниже мы указали образ \spverb|postgres| и опции: порт, файловые пути и
переменные среды.

\begin{english}
  \begin{yaml}
version: '2'
services:
  postgres:
    image: postgres
    volumes:
      - ./initdb.d:/docker-entrypoint-initdb.d
    ports:
      - 5432:5432
    environment:
      POSTGRES_DB: book
      POSTGRES_USER: book
      POSTGRES_PASSWORD: book
  \end{yaml}
\end{english}

В папке \spverb|initdb.d| лежат sql-файлы для старта базы. Достаточно файла
\spverb|01.init.sql| с таблицей:

\begin{english}
  \begin{sql}
drop table if exists requests;
create table requests (
    id            serial primary key,
    path          text not null,
    ip            inet not null,
    is_processed  boolean not null default false,
    zip           text,
    country       text,
    city          text,
    lat           float,
    lon           float
);
  \end{sql}
\end{english}

Если запустить \spverb|docker-compose up|, поднимется сервер PostgreSQL на порту
5432 с базой \spverb|book|. Этого хватит для дальнейшей работы. Больше мы не
будем говорить о Docker, поскольку он тянет на отдельную книгу. Все детали вы
найдете на сайте проекта\footurl{https://docker.com}.

\section{Mount}

Библиотека Mount\footurl{https://github.com/tolitius/mount} описывает сущность с
двумя состояниями: запуск и остановка. По команде она <<включается>> и принимает
значение, которое вернул код запуска. При выключении сработает код
остановки. Сущность похожа на глобальную переменную, которая меняется по
команде. Внешне Mount прост, поэтому подойдет начинающим.

Макрос \spverb|defstate| задает новую сущность. Он напоминает \spverb|def|,
потому что создает переменную в текущем пространстве. Вместо значения
\spverb|defstate| принимает код запуска и остановки.

\subsection{Первая сущность}

Напишем с помощью Mount компонент веб-сервера. Поместим его в модуль
\spverb|server.clj|. Функция \spverb|app| это примитивное приложение, которое
вернет статус 200 на все запросы.

\begin{english}
  \begin{clojure}
(ns book.systems.mount.server
  (:require
   [mount.core :as mount :refer [defstate]]
   [ring.adapter.jetty :refer [run-jetty]]))

(def app (constantly {:status 200 :body "Hello"}))

(defstate server
  :start (run-jetty app {:join? false :port 8080})
  :stop (.stop server))
  \end{clojure}
\end{english}

Пока что мы только объявили состояние, но ничего не включили. Если выполнить
\spverb|server|, увидим следующее:

\begin{english}
  \begin{clojure}
#DerefableState[{:status :pending, :val nil}]
  \end{clojure}
\end{english}

Чтобы запустить компонент, выполните \spverb|(mount/start)|. Функция пробегает
по компонентам и включает их. Выражение \spverb|(run-jetty ...)| под ключом
\spverb|:start| вернет сервер, который работает в фоне. После запуска браузер
покажет приветствие по адресу \spverb|http://127.0.0.1:8080|. Переменная
\spverb|server| станет экземпляром \spverb|Server| из пакета \spverb|jetty|:

\begin{english}
  \begin{clojure}
(type server)
;; org.eclipse.jetty.server.Server
  \end{clojure}
\end{english}

Чтобы выключить систему, выполните \spverb|(mount/stop)|. Обратите внимание, что
в выражении \spverb|(.stop server)| сущность обращается к самой себе. После
остановки \spverb|server| станет особым значением, которое означает завершение.

\begin{english}
  \begin{clojure}
(mount/stop)
(type server)
;; mount.core.NotStartedState
  \end{clojure}
\end{english}

Так строят систему. Сперва находят сущности, которые работают на протяжении всей
программы. В основном это сетевые подключения и фоновые задачи. Затем объявляют
компонент с логикой запуска и остановки.

\subsection{Связь с конфигурацией}

Выше мы допустили ошибку: параметры сервера <<захардкожены>> в компоненте. Мы
уже обсудили, чем это плохо; параметры должны быть в конфигурации. Поскольку у
нас система, поэтому вынесем конфигурацию в компонент.

Сущность \spverb|config| это упрощенный загрузчик конфигурации. Для краткости
опустим перехват ошибок и другие детали. Фаза \spverb|:start| читает файл
EDN. Замените \spverb|edn/read-string| на Yummy, Aero или свое
решение. Компоненту не нужна фаза \spverb|:stop|, потому что он не хранит
состояние.

\begin{english}
  \begin{clojure}
(ns book.systems.mount.config
  (:require
   [mount.core :as mount :refer [defstate]]
   [clojure.edn :as edn]))

(defstate config
  :start
  (-> "system.config.edn"
      slurp
      edn/read-string))
  \end{clojure}
\end{english}

Файл \spverb|system.config.edn| содержит словарь, где ключ это имя компонента, а
значение~--- его параметры. Поместим сервер под ключ \spverb|:jetty|:

\begin{english}
  \begin{clojure}
{:jetty {:join? false :port 8088}}
  \end{clojure}
\end{english}

Улучшим сервер так, чтобы он зависел от конфигурации. В список \spverb|:require|
модуля добавим импорт конфигурации:

\begin{english}
  \begin{clojure}
(ns book.systems.mount.server
 (:require
  [book.systems.mount.config :refer [config]]))
  \end{clojure}
\end{english}

\noindent
Перепишем компонент, чтобы он читал конфигурацию:

\begin{english}
  \begin{clojure}
(defstate
  server
  :start
  (let [{jetty-opt :jetty} config]
    (run-jetty app jetty-opt))
  :stop (.stop server))
  \end{clojure}
\end{english}

Получилась система из двух компонентов, где один зависит от другого. Убедитесь,
что после вызова \spverb|(mount/start)| сервер работает как ожидалось.

\subsection{База данных}

Подготовим компонент базы данных. Понадобяться библиотеки
JDBC\footurl{https://github.com/clojure/java.jdbc} и
HikariCP\footurl{https://github.com/tomekw/hikari-cp}. Первая предлагает доступ
к реляционным базам данных. Это набор функций, которые работают одинаково для
разных баз. Например, выражения:

\begin{english}
  \begin{clojure}
(jdbc/get-by-id db :users 42)
(jdbc/insert! db :users {:name "Ivan" :email "ivan@test.com"})
  \end{clojure}
\end{english}

\noindent
прочитают и запишут пользователя в PostgreSQL, MySQL или Oracle. Для каждого
бекенда JDBC строит запрос с учетом его особенностей.

Функции JDBC принимают первым параметром \emph{JDBC-спеку}. Обычно это словарь
подключения: адрес и порт сервера, имя базы, пользователь и пароль. На каждый
запрос JDBC открывает соединение, обменивается данными и закрывает его.

В спеке может быть ключ \spverb|:datasource| с подготовленным источником
данных. Тогда JDBC игнорирует другие ключи и работает напрямую с
\spverb|:datasource|. HikariCP предлагает функцию, чтобы построить источник с
пулом соединений. Каждый раз, когда мы запросим соединение у источника, получим
одно из открытых ранее.

Источник хранит состояние, поэтому вынесем его в компонент. Подготовим модуль
\spverb|db.clj|:

\begin{english}
  \begin{clojure}
(ns book.systems.mount.db
  (:require
   [mount.core :as mount :refer [defstate]]
   [hikari-cp.core :as cp]
   [book.systems.mount.config :refer [config]]))

(defstate db
  :start
  (let [{pool-opt :pool} config
        store (cp/make-datasource pool-opt)]
    {:datasource store})
  :stop
  (-> db :datasource cp/close-datasource))
  \end{clojure}
\end{english}

Фаза старта вернет JDBC-спеку~--- словарь с ключом \spverb|:datasource|, внутри
которого пул. При выключении функция \spverb|close-datasource| закрывает его и
все открытые соединения. Добавим в конфигурацию настройки пула:

\begin{english}
  \begin{clojure}
{:pool {:minimum-idle       10
        :maximum-pool-size  10
        :adapter            "postgresql"
        :username           "book"
        :password           "book"
        :database-name      "book"
        :server-name        "127.0.0.1"
        :port-number        5432}}
  \end{clojure}
\end{english}

Для экономии укажем только основные параметры. Это свойства подключения (хост,
порт, пользователь, пароль) и размерность пула. При желании можно настроить
каждую стадию пула, в том числе тайминги соединений. Полный список опций
смотрите на странице проекта в GitHub.

Запустите систему и выполните запрос:

\begin{english}
  \begin{clojure}
(mount/start)
(require '[clojure.java.jdbc :as jdbc])
(jdbc/query db "select 42 as answer")
;; ({:answer 42})
  \end{clojure}
\end{english}

\subsection{Фоновая задача}

\label{worker}

Все готово для последнего компонента системы. Это воркер, который работает в
отдельном потоке. Он выбирает из базы сырые записи и дополняет их полями из
стороннего сервиса.

Таблица \spverb|requests| хранит адрес страницы и IP-адрес клиента. Флаг
\spverb|is_processed| это признак того, была ли уже обработана запись. Поля
\spverb|city|, \spverb|country| и другие по умолчанию равны \spverb|NULL|.

Цикл воркера состоит из шагов:

\begin{itemize}

\item
  раз в интервал выбрать запись с флагом \spverb|NOT is_processed|;

\item
  сделать запрос к сервису, который вернет геоданные по IP;

\item
  обновить запись в транзакции.

\end{itemize}

Выразим воркер в терминах Mount. Задача работает в отдельном потоке, поэтому
нужен тред или футура с бесконечным циклом. Чтобы остановить воркер по запросу,
цикл должен быть с условием, например, проверкой флага на каждом шаге. Флаг
доступен и воркеру, и тому, кто им управляет.

В Clojure это решается футурой и атомом. В атоме хранят флаг~--- признак
продолжения цикла. На каждом шаге футура <<дерефит>> атом, и если он истина, то
выполняет задачу. Чтобы завершить футуру, совершают два действия. Первое~---
возводят флаг в ложь. Второе~--- ждут до тех пор, пока футура не станет
\emph{реализованной} (анг. realized). В терминах Clojure это значит, что футура
остановилась.

Подготовим модуль воркера. Понадобится конфигурация, база данных, логирование и
HTTP-клиент:

\begin{english}
  \begin{clojure}
(ns book.systems.mount.worker
  (:require
   [mount.core :as mount :refer [defstate]]
   [clojure.java.jdbc :as jdbc]
   [clj-http.client :as client]
   [clojure.tools.logging :as log]
   [book.systems.mount.db :refer [db]]
   [book.systems.mount.config :refer [config]]))
  \end{clojure}
\end{english}

Воркер это словарь с полями \spverb|:flag| и \spverb|:task|, состояние и
футура. Фаза \spverb|:start| готовит этот словарь. Функции \spverb|make-task|
пока что не существует, но считаем, что она вернет футуру. В фазе \spverb|:stop|
флаг становится ложью, и мы ждем, пока футура не остановится.

\begin{english}
  \begin{clojure}
(defstate worker
  :start
  (let [{task-opt :worker} config
        flag (atom true)
        task (make-task flag task-opt)]
    {:flag flag :task task})
  :stop
  (let [{:keys [flag task]} worker]
    (reset! flag false)
    (while (not (realized? task))
      (log/info "Waiting for the task to complete")
      (Thread/sleep 300))))
  \end{clojure}
\end{english}

Код \spverb|:start| и \spverb|:stop| должен быть небольшим. Чтобы упростить его,
технические шаги выносят в функции. Если этого не сделать, логику запуска и
остановки будет трудно понять.

Добавим в файл EDN параметры воркера. Достаточно одного поля~--- сколько
миллисекунд ждать на каждом шаге цикла.

\begin{english}
  \begin{clojure}
{:worker {:sleep 1000}}
  \end{clojure}
\end{english}

Опишем функцию \spverb|make-task|. Она принимает атом с флагом и параметры
EDN. Функция вернет футуру с циклом:

\begin{english}
  \begin{clojure}
(defn make-task
  [flag opt]
  (let [{:keys [sleep]} opt]
    (future
      (while @flag
        (try
          (task-fn)
          (catch Throwable e
            (log/error e))
          (finally
            (Thread/sleep sleep)))))))
  \end{clojure}
\end{english}

\spverb|(Task-fn)| это функция, которая выполнит бизнес-логику приложения. Ее
оборачивают в \spverb|try/catch|, чтобы футура не завершилась аварийно. Если
поймали исключение, его пишут в лог. На конце итерации небольшая задержка, чтобы
не обружить на базу шквал запросов. Если кто-то установит \spverb|flag| в ложь,
управление выйдет из \spverb|while|, и футура завершится.

Теперь опишем \spverb|task-fn|. Функция читает из базы записи, которые ждут
обработки. Для каждой записи ищем геоданные по IP с помощью функции
\spverb|get-ip-info|. Пока что мы не знаем, как работает поиск, но известно, что
он вернет словарь с полями \spverb|:city|, \spverb|:country| и другими.

\begin{english}
  \begin{clojure}
(defn task-fn []
  (jdbc/with-db-transaction [tx db]
    (when-let [request (first (jdbc/query tx query))]
      (let [{:keys [id ip]} request
            info   (get-ip-info ip)
            fields {:is_processed true
                    :zip (:postal_code info)
                    :country (:country_name info)
                    :city (:city info)
                    :lat (:lat info)
                    :lon (:lng info)}]
        (jdbc/update! tx :requests
                      fields
                      ["id = ?" id])))))
  \end{clojure}
\end{english}

Запрос на чтение мы вынесли в переменную \spverb|query|, чтобы сократить код
\spverb|task-fn|. Это SQL с оператором \spverb|FOR UPDATE|, который блокирует
запись на изменение в других соединениях.

\begin{english}
  \begin{clojure}
(def query
  "SELECT * FROM requests
   WHERE NOT is_processed
   LIMIT 1 FOR UPDATE;")
  \end{clojure}
\end{english}

\spverb|FOR UPDATE| работает только в транзакции, поэтому тело функции обернуто
в \spverb|(jdbc/with-db-transaction)|. Это макрос, внутри которого доступно
транзакционное соединение с базой. На него указывает символ \spverb|tx|. В
функции JDBC мы передаем \spverb|tx|, а не \spverb|db|.

Напишем функцию \spverb|get-ip-info|. Она обращается к сервису, который
принимает IP и возвращает сведения о нем в JSON. В нашем случае это сайт
IP~Location; в промышленных системах базы адресов покупают и запускают локально.

\begin{english}
  \begin{clojure}
(defn get-ip-info [ip]
  (:body (client/post "https://iplocation.com"
                      {:form-params {:ip ip}
                       :as :json})))
  \end{clojure}
\end{english}

Если вызвать \spverb|get-ip-info| с адресом Берлина, получим словарь:

\begin{english}
  \begin{clojure}
(get-ip-info "85.214.132.117")

{:postal_code "12529"
 :continent_code "EU"
 :region_name "Land Berlin"
 :city "Berlin"
 :isp "Strato AG"
 :region "BE"
 :country_code "DE"
 :country_name "Germany"
 :time_zone "Europe/Berlin"
 :lat 52.5167
 :company "Strato AG"
 :lng 13.4}
  \end{clojure}
\end{english}

Мы описали последний элемент воркера, и он готов к работе. Добавим в базу
несколько записей, запустим воркер и через некоторое время прочтем их снова.

\begin{english}
  \begin{clojure}
(jdbc/insert! db :requests {:path "/help" :ip "31.148.198.0"})
(mount/start)
;; wait for a while
(jdbc/query db "select * from requests")
({:path "/help" :ip "31.148.198.0" :is_processed true
  :city "Pinsk" :zip "225710" :id 1
  :lon 26.0728 :lat 52.1214 :country "Belarus"})
  \end{clojure}
\end{english}

\subsection{Сбор системы}

Компоненты готовы и работают по отдельности; осталось собрать вместе. Напишем
модуль, который собирает компоненты. Вызов \spverb|(mount/start)| из этого
модуля запустит их все.

Мы упоминали, что функции \spverb|start| и \spverb|stop| работают только с теми
компонентами, которые известны Mount. Если загрузить модуль воркера, Mount
узнает о компонентах \spverb|worker|, \spverb|db| и \spverb|config|, но не
\spverb|server|. Модуль сервера не будет загружен, и система не узнает об этом
компоненте. Проблему решит общий модуль.

\begin{english}
  \begin{clojure}
(ns book.systems.mount.core
  (:require
   [mount.core :as mount]
   book.systems.mount.config
   book.systems.mount.db
   book.systems.mount.server
   book.systems.mount.worker))

(defn start []
  (mount/start))
  \end{clojure}
\end{english}

Читатель заметит, что модули \spverb|config| и \spverb|db| указывать
необязательно. На них ссылаются \spverb|server| и \spverb|worker|, поэтому
компилятор загрузит их автоматически. Мы оставили их наглядности и советуем
делать так же, особенно если вы только начали с Clojure. Модуль \spverb|core|
это реестр компонентов: достаточно одного взгляда, чтобы понять, как устроен
проект. Указывайте все компоненты без исключения.

\subsection{Зависимости}

Главная проблема системы это зависимости компонентов и их обход. Рассмотрим, как
Mount решает эти задачи.

При объявлении компонента мы не указываем его зависимости. \spverb|Worker|
нуждается в \spverb|config| и \spverb|db|, но об этом нигде не сказано. Когда мы
вызываем \spverb|(mount/start)|, система угадывает порядок запуска:
\spverb|config| \arr{} \spverb|db| \arr{} \spverb|worker|. Если переставить
любые два элемента, система не запустится. Как это работает?

Чтобы вычислить порядок, Mount полагается на компилятор Clojure. Пространства
имен зависят друг от друга, как компоненты в системе. Компилятор ищет в теле
\spverb|ns| ссылки на другие модули и загружает их первыми. Вспомним, как
выглядит \spverb|ns| воркера:

\begin{english}
  \begin{clojure}
(ns book.systems.mount.worker
  (:require
   [book.systems.mount.db :refer [db]]
   [book.systems.mount.config :refer [config]]))
  \end{clojure}
\end{english}

Начертим граф зависимостей:

\chart{chart-sys-2}

Компилятор не загрузит \spverb|mount.worker| до тех пор, пока не разрешит
зависимости. Он начнет с модуля \spverb|mount.db|. Его упрощенное определение:

\begin{english}
  \begin{clojure}
(ns book.systems.mount.db
  (:require
   [book.systems.mount.config :refer [config]]))
  \end{clojure}
\end{english}

Что с точки зрения компилятора:

\chart{chart-sys-3}

Прежде чем загрузить \spverb|db|, компилятор займется \spverb|config|. Он не
зависит других модулей и будет загружен первым. Затем компилятор вернется к
\spverb|db| и загрузит его. Дальше он поднимется на уровень
\spverb|worker|. Модуль \spverb|db| загружен, следующий по списку
\spverb|config|. Конфигурация уже загрузили на этапе \spverb|db|. В Clojure
модуль нельзя загрузить дважды, поэтому компилятор пропустит его. На последнем
шаге загрузится \spverb|worker|.

Мы вывели порядок \emph{пространств}: \spverb|config|, \spverb|db|,
\spverb|worker|. Каждая форма \spverb|defstate| выполняется в той же очереди. В
этом и заключается трюк: вызов \spverb|defstate| увеличивает внутренний счетчик
Mount, а компонент запоминает это число. Сущности \spverb|config|, \spverb|db| и
\spverb|worker| получат номера 1, 2 и 3. Чтобы запустить систему, Mount
сортирует компоненты по возрастанию номера, а для остановки~--- по убыванию.

\subsection{Внутреннее устройство}

Mount хранит сведения о компонентах в приватных атомах. Они скрыты для других
модулей, но Clojure позволяет добраться до них. Когда компоненты загружены,
выполните выражение:

\begin{english}
  \begin{clojure}
(def _state @@(resolve 'mount.core/meta-state))
  \end{clojure}
\end{english}

В переменной \spverb|_state| окажется словарь компонентов. Двойной оператор
\spverb|@| играет следующую роль. Функция \spverb|resolve| по символу вернет
объект \spverb|Var|. Мы выяснили, что это контейнер, который хранит
значение \page{var-section}. Первый \spverb|@| извлекает значение из
\spverb|Var|; это атом со словарем. Второй \spverb|@| получает словарь из атома.

Ключ словаря это текстовая ссылка на компонент, например
\spverb|#'book.systems.mount.config/config|. Ей назначен другой словарь с
состоянием компонента. Нас интересует поле \spverb|:order|~--- его
номер. Отсортируем по нему значения словаря и получим верный порядок.

\begin{english}
  \begin{clojure}
(->> _state
     vals
     (sort-by :order)
     (map #(-> % :var meta :name)))
;; (config server db worker)
  \end{clojure}
\end{english}

Код ниже вернет словарь запущенных компонентов с похожей структурой:

\begin{english}
  \begin{clojure}
@@(resolve 'mount.core/running)
  \end{clojure}
\end{english}

Атом \spverb|state-seq| хранит глобальный счетчик компонентов. Чтобы прочитать
его, выполните:

\begin{english}
  \begin{clojure}
@@(resolve 'mount.core/state-seq)
  \end{clojure}
\end{english}

Получится 4, что верно: значения от 0 до 3 заняты нашими компонентами.

При работе с Mount вы не должны менять его внутренности. Примеры выше нужны,
чтобы читатель лучше понял устройство библиотеки.

\subsection{Состояние}

Легкость, с которой компонент изменяется при вызове \spverb|start| и
\spverb|stop|, похожа магию. Раскроем секрет \spverb|defstate|: он работает на
функции \spverb|alter-var-root|, которую мы рассмотрели в главе про
изменяемость \page{alter-var-root}. Вспомним компонент сервера:

\begin{english}
  \begin{clojure}
(defstate server
  :start (let [{jetty-opt :jetty} config]
           (run-jetty app jetty-opt))
  :stop (.stop ^Server server))
  \end{clojure}
\end{english}

Форма \spverb|defstate| состоит из нескольких выражений. Это глобальная
переменная без значения:

\begin{english}
  \begin{clojure}
(def server)
  \end{clojure}
\end{english}

\noindent
и две анонимные функции запуска и остановки. Тела функций это код из ключей
\spverb|:start| и \spverb|:stop|.

\begin{english}
  \begin{clojure}
(fn [] ;; start
  (alter-var-root #'server
   (fn [_]
     (let [{jetty-opt :jetty} config]
       (run-jetty app jetty-opt)))))

(fn [] ;; stop
  (alter-var-root #'server
   (fn [_]
     (.stop ^Server server))))
  \end{clojure}
\end{english}

Mount помещает ссылки на эти функции в атом \spverb|meta-state|. Чтобы включить
компонент, нужно найти в словаре функцию включения и вызвать ее. Функция
назначит переменной \spverb|#'server| новое значение. Остановка работает
аналогично.

\subsection{Выборочный запуск}

До сих пор мы запускали систему целиком. Вызов \spverb|(mount/start)| без
параметров пробегает по \spverb|meta-state| и включает все компоненты. Это не
всегда удобно. Предположим, мы работаем над воркером и хотели бы запустить
только его и зависимости. В этом случае веб-сервер не нужен.

Чтобы запустить только нужные компоненты, их передают в функцию. Важно:
компонент должен быть не значением, а объектом \spverb|Var|.

\begin{english}
  \begin{clojure}
(mount/start
  #'book.systems.mount.config/config
  #'book.systems.mount.db/db
  #'book.systems.mount.worker/worker)
  \end{clojure}
\end{english}

Если передать не ссылку, а значение (без \spverb|#'|), Mount не запустит
компонент. Связь между переменной и значением работает в одну сторону: по
второму нельзя найти первое. В примере ниже не будет ошибки, просто ничего не
произойдет:

\begin{english}
  \begin{clojure}
;; does nothing
(mount/start
  book.systems.mount.config/config
  book.systems.mount.db/db
  book.systems.mount.worker/worker)
  \end{clojure}
\end{english}

Тот факт, что функция ожидает именно \spverb|Var|, а не значение, сбивает с
толку новичков. Это не очевидно, поскольку в Clojure мы редко прибегаем к
переменным.

Минус ручного запуска в том, что он не решает зависимости. Mount знает только
порядок компонентов, но не как они связаны. Предположим, мы забыли, что базе и
воркеру нужна конфигурация:

\begin{english}
  \begin{clojure}
(mount/start
  #'book.systems.mount.db/db
  #'book.systems.mount.worker/worker)
  \end{clojure}
\end{english}

Получим странное исключение. Оно возникнет в компоненте \spverb|db|, где
создается пул. Объект \spverb|config| не запущен, и выражение
\spverb|(:pool config)| вернет \spverb|nil|. При попытке создать
пул из \spverb|nil| получим ошибку типов.

С ростом системы все сложнее отслеживать зависимости. Это слабое место Mount~---
чтобы запустить подсистему, компоненты указывают вручную. Чтобы облегчить этот
сценарий, библиотека предлагает \emph{селекторы} компонентов: \spverb|only|,
\spverb|except| и другие.

\spverb|Except| вернет имена компонентов \emph{кроме} перечисленных. Если
передать результат в \spverb|start|, получим систему без указанных
компонентов. Ниже запускается подмножество без веб-сервера:

\begin{english}
  \begin{clojure}
(-> [#'book.systems.mount.server/server]
    mount/except
    mount/start)
  \end{clojure}
\end{english}

Другие селекторы и их комбинации смотрите на странице проекта в GitHub.

\subsection{Проблема перезагрузки}

В режиме разработки редактор подключен к REPL. Когда мы меняем код, редактор
отправляет изменения серверу. Вопрос: что случится, если внести правки в уже
запущенный компонент? Как Mount отреагирует на перезагрузку модуля?

Если вы работаете в Emacs и Cider, подключитесь к проекту через \spverb|M-x
cider-connect|. Запустите систему, как мы делали это выше. Откройте модуль
сервера и выполните \spverb|M-x cider-eval-buffer| (или клавишами \spverb|C-c
C-k|). Команда исполнит файл на сервере. Все определения, включая \spverb|ns|,
\spverb|def| и \spverb|defstate| сработают повторно.

Вы увидете сообщения, что сервер перезагружен. Mount учитывает этот сценарий:
макрос \spverb|defstate| проверяет, что компонент уже запущен и перезагружает
его.

Перезагрузка это не всегда желаемое поведение. При частых изменениях случается
<<рассинхрон>>~--- ситуация, когда компонент считается выключенным, но его
ресурс занят. Например, в блоке \spverb|:stop| мы не вызвали метод
\spverb|(.stop)|. Если перезагрузить такой компонент, получим ошибку, что порт
занят.

Реакцию компонента на перезагрузку задают в метаданных. Это поле
\spverb|:on-reload|, которое по умолчанию равно \spverb|:restart|. С ним
компонент перезапускает себя при повторном вызове \spverb|defstate|. Если задать
\spverb|:stop|, компонент остановится. Ключ \spverb|:noop| означает не делать
ничего. Компонент с метаданными выглядит так:

\begin{english}
  \begin{clojure}
(defstate ^{:on-reload :noop} server
  :start (run-jetty app {:join? false :port 8080})
  :stop (.stop server))
  \end{clojure}
\end{english}

Указывайте компонентам \spverb|:noop|: он освобождает перезагрузку кода от
побочных эффектов. Изменения в модуле не обязательно относятся к компоненту, и
запускать его повторно нет смысла. даже если вы исправили компонент,
перезагрузите его вручную.

\subsection{Самостоятельная работа}

Вернемся к функции \spverb|get-ip-info| из модуля воркера. Для каждого адреса
она выполняет HTTP-запрос. На низком уровне мы открываем TCP-соединение,
работаем с ним и закрываем. Это не оптимально, и проблему решают так же, как с
базами данных~--- пулом соединений. Изучите пример из библиотеки
Clj-http:\footurl{https://github.com/dakrone/clj-http}

\begin{english}
  \begin{clojure}
;; create a new pool
(def cm (clj-http.conn-mgr/make-reusable-conn-manager
         {:timeout 2 :threads 3}))

;; make a request within the pool
(client/get "http://example.org/"
            {:connection-manager cm})

;; shut down the pool
(clj-http.conn-mgr/shutdown-manager cm)
  \end{clojure}
\end{english}

Напишите компонент, который шлет запросы через пул. Параметры компонента
(тайминг, число потоков) приходят из конфигурации. На старте компонент запускает
пул, при остановке закрывает его. Перепишите воркер так, чтобы он зависел от
нового компонента.

\section{Component}

Библиотека Component\footurl{https://github.com/stuartsierra/component} тоже
описывает компоненты и систему. Это небольшой фремворк, в котором главную роль
играет не объем кода, а идея. Дизайн Component в корне отличаются от Mount,
который мы рассмотрели выше.

Как и в Mount, на компонент действуют операции \spverb|start| и
\spverb|stop|. Они возвращают \emph{копию} объекта в новом состоянии; исходный
компонент остается прежним. Можно сказать, компоненты неизменяемы. Это отсекает
целый пласт ошибок, связанных с состоянием.

Система это словарь компонентов с зависимостями. Сначала система в состоянии
покоя: компоненты еще не запущены. Специальный код обходит и включает
их. Получается рабочая копия системы. Она похожа на исходную, но каждый
компонент заменен на включенную версию себя. Остановка работает так же: на
выходе получится выключенная копия системы.

Component не терпят глобального состояния: сущности это обычные объекты. В
библиотеке нет скрытых атомов, которые хранят информацию о компонентах. Один
компонент имеет доступ к другому только если они зависимы. Компонент не хранит
состояние в атоме или другой изменяемой сущности. На каждое действие он
возвращает новую копию себя.

\subsection{Устройство}

Компонент это объект, который реализует протокол \spverb|Lifecycle|. Протокол
задает операции \spverb|start| и \spverb|stop|. На роль компонента подходит
типизированный словарь~--- сущность, которую объявляют формой
\spverb|defrecord|. По-другому их называют <<типизированные записи>> или
<<р\'{е}корды>>.

Запись отличается от словаря тем, что заранее перечисляет ключи. Они называют
\emph{слотами} записи. Доступ к слотам работает быстрее, чем в обычном
словаре. Компонент использует слоты для входных параметров и состояния.

Запиь и протокол сочетаются на уровне языка. При объявлении записи можно сразу
расширить ее протоколом. В методах протокола слоты доступны как локальные
переменные. Это уменьшает код и экономит внимание.

Компонент таит в себе состояние, и только он знает, как им управлять. Будет
ошибкой читать из него слоты и передавать их функции. Потребителям компонент
предлагает методы, которые заданы в протоколе. Код на Component напоминает ООП:
это объекты и набор операций над ними. Как и класс, компонент инициируют,
запускают и останавливают.

Разница в том, что компоненты неизменяемы. Переход в новое состояние не меняет
слоты объекта, в то время как в промышленных языках их переписывают. Принцип
\spverb|SOLID| и классическая тройка <<инкапсуляция, наследование, полиморфизм>>
не имеют той же силы в Clojure. Б\'{о}льшая часть этих правил отпадает за
ненадобностью. Программируя на Clojure, мы не волнуемся о том, что нарушили
постулаты ООП.

\subsection{Первый компонент}

Перепишем систему из прошлого раздела на Component. Начнем с веб-сервера. В
файле \spverb|server.clj| объявим пространство имен:

\begin{english}
  \begin{clojure}
(ns book.systems.comp.server
  (:require
   [com.stuartsierra.component :as component]
   [ring.adapter.jetty :refer [run-jetty]]))
  \end{clojure}
\end{english}

Компонент это запись с двумя слотами: \spverb|options| и \spverb|server|. В
опциях записаны параметры Jetty-сервера, в \spverb|server|~--- его
экземпляр. Строка \spverb|component/Lifecycle| означает протокол, который
реализует запись. Ниже следует \emph{реализация} протокола.

\begin{english}
  \begin{clojure}
(defrecord Server [options server]

  component/Lifecycle

  (start [this]
    (let [server (run-jetty app options)]
      (assoc this :server server)))

  (stop [this]
    (.stop server)
    (assoc this :server nil)))
  \end{clojure}
\end{english}

Метод \spverb|start| вернет ту же запись, но с заполненным слотом
\spverb|:server|. В нем находится объект сервера. Метод \spverb|stop| принимает
запущенный компонент. Он выключает сервер и возвращает еще одну запись, где слот
\spverb|:server| равен \spverb|nil|.

Внутри методов мы обращаемся к слотам как к локальным переменным. Это работает
только если методы расположены внутри \spverb|defrecord|. Если запись расширяют
отдельным шагом, например через \spverb|extend|, доступ к слотам
теряется. Придется извлечь их из переменной \spverb|this|.

Сущность \spverb|Server| это не компонент, а только абстрактное описание. На
первом шаге его \emph{инициируют}, то есть создают экземпляр. Для этого служит
функция \spverb|map-><Record>|, где \spverb|<Record>| это имя записи. Макрос
\spverb|defrecord| автоматически порождает эту функцию. В нашем случае она
называется \spverb|map->Server|. Функция принимает обычный словарь и возвращает
его типизированную версию. Ключи словаря совпадают со слотами записи. Если ключ
не найден, слот равен \spverb|nil|.

\begin{english}
  \begin{clojure}
(def s-created
  (map->Server
   {:options {:port 8080 :join? false}}))
  \end{clojure}
\end{english}

Переменная \spverb|s-created| это экземпляр записи \spverb|Server|. Мы указали
слот \spverb|options|, но не \spverb|server|, потому что он будет заполнен
позже.

\begin{english}
  \begin{clojure}
(def s-started (component/start s-created))
  \end{clojure}
\end{english}

Это выражение вернет \emph{запущенный} компонент. Откройте браузер по адресу
\spverb|http://127.0.0.1:8080| и проверьте, что сервер работает. У записи
\spverb|s-started| заполнен слот \spverb|:server|:

\begin{english}
  \begin{clojure}
(-> s-started :server type)
;; org.eclipse.jetty.server.Server
  \end{clojure}
\end{english}

Остановите компонент. Проверьте, что страница больше не открывается, а слот
сервера равен \spverb|nil|.

\begin{english}
  \begin{clojure}
(def s-stopped (component/stop s-started))
(:server s-stopped) ;; nil
  \end{clojure}
\end{english}

Мы прошли полный цикл компонента: подготовку, запуск и остановку. Переход на
каждую стадию вернет новый компонент. На практике компонентами не управляют
вручную~--- это делает система.

\subsection{Конструктор}

Вспомним, как мы создали экземпляр \spverb|Server|:

\begin{english}
  \begin{clojure}
(map->Server {:options {:port 8080 :join? false}})
  \end{clojure}
\end{english}

У этой записи недостаток: нужно помнить, какие слоты нужны для инициализации, а
какие для внутреннего состояния. Для простых записей это не критично, но на
практике бывают компоненты с десятью и более слотами. Чтобы не запутаться,
объявляют функцию-\emph{конструктор}.

Конструктор принимает только те аргументы, которые нужны для инициализации
компонента. В нашем случае это \spverb|options|, поэтому функция выглядит так:

\begin{english}
  \begin{clojure}
(defn make-server
  [options]
  (map->Server {:options options}))

(def s-created (make-server {:port 8080 :join? false}))
  \end{clojure}
\end{english}

Конструктор упрощает создание компонента: с ним невозможно передать в
\spverb|map->Server| что-то лишнее. Конструктор это функция, поэтому к нему
можно добавить докуменатцию и спеку. Продвинутый редактор подскажет сигнатуру в
месте вызова. Пишите конструктор даже для тривиальных компонентов.

\subsection{Особенность слотов}

При остановке сервера мы совершаем два действия: вызываем у него метод
\spverb|(.stop)| и заменяем слот на \spverb|nil|. Почему бы не заменить
\spverb|assoc| на \spverb|dissoc|? Зачем хранить \spverb|nil|, когда можно
отсоединить поле?

\begin{english}
  \begin{clojure}
(assoc this :server nil)
;; why not this?
(dissoc this :server)
  \end{clojure}
\end{english}

Причина в том, как устроены записи и слоты. Запись сохраняет уникальные свойства
до тех пор, пока ее слоты на месте. Если забрать у записи слот через
\spverb|dissoc|, получим обычный словарь. Покажем это на примере:

\begin{english}
  \begin{clojure}
(-> s-stopped (assoc :server nil) type)
;; book.systems.comp.server.Server

(-> s-stopped (dissoc :server) type)
;; clojure.lang.PersistentArrayMap
  \end{clojure}
\end{english}

Если компонент вызывает \spverb|dissoc| на себе, на новой стадии получим не
компонент, а словарь. Это ведет к странному поведению: при попытке выключить
компонент он продолжит работу. Почему так происходит?

Когда запись расширяют протоколом, тем самым строят связь между ее типом и
логикой. Для \spverb|Server| методы \spverb|start| и \spverb|stop| выполнят
одно, для \spverb|DB| или \spverb|Worker|~--- другое. Component устроен так, что
по умолчанию методы \spverb|start| и \spverb|stop| просто вернут объект. Поэтому
вызов \spverb|(stop {...})| на обычном словаре ничего не даст.

Приведем неудачный пример. Метод \spverb|start| возвращает словарь с полем
\spverb|server|:

\begin{english}
  \begin{clojure}
(defrecord BadServer [options server]
  component/Lifecycle
  (start [this]
    {:server (run-jetty app options)})
  (stop [this]
    (.stop server)
    nil))
  \end{clojure}
\end{english}

Сервер запустится без ошибок. Но после запуска это будет уже не запись, а
словарь. Метод \spverb|stop| словаря вернет его же без каких либо
действий. Можно сколько угодно вызывать \spverb|component/stop|, но сервер не
остановится.

\begin{english}
  \begin{clojure}
(def bs-created (map->BadServer {:options {:port 8080 :join? false}}))
(def bs-started (component/start bs-created))
(type bs-started)
;; clojure.lang.PersistentArrayMap
(component/stop bs-started)
;; does nothing, the server still works
  \end{clojure}
\end{english}

Похожие трудности возникнут, если исправить \spverb|start| без учета
\spverb|stop|. При остановке компонент выключит сервер, но вернет
\spverb|nil|. При повторном запуске получим ошибку, что \spverb|nil| не
реализует протокол \spverb|Lifecycle|.

Следите за тем, чтобы компонент менял только значения слотов, но не их
состав. Код \spverb|start| и \spverb|stop| завершается формой \spverb|assoc|, но
не \spverb|dissoc|.

\subsection{Компонент базы}

Напишем компонент для работы с базой. Концепция пула соединений уже известна из
прошлых разделов. Компонент содержит два слота: \spverb|options| и
\spverb|db-spec|. Первый это словарь опций будущего пула. Слот \spverb|db-spec|
хранит JDBC-спеку с открытым пулом.

\begin{english}
  \begin{clojure}
(defrecord DB
    [options db-spec]

  component/Lifecycle

  (start [this]
    (let [pool (cp/make-datasource options)]
      (assoc this :db-spec {:datasource pool})))

  (stop [this]
    (-> db-spec :datasource cp/close-datasource)
    (assoc this :db-spec nil)))
  \end{clojure}
\end{english}

Добавим конструктор:

\begin{english}
  \begin{clojure}
(defn make-db [options]
  (map->DB {:options options}))
  \end{clojure}
\end{english}

Компонент готов к запуску, и его можно прогнать через функции
\spverb|make-db|~\arr{} \spverb|component/start|~\arr{} \spverb|component/stop|.

Пока что неясно, как выполнить запрос через компонент. Нас интересует слот
\spverb|db-spec|, который хранит спеку. Можно вычленить его и передать в
функцию:

\begin{english}
  \begin{clojure}
(let [{:keys [db-spec]} db-started
      users (jdbc/query db-spec "select * from users")]
  (process-users users))
  \end{clojure}
\end{english}

Это варварский подход: нельзя вторгаться в компонент, даже если язык предлагает
такую возможность. Мы нарушаем идею, согласно которой компонент неделим для
потребителя. В этом плане компонент похож объект в современных языках.

Дополним запись \spverb|DB| методами для работы с базой. Поместим их в отдельный
протокол. Сигнатуры похожи на функции JDBC с той разницей, что первый параметр
это не спека, а \spverb|this|, компонент:

\begin{english}
  \begin{clojure}
(defprotocol IDB
  (query [this sql-params])
  (update! [this table set-map where-clause]))
  \end{clojure}
\end{english}

В теле \spverb|defrecord|, сразу после \spverb|stop|, реализуем новый
протокол. Методы сводятся к функциям JDBC, в которые передаем слот
\spverb|db-spec| и аргументы.

\begin{english}
  \begin{clojure}
(defrecord BadServer [options server]
  ;; component/Lifecycle implementation

  IDB
  (query [this sql-params]
    (jdbc/query db-spec sql-params))

  (update! [this table set-map where-clause]
    (jdbc/update! db-spec table set-map where-clause)))
  \end{clojure}
\end{english}

Компонент готов к запросам. Теперь мы вызываем не JDBC-функции, а методы
протокола. Тем самым мы изолируем зависимость от JDBC.

\begin{english}
  \begin{clojure}
(def db-created (make-db options))
(def db-started (component/start db-created))
(query db-started "select * from requests")
(update! db-started :requests {:is_processed false} ["id = ?" 42])
(def db-stopped (component/stop db-started))
  \end{clojure}
\end{english}

\subsection{Транзакционный компонент}

Для согласованных изменений в базе нужны транзакции. Раньше мы пользовались
макросом \spverb|jdbc/with-db-transaction|. Из обычного соединения он получает
транзакционное и связывет его с символом.

В отличии от JDBC, наш макрос работает с компонентом. Он принимает обычный
компонент и связывает с символом его \emph{транзакционную} версию. Макрос
сводится к следующим шагам:

\begin{itemize}

\item
  получить спеку из компонента;

\item
  обернуть тело в макрос JDBC, получить транзакционное соединение;

\item
  получить компонент, в котором слот \spverb|:db-spec| заменен на
  транзакционное соединение;

\item
  связать этот компонент с символом из макроса.

\end{itemize}

\begin{english}
  \begin{clojure}
(defmacro with-db-transaction
  [[comp-tx comp-db & trx-opt] & body]
  `(let [{db-spec# :db-spec} ~comp-db]
     (jdbc/with-db-transaction
       [t-conn# db-spec# ~@trx-opt]
       (let [~comp-tx (assoc ~comp-db :db-spec t-conn#)]
         ~@body))))
  \end{clojure}
\end{english}

Читатель заметит, что нарушен принцип закрытости компонента. Мы вручную читаем и
заменяем его слот \spverb|db-spec|. В единичных случаях на это закрывают глаза,
но все же подумайте, как улучшить код. Подсказка: доступ к слоту можно вынести в
методы \spverb|get-| и \spverb|set-spec|, то есть обычные <<геттер>> и
<<сеттер>> из мира ООП. Разница в том, что <<сеттер>> вернет новый компонент.

Макрос в действии:

\begin{english}
  \begin{clojure}
(with-db-transaction
  [db-tx db-started]
  (let [query "select * from requests limit 1 for update"
        [request] (query db-tx query)
        {:keys [id]} request]
    (when request
      (update! db-tx :requests
               {:is_processed false}
               ["id = ?" id]))))
  \end{clojure}
\end{english}

В логах PostgreSQL увидим записи:

\begin{english}
  \begin{sql}
BEGIN
select * from requests limit 1 for update
UPDATE requests SET is_processed = $1 WHERE id = $2
DETAIL:  parameters: $1 = 'f', $2 = '3'
COMMIT
  \end{sql}
\end{english}

Запросы \spverb|SELECT| и \spverb|UPDATE| действительно сработали в транзакции.

\subsection{Воркер}

Напишем компонент воркера. Объявим модуль и подключим зависимости:

\begin{english}
  \begin{clojure}
(ns book.systems.comp.worker
  (:require
   [com.stuartsierra.component :as component]
   [book.systems.comp.db :as db]
   [clj-http.client :as client]
   [clojure.tools.logging :as log]))
  \end{clojure}
\end{english}

Воркер это запись с протоколами \spverb|Lifecycle| и \spverb|IWorker|. Протокол
\spverb|Lifecycle| уже знаком читателю: это функции \spverb|start| и
\spverb|stop|. В \spverb|IWorker| поместим логику компонента: это бесконечный
цикл и его подготовка. Ожидаем, что \spverb|task-fn| это функция, которую воркер
вызывает на каждом шаге цикла. Метод \spverb|make-task| оборачивает ее в цикл и
\spverb|try/catch|.

\begin{english}
  \begin{clojure}
(defprotocol IWorker
  (make-task [this])
  (task-fn [this]))
  \end{clojure}
\end{english}

Запись хранит четыре слота: входные опции, флаг продолжения, футура с циклом и
база данных. Последний слот~--- зависимый компонент, экземпляр \spverb|DB|,
который мы только что написали. Реализуем \spverb|Lifecycle|:

\begin{english}
  \begin{clojure}
(defrecord Worker
  [options flag task db]
  component/Lifecycle
  (start [this]
    (let [flag (atom true)
          this (assoc this :flag flag) ;; <= note this
          task (make-task this)]
      (assoc this :task task)))

  (stop [this]
    (reset! flag false)
    (while (not (realized? task))
      (log/info "Waiting for the task to complete")
      (Thread/sleep 300))
    (assoc this :flag nil :task nil)))
  \end{clojure}
\end{english}

Обратите внимание на строку с меткой: мы дополняем \spverb|this| флагом
состояния. Метод \spverb|make-task| ожидает \spverb|this| с заполненным слотом
\spverb|flag|. Если строку убрать, \spverb|make-task| получит запись с пустым
слотом.

Опишем протокол \spverb|IWorker|. Код \spverb|make-task| и \spverb|task-fn| уже
знаком читателю из раздела про Mount. Разница в том, что теперь мы работаем не с
функциями, а методами. Метод имеет прямой доступ к слотам, поэтому нет смысла
передавать параметры. Ниже мы перенесли код \spverb|make-task| и
\spverb|task-fn| в компонент. Для краткости опустим перехват ошибок и некоторые
детали.

\begin{english}
  \begin{clojure}
(defrecord Worker
  ;; component/Lifecycle skipped
  IWorker

  (make-task [this]
    (future
      (while @flag ;; try/catch
        (task-fn this)))) ;; sleep

  (task-fn [this]
    (db/with-db-transaction [tx db]
      (when-let [[request] (db/query tx query)]
        (let [fields (...))] ;; get fields
          (db/update! tx :requests
                      fields ["id = ?" id]))))))
  \end{clojure}
\end{english}

Добавим конструктор, и компонент готов:

\begin{english}
  \begin{clojure}
(defn make-worker
  [options]
  (map->Worker {:options options}))
  \end{clojure}
\end{english}

\subsection{Ручные зависимости}

Воркер отличается тем, что имеет зависимости. Пока что не ясно, как воркер
узнает о базе данных, потому что конструктор принимает только опции. Эту
проблему решает система, а не программист. Мы не должны передавать компоненты
друг другу при их создании.

На время разработки \emph{нарушим} это правило. Соберем мини-систему из двух
компонентов. Так мы проверим код, который написали и поймем, как работает
система. Проведем эксперимент в модуле \spverb|core|. Добавьте в него
конструкторы и Component:

\begin{english}
  \begin{clojure}
(ns book.systems.comp.core
  (:require
   [com.stuartsierra.component :as component]
   [book.systems.comp.worker :refer [make-worker]]
   [book.systems.comp.db :refer [make-db]]))
  \end{clojure}
\end{english}

Наивная система ниже. Это функция, которая принимает конфигурацию. Мы вручную
запускаем базу и воркер и возвращаем словарь компонентов. В строке с отметкой мы
задаем воркеру слот с базо. Важен момент, когда это происходит: компонент базы
\emph{уже включен}, а воркер еще нет (\spverb|assoc| перед \spverb|start|).

\begin{english}
  \begin{clojure}
(defn my-system-start
  [config]
  (let [{db-opt :pool
         worker-opt :worker} config
        db (-> db-opt
               make-db
               component/start)
        worker (-> worker-opt
                   make-worker
                   (assoc :db db) ;; <= note this
                   component/start)]
    {:db db :worker worker}))
  \end{clojure}
\end{english}

Чтобы запустить систему, передайте в функцию параметры пула и воркера. Сохраните
систему в переменной, чтобы выключить ее позже.

\begin{english}
  \begin{clojure}
(def _sys (my-system-start {:pool {...} :worker {...}}))
  \end{clojure}
\end{english}

Проверьте систему: добавьте записи в таблицу \spverb|requests| и убедитесь, что
воркер дополняет их. Функция выключения остановит компоненты в верном порядке.

\begin{english}
  \begin{clojure}
(defn my-system-stop
  [system]
  (-> system
      (update :worker component/stop)
      (update :db component/stop)))

(my-system-stop _sys)
  \end{clojure}
\end{english}

\subsection{Промышленная система}

Рассмотрим, как строят систему на практике. Функция \spverb|system-map|
принимает цепочку значений. Нечетные элементы это имена компонентов, а
четные~--- вызовы их конструкторов. Функция вернет систему в состоянии покоя.

Построение системы не должно нести побочных эффектов. Вызов \spverb|system-map|
строит дерево компонентов с заполненными слотами. Конструкторы только порождают
записи. Если конструктор обращается к диску или меняет состояние, это грубая
ошибка.

Система зависит от конфигурации, поэтому ее оборачивают в функцию
\spverb|make-system|. Она принимает словарь конфигурации и делит его на
части. Каждый конструктор вызывают со своей частью. Удобно, когда конфигурация
повторяет систему: на верхнем уровне ключи компонентов, а под ними словари
опций.

Чтобы сообщить компоненту зависимости, его оборачивают в функцию
\spverb|component/using|. Второй аргумент это ключи компонентов, которые он
должен получить до старта. Ключи могут быть вектором или словарем. Если слот
совпадает с именем компонента, это вектор. Если отличается, передают словарь
вида \spverb|{:slot :component}|.

Ниже функция \spverb|make-system| строит систему, о которой мы договорились в
начале главы. Компонент \spverb|worker| обернут в
\spverb|component/using|. Поскольку слот \spverb|:db| совпадает с именем
компонента в системе, мы передали вектор \spverb|[:db]|.

\begin{english}
  \begin{clojure}
(defn make-system
  [config]
  (let [{:keys [jetty pool worker]} config]
    (component/system-map
     :server (make-server jetty)
     :db     (make-db pool)
     :worker (component/using
              (make-worker worker) [:db]))))
  \end{clojure}
\end{english}

Если компонент назывался \spverb|:storage|, мы бы задали словарь:

\begin{english}
  \begin{clojure}
(component/system-map
 :server  (make-server jetty)
 :storage (make-db pool)
 :worker  (component/using
           (make-worker worker) {:db :storage}))
  \end{clojure}
\end{english}

Словарь полезен, когда подключают сторонние компоненты. Их создатели не знают,
как называются сущности в вашем проекте. Например, чужой компонент зависит от
\spverb|:database|, а у нас это просто \spverb|:db|. Словарь снимает проблему
расхождения имен.

Чтобы запустить систему, ее передают в \spverb|component/start|. У системы
особая реализация \spverb|Lifecycle|. При запуске она строит граф зависимостей и
выводит порядок обхода. Перед тем как запустить компонент с зависимостями,
система сообщает их компоненту через \spverb|assoc|, как мы делали это
вручную. Аналогично работает выключение системы.

\begin{english}
  \begin{clojure}
(def config {...})
(def sys-init (make-system config))
(def sys-started (component/start sys-init))
(def sys-stopped (component/stop sys-started))
  \end{clojure}
\end{english}

\subsection{Хранение системы}

Выше мы задали систему через \spverb|def|, что не совсем правильно. Система это
сущность, которую включают по требованию. С ней обращаются как с глобальной
переменной, которая меняет значение. Для этого подходит \spverb|alter-var-root|.

В модуле объявляют переменную будущей системы. Для этого служит макрос
\spverb|defonce|, чтобы случайно не затереть ее при перезагрузке модуля. Как и
компонент, система пребывает в одном из трех состояниях: покой, запуск и
остановка. Функции \spverb|system-init|, \spverb|system-start| и
\spverb|system-stop| переводят систему в нужное состояние. Они работают с
помощью служебной функции \spverb|alter-system|, которую задали с помощью
частичного вызова.

\begin{english}
  \begin{clojure}
(defonce system nil)

(def alter-system (partial alter-var-root #'system))

(defn system-init [config]
  (alter-system (constantly (make-system config))))

(defn system-start []
  (alter-system component/start))

(defn system-stop []
  (alter-system component/stop))
  \end{clojure}
\end{english}

Код выше дает рычаги, чтобы управлять приложением. Функция \spverb|-main|
сводится к трем шагам: чтению конфигурации, подготовке системы и запуску.

\begin{english}
  \begin{clojure}
(defn -main [& args]
  (let [config (load-config "config.edn")]
    (system-init config)
    (system-start)))
  \end{clojure}
\end{english}

Хотя система и глобальна, к ней нельзя обращаться напрямую. Если один компонент
извлекает другой из недр системы, это провал разработчика. Такой подход сводит
на нет идею системы и компонентов. Обращаться к системе можно только при
разработке или в тестах. Для б\'{о}льшей надежности систему делают приватной:
так мы обезопасим ее от обращения извне.

\begin{english}
  \begin{clojure}
(defonce ^:private system nil)
  \end{clojure}
\end{english}

До приватной системы можно добраться с помощью \spverb|resolve| по ее полному
символу.

\subsection{Корректное завершение}

Глобальная система идет вразрез с тем, что пишет автор библиотеки. На странице
проекта встречается фраза: <<In production, the system map is ephemeral. It is
used to start all the components running, then it is discarded. (В промышленном
запуске система эфемерна. Она запускает все компоненты и затем исчезает.)>>

Это редкий случай, когда мы не согласимся с автором. Даже в боевом запуске вам
нужна ссылка на систему. Без ссылки нельзя корректно остановить приложение
(анг. <<graceful shutdown>>). Под корректностью имеют в виду , что все ресурсы
закрыты.

Некоторые компоненты сложны: это очереди задач, каналы данных, транзакции. Если
аварийно завершить очередь, мы потеряем сообщение или обработаем его
дважды. Закрывайте ресурсы правильно, даже если приходится ждать.

В боевом режиме приложение перехватывает сигналы POSIX и реагирует на них
должным образом. Если поступил SIGTERM, приложение останавливает систему,
дожидается остановки и только потом завершается.

Библиотека Signal\footurl{https://github.com/pyr/signal} предлагает макрос,
чтобы связать сигнал с реакцией на него. Подключите библиотеку в проект:

\begin{english}
  \begin{clojure}
;; project.clj
[spootnik/signal "0.2.2"]

;; src/book/systems/comp/core.clj
(ns ...
  (:require [signal.handler :refer [with-handler]]))
  \end{clojure}
\end{english}

Расширьте функцию \spverb|-main|. После запуска системы добавьте реакцию на
сигналы SIGTERM и SIGHUP. Первый останавливает систему и завершают
программу. Сигнал SIGHUP мы расцениваем как перезагрузку системы.

\begin{english}
  \begin{clojure}
(with-handler :term
  (log/info "caught SIGTERM, quitting")
  (system-stop)
  (log/info "all components shut down")
  (System/exit)

(with-handler :hup
  (log/info "caught SIGHUP, reloading")
  (system-stop)
  (system-start)
  (log/info "system reloaded"))
  \end{clojure}
\end{english}

Сигналы не работают, когда проект запущен через \spverb|lein run| или в
REPL. Чтобы проверить сигналы, соберите \spverb|uberjar| и запустите его как
Java-приложение.

\begin{english}
  \begin{bash}
lein uberjar
java -jar target/book-standalone.jar
  \end{bash}
\end{english}

Нажмите \spverb|Ctrl-C|. Приложение завершится не сразу, и вы увидите логи о
том, что система остановлена.

Программы по управлению процессами обычно ждут 30 секунд, пока процесс не
завершится. В противном случае его завершают принудительно. Ожидание системы
должно быть разумным. Если оно близко к минуте, код нужно оптимизировать.

\subsection{Подробнее об ожидании}

Вернемся к функции \spverb|-main| приложения. Это входная точка программы на
Clojure:

\begin{english}
  \begin{clojure}
(defn -main [& args]
  (let [config (load-config "config.edn")]
    (system-init config)
    (system-start)))
  \end{clojure}
\end{english}

У читателя, не знакомого с тонкостями JVM, возникнет вопрос. Почему программа не
завершается после \spverb|(system-start)|? После нее нет цикла, хука или
события, но платформа продолжит работать.

Это стандартное поведение JVM. Если программа завершается не аварийно, главный
поток ожидает, пока не остановятся дочерние. Запуск системы порождает новые
потоки (сервер, пул соединений). После \spverb|(system-start)| основной поток
повиснет в ожидании их завершения. Он будет ждать до тех пор, пока систему не
выключат в другом потоке или не придет сигнал, на который задали реакцию.

Если у компонента нет состояния, не будет и новых потоков. Компонент \spverb|DB|
можно изменить так, что слот \spverb|db-spec| это не пул соединений, а словарь
подключения. Бывают компоненты, которые выполняют разовую задачу на старте. Если
ни один компонент не порождает поток, программа выполнит \spverb|start| для
каждого из них и завершится.

\subsection{Улучшаем зависимости}

Мы сообщили компоненту \spverb|:worker| его зависимости:

\begin{english}
  \begin{clojure}
(component/system-map
 ;; ...
 :worker (component/using
          (make-worker worker) [:db]))
  \end{clojure}
\end{english}

Когда компонентов много, зависимости вносят шум, и код трудно читать. Поможет
трюк: вынесем зависимости в конструктор. Выше \spverb|(make-worker {...})|
вернет компонент, который не знает о зависимостях. Его оборачивает
\spverb|using|, которая сообщает их. Если сдвинуть \spverb|using| в конструктор,
он уйдет из системы. Перепишем конструктор воркера:

\begin{english}
  \begin{clojure}
(defn make-worker [config]
  (-> config
      map->Worker
      (component/using [:db])))
  \end{clojure}
\end{english}

Система стала чище:

\begin{english}
  \begin{clojure}
(component/system-map
 :server (make-server jetty)
 :db     (make-db pool)
 :worker (make-worker worker))
  \end{clojure}
\end{english}

Подход требует, чтобы имена компонентов совпадали со слотами. Если это ваши
компоненты, договоритесь с командой об именах. Для сторонних компонентов легко
написать свой конструктор.

Рассмотрим, как устроены зависимости. Очевидно, вызов \spverb|component/using|
что-то сообщает компоненту, но последний от этого не меняется. В нем не
появляется поля \spverb|:deps| или чего-то другого. Компонент хранит зависимости
в \emph{метаданных}.

Метаданные это словарь дополнительной информации об объекте. Метаданные работают
с коллекциями и некоторым другим типам Clojure, например, символом или
переменной. К метаданным прибегают, когда нужно дополнить объект, не изменяя
его. Зависимости компонента подходят на эту роль.

Функция \spverb|meta| вернет метаданные объекта. Пример ниже доказывает, что
конструктор добавил зависимости:

\begin{english}
  \begin{clojure}
(-> {...} make-worker meta)
#:com.stuartsierra.component{:dependencies {:db :db}}
  \end{clojure}
\end{english}

Другой способ увидеть их~--- задать переменной \spverb|*print-meta*| истину. При
печати объекта в REPL появятся его метаданные:

\begin{english}
  \begin{clojure}
(set! *print-meta* true)
(make-worker {...})
^#:com.stuartsierra.component{:dependencies {:db :db}}
#book.systems.comp.worker.Worker{...}
  \end{clojure}
\end{english}

\subsection{Группировка слотов}

Слоты компонента делятся на три группы: входные параметры, состояние и
зависимости. Вспомним компонент воркера:

\begin{english}
  \begin{clojure}
(defrecord Worker
    [options flag task db])
  \end{clojure}
\end{english}

В этом примере слот \spverb|options| относится к инициализации, \spverb|flag| и
\spverb|task| к состоянию, а \spverb|db|~--- зависимость. Чем сложнее компонент,
тем больше слотов в каждой группе. Когда слоты случайном порядке, трудно понять
их семантику. Считается хорошим тоном отделять слоты комментарием:

\begin{english}
  \begin{clojure}
(defrecord Worker
    [;; init
     options
     ;; runtime
     flag
     task
     ;; deps
     db])
  \end{clojure}
\end{english}

Первой идет группа \spverb|init|, входные параметры. Ожидается, что конструктор
принимает такие же аргументы. Группа \spverb|runtime| перечисляет слоты, которые
компонент заполнит при старте. В \spverb|deps| указаны зависимости. Они
совпадают с вектором ключей, который передают в \spverb|using| в конструкторе.

Группировка слотов облегчает работу с кодом. Договоритесь с командой, чтобы
внедрить эту практику. Когда слотов слишком много, это говорит о том, что
компонент переусложнен. Часть логики выносят в дочерний компонент и подключают в
зависимости первого.

На страницах книги мы не группируем слоты, потому что иначе код займет много
места. В вашем проекте делайте это обязательно.

\subsection{Условная система}

В главе про конфигурацию мы писали про \emph{feature
  flags} \page{feature-flags}. Это параметры, которые включают пласты
логики. Флаги удобны тем, что отпадает нужда в новой сборке
приложения. Достаточно изменить конфигурацию и перезагрузить сервис.

Иногда систему строят не линейно, а по условиям. Предположим, компонент воркера
все еще в испытательном режиме. Добавим в конфигурацию поле с семантикой
<<включить воркер>>. Если оно ложь, система запустится без этого компонента.

Выделим в конфигурации группу \spverb|:features|. Это флаги <<фич>>, которыми
управляют:

\begin{english}
  \begin{clojure}
{:features {:worker? true}
 :jetty {:join? false :port 8088}
 ...}
  \end{clojure}
\end{english}

Перепишем функцию \spverb|make-system|. Прежде тем как попасть в
\spverb|system-map|, компоненты проходят отбор. Макрос \spverb|cond->| передает
вектор компонентов по цепочке условий и форм. Если условие \spverb|worker?|
вернет истину, следующая форма добавит к вектору значения \spverb|:worker| и
\spverb|(make-worker {...})|. Ниже могут идти другие флаги или проверки.

\begin{english}
  \begin{clojure}
(defn make-system [config]
  (let [{:keys [features jetty pool worker]} config
        {:keys [worker?]} features
        comps-base [:server (make-server jetty)
                    :db (make-db pool)]
        comps (cond-> comps-base
                worker?
                (conj :worker (make-worker worker)))]
    (apply component/system-map comps)))
  \end{clojure}
\end{english}

Убедимся, что флаг работает. Система это запись, поэтому функция \spverb|keys|
вернет ее ключи. Видно, что слот \spverb|:worker| появляется в зависимости от
флага:

\begin{english}
  \begin{clojure}
(keys (make-system {:features {:worker? false}}))
(:server :db)

(keys (make-system {:features {:worker? true}}))
(:server :db :worker)
  \end{clojure}
\end{english}

Флаги облегчают работу с проектом. Некоторые компоненты сложны и требуют
специального окружения. Если можно задать их флагом, вы принесете пользу всей
команде.

\subsection{Спуск системы}

Компоненты свободно общаются друг с другом. Если одному компоненту нужен другой,
мы ставим зависимость и добавляем слот. Проблемы начинаются, когда к системе
обращается не компонент, а другая сущность.

Чаще всего это обработчик HTTP-запроса, о которых мы говорили в первой
главе \page{first-handler}. Функция плохо ложится на идеи компонента: последний
хранит состояние, а функция избегает его. Запуск и остановка функции это
бессмысленная операция. Функция и компонент противоположны друг другу.

Рассмотрим случай, когда запросу нужен компонент базы данных. Как спустить часть
системы в функцию, не нарушив принципы библиотеки? Обращение к глобальной
переменной мы не рассматриваем, потому что это слабое решение. Помогут два
способа: проброс и замыкание.

Проброс означает, что отдельные компоненты передают в запросе. Вариант имеет
право на жизнь, потому что запрос это часть сервера, а сервер это
компонент. Поэтому сервер имеет право добавить поля запросу.

Чтобы компонент базы стал доступен серверу, подключим его в зависимости. Изменим
слоты сервера и конструктор:

\begin{english}
  \begin{clojure}
(defrecord Server
  [options server db])

(defn make-server
  [options]
  (-> (map->Server {:options options})
      (component/using [:db])))
  \end{clojure}
\end{english}

Расширим метод сервера \spverb|start|. Если раньше мы передавали \spverb|app|
напрямую в \spverb|run-jetty|, то теперь введем дополнительный шаг. Функция
\spverb|make-handler| оборачивает \spverb|app| таким образом, что каждый запрос
в \spverb|app| дополнен базой.

\begin{english}
  \begin{clojure}
;; app factory
(defn make-handler [app db]
  (fn [request]
    (app (assoc request :db db))))

;; Lifecycle
(start [this]
  (let [handler (make-handler app db)
        server (run-jetty handler options)]
    (assoc this :server server)))
  \end{clojure}
\end{english}

Пусть главная страница выводит данные из базы. Пример ниже показывает, как
выполнить запрос к базе из HTTP-запроса. Чтобы не усложнять пример версткой
HTML, вернем обычный текст.

\begin{english}
  \begin{clojure}
(defn app [request]
  (let [{:keys [db]} request
        data (db/query db "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint data))}))
  \end{clojure}
\end{english}

Со временем понадобятся другие компоненты, например очередь задач или
кэш. Поступим с ними аналогично: добавим в зависимости серверу и пробросим в
\spverb|make-handler|.

Когда компонентов все больше, хранить их на верхнем уровне запроса неудобно:
возникает риск конфликта ключей. Поместим их во вложенный словарь
\spverb|:system| или \spverb|:engine|. Важно понимать, что \spverb|:system|
содержит не всю систему, а минимальное подмножество, необходимое для веб-части.

В случае с замыканием компоненты передают в функцию отдельным аргументом. С
таким подходом обработчик принимает не один, а два аргумента: подмножество
системы и текущий запрос.

Чтобы собрать нужные компоненты, в систему вводят группировочный компонент. Он
ничего не делает при запуске и остановке, а только аккумулирует
зависимости. Сервер зависит от группировочного компонента. На базе него мы
строим дерево маршрутов, где каждый обработчик принимает компонент первым
аргументом.

Введем группировочный компонент \spverb|:web|. Пока что он зависит в только от
базы данных, но в будущем потребует и другие компоненты:

\begin{english}
  \begin{clojure}
(defrecord Web [db])

(defn make-web []
  (-> (map->Web {})
      (component/using [:db])))
  \end{clojure}
\end{english}

В функции \spverb|make-system| подключим его в систему:

\begin{english}
  \begin{clojure}
(component/system-map
 :web    (make-web)
 :server (make-server jetty)
 :db     (make-db pool)
 :worker (make-worker worker))
  \end{clojure}
\end{english}

Переключим зависимости сервера: теперь это не база данных, а группировочный
\spverb|web|:

\begin{english}
  \begin{clojure}
(defrecord Server
  [options server web])

(defn make-server
  [options]
  (-> (map->Server {:options options})
      (component/using [:web])))
  \end{clojure}
\end{english}

Вспомним, как мы строили маршруты. Макрос \spverb|defroutes| вернет функцию,
которая принимает запрос и возвращает ответ.

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
  \end{clojure}
\end{english}

Новое дерево маршрутов не статично, потому что зависит от компонента. Функция
\spverb|make-routes| принимает группировочный компонент и возвращает маршруты,
замкнутые на нем. В функции \spverb|page-index| и другие приходят два аргумента:
компонент и запрос. Компонент будет в том состоянии, в каком он пришел в
\spverb|make-routes|:

\begin{english}
  \begin{clojure}
(defn make-routes [web]
  (routes
   (GET "/"      request (page-index web request))
   (GET "/hello" request (page-hello web request))))
  \end{clojure}
\end{english}

Метод \spverb|start| сервера строит маршруты и передает в \spverb|run-jetty|:

\begin{english}
  \begin{clojure}
(start [this]
  (let [routes (make-routes web)
        server (run-jetty routes options)]
    (assoc this :server server)))
  \end{clojure}
\end{english}

Рассмотрим обработчик \spverb|page-index|, который обращается к базе
данных. Первый аргумент это \spverb|web|, хранилище компонентов, поэтому
распакуем его на уровне сигнатуры.

\begin{english}
  \begin{clojure}
(defn page-index
  [{:keys [db]} request]
  (let [data (db/query db "select * from requests")]
    {:status 200
     :body (with-out-str
             (clojure.pprint/pprint data))}))
  \end{clojure}
\end{english}

Проброс и замыкание решают одну и ту же задачу. Разница в том, как технически
передать аргументы в функцию. Проброс удобен тем, что обычно HTTP-функции
принимают один аргумент, и не придется менять сигнатуры.

С другой стороны, передача компонентов в запросе не всегда очевидна. Когда в
запросе много полей, становится трудно его постоить в тестах и разработке. При
печати запроса или записи в лог вы получите слишком большой выхлоп. Вариант с
замыканием и двумя аргументами выглядит понятнее. Сигнатура прямо говорит о том,
какие данные ожидают на входе. Конкретный способ зависит от соглашений в
команде.

\subsection{Идемпотентность}

До сих пор мы писали компоненты так, что их повторный запуск приводил к
ошибке. Покажем это на примере веб-сервера:

\begin{english}
  \begin{clojure}
(def s (-> {:port 8088 :join? false}
           make-server
           component/start))

(component/start s)
;; Execution error (BindException)
;; Address already in use
  \end{clojure}
\end{english}

В теле \spverb|start| мы не проверяем, что сервер уже работает. При попытке
включить его повторно получим ошибку, что порт занят. Это правильное поведение:
мы бы не хотели, чтобы запустилось два сервера. Для других компонентов
исключения может не быть. Например, если повторно запустить базу данных, получим
новый пул соединений. Старый пул останется в памяти и будет работать. Так
происходит утечка ресурсов.

Свойство, когда повторная операция возвращает тот же результат, называется
\emph{идемпотентность}. Компонент должен ему следовать, чтобы избежать утечки
ресурсов. Для этого мы проверяем слот перед тем, как открывать ресурс. Если слот
\spverb|nil|, мы порождаем новый сервер и записываем в слот. Иначе сервер уже
запущен, и возвращают \spverb|this|.

\begin{english}
  \begin{clojure}
(start [this]
  (if server
    this
    (let [server (run-jetty app options)]
      (assoc this :server server))))
  \end{clojure}
\end{english}

Аналогично работает \spverb|stop|: перед тем, как закрыть ресурс, слот проверяют
на заполненность:

\begin{english}
  \begin{clojure}
(stop [this]
  (when server
    (.stop server))
  (assoc this :server nil))
  \end{clojure}
\end{english}

Вариант с макросом \spverb|or| немного короче. Мы всегда записываем слот, но
значение это либо текущий сервер, либо новый.

\begin{english}
  \begin{clojure}
(start [this]
  (let [server (or server (run-jetty app options))]
    (assoc this :server server)))
  \end{clojure}
\end{english}

\section{Integrant}

Библиотека Integrant\footurl{https://github.com/weavejester/integrant} это
следующий виток мысли о том, как строить системы. Мы поместили ее в конец обзора
по нескольким причинам. Integrant отталкивается от идей Component, которые мы
только что рассмотрели. Библиотека устроена гибче и в целом более
продвинута. Перечислим основные отличия.

Сущности Component напоминают классы и ООП. В Clojure на фоне данных и функций
это выглядит усложнением. Пусть компоненты будут функциями. Они проще объекта,
потому что на функцию действует только одна операция~--- вызов.

Component выделяет только два состояния~--- \spverb|start| и
\spverb|stop|. Integrant предлагает дополнительные стадии: приостановку и
возобновление, валидацию спекой, подготовку параметров. По умолчанию эти стадии
ничего не делают, но компонент может дополнить их. С таким подходом система
гибче и удобней в поддержке.

Integrant делает ставку на декларативность. Можно описать систему в EDN-файле и
считать одной функцией. Это выгодное отличие от Component, где систему строят
вручную.

Integrant лоялен к зависимостям. Если в Component зависимость требует два
действия~--- добавить слот и метаданные,~--- то в Integrant это один шаг. В
Component зависимость может быть только другим компонентом. Иногда объект
оборачивают в компонент только чтобы выполнить это требование. В Integrant
зависимостью может быть что угодно: словарь, символ, функция.

\subsection{Базовое устройство}

Работу с Integrant начинают с описания будущей системы. Это словарь, за который
цепляется дальнейшая логика. Система ниже состоит из веб-сервера и пула базы
данных. Ключ словаря это машинное имя компонента, а значение~--- параметры
запуска.

\begin{english}
  \begin{clojure}
(def config
  {::server {:port 8080 :join? false}
   ::db {:username      "book"
         :password      "book"
         :database-name "book"
         :server-name   "127.0.0.1"
         :port-number   5432}})
  \end{clojure}
\end{english}

Система и компоненты связаны через мультиметоды. Чтобы добавить реакцию на
событие, мы расширяем нужный мультиметод ключом компонента. Например, при старте
система вызывает метод \spverb|init-key| для каждого ключа. Чтобы объяснить
системе, как запускать сервер, метод расширяют ключом \spverb|::server|.

Integrant ожидает, что ключ реализует минимум два метода: запуск и
остановку. Это ключевые действия, поэтому для них нет реакции по
умолчанию. Другие события не обязательны и остаются на ваше усмотрение.

\subsection{Первые компоненты}

Напишем компоненты сервера и базы. Они просты и не имеют
зависимостей. Подготовьте модуль \spverb|integrant.clj| с шапкой:

\begin{english}
  \begin{clojure}
(ns book.integrant
  (:require [integrant.core :as ig]))
  \end{clojure}
\end{english}

Для краткости опустим импорты \spverb|Jetty|, \spverb|HikariCP| и других
библиотек. Они аналогичны тем, что мы писали в разделах с Mount и Component.

Начнем с сервера. Метод \spverb|init-key| принимает два параметра: ключ и
словарь опций. Это значения \spverb|::server| и \spverb|{:port 8080 :join? false}|
из конфигурации. Метод должен вернуть состояние компонента. В нашем
случае это результат \spverb|run-jetty|.

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::server
  [_ options]
  (run-jetty app options))
  \end{clojure}
\end{english}

Ключ известен из определения метода, поэтому первый параметр затеняют
подчеркиванием. По аналогии опишем базу данных. Состояние компонента это спека
JDBC с пулом соединений.

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::db
  [_ options]
  {:datasource (cp/make-datasource options)})
  \end{clojure}
\end{english}

Функция \spverb|init| пробегает по системе и вызывает для каждого ключа
мультиметод \spverb|init-key|. Получим словарь, где ключ это имя компонента, а
значение~--- его состояние:

\begin{english}
  \begin{clojure}
(def _sys (ig/init config))

(keys _sys)
(:book.integrant/db :book.integrant/server)
  \end{clojure}
\end{english}

Остановка системы называется \spverb|halt|. Метод \spverb|halt-key!| определяет,
как выключить определенный ключ. Он принимает два параметра: ключ и состояние,
которые получили из метода \spverb|init-key|. Опишем эти события для сервера и
базы:

\begin{english}
  \begin{clojure}
(defmethod ig/halt-key! ::server
  [_ server]
  (.stop server))

(defmethod ig/halt-key! ::db
  [_ db-spec]
  (-> db-spec :datasource cp/close-datasource))
  \end{clojure}
\end{english}

Функция \spverb|halt!| остановит всю систему:

\begin{english}
  \begin{clojure}
(ig/halt! _sys)
  \end{clojure}
\end{english}

\subsection{Зависимости}

Чтобы указать зависимости, в опции добавляют параметр-ссылку. При запуске
Integrant ищет ссылки в системе и строит по ним граф зависимостей. Ссылку задают
функцией \spverb|ig/ref|. Она принимает ключ, от которого зависит компонент.

Рассмотрим зависимость на примере воркера. Добавьте в конфигурацию ключ как в
примере ниже. Чтобы отделить опции компонента от зависимостей, поместим их в
отдельное поле \spverb|:options|.

\begin{english}
  \begin{clojure}
{::worker {:options {:sleep 1000}
           :db (ig/ref ::db)}}
  \end{clojure}
\end{english}

Когда \spverb|init-key| дойдет до ключа \spverb|::worker|, в поле \spverb|:db|
будет значение, которое \spverb|init-key| вернул для этого ключа. Приведем
реализацию \spverb|init-key| и \spverb|halt-key!|. Если вы забыли, как устроен
воркер, обратитесь к разделу, где мы писали его в первый раз \page{worker}.

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::worker
  [_ {:keys [db options]}]
  (let [flag (atom true)
        task (make-task db flag options)]
    {:flag flag :task task}))

(defmethod ig/halt-key! ::worker
  [_ {:keys [flag task]}]
  (reset! flag false)
  (while (not (realized? task))
    (Thread/sleep 300)))
  \end{clojure}
\end{english}

\subsection{Параллели с Component}

Многие из приемов, что мы рассмотрели в Component, работают и в
Integrant. Вспомним некоторые их них.

\textbf{Глобальное хранилище.} Чтобы управлять системой, нужно где-то ее
хранить. Проще всего добавить глобальную переменную и служебные функции для
запуска и остановки.

\begin{english}
  \begin{clojure}
(defonce ^:private system nil)

(def alter-system (partial alter-var-root #'system))

(defn system-start []
  (alter-system (constantly (ig/init config))))

(defn system-stop []
  (alter-system ig/halt!))
  \end{clojure}
\end{english}

Как и в Component, система должна быть приватной. Недопустимо, чтобы
компоненты свободно обращались к ней.

\textbf{Ожидание и сигналы.} Перед тем как закончить работу, приложение ожидает,
пока все компоненты остановятся. Макрос \spverb|with-handler| и перехват
сигналов работает аналогично для Integrant:

\begin{english}
  \begin{clojure}
(with-handler :term
  (log/info "caught SIGTERM, quitting")
  (system-stop)
  (log/info "all components shut down")
  (exit))
  \end{clojure}
\end{english}

\textbf{Спуск системы и маршруты.} В Integrant легче обратиться к системе из
HTTP-запроса. Обработчик может быть компонентом и зависеть от базы. Представим,
что главная страница выводит число записей в базе. Добавим в систему новый ключ
и ссылку на базу:

\begin{english}
  \begin{clojure}
{::handler {:db (ig/ref ::db)}}
  \end{clojure}
\end{english}

В запуске ключа вернем обработчик запроса, замкнутый на \spverb|db|:

\begin{english}
  \begin{clojure}
(defmethod ig/init-key ::handler
  [_ {:keys [db]}]
  (fn [request]
    (let [query "select count(*) as total from requests"
          result (jdbc/query db query)
          total (-> result first :total)]
      {:status 200
       :body (format "You've got %s records." total)})))
  \end{clojure}
\end{english}

Доработаем сервер, чтобы он зависел от обработчика:

\begin{english}
  \begin{clojure}
{::server {:options {:port 8080 :join? false}
           :handler (ig/ref ::handler)}}

(defmethod ig/init-key ::server
  [_ {:keys [handler options]}]
  (run-jetty handler options))
  \end{clojure}
\end{english}

Теперь браузер покажет фразу <<You've got N records>>, где \spverb|N|~--- число
записей в базе. Как и в Component, \spverb|::handler| может вернуть дерево
маршрутов с помощью Compojure.

\textbf{Условное построение.} Перед запуском в систему можно изменить по
условию. Например, специальный флаг определяет, будет ли запущен воркер. Если
да, добавим в систему ключ компонента и его настройки.

\begin{english}
  \begin{clojure}
(cond-> sys-config
  (is-worker-supported?)
  (assoc ::worker {:options {:sleep 1000}
                   :db (ig/ref ::db)}))
  \end{clojure}
\end{english}

Есть и другой способ запустить подмножество системы, похожий на Mount. Функция
\spverb|init| принимает необязательный список ключей, которые следует
включить. Список готовят заранее по какому-то правилу.

\begin{english}
  \begin{clojure}
(let [components (-> config keys set)
      components (cond-> components
                   (not (is-worker-supported?))
                   (disj ::worker))]
  (ig/init config components))
  \end{clojure}
\end{english}

\subsection{Потеря ключей}

Для компонентов указывают полные (квалифицированные) ключи, например
\spverb|::server| или \spverb|::db|. Двойное двоеточие означает текущее
пространство имен, в котором объявлен ключ. Запись \spverb|::db| это краткий
вариант \spverb|:book.integrant/db|.

Когда ключ полный (с пространством), легко понять, в каком модуле он объявлен. В
боевых системах бывает более десяти компонентов. Представьте, что возникла
проблема с ключом \spverb|:queue|. Как понять, в каком модуле он находится?
Наоборот, ключ \spverb|:my-project.utils.queue/queue| несет эту
информацию. Всегда используйте полные ключи.

Возможна ситуация, когда вы забыли импортировать модуль, в котором расширили
мультиметод. Если модуль не загружен, Integrant не узнает о компоненте. Иногда
это вгоняет в ступор: вы точно помните, что писали код. Чтобы избежать ошибки,
добавьте все модули с мультиметодами в \spverb|ns| главного модуля, который
загружается всегда. Пусть это будет модуль системы.

\begin{english}
  \begin{clojure}
(ns project.system
  (:require project.db
            project.server
            project.worker
            project.utils.queue))
  \end{clojure}
\end{english}

Утилиты для проверки синтаксиса (линтеры) могут выдать предупреждение. С их
точки зрения вы добавили модуль, но не используете его, потому что в коде нет
выражения \spverb|project.db/<something>|. Чтобы подавить предупреждения,
исправьте конфигурацию линтера. Добавьте модули в секцию <<known namespaces>>
или аналогичную.

Integrant предлагает функцию \spverb|load-namespaces| для автоматической
загрузки модулей. На вход подают конфигурацию системы. Для каждого ключа функция
вычисляет его пространство и загружает его. Вот как выглядит промышленная
система с ключами из разных модулей:

\begin{english}
  \begin{clojure}
(def config
  {:project.server/server
   {:options {:port 8080 :join? false}
    :handler (ig/ref :project.handlers/index)}
   :project.db/db {...}
   :project.worker/worker
   {:options {:sleep 1000}
    :db      (ig/ref :project.db/db)}
   :project.handlers/index
   {:db (ig/ref :project.db/db)}})
  \end{clojure}
\end{english}

Чтобы загрузить все модули, которые участвуют в системе, выполните:

\begin{english}
  \begin{clojure}
(ig/load-namespaces config)
  \end{clojure}
\end{english}

Новичкам советуем воздержаться от автоматических импортов. Размещайте их явно в
блоке \spverb|ns|: вариант хоть и многословен, но очевиден. Прибегайте к
\spverb|load-namespaces| только если точно знаете, как работают пространства
имен в Clojure.

\subsection{Система в файле}

Мы упоминали, что Integrant делает ставку на декларативность. Конфигурация
системы это статичная структура данных, словарь. Для экономии места систему
выносят в EDN-файл и читают функцией из модуля \spverb|clojure.edn|.

%% ----------------

Читатель заметит, что мы указали ссылки через функцию \spverb|ig/ref|, и не
совсем ясно, как записать это выражение в файл. Тег \spverb|#ig/ref| работает
как одноименная функция.

\begin{english}
  \begin{clojure}
{:project.worker/worker {:options {:sleep 1000}
                         :db #ig/ref :project.db/db}}
  \end{clojure}
\end{english}

Integrant предлагает функцию \spverb|read-string| что чтения EDN. Это обертка
вокруг обычного \spverb|clojure.edn/read-string|, но с дополнительными
тегами. Чтобы прочитать систему из файла, выполните:

\begin{english}
  \begin{clojure}
(def config
  (-> "config.edn" slurp ig/read-string))
  \end{clojure}
\end{english}

Из главы про конфигурацию мы помним, что нежелательно хранить в файле пароли и
ключи доступа \page{password-note}. Компонент \spverb|:project.db/db| нарушает
этот принцип: пароль к базе записан открыто. Сделаем так, чтобы парсер читал
пароль из переменной среды.

Поместим конфигурацию в файл \spverb|integrant.test.edn| (ниже ее фрагмент):

\begin{english}
  \begin{clojure}
{:project.db/db {:password #env DB_PASSWORD}
 :project.worker/worker {:options {:sleep 1000}
                         :db #ig/ref :project.db/db}}
  \end{clojure}
\end{english}

Обернем чтение конфигурации в функцию. Первым аргументом в
\spverb|ig/read-string| укажем словарь с тегами. Функцию \spverb|tag-env| для
тега \spverb|#env| возьмем из прошлой главы. На нижнем уровне Integrant
дополнит словарь тегов собственными, поэтому оба \spverb|#ig/ref| и
\spverb|#env| будут работать.

Теперь система хранится в файле, а теги описывают ее точнее и гибче.

\begin{english}
  \begin{clojure}
(defn load-config [filename]
  (ig/read-string {:readers {'env tag-env}}
                  (slurp filename)))

(load-config "integrant.test.edn")
{:project.db/db {:password "c8497b517da25"}
 :project.worker/worker
 {:options {:sleep 1000}
  :db #integrant.core.Ref{:key :project.db/db}}}
  \end{clojure}
\end{english}

\subsection{Наследование ключей}

В Clojure ключи могут строиться в иерархию. Функция \spverb|derive| принимает
два ключа и задает \emph{превосходство} первого над вторым.

\begin{english}
  \begin{clojure}
(derive ::postgresql ::database)
  \end{clojure}
\end{english}

Когда мультиметод ищет действие по ключу, он учитывает иерархию. Например, если
мультиметод задан для \spverb|::database|, вызов с \spverb|::postgresql| не
приведет к ошибке: сработает версия \spverb|::database|.

Поскольку Integrant устроен на мультиметодах, из наследования можно
извлечь пользу. Представим нагруженный проекты с двумя базами данных: мастер для
записи и реплика для чтения. Пусть это компоненты \spverb|::db-master| и
\spverb|::db-replica|. Технически они одинаковы и отличаются только входными
параметрами.

Если бы мы не знали про наследование, то расширили бы \spverb|ig/init-key| и
\spverb|ig/halt-key!| каждым ключом. Это дублирует код и считается плохой
практикой. Мы уже описали компонент \spverb|::db|. Унаследуем от него две других
базы:

\begin{english}
  \begin{clojure}
(derive ::db-master ::db)
(derive ::db-replica ::db)
  \end{clojure}
\end{english}

Напишем конфигурацию для двух баз. Для реплики выставим флаг \spverb|:read-only|
\spverb|true|, чтобы обезопасить себя от записи не в тот источник. Обратите
внимание на зависимости. Поскольку воркер пишет данные в базу, он ссылается на
\spverb|::db-master|. Компонент \spverb|::hander| только читает данные, поэтому
зависит от \spverb|::db-replica|.

\begin{english}
  \begin{clojure}
(def config
  {::server {:options {:port 8080 :join? false}
             :handler (ig/ref ::handler)}
   ::db-master {;; other fields
                :read-only false}
   ::db-replica {;; other fields
                 :read-only true}
   ::worker {:options {:sleep 1000}
             :db (ig/ref ::db-master)}
   ::handler {:db (ig/ref ::db-replica)}})
  \end{clojure}
\end{english}

Функция и тег \spverb|ig/refset| вернут множество ссылок с учетом
иерархии. Предположим, один из компонентов ожидает \emph{все} базы данных для
ручной синхронизации. Чтобы не ссылаться на каждую базу вручную, укажем корневой
ключ \spverb|::db|.

Добавим компонент \spverb|::sync| для синхронизации баз. Укажем зависимость
\emph{от всех} баз через \spverb|refset|. Метод \spverb|init-key| вернет фоновую
задачу, которая раз в интервал сверяет данные. Запуск и остановка задачи
аналогичны воркеру. Пример ниже показывает, как добраться до обеих баз из
параметров.

\begin{english}
  \begin{clojure}
{::sync {:dbs (ig/refset ::db)}}

(defmethod ig/init-key ::sync
  [_ opt]
  (let [{:keys [dbs]} opt
        [db-master db-replica] dbs]
    (run-task db-master db-replica)))
  \end{clojure}
\end{english}

\subsection{Другие стадии компонента}

Кроме запуска и остановки, Integrant выделяет другие стадии, которые
проходит компонент. Они не обязательны к реализации. Стадии устроены как
мультиметоды, которым задано действие по умолчанию (вернуть \spverb|nil| или
исходный объект). Чтобы подписать компонент на событие, расширите мультиметод
его ключом. Ниже мы рассмотрим несколько полезных стадий.

\subsection{Подготовка}

Метод \spverb|ig/prep-key| служит для предварительной подготовки
параметров. Чаще всего это объединение параметров по умолчанию с теми, что
пришли из конфигурации. Например, методом проб мы нашли идеальные метрики пула
БД. Чтобы не указывать в конфигурации все поля, фиксированную часть в словарь по
умолчанию.

\begin{english}
  \begin{clojure}
(def db-defaults
  {:auto-commit        false
   :read-only          false
   :connection-timeout 30000
   :validation-timeout 5000
   :idle-timeout       600000
   :max-lifetime       1800000
   :minimum-idle       10
   :maximum-pool-size  10})

(defmethod ig/prep-key ::db
  [_ options]
  (merge db-defaults options))
  \end{clojure}
\end{english}

Метод \spverb|prep-key| объединяет этот словарь с параметрами. В конфигурации
достаточно указать только параметры подключения и, если требуется,
переопределения:

\begin{english}
  \begin{clojure}
{::db {:auto-commit   true ;; override the default
       :adapter       "postgresql"
       :username      "book"
       :password      "book"
       :database-name "book"
       :server-name   "127.0.0.1"
       :port-number   5432}}
  \end{clojure}
\end{english}

Функция \spverb|ig/prep| принимает конфигурацию и запускает метод для каждого
ключа. Чтобы не забыть этот шаг, добавьте его в \spverb|load-config|.

\subsection{Спека}

Метод \spverb|ig/pre-init-spec| связывает параметры компонента со спекой. Если
метод вернул спеку, параметры проходят проверку. Например, для базы данных
обязательны параметры подключения. Проверим их перед запуском пула:

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])

(s/def :db/username string?)
(s/def :db/database-name string?)
;; etc

(defmethod ig/pre-init-spec ::db [_]
  (s/keys :req-un [:db/username
                   :db/password
                   :db/database-name
                   :db/server-name
                   :db/port-number]))
  \end{clojure}
\end{english}

Если запустить систему с неверными параметрами, получим ошибку \spverb|spec|.

\subsection{Приостановка}

Кроме \spverb|init| и \spverb|halt|, Integrant выделяет третье
состояние системы~--- \spverb|suspended|. Приостановленный компонент не теряет
состояние, а только ставит на паузу внутренние процессы. Например, если это
потребитель сообщений из очереди \spverb|(KafkaConsumer)|, он не закрывает
соединение, а временно перестает читать сообщения (вызывать метод
\spverb|poll|). Обратная операция называется \spverb|resume|. При возобновлении
компонент, не порождая новых соединений, продолжает работу.

По умолчанию эти события работают как \spverb|halt| и \spverb|init|. Чтобы
задать особую реакцию на \spverb|suspend| и \spverb|resume|, задайте методы
\spverb|ig/suspend-key!| и \spverb|ig/resume-key|. Это потребует углубленного
чтения документации. Оставим тему читателю на самостоятельное изучение.

\section{Заключение}

Подобно тому, как машина складывается из деталей, программа состоит из
компонентов. Ими управляет система~--- соглашение о том, как устроены и связаны
компоненты друг с другом.

Любой проект нуждается в системе, и чем дольше он развивается, тем сильнее
потребность. Если в проекте нет соглашения о том, как писать составные части, он
начинает буксовать. Поддержка проекта станет слишком затратной.

Clojure предлагает разные подходы для систем. Проекты Mount, Component и
Integrant наиболее популярны. Они исповедуют разный подход, так что разработчик
найдет то, что ему по душе.

Mount отталкивается от глобальных переменных. Если проект написан в таком стиле:

\begin{english}
  \begin{clojure}
(def server (run-jetty app {:port 8080}))
  \end{clojure}
\end{english}

\noindent
, то портировать его на Mount будет легко. Переменная \spverb|server| станет
сущностью, которая меняет значение по команде. Mount подойдет тем, кто только
начал знакомство с Clojure.

Component это шаг в сторону настоящих компонентов. Это сущности, которые
изолируют состояние. Компоненты и протоколы напоминают классы и объекты и из
современных языков программирования. По этой причине некоторые недолюбливают
Component и обвиняют в излишней раздутости, <<энтерпрайзности>>.

Действительно, иногда решение на компонентах занимает больше места, чем на
атомах и функциях. С другой стороны, именно Component дает понимание того, как
строить устойчивые системы. Заметим, что б\'{о}льшую часть вопросов мы обсудили
в разделе именно про Component.

Проект Integrant ставит цель исправить недостатки Component. Он лишен тяжести
ООП и целом более <<кложурный>>. Integrant опирается на идиомы и техники,
принятые в Clojure, и тем самым подкупает опытных разработчиков.

Мы не ставим цель выяснить, какая из библиотек лучше. Не бросайтесь переписывать
проект с условного Mount на Component или наоборот. Это изнуряющий труд, и вы не
поймете, каких преимуществ достигли, пока не ощутите в них потребность.

Вместо споров о том, \emph{какая} система лучше, подумайте \emph{зачем} система
нужна проекту. Когда системный подход очевиден, технические решения найдутся
сами.
