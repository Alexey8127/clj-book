\chapter{Исключения}

\begin{teaser}
В этой главе мы рассмотрим исключения в Clojure: как они устроены и чем
отличаются от аналогов Java. Когда лучше кидать, а когда перехватывать
исключения. Как и что писать в лог, чтобы расследовать инцидент было легко.
\end{teaser}

Возможно, читателю покажется странным, что на эту тему написано так
много. Считается, что исключения просты: их можно кинуть, поймать и записать в
лог. В теории этих знаний достаточно, чтобы работать в проекте.

Исключения просты с технической стороны, но несут обширную
\emph{семантику}. Когда именно кидать исключения, а когда перехватывать? Как
извлечь полезную информацию из их цепочки? Куда их записывать? Возможно ли
ловить исключения предикатами? Мы прочли теорию, но на практике тонем во
множестве частных случаев.

Начинающие программисты пишут код, следуя только положительному пути. Отчасти
поэтому так трудно расследовать ошибки. Сервер вернул статус 500. Почему?
Возможны сотни причин, по которым запрос не удался. Но запись в логе слишком
скупа, чтобы расследовать инцидент.

Хороший программист внимателен к ошибкам. С опытом становится ясно: экономия на
исключениях не дает выигрыша. Да, мы быстрее закроем задачу, и кода получится
меньше. Позже на нас повесят новые задачи по расследованию ошибок.

Исключения в системах столь же равноправны, как и нормальное поведение. Избегайте
мысли, что это недоразумение, которое не случится с вами. Частые задачи на
непойманные ошибки~--- верный признак того, что пора разобраться с темой.

\section{Основы исключений}

Прежде чем углубляться в детали, вспомним, что такое исключения и как они себя
ведут.

Исключение~--- это объект, чаще всего экземпляр класса \spverb|Exception|. От
других классов он отличается тем, что его можно \emph{выбросить}. В разных
языках для этого служат операторы \spverb|throw|, \spverb|raise| и другие.

Брошенный объект прерывает исполнение и всплывает вверх по стеку
вызовов. Возможны два исхода: либо его поймали оператором \spverb|catch| на
одном из уровней, либо перехват не состоялся.

В первом случае программист получит \emph{объект} исключения. К нему обращаются
как обычно: читают поля, вызывают методы, передают в функции. Дальнейшее
поведение зависит от логики программы. Когда-то исключение пишут в лог и
завершают программу, в других случаях продолжают работу.

Когда исключение не поймали, программа завершится с ошибкой. Если не
предусмотрено иное, перед выходом программа запишет его в \spverb|stderr| (канал
ошибок). Мы увидем класс исключения, его сообщение и то, что называют
<<стектрейс>>. Это цепочка вызовов, по которому всплыло исключение.

Отдельные платформы позволяют задать реакцию на не пойманное
исключение. Например, чтобы записать его в файл или завершить программу особым
способом.

Clojure это гостевой язык (анг. \emph{hosted language}). Он пользуется
возможностями, которые предлагает домашняя платформа, \emph{хост}.
Исключения~--- одна из областей, в которую Clojure не вмешивается.
По умолчанию Clojure опирается на формы \spverb|try| и \spverb|catch|,
аналогичные Java.

Рассмотрим исключения в Java. Платформа содержит базовый класс
\spverb|Throwable|. Это общий предок всех исключений. Другие классы наследуют
\spverb|Throwable| и расширяют его семантику. Например, наследники первого
уровня это классы \spverb|Error| и \spverb|Exception|. Его наследует
\spverb|RuntimeException| и так далее. Это видно на схеме.

\begin{tikzpicture}[auto, node distance=1.5cm]

\node (obj) [entity] {Object};
\node (thr) [entity, below of=obj] {Throwable};
\node (err) [entity, below left = of thr, yshift=0.5cm, xshift=2cm] {Error};
\node (exc) [entity, below right = of thr, yshift=0.5cm, xshift=-2cm] {Exception};
\node (rex) [entity, below right = of exc, yshift=0.5cm, xshift=-2cm] {RuntimeException};

\draw [arrow] (obj) -- (thr);
\draw [arrow] (thr) -| (err);
\draw [arrow] (thr) -| (exc);
\draw [arrow] (exc) -| (rex);

\end{tikzpicture}

Пакеты Java несут дополнительные исключения, унаследованные от описанных
выше. Например, \spverb|java.io.IOException| для ошибок ввода-вывода,
\spverb|java.net.ConnectException| для сетевых проблем другие. Бросать
\spverb|Throwable| считается дурным тоном. Он несет слишком мало информации о
том, что случилось.

В дереве исключений каждый класс дополняет семантику предка. Рассмотрим
исключение \spverb|FileNotFoundException|. Оно возникает, когда обращаются к
файлу, которого нет на диске. Его полная родословная выглядит так:

\begin{verbatim}
java.lang.Object
  java.lang.Throwable
    java.lang.Exception
      java.io.IOException
        java.io.FileNotFoundException
\end{verbatim}

Схему читают как <<выбрасываемое $\to$ исключение $\to$ ошибка ввода-вывода
$\to$ файл не найден>>. По имени \spverb|FileNotFoundException| легко
догадаться, с чем связана проблема. Если же разработчик выбросил
\spverb|Throwable|, это осложнит поиск причины.

Различают \spverb|checked| и \spverb|unchecked| исключения, они же проверяемые и
нет. Разница между ними в семантике. Разработчик должен предвидеть
\spverb|checked| исключения и обработать их в коде. При чтении файла справедливо
ожидать, что его не окажется на диске. Поэтому \spverb|FileNotFoundException|
относится к категории \spverb|checked|.

Предвидеть нехватку памяти трудно, поэтому \spverb|OutOfMemoryError| относится к
непроверяемым исключениям. Когда оборудование на пределе, любое действие может
исчерпать память. Перехватывать это исключение нет смысла, поскольку при
нехватке памяти система ведет себя непредсказуемо.

Классы, унаследованные от \spverb|Error| и \spverb|RuntimeException| относятся к
непроверяемым (unchecked) исключениям. Унаследованные от \spverb|Exception|~---
проверяемые (checked).

Чтобы бросить исключение, его экземпляр передают в оператор
\spverb|throw|. Оператор \spverb|catch| перехватывает потенциальные
исключения. В Java и других языках отлов исключений устроен на иерархии
классов. Например, если искомый тип \spverb|IOException|, мы поймаем все
исключения, унаследованные от этого класса.

Чем выше класс в дереве наследования, тем больше исключений поймает
\spverb|catch|. В мире Java считается плохим тоном ловить ошибки классами
\spverb|Throwable| или \spverb|Exception|. Современные IDE выдают предупреждение
<<too wide catch expression>>, слишком широкий охват. Класс \spverb|Exception|
заменяют на несколько более точных исключений. Например, отдельно ошибки
ввода-вывода, сети и другие.

Одного класса недостаточно, чтобы понять причину исключения. У
\spverb|FileNotFoundException| нет поля \spverb|file|, чтобы отследить, какой
именно файл не удалось найти. Большинство исключений принимают строку с
сообщением об ошибке. Сообщение формируют так, чтобы было удобно
человеку. Например, <<File С:/work/test.txt not found>>.

Иногда текста не хватает, чтобы объяснить причину ошибки. Предположим, данные не
прошли валидацию, и нам хотелось бы исследовать их позже. Если записать данные в
сообщение, текст получится слишком большим, и это небезопасно. В данных могут
быть личные данные или ключи доступа. Такое сообщение нельзя писать в лог или
показывать пользователю. Даже путь к файлу способен выдать важную информацию.

Сообщение принято отделять от данных. Если нужно передать информацию для
расследования, создают новый класс исключения. У такого класса отдельные поля
для данных, из-за которых произошла ошибка. Поля заполняют в конструкторе
исключения. Сообщение пишут так, чтобы оно не выдало деликатную информацию.

\section{Цепочки и контекст}

Исключения строятся в цепочку. Каждый экземпляр принимает необязательный
аргумент \spverb|cause| (анг. \emph{причина}). Он может быть либо \spverb|Null|,
либо ссылкой на другое исключение.

Цепочки образуются, когда код перехватил исключение, но не знает, что с ним
делать. Это нормально, потому что на низких уровнях код не видит всего
контекста. Например, метод пишет даные в файл. У него нет полномочий решать что
делать, если файла нет, поэтому метод бросит исключение. Код выше перехватывает
его, но тоже не знает, что делать. Он бросит новое исключение со ссылкой на
изначальное. Это и есть цепочка.

В конце управление перейдет к методу, который знает, что делать. Его логика
зависит от типа исключения и бизнес-правил. Например, если файла нет, программа
создаст его или продолжит поиск в других папках. Если не удалось извлечь данные
для работы, выведет понятный текст и завершится.

В системе должен быть последний рубеж, где отлавливают \emph{все}
исключения. Если ошибка дошла до этого уровня, значит, ее не поймали правила
рангом ниже. Это говорит о нештатном поведении системы. Клиенту выводят
нейтральный текст о том, что запрос не прошел. Чтобы расследовать причину,
исключение пишут в лог и передают сборщику ошибок.

На верхнем уровне кода лежит бизнес-логика. Это шаги, которые диктует
руководство, чтобы заработать больше денег. При спуске вниз начинается переход в
техническую часть. Представим, что функция \spverb|get-user| извлекает
пользователя по его номеру. Снаружи это черный ящик: мы не знаем, откуда
приходят данные. Скорей всего, это база данных. В крупных системах пользователей
выносят в сетевой сервис. Выразим это на псевдокоде:

\begin{verbatim}
func get-user(id):
  let url = "http://api.company.com/user/" + str(id)
  return http.GET(url).body.json()
\end{verbatim}

Если вызвать функцию с номером, которого нет в системе, получим исключение
\spverb|HTTP Error: status 404|. Текст ничего не говорит о пользователе. Если
встретить эту запись в журнале, то мы даже не поймем, к какому сервису
обращались.

Чем больше мы углубляемся в технические детали, тем меньше знаем о бизнесе. В
мире HTTP нет понятия пользователя. Известны лишь метод, адрес и другие
поля. Разделим ошибку на две половины. Ее верхняя часть называет бизнес-причину:
не найден пользователь с номером 42. Почему? Из-за технического сбоя: запрос
\spverb|GET| к адресу \spverb|http://api.company.com/user/42| вернул ответ с
кодом 404.

Расставим в коде дополнительные \spverb|try/catch|. Когда исключение пришло из
технических недр, мы дополняем его контекстом и отправляем наверх. Этот паттерн
называется \spverb|re-throw|, повторный выброс.

Улучшенный псевдокод:

\begin{verbatim}
func get-user(id):
  try {
    let url = "http://api.company.com/user/" + str(id)
    return http.GET(url).body.json()
  } catch error {
    let message = "Cannot fetch a user #" + str(id)
    throw Error(message, cause=error)
  }
\end{verbatim}

Новое исключение описывает бизнес-проблему, но и при этом ссылается на
техническую. Это еще не конечая точка, у HTTP-ошибки тоже своя причина. Это
может быть сбой сети, устаревший сертификат, не тот пароль. Так образуется
цепочка исключений. В реальных проектах они достигают пять и более звеньев.

Спуск по цепочке напоминает допрос. На каждое <<почему>> мы получаем новую пищу
для размышлений, пока не доберемся до сути. Это не значит, что самое нижнее
исключение важнее других. Одно лишь \spverb|HTTPError| не описывает
ситуацию. Важно то, как мы к нему пришли.

Так работают исключения в промышленных языках: Java, Python и других. Каждая
платформа несет особенности, но в целом картина не меняется. Теперь рассмотрим,
что предлагает Clojure.

\section{Переходим к Clojure}

Чтобы познакомиться с исключением, спровоцируем его. Подойдет старый, как мир,
прием~--- поделить число на ноль. Откройте сеанс REPL и выполните:

\begin{verbatim}
(/ 1 0)
\end{verbatim}

\noindent
Появится похожий текст:

\begin{verbatim}
Execution error (ArithmeticException) at user/eval5848...
Divide by zero
\end{verbatim}

Это отчет об ошибке. В зависимости от редактора и настроек оно выглядит
по-разному. Например, Emacs с модулем Cider откроет дополнительный буфер
\spverb|*cider-error*| с подробной информацией.

Заметим, что исключение в REPL не завершает его. От нас по-прежнему ждут
команды. В боевом режиме программы на Clojure ведут себя как обычно. Если в
главном потоке не поймано исключение, программа остановится.

Чтобы поймать исключение, код помещают в форму \spverb|try|. За ним следует одна
и более форм \spverb|catch|. В них указывают, какие классы перехватывать и что
делать с экземпляром. Вот как безопасно разделить число:

\begin{verbatim}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
\end{verbatim}

Форма \spverb|catch| принимает класс и произвольный символ. С ним будет связано
исключение, если управление перейдет в эту ветку. В нашем случае мы указали
\spverb|ArithmeticException| и символ \spverb|e|. После класса и символа идет
произвольный код. В нем с исключением работают как с локальной переменной
\spverb|e|.

Мы вывели на экран текст, что вычисления прошли неудачно. Это слишком
поверхностное объяснение. Метод \spverb|.getMessage| возвращает сообщение,
которое назначили исключению при его создании. С версии 1.10 Clojure предлагает
функцию \spverb|ex-message|, которая делает то же самое:

\begin{verbatim}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println (ex-message e))))
;; Divide by zero
\end{verbatim}

Класс \spverb|ArithmeticException| ловит не все ошибки вычислений. Что случится,
если сложить 1 и \spverb|nil|? Даже если поместить расчеты в \spverb|try/catch|,
исключение мы не поймаем:

\begin{verbatim}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics")))

;; Execution error (NullPointerException) at user/eval6159
\end{verbatim}

Дело в том, что классы \spverb|ArithmeticException| и
\spverb|NullPointerException| не пересекаются. У них разные пути в дереве
исключений, которое мы обсудили в начале главы. Перехват одного не влияет на
другой. Это правильно, потому что у классов разная семантика. Ошибка в
арифметике это не то же самое, что \spverb|Null| вместо значения.

\emph{Примечание:} класс \spverb|NullPointerException|~--- частый гость в мире
Java, и для краткости его называют \spverb|NPE|.

Форма \spverb|try| принимает несколько веток \spverb|catch|. Вот как перехватить
оба случая:

\begin{verbatim}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics"))
  (catch NullPointerException e
    (println "You've got a null value")))
\end{verbatim}

Макрос перебирает классы из каждого \spverb|catch|. Он остановится на первом
подходящем варианте. Результатом \spverb|try| станет последнее выражения из
блока \spverb|catch|, который подошел по классу. В примере выше результат будет
\spverb|nil|, потому что его вернет \spverb|println|. Если ни один вариант не
подошел, оно продолжит путь вверх по стеку вызовов.

Мы упоминали, что чем выше класс исключения в дереве, тем больше случаев он
поймает. Если заменить \spverb|ArithmeticException| на \spverb|Throwable|, такой
ветка поймает любое исключение, будь то деление на ноль или \spverb|NPE|:

\begin{verbatim}
(try
  (/ 1 0)
  (+ 1 nil)
  (catch Throwable e
    (println "I catch everything")))
\end{verbatim}

В отличие от Java, в Clojure нет строгих правил о том, какие исключения
перехватывать. Это остается на усмотрение разработчика. Здравый смысл
подсказывает, что перехват \spverb|Throwable| опасен. Создается ложное ощущение,
что код работает без ошибок.

В случае с \spverb|ArithmeticException| проблема в расчетах, но для
\spverb|NullPointerException| это не так. \spverb|Nil| вместо числа говорит о
том, что проблема не в арифметике, а в функции, которая вернула
\spverb|nil|. Иными словами, \emph{ошибка кроется в другом месте}. Вот почему
перехват \spverb|NullPointerException| вредит разработке.

Форму \spverb|try/catch| с широким классом ставят на верхний уровень
кода. Например, когда важно, чтобы программа не остановилось никогда. Так
работают веб-серверы, очереди сообщений, сетевое ПО.

Иногда мы намеренно бросаем исключение, чтобы сообщить о нештатной
ситуации. Оператор \spverb|new| создает новый Java-объект. Ему передают класс и
параметры конструктора. Форма \spverb|throw| принимает исключение и запускает
механизм выброса.

\begin{verbatim}
(let [e (new Exception "Something is wrong!")]
  (throw e))
\end{verbatim}

Сообщение такого рода не информативно. Даже если мы указали, что проблема в
арифметике или базе данных, хотелось бы знать, какие именно значения были на
момент ошибки. Поэтому сообщение строят функцией \spverb|format|. Она принимает
шаблон и параметры подстановки:

\begin{verbatim}
(defn add [a b]
  (when-not (and a b)
    (let [message (format "Value error, a: %s, b: %s" a b)]
      (throw (new Exception message))))
  (+ a b))
\end{verbatim}

\noindent
Если вызвать функцию выше с одним и параметров \spverb|nil|, сообщение станет
понятнее:

\begin{verbatim}
Execution error at book.exceptions/add (exceptions.clj:86).
Value error, a: 1, b: null
\end{verbatim}

Функция \spverb|format| полезна тем, что отображает \spverb|nil| как
\spverb|null|. Это преимущество перед \spverb|str|, которая приводит
\spverb|nil| к пустой строке. Вариант с \spverb|str| выглядит так:

\begin{verbatim}
(str "Value error, a:" 1 ", b: " nil)
;; Value error, a:1, b:
\end{verbatim}

\noindent
Текст вводит в заблуждение. Мы не указали \spverb|b|? Или \spverb|b| пустая
строка? Непонятно.

\section{Контекст ошибки}

Выше мы упоминали, что данные в тексте приводят к риску. Сообщение может
оказаться слишком большим или выдать лишние сведения. Проблему решает класс
\spverb|ExceptionInfo|. Это особое исключение из поставки Clojure. Оно устроено
так, чтобы хранить произвольные данные. Дополнительно в Clojure набор функций
для работы с ним.

Ключевая функция \spverb|ex-info| создает экземпляр \spverb|ExceptionInfo|. Она
принимает сообщение и словарь данных. Это контекст, в котором возникло
исключение. Например, если HTTP-запрос не удался, в словарь помещают метод,
адрес и код ответа.

\spverb|Ex-info| только создаст исключение, но не бросит его. Результат передают
в форму \spverb|throw|:

\begin{verbatim}
(throw (ex-info
        "Cannot fetch a user."
        {:user-id 42
         :http-status 404
         :http-method "GET"
         :http-url "https://host.com/users/42"}))
\end{verbatim}

Здесь мы разделили сообщение и данные. Сообщение не выдает номер пользователя и
адрес подсистемы. Его запишут в лог или отправят пользователю, а контекст
обработают отдельно.

В работе с контекстом помните несколько правил. Словарь не может быть
\spverb|nil|. Это редкий случай, когда Clojure отличает его от
коллекции. Нежелательно хранить в словаре значения, которые не
сериализируются. Например, поток или сетевое подключение. В идеале контекст
можно записать в JSON-файл. Позже мы рассмотрим, что делать с контекстом.

Функция \spverb|ex-data| возвращает данные из исключения. Если это <<родное>>
\spverb|ExceptionInfo|, получим словарь. Если исключение другого типа, то
\spverb|nil|.

Вообразим, как бы мы поймали исключение, которое бросили выше. В форме
\spverb|catch| укажем класс \spverb|ExceptionInfo|. В ее теле функция
\spverb|ex-data| вернет словарь, который передали в \spverb|ex-info|. Разделим
словарь на поля и построим сообщение.

\begin{verbatim}
(try
  (get-user 42)
  (catch clojure.lang.ExceptionInfo e
    (let [data (ex-data e)
          {:keys [http-method http-url]} data]
      (format "HTTP error: %s %s" http-method http-url))))
;; HTTP error: GET https://host.com/users/42
\end{verbatim}

\section{Когда бросать исключения}

Наверняка читатель сомневается, когда бросать исключения, а когда ограничиться
проверкой. Рассмотрим типичные ситуации и оптимальные решения.

\emph{При обработке коллекций} исключения бросать не нужно. Как правило, в этом
нет смысла. В Clojure коллекции устроены так, что проблемы \spverb|nil| пройдут
мимо вас незамеченными. Все <<коробочные>> функции трактуют \spverb|nil| как
пустую коллекцию. Выражения:

\begin{verbatim}
(assoc nil :test 42)
(update nil :test (fnil inc 0))
(into nil [1 2 3])
(merge nil {:test 42})
\end{verbatim}

\noindent
вернут списки или словари. Ключ от \spverb|nil| вернет \spverb|nil|. Разбор
словаря или вектора сообщит переменным \spverb|nil|, если подстановка не
сработала:

\begin{verbatim}
(let [{:keys [a b c]} nil]
  [a b c])

(let [[a b c] nil]
  [a b c])
\end{verbatim}

\noindent
Оба примера вернут вектор из трех \spverb|nil|.

Термин <<nil punning>> означает лояльность к \spverb|nil|. С таким подходом
ситуацию с пустым значением решают без ошибок. Нельзя утверждать, что Clojure
полностью <<nil punning>>. \spverb|Nil| дружит с коллекциями, но не работает с
арифметикой и регулярными выражениями.

%% Todo REF

Если вы сомневаетесь в коллекции, используйте спеку. Вспомните \spverb|s/valid?|
и \spverb|s/conform| из прошлой главы. Тем самым вы отделите проверку от работы
с данными. Если валидация не прошла, бросайте исключение. Передайте в контекст
данные \spverb|explain|, чтобы разобрать их позже.

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
(s/def ::data (s/coll-of int?))
(when-let [explain (s/explain-data ::data [1 2 nil])]
  (throw (ex-info "Validation failed" {:explain explain})))
\end{verbatim}

Другой случай, когда прибегают к исключениями~--- это \emph{отказ ресурса}. Если
не удалось прочитать файл, недостаточно сказать об этом. Возможны десятки
причин: файла нет, он занят другим процессом, кончилось место на диске, ошибка в
кодировке. От ошибки зависит, кто за нее отвечает и что нужно исправить, чтобы
не допустить ее снова.

Бывает, доступ к ресурсу \emph{не бросает исключение}, и мы делаем это
намеренно. Согласно протоколу HTTP, ответ со статусом 404 такой же верный, как и
200. В индустрии нет единого мнения о том, бросать ли исключение на негативный
статус. Продвинутые библиотеки предлагают флаг, чтобы управлять этим поведением.

Предположим, наш клиент не бросает исключение на <<плохой>> ответ. Но логика
программы такова, что продолжать не имеет смысла. Проверим статус и бросим
исключение со всеми подробностями:

\begin{verbatim}
(defn auth-user [user-id]
  (let [url "http://auth.company.com"
        params {:as :json :form-params {:user-id user-id}}
        response (client/post url params)
        {:keys [status body]} response]
    (if (= status 200)
      body
      (throw (ex-info "Authentication error"
                      {:user-id user-id
                       :http-url url
                       :http-status status
                       :http-body body})))))
\end{verbatim}

Исключения полезны \emph{в библиотеках}. Код условно делится на два типа:
исполнение и координация. Библиотеки относятся с исполнительному коду. На уровне
библиотеки мы не знаем, в разрезе какой логики работает код. Если бросить
исключение в исполнительном коде, бизнес-логика перехватит его и продолжит
работу. Но если исполнитель молча подавляет ошибки, это влечет
неприятности. Сюда же относится паттерн <<вернуть \spverb|nil| и записать в
лог>>. Это игнорирование проблемы.

\section{Подробнее о цепочках}

Мы говорили про цепочки исключений. Рассмотрим, как строить их на
практике. Функция \spverb|ex-info| принимает третий необязательный параметр
\spverb|cause|. Это либо \spverb|nil|, либо другое исключение; оно становится
частью нового. Ниже функция \spverb|divide| ловит ошибку арифметики и
оборачивает в другое исключение с контекстом.

\begin{verbatim}
(defn divide [a b]
  (try
    (/ a b)
    (catch ArithmeticException e
      (throw (ex-info
              "Calculation error"
              {:a a :b b}
              e)))))
\end{verbatim}

Функция \spverb|ex-cause| возвращает причину исключения, если оно было передано
в \spverb|ex-info|. Если причины нет, результат будет \spverb|nil|.

\begin{verbatim}
(try
  (divide 1 0)
  (catch Exception e
    (-> e ex-message println)
    (-> e ex-cause ex-message println)))
\end{verbatim}

\noindent
Код выведет:

\begin{verbatim}
Calculation error
Divide by zero
\end{verbatim}

Нельзя утверждать, что у исключения строго одна причина. Их может быть много или
ни одной. Напишем функцию, которая вернет список исключений. Расположим их по
убыванию старшинства. На первом месте самое главное, на втором его причина,
далее причина причины и так далее. Проще всего сделать это формой \spverb|loop|:

\begin{verbatim}
(defn ex-chain [e]
  (loop [e e
         result []]
    (if (nil? e)
      result
      (recur (ex-cause e) (conj result e)))))
\end{verbatim}

Для экспериментов объявим переменную \spverb|e|. Это цепь исключений из трех
звеньев. На первом уровне ошибка бизнес-логики: не удалось извлечь
пользователя. На втором уровне техническая проблема: что-то не так с
авторизацией. На третьем ошибка транспорта: не прошел HTTP-запрос.

\begin{verbatim}
(def e
  (ex-info
   "Get user info error"
   {:user-id 42}
   (ex-info "Auth error"
            {:api-key "........."}
            (ex-info "HTTP error"
                     {:method "POST"
                      :url "http://api.site.com"}))))
\end{verbatim}

Получилось дерево искючений, но не всегда удобно работать с деревом. Плоская
структура лучше поддается обходу. Пригодится функция \spverb|ex-chain|, которую
мы написали. Вот как получить сообщения всех исключений:

\begin{verbatim}
(map ex-message (ex-chain e))
("Get user info error" "Auth error" "HTTP error")
\end{verbatim}

\noindent
А вот как вывести на экран построчно:

\begin{verbatim}
(doseq [e (ex-chain e)]
  (-> e ex-message println))

;; Get user info error
;; Auth error
;; HTTP error
\end{verbatim}

Выразим \spverb|ex-chain| короче через \spverb|iterate|. Это функция, которая
шаг за шагом применяет другую функцию к аргументу. Ограничение
\spverb|take-while some?| нужно для того, чтобы остановиться на первом же
\spverb|nil|-элементе.

\begin{verbatim}
(defn ex-chain [^Exception e]
  (take-while some? (iterate ex-cause e)))
\end{verbatim}

\section{Печать исключения}

Разберемся, что делать с пойманным исключением. В приложении что-то пошло не
так, и форма \spverb|try/catch| вернула ошибку. Как с ней посупить?

Самое простое, что можно сделать с исключением~--- напечатать в консоль. Функция
\spverb|println| достаточно умна: перед выводом она переводит исключение в
словарь. Это удобно для редакторов и IDE, потому что словарь легко разобрать на
части. Например, показать только ту часть стек-трейса, что касается Clojure.

Последнее исключение в цепочке иногда наывают корнем, \emph{root}. Для нашего
удобства \spverb|println| дублирует корень в начале вывода. Так сразу видно
первопричину. Вот что выведет \spverb|(println e)|:

\begin{verbatim}
#error {
 :cause HTTP error
 :data {:method POST, :url http://api.site.com}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Get user info error
   :data {:user-id 42}}
  {:type clojure.lang.ExceptionInfo
   :message Auth error
   :data {:api-key .........}}
  {:type clojure.lang.ExceptionInfo
   :message HTTP error
   :data {:method POST, :url http://api.site.com}}]
 :trace
 [[clojure.lang.AFn applyToHelper AFn.java 156]
  [clojure.lang.AFn applyTo AFn.java 144]
  [clojure.lang.Compiler$InvokeExpr eval Compiler.java 3701]
  ..........]}
\end{verbatim}

Вектор \spverb|:trace| называют стек-трейсом. Это Java-методы, по которым прошло
исключение с выброса до перехвата. Каждый элемент трейса это вектор с именем
класса, метода, файла и номера строки.

Мы сократили трейс, чтобы не тратить на него слишком много места. В реальности
трейсы занимают несколько экранов. Они показывают Java-код, который получился из
Clojure, и это сбивает с толку. Шумные трейсы~--- справедливый упрек в адрес
Clojure. С другой стороны, это этим страдают многие JVM-языки.

В пакете \spverb|clojure.stacktrace| несколько функций для печати
исключений. Так, \spverb|print-throwable| выводит только сообщение, текст
и словарь данных:

\begin{verbatim}
(clojure.stacktrace/print-throwable e)
clojure.lang.ExceptionInfo: Get user info error
{:user-id 42}
\end{verbatim}

Вывод в консоль легко захватить макросом \spverb|with-out-str|. Форма ниже
ничего не печатает, но вернет строку:

\begin{verbatim}
(with-out-str
  (clojure.stacktrace/print-stack-trace e))
\end{verbatim}

Функции \spverb|print-stack-trace| и \spverb|print-cause-trace| печатают трейс с
небольшими отличиями. Параметр \spverb|n| задает максимальную глубину трейса.

\section{Логирование}

Вывод в консоль помогает в отладке, не не подходит для боевого
запуска. Перечислим, что еще ожидают от кода, который ловит ислючения.

Для любого сообщения важны его \emph{вспомогательные данные}: время, модуль,
номер процесса. Сообщения различают по уровню важности: информационное,
предупреждение, ошибка и другие. Печать не несет этих сведений, а их ручной сбор
увеличит код.

Если программа работает на многих серверах, сбор сообщений делают
\emph{централизованным}. Представьте, что админ переключается между сотней
машин, чтобы читать логи. Идея сообщений по сети подсказывает, что для каждого
сообщения нужно знать адрес машины, с которой оно пришло.

Не все сообщения одинаково важны. Иногда библиотеки порождают сотни отладочных
сообщений в минуту. Нужен механизм, чтобы \emph{подавлять сообщения} по
некоторым признакам.

Наконец, консоль или файл~--- \emph{не единственные каналы данных}. Особо важные
сообщения пишут в журнал операционной системы, отправляют на почту, в чаты с
помощью ботов или даже в смс ответственным лицам.

Перечисленные проблемы решает логирование. Это система, которая принимает
сообщения из кода и пересылает в нужные каналы. Библиотека
\spverb|clojure.tools.logging| предлагает функции и макросы, чтобы логировать
сообщения. Это сторонний проект, поэтому добавьте его в зависимости:

\begin{verbatim}
[org.clojure/tools.logging "0.4.1"]
\end{verbatim}

\noindent
Запишем простое сообщение:

\begin{verbatim}
(require '[clojure.tools.logging :as log])
(log/info "A message from my module")
\end{verbatim}

В REPL появится строка:

\begin{verbatim}
INFO: A message from my module
\end{verbatim}

\noindent
По умлочанию лог дополняет сообщение уровнем важности.

В Clojure логирование устроено из двух уровней. Верхний уровень~--- это макросы
\spverb|log/info|, \spverb|log/error| и другие. Второй уровень называют
бекендом. Под ним понимают Java-библиотеку, которая выполняет основную работу:
пишет сообщения в файлы, отправляет их по сети и так далее.

Такое устройство несет преимущества. Исторически сложилось так, что для Java
написано много библиотек логирования. Каждая из них предлагает свои классы и
методы. Если проект использует одну из библиотек, переход на другую вынудит
править код.

В Clojure эту проблему решили на уровне дизайна. При старте модуль
\spverb|logging| ищет библиотеки \spverb|Logback|, \spverb|Log4j| и другие. Если
ничего не найдено, он использует стандартный пакет
\spverb|java.util.logging|. Вызов \spverb|log/info| сводится к вызову классов
найденной библиотеки.

Чтобы нужный бекенд <<подхватился>>, добавьте его в зависимости. Многие
библиотеки ищут конфигурацию в стандартных местах. Например, если в папку
\spverb|resources| положить XML-файл для бекенда, он прочтет его при старте.

Из бекендов популярностью пользуется проект \spverb|Logback|. От аналогов его
отличает большой выбор т.н. аппендеров (анг. \emph{appenders}). Так называют
пункт назначения, куда писать сообщения. Это может быть файл, удаленный
\spverb|syslog|, почтовый сервер.

Подключите \spverb|Logback| к проекту:

\begin{verbatim}
[ch.qos.logback/logback-classic "1.2.3"]
\end{verbatim}

\noindent
В папку \spverb|resources| положите файл \spverb|logback.xml| следующего содержания:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <charset>UTF-8</charset>
      <pattern>%date{ISO8601} %-5level %logger{36} - %msg %n</pattern>
    </encoder>
  </appender>
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
\end{verbatim}

Это укороченная конфигурация. Мы задали appender для вывода в консоль. Под тегом
\spverb|pattern| указан шаблон сообщения. Параметры шаблона начинаются со знака
процента. Подстановка \spverb|\%msg| означает текст сообщения,
\spverb|\%date{ISO8601}|~--- дату и ее формат в фигурных скобках. Сообщение в
логе выглядит так:

\begin{verbatim}
(log/info "Hello Logback!")
2019-05-03 17:36:04,001 INFO  book.exceptions - Hello Logback!
\end{verbatim}

Макросы \spverb|log/info|, \spverb|log/error| и другие допускают, что первым
аргументом может быть не текст, а исключение. В этом случае бекенд запишет его в
лог. Выше мы объявили переменную \spverb|e| для экспериментов. Запишем ее в лог:

\begin{verbatim}
(log/error e "Error while processing the request")

2019-05-03 17:41:03,913 ERROR book.exceptions - Error while processing the request
clojure.lang.ExceptionInfo: Get user info error
    at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 31 common frames omitted
\end{verbatim} 

Для экономии мы удалили часть трейса, которая не несет пользы. Из примера видно,
что цепочка состоит из трех звеньев. Это совпадает с тем, как мы задали
\spverb|e|. Проблема в том, что у каждого звена пропали данные. \spverb|Logback|
не знает о том, что поле \spverb|data| класса \spverb|ExceptionInfo| так важно
для нас.

Библиотека предлагает несколько способов напечатать исключение. Они влияют на
длину и детализацию трейса, но игнорируют данные. Аналогично ведут себя
\spverb|Log4j| и другие проекты.

В Java проблему решают новым классом. Как правило, библиотека содержит
стандартный класс, который переводит исключение в строку. Его наследуют и
заменяют нужные методы. В конфигурации логирования указывают путь к этому
классу.

Способ работает и в Clojure, но здесь проступают его недостатки. Чтобы
унаследовать класс в Clojure, нужны навыки работы с Java выше среднего. Придется
читать документацию к конкретной библиотеке, исследовать ее классы и интерфейсы.

Решение завязано на конкретную библиотеку. Класс для \spverb|Logback| придется
менять, если проект переедет на \spverb|Log4j| и наоборот. Это называют <<не
Clojure-way>>, то есть не тот способ, которому следуют в языке.

Напишем функцию для логирования ошибок. Она принимает исключение и переводит его
в текст, как удобно нам. Затем пишет лог с уровнем \spverb|error|.

Чтобы вывести данные об ошибке, обойдем цепочку исключений. Выше мы задали
\spverb|ex-chain| для этой цели. Функция \spverb|ex-print| пробегает по ее
результату и печатает данные в консоль.

\begin{verbatim}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
\end{verbatim}

Результат выглядит приятнее, чем пирамида из трейсов. Четко видны данные,
которые привели к ошибке:

\begin{verbatim}
clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 42}
clojure.lang.ExceptionInfo
  Auth error
  {:api-key "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST", :url "http://api.site.com"}
\end{verbatim}

Осталось собрать функцию для записи в лог. Чтобы перехватить печать на экран,
вызов \spverb|ex-print| оборачивают в \spverb|with-out-str|:

\begin{verbatim}
(defn log-error
  [^Throwable e & [^String message]]
  (log/error
   (with-out-str
     (println (or message "Error"))
     (ex-print e))))
\end{verbatim}

Функцию \spverb|log-error| можно вызвать с дополнительным сообщением. Если его
не передали, запишем нейтральное <<Error>>. Чтобы сообщение и тело не слиплись,
используем \spverb|println|. Эта функция добавляет перенос строки в конец.

\begin{verbatim}
(log-error e)
(log-error e "An error occurred during request")
\end{verbatim}

Последнее выражение запишет в лог следующее:

\begin{verbatim}
2019-05-03 19:00:05,590 ERROR book.exceptions - An error occurred during request
clojure.lang.ExceptionInfo
  Get user info error
  ...
\end{verbatim}

Сообщения об ошибках принято отделять от остальных записей. Для этого заводят
минимум два аппендера: консоль и файл. В консоль выводят все сообщения, чтобы
программист был в курсе дела. Ошибки требуют ответной реакции, поэтому их пишут
в файл или пересылают по сети. Позже их анализируют вручную или специальными
программами.

В следующей главе мы расскажем, как сделать так, чтобы макрос
\spverb|(log/error)| сводился к функции \spverb|log-error|. Пока что об этом
говорить преждевременно.

\section{Сбор исключений}

В прошлом разделе мы придумали, как выразить исключение текстом. Теперь можно
записать его в файл, отправить письмом или даже распечатать. Недостаток в том,
что у текста нет структуры. С точки зрения кода это символы, и неясно, где что.
При сборе ошибок важно выделить их ключевые данные, например, тип, подсистему,
модуль. Это необходимо по следующим причинам.

\emph{Предотвратить дублирование.} Во время наплыва клиентов может вскрыться
ошибка, которую не заметили ранее. Если каждый раз писать ее в файл, получим
тысячи одинаковых сообщений. Это не имеет смысла, расточительно в плане ресурсов
и затрудняет поиск.

Системы сбора определяют схожесть исключений по особым правилам. С точки зрения
текста сообщения <<user 1 not found>> и <<user 2 not found>> отличаются. Сборщик
схлопнет их в одну ошибку и по запросу покажет все варианты.

\emph{Поиск.} Нельзя построить эффективный поиск без структуры. Когда ошибки в
виде текста, можно искать только по вхождению или регулярному выражению. Такой
поиск нерелевантен, то есть не учитывает, насколько точно сущность совпадает с
запросом. Еще он не учитывает дубли. Мы бы не хотели видеть тысячу одинаковых
сообщений в выдаче.

\emph{Статистика.} Когда ошибки разобрали на части, можно строить
отчеты. Например, сколько ошибок случилось за последний месяц или
год. Группировать данные по проектам или командам. Выявить проекты, где ошибки
случаются чаще всего.

\emph{База знаний.} В системе сбора каждая ошибка становится артефактом. К ней
пишут комментарии, прикрепляют скриншоты или записи с экрана. На ошибку можно
сослаться как на документ в задаче или ревью кода. Если исключения хранят в
логах, это невозможно.

Среди прочих систем достойно выглядит Sentry, веб-приложение на Django. На
главной страницы видны проекты и краткая статистика по ним. Каждый проект
накапливает ошибки, которые получает от клиентов.

Чтобы отправить ошибку в Sentry, к нему обращаются по HTTP методом POST. В теле
передают JSON-документ с различными полями. Протокол Sentry предлагает несколько
десятков полей, чтобы описать ошибку. Сюда входят параметры машины, операционной
системы, детали HTTP-запроса, стек-трейс и другие.

Как правило, приложение не собирает эти данные вручную, а пользуется
библиотеками. Часто они называются Raven или похожим образом. Семантика в том,
что \emph{сторожевой ворон} (анг. raven) несет вести \emph{дозорному}
(анг. sentry).

Для Clojure написаны две библиотеки к \spverb|Sentry|:
\spverb|getsentry/sentry-clj|\footnote{github.com/getsentry/sentry-clj} и
\spverb|exoscale/raven|\footnote{github.com/exoscale/raven}. Первая опирается на
официальную Java-библиотеку. Это частая практика в мире Clojure~--- не писать
код с нуля, а повторно использовать код на Java.

%% ---------------

Чтобы воспользоваться \spverb|sentry-clj|, добавьте зависимость в проект:

\begin{verbatim}
[io.sentry/sentry-clj "0.7.2"]
\end{verbatim}

На первом шаге инициализируйте библиотеку с нужным DSN. Под DSN понимают
уникальный адрес проекта в Sentry. Проект объединяет сообщения по какому-то
глобальному признаку. Например, ошибки бекенда в одном проекте, фронтенда~--- во
втором, мобильного приложения~--- в третьем. Получить DSN проекта можно на
странице его дополнительной информации в разделе "интеграция".

\begin{verbatim}
(require '[sentry-clj.core :as sentry])

(def DSN "https://.....@sentry.io/.....")

(sentry/init! DSN)
\end{verbatim}

Теперь когда проект задан, отправим сообщение. Функция \spverb|send-event| принимает
словарь параметров сообщения. Нас интересует сценарий, когда мы поймали
исключение и хотели бы отправить его без лишних усилий. Достаточно передать ключ
\spverb|:throwable| с экземпляром исключения:

\begin{verbatim}
(sentry/send-event {:throwable e})
\end{verbatim}

Sentry вернет номер сообщения, а в проекте появится новая запись Предположим, мы
передали эксземпляр \spverb|e|, который объявили выше. Это цепочка из трех
исключений. В веб-интерфейсе увидим информацию о каждом из них. В поле \spverb|:extra|
будут данные верхнего звена исключения, то есть словарь \spverb|{:user-id 42}|.

Недостаток \spverb|sentry-clj| в том, что он полагается на Java-библиотеку. Вспомним,
что в мире Java не популярны принципы, которые мы обсуждали в этой
главе. Например, хотелось бы иметь данные со всех уровней, а не только
верхнего. Иначе мы не узнаем, какой был API-ключ, по какому адресу мы обращались
в сеть и другие детали. Технически возможно собрать эти данные вручную и
передать в ключ \spverb|:extra|. Но будет привильней научить этому библиотеку.

Это и другие замечания исправлены в \spverb|exoscale/raven|. Библиотека написана на
Clojure и потому более гибка. С недавний версий она передает максимально полные
данные об исключении. Подключите ее в проект:

\begin{verbatim}
[exoscale/raven "0.4.8"]
\end{verbatim}

и отправье исключение \spverb|e|:

\begin{verbatim}
(require '[raven.client :as raven])

(raven/capture! DSN e)
\end{verbatim}

Теперь откройте сообщение в Sentry и промотайте вниз. В секции \spverb|extra| будет
ключ \spverb|:via| с очень детальной информацией:

\begin{verbatim}
[ {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "Get user info error",
  "data" : {
    "user-id" : 42
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 160 ]
}, {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "Auth error",
  "data" : {
    "api-key" : "........."
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 160 ]
}, {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "HTTP error",
  "data" : {
    "method" : "POST",
    "url" : "http://api.site.com"
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 156 ]
} ]
\end{verbatim}

Это вектор словарей, где каждый словарь состоит из класса исключения, его
сообщения и данных. В поле \spverb|:at| вектор четырех элементов. Это класс, метод, имя
файла и строка, на которой возникло исключение. С таким отчетом расследовать
инцидент становится проще.

Структуру выше легко получить в любом месте Clojure. Нам доступна функция
\spverb|Throwable->map|. Она принимает исключение и возвращает словарь с ключами
\spverb|:via|, \spverb|:cause| и другими. В этом словаре вся информация об исключении, в
т.ч. цепочка исключений и трейс.

Зачем нужна функция, если ту же информацию можно извлечь самостоятельно?
Преимущество в том, что результат \spverb|Throwable->map| состоит из структур и типов
Clojure. Это комбинация словарей, векторов и символов. Такой словарь
обрабатывают как обычную Clojure-коллекцию. Его легко записать в форматы EDN или
JSON.

Ключ \spverb|:via| представляет особую ценность. Это те данные, что мы привели выше:
цепочка исключений с данными. Вот как извлечь их:

\begin{verbatim}
(-> e Throwable->map :via)
\end{verbatim}

Теперь когда вы знакомы с логированием и Sentry, напишем защитный декоратор для
Ring-приложения. Напомним, мы разобрали декораторы [в главе про
веб-разработку][clj-web]. Такой декоратор ставят на вершину стека middleware. Он
перехватывает все потенциальные ошибки, отправляет в Sentry и возвращает
нейтральный ответ о том, что запрос не удался.

\begin{verbatim}
(defn wrap-exception
  [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        (try
          (raven/capture! DSN e)
          (catch Exception e-sentry
            (log/errorf e-sentry "Sentry error: %s" DSN)
            (log/error e "HTTP Error"))
          (finally
            {:status 500
             :body "Internal error, please try later"}))))))
\end{verbatim}

Обратите внимание, что запрос к Sentry тоже обернут в \spverb|try/catch|. Как мы
выяснили ранее, обращение в сеть потенциально несет ошибки. Sentry это отдельный
сервис и может быть недоступен. В противном случае мы пишем в файл оба
исключения: и оригинальное, и связанное с Sentry. Это лучше, чем просто
проигнорировать их.

\section{Переходы}

До сих пор мы рассматривали исключения как оповещения об ошибке. Вспомним
ключевое свойство исключения. Оно прерывает исполнение и всплывает вверх, пока
не будет поймано. Поэтому иногда исключения трактуют как моментальный прыжок
вверх по стеку.

Действительно, если бросить какое-то специфичное исключение, например
\spverb|MyGOTOException|, а вызов сверху обернуть в \spverb|catch| с этим классом, то перед
нами классический оператор \spverb|GOTO|:

\begin{verbatim}
(try
  (do-first-step)
  (do-second-step)
  (when (condition)
    (throw (new MyGOTOException)))
  (do-third-step)
  (catch MyGOTOException e
    (println "Skipped the third one")))
\end{verbatim}

Если что-то пошло не так, мы прыгаем через третий шаг. Трюк называют "исключение
как способ управления исполнением".

Это очень противоречивая практика, и прибегать к ней следует с
осторожностью. Исключения не были задуманы для подобных рывков. Тот, кто
злоупотребляет прыжками по коду, использует инструмент не по назначению. Код
становится неочевидным и трудным в поддержке.

Все же, порой бывают моменты, когда нужно прервать текущий запрос на
середине. Например, мы выяснили, что у пользователя нет прав на доступ к
ресурсу, поэтому продолжать нет смысла.

Усложним задачу тем, что требуется выполнить ряд проверок, и на каждом отказе
прерывать исполнение. Для императивных языков это легкая задача. Код на Python
выглядел бы так:

\begin{verbatim}
class AccountHandler(RequestHandler):

  def on_get(self, request):

    if not self.check_this(request):
      return BadRequest("Wrong input data")

    if not self.check_that(request):
      return NotFound("No such an account")

    if not self.check_quotas(request):
      return QuotasReached("Request rate is limited")

    return JSONResponse(self.get_data_from_db())
\end{verbatim}

В Clojure нет оператора \spverb|return|. Результат нескольких форм это результат
последней. Мы не можем расположить несколько форм \spverb|if| на одном уровне друг под
другом. Это не имеет смысла, поскольку даже если какая-то из них вернет ложь,
исполнение перейдет к следующей форме.

Вариант с каскадным деревом работает, но выглядит слишком громоздко. Получилось
то, что называют The Pile of Doom, пирамида судьбы. Чем больше в ней уровней,
тем больше проблем у разработчика. Ради интереса добавьте новое условие в
середину:

\begin{verbatim}
(defn account-handler
  [request]
  (if (check-this request)
    (if (check-that request)
      (if (check-quotas request)
        {:status 200
         :body (get-data-from-db)}
        (quotas-reached "Request rate is limited"))
      (not-found "No such an account"))
    (bad-request "Wrong input data")))
\end{verbatim}

Подобный случай решают разными способами, в том числе исключениями. Библиотека
\spverb|metosin/ring-http-response| предлагает функции, которые выбрасывают исключения
с данными HTTP-ответа. В стек middleware добавляют особый декоратор, который
перехватывает такие исключения и возвращает ответ клиенту.

Добавьте библиотеку в проект:

\begin{verbatim}
[metosin/ring-http-response "0.9.1"]
\end{verbatim}

Теперь обработчик выглядит так:

\begin{verbatim}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler
  [request]

  (when-not (check-this request)
    (bad-request! "Wrong input data"))

  (when-not (check-that request)
    (not-found! "No such an account"))

  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))

  {:status 200
   :body (get-data-from-db)})
\end{verbatim}

Такой код похож на императивный. Некоторых разработчиков уязвляет факт, что в
Clojure мы пользуемся императивным подходом. Это нормально. Наша задача --
сделать так, чтобы код был максимально понятным и удобным в поддержке. Вопрос
какую парадигму при этом использовать остается на усмотрение команды.

Функции из модуля \spverb|ring.util.http-response| бывают с восклицательным знаком на
конце и без него. Это сигнал о том, что функция несет побочный эффект, в данном
случае бросает исключение. Так, \spverb|not-found!| бросает знакомый нам \spverb|ex-info|, в
теле которого HTTP-ответ со статусом 404.

Чтобы схема работала, добавим в стек middleware декоратор
\spverb|wrap-http-response|. Он ловит ошибки, выброшенные функциями с восклицательным
знаком, достает из них ответ и возвращает пользователю.

\begin{verbatim}
(require '[ring.middleware.http-response
           :refer [wrap-http-response]])

(def app
  (-> app-naked
      wrap-params
      wrap-session
      wrap-cookies
      wrap-http-response))
\end{verbatim}

Не злоупотребляйте исключениями для переходов. Убедитесь, что это крайняя
мера. Хорошо, если вы используете библиотеку, а не сиюминутное
решение. Преимущество библиотеки в том, что она несет документацию и опыт других
людей.

\section{Finally и контекстный менеджер}

Иногда мы выполняем код в рамках какого-то ресурса. Это может быть файл, сетевой
порт или база данных. В начале работы эти ресурсы "открывают", а в конце
"закрывают". В других терминах говорят, что кто-то занял ресурс, а затем
освободил его.

Когда ресурс занят, другие клиенты не могут пользоваться им в полной
мере. Например, открытый кем-то файл можно только читать, но не
изменять. Считается правильным освобождать ресурс сразу же, как только в нем
отпала потребность. Технически это сводится к вызову метода \spverb|.close| у объекта.

Этому может помешать непредвиденная ошибка. Если код, который работает с
ресурсом, не перехватил исключение, то файл или порт останется занятым до конца
работы программы. Чтобы гарантированно закрыть ресурс даже в случае ошибки,
прибегают к форме \spverb|finally|.

Эту форму ставят последней внутри \spverb|try|. Исключения в JVM устроены так, что
управление переходит в \spverb|finally| даже в случае исключения. Если ошибки не было,
\spverb|finally| срабатывает после основного кода из \spverb|try|. Если ошибка возникла,
\spverb|finally| будет выполнен в промежутке между ее появлением и выбрасыванием.

Вот как выглядит низкоуровневый доступ к файлу. В примере ниже мы записываем в
него несколько байт. Форма \spverb|finally| гаранитрует, что файл будет закрыт, даже
если если что-то пойдет не так.

\begin{verbatim}
(import '[java.io File FileWriter])

(let [out (new FileWriter (new File "test.txt"))]
  (try
    (.write out "Hello")
    (.write out " ")
    (.write out "Clojure")
    (finally
      (.close out))))
\end{verbatim}

Чтобы программист не забыл закрыть файл, современные языки предлагают
контекстные менеджеры. В зависимости от платформы это может быть класс, оператор
или макрос. Менеджер исполняет произвольный блок кода с дополнительными
эффектами. Он гарантирует, что перед блоком сработает логика входа, а после него
-- логика выхода. При этом выход сработает даже в том случае, если блок выбросил
исключение. Платформа удержит его, выполнит логику выхода и снова бросит.

В языке Python контекстный менеджер выполнен изящно. Это оператор \spverb|with|,
который ожидает объект. У объекта должны быть методы \spverb|__enter__| и \spverb|__exit__|,
которые вызываются в момент входа и выхода. Чаще всего \spverb|with| используют при
чтении файла. В методе \spverb|__exit__| срабатывает его закрытие:

\begin{verbatim}
with open("/path/to/file.txt", "w") as f:
    f.write("test")
\end{verbatim}

Не составит труда написать такой же менеджер в Clojure. Это будет макрос,
который принимает символ объекта для записи и путь к файлу. Объект назначается
первому символу. Форма \spverb|finally| гарантирует, что файл будет закрыт при выходе
из тела макроса.

\begin{verbatim}
(defmacro with-file-writer
  [[bind path] & body]
  `(let [~bind (new FileWriter (new File ~path))]
     (try
       ~@body
       (finally
         (.close ~bind)))))
\end{verbatim}

Пример:

\begin{verbatim}
(with-file-writer [out "test.txt"]
  (.write out "Hello macro!"))
\end{verbatim}

Принято называть контекстные менеджеры с префикса \spverb|with-|. Так вы делаете акцент
на том, что код работает в рамках временного ресурса.

В библиотеке Clojure уже предусмотрен макрос \spverb|with-open|. Это улучшенная версия
кода, что мы написали выше. В отличии от нашего примера, \spverb|with-open| работает с
более абстрактной сущностью \spverb|Reader|. Это источник данных, который может быть в
том числе и файлом. Выход из макроса, даже с ошибкой, гарантирует закрытие
источника.

Как правило, в форме \spverb|finally| нет смысла при обработке коллекций или действий
без побочных эффектов. Пользуйтесь ей только если источник данных должен быть
занят и освобожден.

\section{Исключения на предикатах}

Система \spverb|try/catch| работает на классах и наследовании. Это значит, если
требуется отловить особый случай, мы создаем специальный класс и бросаем его
экземпляр.

Типичный проект на Java или Python несет на борту отдельный модуль с
собственными исключениями. Как правило, это базовое \spverb|CommonProjectException| и
унаследованные от него \spverb|UserNotFound|, \spverb|UserAccessDenied| и другие. Это длинный
однообразный код, написанный вручную.

В главе про \spverb|clojure.spec| мы упоминали, что предикаты мощнее типов. Это верно и
для исключений. Если бы можно было перехватить исключение функцией, нам бы не
потребовались классы. В Clojure это возможно при помощи библиотеки \spverb|Slingshot|
(анг. рогатка).

Библиотека предлагает улучшенные версии \spverb|try|, \spverb|catch| и \spverb|throw|. Новичкам
покажется это странным, но в Clojure с ее мощной системой макросов можно сделать
очень много. В том числе определить иной способ работы с исключениями.
Пользователи других языков ждут новый оператор годами, а в Clojure это решается
библиотекой.

Автор Slingshot предположил, что ошибкой может быть не только экземпляр
исключения, а любое значение в принципе. Например, строка, число, словарь. Выше
мы выяснили, что контекст~--- самый важный элемент исключения. Поэтому логично
сосредоточить внимание на словарях, а не Java классах.

В техническом плане библиотека реализует макросы \spverb|throw+| и \spverb|try+|. Оба они
совместимы с обычными \spverb|throw| и \spverb|try|. Если заменить стандартные формы на версии
с плюсом, ничего не изменится. Однако новые формы дают следующие преимущества.

Макрос throw+ принимает не только исключение, но и \emph{любой
Java-объект}. Словарь лучше всего подходит на роль этого объекта, потому что
передает несколько значений и их семантику по имени ключей. Пример ниже выбросит
\spverb|ex-info| с переданным словарем:

\begin{verbatim}
(require '[slingshot.slingshot
           :refer [try+ throw+]])

(throw+ {:user-id 42
         :action :create})
\end{verbatim}

Более детальная форма этого макроса: словарь, причина (cause), сообщение и
переметры форматирования:

\begin{verbatim}
(let [path "/var/lib/file.txt"]
  (try
    (slurp path)
    (catch Exception e
      (throw+ {:path path} e "Cannot open a file %s" path))))
\end{verbatim}

Форма \spverb|catch| внутри \spverb|try+|, помимо классов, ловит исключения по \emph{селектору и
предикату}. Под селектором понимают вектор, где нечетный элемент ключ словаря,
а четный~--- значение. Селектор проверяет, что такие ключи и значения есть в
контексте исключения. Если да, исключение считается пойманным, и управление
переходит в форму \spverb|catch| с этим селектором.

\begin{verbatim}
(try+
 (throw+ {:type ::user-error
          :user 42
          :action :update
          :data {:name "Ivan"}})
 (catch [:type ::user-error] e
   (clojure.pprint/pprint e)))
\end{verbatim}

Считается хорошей практикой добавлять в словарь поле \spverb|:type|. В него записывают
тип исключения с текущим простанстом имен. В нашем случе это
\spverb|:book.exceptions/user-error|. При отлове исключений прибегают к этому же
полю. Пространство гарантирует, что мы не отреагируем на \spverb|:user-error| из
другого модуля.

Пример выше напечатает в консоль переданный словарь. Макрос \spverb|catch| достаточно
умен и подставляет в переменную \spverb|e| не исключение, а данные, что мы выбросили.

Вариант с предикатом аналогичен примеру выше. Разница лишь в том, что вместо
селектора указывают функцию одного аргумента. Она принимает исключение или
данные и возвращает истину или ложь. Функция должна быть готова к тому, что ее
параметр разного типа.

Пример ниже предполагает, что операции над пользователем с номером 1 заслуживают
особого внимания. В этом есть смысл, потому что первый пользователь, как
правило, это супер-админ, основатель фирмы или системный пользователь.

\begin{verbatim}
(defn special-user-case?
  [data]
  (when (map? data)
    (let [{:keys [type user]} data]
      (and (= type ::user-error)
           (= user 1)))))
\end{verbatim}

С таким предикатом любой пользователь сможет удалить себя из системы, но не
админ:

\begin{verbatim}
(try+
 (throw+ {:type ::user-error
          :user 1
          :action :delete})
 (catch special-user-case? e
   (println "Attempt to delete a system account")))
\end{verbatim}

Рассмотрим пример из реального проекта. Это предикат для проверки исключения при
работе с Java AWS SDK. При определенных обстоятельствах возможен случай, когда
исключение возникло после того, как файл загружен в S3. Такая загрузка считается
неудачной, и мы должны удалить файл, чтобы он не занимал место. К сожалению, для
этого сценария не существует отдельного класса. Приходится ловить стандартный
AmazonS3Exception и проверять его регулярным выражением.

\begin{verbatim}
(defn aws-special-case?
  [e]
  (and
   (instance? AmazonS3Exception e)
   (some?
    (re-find
     #"(?i)The Content-Md5 you specified did not match"
     (ex-message e)))))
\end{verbatim}

Библиотеку Slingshot используют другие проекты, например \spverb|clj-http|. Это
популярный HTTP-клиент для Clojure. В случае ошибки он кидает ответ через
\spverb|throw+|. Если код оборачивает HTTP-запрос в \spverb|try+|, вам доступен более тонкий
разбор ошибок. Например, отдельные ветки для статуса 500 и негативного ответа в
целом.

\begin{verbatim}
(require '[clj-http.client :as client])

(try+
 (client/get "http://example.com/test")
 (catch [:status 500] e
   (println "The service is unavailable"))
 (catch [:type :client/unexceptional-status] e
   (println "The response was not 200")))
\end{verbatim}

Подход Slingshot дает несколько преимуществ. Он скрывает внутренний механизм
классов и наследования, дает новый слой абстракции. Чем меньше мы прибегаем к
взаимодействию с JVM, тем лучше Clojure-код. Невозможно избежать этого
полностью, но по крайней мере доступ к JVM становится изолирован.

Библиотека выводит на первое место данные, а не классы. Это хорошая практика, и
она всячески поощряется языком. Clojure спроектирована так, что данные занимают
в ней первое место.

Slingshot относится к расширенной технике Clojure. Начинающим не очевидны плюсы,
которые библиотека несет в проект. Это нормально. Автор советует сначала
разобраться со стандартными формами \spverb|try/catch|. Подключайте Slingshot только
если вы остро чувствуете в нем потребность.

\section{Приемы и функции}

В последнем разделе мы рассмотрим несколько интересных функций. Их объединяет
тема исключений. Функции достаточно просты и потому не стоят того, чтобы
выносить их в отдельную библиотеку. Как правило, их копируют из проекта в проект
с небольшими изменениями. Автор уверен, у каждого Clojure-разработчика найдется
что-то подобное.

\emph{Безопасный вызов функции.} В замечательном языке Lua нет операторов \spverb|try| и
\spverb|catch|. Чтобы обезопасить вызов функции от ошибки, используют \spverb|pcall|. Это
сокращение от protected call, защищенный вызов.

В \spverb|pcall| передают целевую функцию и аргументы. Результатом будет пара и более
элементов (в Lua функция может вернуть несколько значений). Первый их них
определяет успех выполнения. Если истина, то на втором месте результат
вычисления. Если ложь, то экземпляр исключения.

Тот же самое в Clojure:

\begin{verbatim}
(defn pcall
  [f & args]
  (try
    [true (apply f args)]
    (catch Exception e
      [false e])))
\end{verbatim}

Чтобы получить доступ к элементам пары, пользуйтесь векторным разбиением в форме
\spverb|let|:

\begin{verbatim}
(let [[ok? result-error] (pcall inc 1)]
  (if ok?
    (println (str "The result is " result-error))
    (println "Failure")))
\end{verbatim}

\emph{Ошибка и результат.} В мире JavaScript популярны функции-колбеки. Они
выполняются асинхронно и поэтому не прерывают главный тред в случае
ошибки. Существует особое соглашение, что коллбек принимает аргументы \spverb|error| и
\spverb|result|. Функция pcall-js это измененный вариант \spverb|pcall|, который возвращает
пару "ошибка-результат" по этому соглашению.

\begin{verbatim}
(defn pcall-js
  [f & args]
  (try
    [nil (apply f args)]
    (catch Exception e
      [e nil])))
\end{verbatim}

\emph{Попытки с задержкой.} Иногда функция не гарантирует, что отработает
успешно. Такое случается, когда мы обращаемся ко внешнему нестабильному
сервису. Функция \spverb|pcall-retry| пытается выполнить целевую функцию за несколько
попыток. Первый же удачный вызов станет результатом. Если была ошибка, но число
попыток еще не превысило порога, то функция ждет небольшой интервал времени и
повторяет вызов. Когда все попытки закончились, функция вызывает исключение.

\begin{verbatim}
(defn pcall-retry
  [n f & args]
  (loop [attempt n]
    (let [[ok? res] (apply pcall f args)]
      (cond
        ok? res

        (< attempt n)
        (do
          (Thread/sleep (* attempt 1000))
          (recur (inc n)))

        :else
        (throw res)))))
\end{verbatim}

Это наивная версия функции, и в реальных проектах ее дорабатывают. Например,
меняют стратегию задержки, добавляют логирование. Но основа остается прежней.

Любопытно, что функции выше стыкуются между собой. Чтобы предотвратить выброс
исключения из \spverb|pcall-retry|, завернем ее в \spverb|pcall|:

\begin{verbatim}
(pcall pcall-retry get-user-by-id 42)
\end{verbatim}

Тогда даже в случае ошибки получим пару \spverb|[ok? result]|.

Форма \spverb|loop| заслуживает особого упоминания. Ее дочерняя форма \spverb|recur| не может
располагаться внутри \spverb|try/catch|. Пример ниже не просто ошибочный в плане
семантики. При при попытке ее скомпилировать вы получите исключение "Can only
recur from tail position":

\begin{verbatim}
(defn pcall-retry
  [n f & args]
  (loop [attempt n]
    (try
      (apply pcall f args)
      (catch Exception e
        (recur (inc n))))))
\end{verbatim}

Это один их тех случаев, когда мы не можем использовать \spverb|try/catch|. На помощь
приходит \spverb|pcall| и его вариации.

\emph{Throw in place.} До сих пор мы кидали исключения двумя формами: \spverb|ex-info| и
\spverb|throw|. Первая формирует исключение, а вторая его бросает. Логично совместить
их в функцию \spverb|error!|. Заодно сделаем часть аргументов необязательными:

\begin{verbatim}
(defn error!
  [message & [data e]]
  (throw (ex-info message (or data {}) e)))
\end{verbatim}

Теперь достаточно написать:

\begin{verbatim}
(error! "Some error!" {:type ::error})
\end{verbatim}

, чтобы кинуть исключение с нужными данными.

\emph{Форматированное сообщение.} Иногда нам нужен не контекст, а подробное
сообщение об ошибке. В этом случае \spverb|ex-info| избыточен, поскольку без контекста
он не имеет смысла. Достаточно выкинуть \spverb|Exception| с форматированным
сообщением. В параметры функции передают шаблон и значения для подстановки. В
этом и других примерах часть \spverb|f| на конце означает форматирование.

\begin{verbatim}
(defn errorf!
  [template & args]
  (let [message (apply format template args)]
    (throw (new Exception ^String message))))

(errorf! "Cannot process a user %s with the action %s" "AAA" :UPDATE)
\end{verbatim}

\emph{Безопасный макрос.} Примеры выше можно переписать на макросах. Преимущество
макросов в том, что они изящней встраиваются в код. С другой стороны, на них
нельзя ссылаться как на объект. Макрос нельзя передать в \spverb|apply|, \spverb|map| и другие
высшие функции.

Пример ниже показывает, как выполнить часть кода в безопасном режиме, игнорируя
ошибку:

\begin{verbatim}
(defmacro with-safe
  [& body]
  `(try
     ~@body
     (catch Exception e#)))
\end{verbatim}

Пустая форма catch возвращает nil. Мы получим его, если случится ошибка:

\begin{verbatim}
(with-safe (/ 0 0))
nil
\end{verbatim}

\spverb|Nil| может быть положительным результатом кода, который мы передали в
макрос. На практике ошибку передают другим значением. Обычно это кейворд
\spverb|:error| или \spverb|:invalid|. По такому принципу работает пакет \spverb|clojure.spec|,
который мы разобрали в прошлой главе. Если валидация не прошла, результат будет
\spverb|:clojure.spec.alpha/invalid|.

В реальности редко бывает так, что нам безразлично, была ошибка или нет. Поэтому
на практике макрос дорабатывают: добавляют в форму \spverb|catch| код для записи
исключения в лог или отправки в Sentry.

\section{Заключение}

Перечислим основные тезисы главы. Clojure использует систему исключений
Java. Эта система работает на классах и дереве наследования. Формы \spverb|try| и
\spverb|catch| похожи на одноименные операторы Java.

Особая форма \spverb|finally| дает шанс закрыть ресурс в случае ошибки. Чтобы упростить
работу с ресурсом, пользуйтесь контекстными менеджерами. Это макросы вида
\spverb|with-<something>|. Для доступа к файлам Clojure предлагает макрос \spverb|with-open|.

Класс \spverb|ExceptionInfo| разработан специально для Clojure. Его преимущество в поле
\spverb|data|, куда можно записать любой словарь. Функция \spverb|ex-info| упрощает создание
этого исключения.

У каждой ошибки может быть причина, \spverb|cause|. Если вы поймали исключение, лучше
бросить новое с текущим контекстом и причиной-оригинальным исключением. Так
исключения собираются в цепочку.

В приложении должен быть код, который решает, что делать с пойманным
исключением. Лучше всего отправить его в единую систему сбора ошибок. Sentry
будет хорошим решением. Проследите, что ваш клиент к Sentry передает всю нужную
информацию, а не только стек-трейс.

В особых случаях исключениями пользуются, чтобы мгновенно перейти в другое место
в коде. На это у вас должны быть веские причины.

Проект Slingshot предлагает улучшенную схему \spverb|try/catch|. При таком подходе мы
оперируем не исключениями, а данными.

Ряд функций и макросов упрощают контроль над исключениями. Изучите их, чтобы
уменьшить код.

%% [source]: https://github.com/igrishaev/book-sessions/blob/master/src/book/exceptions.clj TODO

Код этой главы доступен [в одном модуле][source] на Гитхабе.
