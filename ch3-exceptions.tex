\chapter{Исключения}

\begin{teaser}
В этой главе мы рассмотрим исключения в Clojure: как они устроены и чем
отличаются от аналогов Java. Когда лучше кидать, а когда перехватывать
исключения. Как и что писать в лог, чтобы расследовать инцидент было легко.
\end{teaser}

Возможно, читателю покажется странным, что на эту тему написано так
много. Считается, что исключения просты: их можно кинуть, поймать и записать в
лог. В теории этих знаний достаточно, чтобы работать в проекте.

Исключения просты с технической стороны, но несут обширную
\emph{семантику}. Когда именно кидать исключения, а когда перехватывать? Как
извлечь полезную информацию из их цепочки? Куда их записывать? Возможно ли
ловить исключения предикатами? Мы прочли теорию, но на практике тонем во
множестве частных случаев.

Начинающие программисты пишут код, следуя только положительному пути. Отчасти
поэтому так трудно расследовать ошибки. Сервер вернул статус 500. Почему?
Возможны сотни причин, по которым запрос не удался. Но запись в логе слишком
скупа, чтобы расследовать инцидент.

Хороший программист внимателен к ошибкам. С опытом становится ясно: экономия на
исключениях не дает выигрыша. Да, мы быстрее закроем задачу, и кода получится
меньше. Позже на нас повесят новые задачи по расследованию ошибок.

Исключения в системах столь же равноправны, как и нормальное поведение. Избегайте
мысли, что это недоразумение, которое не случится с вами. Частые задачи на
непойманные ошибки~--- верный признак того, что пора разобраться с темой.

\section{Основы исключений}

Прежде чем углубляться в детали, вспомним, что такое исключения и как они себя
ведут.

Исключение~--- это объект, чаще всего экземпляр класса \spverb|Exception|. От
других классов он отличается тем, что его можно \emph{выбросить}. В разных
языках для этого служат операторы \spverb|throw|, \spverb|raise| и другие.

Брошенный объект прерывает исполнение и всплывает вверх по стеку
вызовов. Возможны два исхода: либо его поймали оператором \spverb|catch| на
одном из уровней, либо перехват не состоялся.

В первом случае программист получит \emph{объект} исключения. К нему обращаются
как обычно: читают поля, вызывают методы, передают в функции. Дальнейшее
поведение зависит от логики программы. Когда-то исключение пишут в лог и
завершают программу, в других случаях продолжают работу.

Когда исключение не поймали, программа завершится с ошибкой. Если не
предусмотрено иное, перед выходом программа запишет его в \spverb|stderr| (канал
ошибок). Мы увидем класс исключения, его сообщение и то, что называют
<<стектрейс>>. Это цепочка вызовов, по которому всплыло исключение.

Отдельные платформы позволяют задать реакцию на не пойманное
исключение. Например, чтобы записать его в файл или завершить программу особым
способом.

Clojure это гостевой язык (анг. \emph{hosted language}). Он пользуется
возможностями, которые предлагает домашняя платформа, \emph{хост}.
Исключения~--- одна из областей, в которую Clojure не вмешивается.
По умолчанию Clojure опирается на формы \spverb|try| и \spverb|catch|,
аналогичные Java.

Рассмотрим исключения в Java. Платформа содержит базовый класс
\spverb|Throwable|. Это общий предок всех исключений. Другие классы наследуют
\spverb|Throwable| и расширяют его семантику. Например, наследники первого
уровня это классы \spverb|Error| и \spverb|Exception|. Его наследует
\spverb|RuntimeException| и так далее. Это видно на схеме.

\begin{tikzpicture}[auto, node distance=1.5cm]

\node (obj) [entity] {Object};
\node (thr) [entity, below of=obj] {Throwable};
\node (err) [entity, below left = of thr, yshift=0.5cm, xshift=2cm] {Error};
\node (exc) [entity, below right = of thr, yshift=0.5cm, xshift=-2cm] {Exception};
\node (rex) [entity, below right = of exc, yshift=0.5cm, xshift=-2cm] {RuntimeException};

\draw [arrow] (obj) -- (thr);
\draw [arrow] (thr) -| (err);
\draw [arrow] (thr) -| (exc);
\draw [arrow] (exc) -| (rex);

\end{tikzpicture}

Пакеты Java несут дополнительные исключения, унаследованные от описанных
выше. Например, \spverb|java.io.IOException| для ошибок ввода-вывода,
\spverb|java.net.ConnectException| для сетевых проблем другие. Бросать
\spverb|Throwable| считается дурным тоном. Он несет слишком мало информации о
том, что случилось.

В дереве исключений каждый класс дополняет семантику предка. Рассмотрим
исключение \spverb|FileNotFoundException|. Оно возникает, когда обращаются к
файлу, которого нет на диске. Его полная родословная выглядит так:

\begin{verbatim}
java.lang.Object
  java.lang.Throwable
    java.lang.Exception
      java.io.IOException
        java.io.FileNotFoundException
\end{verbatim}

Схему читают как <<выбрасываемое $\to$ исключение $\to$ ошибка ввода-вывода
$\to$ файл не найден>>. По имени \spverb|FileNotFoundException| легко
догадаться, с чем связана проблема. Если же разработчик выбросил
\spverb|Throwable|, это осложнит поиск причины.

Различают \spverb|checked| и \spverb|unchecked| исключения, они же проверяемые и
нет. Разница между ними в семантике. Разработчик должен предвидеть
\spverb|checked| исключения и обработать их в коде. При чтении файла справедливо
ожидать, что его не окажется на диске. Поэтому \spverb|FileNotFoundException|
относится к категории \spverb|checked|.

Предвидеть нехватку памяти трудно, поэтому \spverb|OutOfMemoryError| относится к
непроверяемым исключениям. Когда оборудование на пределе, любое действие может
исчерпать память. Перехватывать это исключение нет смысла, поскольку при
нехватке памяти система ведет себя непредсказуемо.

Классы, унаследованные от \spverb|Error| и \spverb|RuntimeException| относятся к
непроверяемым (unchecked) исключениям. Унаследованные от \spverb|Exception|~---
проверяемые (checked).

Чтобы бросить исключение, его экземпляр передают в оператор
\spverb|throw|. Оператор \spverb|catch| перехватывает потенциальные
исключения. В Java и других языках отлов исключений устроен на иерархии
классов. Например, если искомый тип \spverb|IOException|, мы поймаем все
исключения, унаследованные от этого класса.

Чем выше класс в дереве наследования, тем больше исключений поймает
\spverb|catch|. В мире Java считается плохим тоном ловить ошибки классами
\spverb|Throwable| или \spverb|Exception|. Современные IDE выдают предупреждение
<<too wide catch expression>>, слишком широкий охват. Класс \spverb|Exception|
заменяют на несколько более точных исключений. Например, отдельно ошибки
ввода-вывода, сети и другие.

Одного класса недостаточно, чтобы понять причину исключения. У
\spverb|FileNotFoundException| нет поля \spverb|file|, чтобы отследить, какой
именно файл не удалось найти. Большинство исключений принимают строку с
сообщением об ошибке. Сообщение формируют так, чтобы было удобно
человеку. Например, <<File С:/work/test.txt not found>>.

Иногда текста не хватает, чтобы объяснить причину ошибки. Предположим, данные не
прошли валидацию, и нам хотелось бы исследовать их позже. Если записать данные в
сообщение, текст получится слишком большим, и это небезопасно. В данных могут
быть личные данные или ключи доступа. Такое сообщение нельзя писать в лог или
показывать пользователю. Даже путь к файлу способен выдать важную информацию.

Сообщение принято отделять от данных. Если нужно передать информацию для
расследования, создают новый класс исключения. У такого класса отдельные поля
для данных, из-за которых произошла ошибка. Поля заполняют в конструкторе
исключения. Сообщение пишут так, чтобы оно не выдало деликатную информацию.

\section{Цепочки и контекст}

Исключения строятся в цепочку. Каждый экземпляр принимает необязательный
аргумент \spverb|cause| (анг. \emph{причина}). Он может быть либо \spverb|Null|,
либо ссылкой на другое исключение.

Цепочки образуются, когда код перехватил исключение, но не знает, что с ним
делать. Это нормально, потому что на низких уровнях код не видит всего
контекста. Например, метод пишет даные в файл. У него нет полномочий решать что
делать, если файла нет, поэтому метод бросит исключение. Код выше перехватывает
его, но тоже не знает, что делать. Он бросит новое исключение со ссылкой на
изначальное. Это и есть цепочка.

В конце управление перейдет к методу, который знает, что делать. Его логика
зависит от типа исключения и бизнес-правил. Например, если файла нет, программа
создаст его или продолжит поиск в других папках. Если не удалось извлечь данные
для работы, выведет понятный текст и завершится.

В системе должен быть последний рубеж, где отлавливают \emph{все}
исключения. Если ошибка дошла до этого уровня, значит, ее не поймали правила
рангом ниже. Это говорит о нештатном поведении системы. Клиенту выводят
нейтральный текст о том, что запрос не прошел. Чтобы расследовать причину,
исключение пишут в лог и передают сборщику ошибок.

На верхнем уровне кода лежит бизнес-логика. Это шаги, которые диктует
руководство, чтобы заработать больше денег. При спуске вниз начинается переход в
техническую часть. Представим, что функция \spverb|get-user| извлекает
пользователя по его номеру. Снаружи это черный ящик: мы не знаем, откуда
приходят данные. Скорей всего, это база данных. В крупных системах пользователей
выносят в сетевой сервис. Выразим это на псевдокоде:

\begin{verbatim}
func get-user(id):
  let url = "http://api.company.com/user/" + str(id)
  return http.GET(url).body.json()
\end{verbatim}

Если вызвать функцию с номером, которого нет в системе, получим исключение
\spverb|HTTP Error: status 404|. Текст ничего не говорит о пользователе. Если
встретить эту запись в журнале, то мы даже не поймем, к какому сервису
обращались.

Чем больше мы углубляемся в технические детали, тем меньше знаем о бизнесе. В
мире HTTP нет понятия пользователя. Известны лишь метод, адрес и другие
поля. Разделим ошибку на две половины. Ее верхняя часть называет бизнес-причину:
не найден пользователь с номером 42. Почему? Из-за технического сбоя: запрос
\spverb|GET| к адресу \spverb|http://api.company.com/user/42| вернул ответ с
кодом 404.

Расставим в коде дополнительные \spverb|try/catch|. Когда исключение пришло из
технических недр, мы дополняем его контекстом и отправляем наверх. Этот паттерн
называется \spverb|re-throw|, повторный выброс.

Улучшенный псевдокод:

\begin{verbatim}
func get-user(id):
  try {
    let url = "http://api.company.com/user/" + str(id)
    return http.GET(url).body.json()
  } catch error {
    let message = "Cannot fetch a user #" + str(id)
    throw Error(message, cause=error)
  }
\end{verbatim}

Новое исключение описывает бизнес-проблему, но и при этом ссылается на
техническую. Это еще не конечая точка, у HTTP-ошибки тоже своя причина. Это
может быть сбой сети, устаревший сертификат, не тот пароль. Так образуется
цепочка исключений. В реальных проектах они достигают пять и более звеньев.

Спуск по цепочке напоминает допрос. На каждое <<почему>> мы получаем новую пищу
для размышлений, пока не доберемся до сути. Это не значит, что самое нижнее
исключение важнее других. Одно лишь \spverb|HTTPError| не описывает
ситуацию. Важно то, как мы к нему пришли.

Так работают исключения в промышленных языках: Java, Python и других. Каждая
платформа несет особенности, но в целом картина не меняется. Теперь рассмотрим,
что предлагает Clojure.

\section{Переходим к Clojure}

Чтобы познакомиться с исключением, спровоцируем его. Подойдет старый, как мир,
прием~--- поделить число на ноль. Откройте сеанс REPL и выполните:

\begin{verbatim}
(/ 1 0)
\end{verbatim}

\noindent
Появится похожий текст:

\begin{verbatim}
Execution error (ArithmeticException) at user/eval5848...
Divide by zero
\end{verbatim}

Это отчет об ошибке. В зависимости от редактора и настроек оно выглядит
по-разному. Например, Emacs с модулем Cider откроет дополнительный буфер
\spverb|*cider-error*| с подробной информацией.

Заметим, что исключение в REPL не завершает его. От нас по-прежнему ждут
команды. В боевом режиме программы на Clojure ведут себя как обычно. Если в
главном потоке не поймано исключение, программа остановится.

Чтобы поймать исключение, код помещают в форму \spverb|try|. За ним следует одна
и более форм \spverb|catch|. В них указывают, какие классы перехватывать и что
делать с экземпляром. Вот как безопасно разделить число:

\begin{verbatim}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
\end{verbatim}
%% -----------------
Форма \spverb|catch| принимает класс исключения и символ, с которым будет связан
пойманный экземпляр. В нашем случае это \spverb|ArithmeticException| и символ
\spverb|e|. Далее следует произвольный код. Выражения этого кода обращаются к
исключению как к локальной переменной \spverb|e|.

В примере выше мы просто вывели на экран текст о том, что вычисления прошли
неудачно. Но могли бы извлечь сообщение. Метод \spverb|.getMessage| класса \spverb|Throwable|
возвращает текст исключения. Начиная с версии 1.10 Clojure предлагает функцию
\spverb|ex-message|, которая делает то же самое:

\begin{verbatim}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println (ex-message e))))

;; Divide by zero
\end{verbatim}

Класс \spverb|ArithmeticException| ловит не все ошибки, связанные с вычислениями. Что
случится, если сложить 1 и \spverb|nil|? Даже если поместить расчеты в try/catch, это
не спасет от ошибки:

\begin{verbatim}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics")))

;; Execution error (NullPointerException) at user/eval6159
\end{verbatim}

Дело в том, что классы \spverb|ArithmeticException| и \spverb|NullPointerException| не
пересекаются с друг с другом. У них разные пути в дереве исключений, которое мы
обсуждали в начале главы. Поэтому перехват одного не влияет на другой. Это
правильно, потому что семантика классов разная. Ошибка в арифметике это не то же
самое, что \spverb|Null| вместо значения.

Форма \spverb|try| принимает несколько форм \spverb|catch|. Вот как перехватить оба случая:

\begin{verbatim}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics"))
  (catch NullPointerException e
    (println "You've got a null value")))
\end{verbatim}

Макрос перебирает классы из каждого \spverb|catch|. Он остановится на первом подходящем
варианте. Результатом \spverb|try| станет последнее выражения из блока \spverb|catch|, который
подошел. В примере выше результат будет \spverb|nil|, потому что это значение вернет
функция \spverb|println|. Если ни один вариант не поймал исключение, оно продолжит путь
вверх по стеку вызовов.

Ранее мы упоминали, что чем выше класс исключения в дереве, тем больше ситуаций
он поймает. Если заменить \spverb|ArithmeticException| на \spverb|Throwable|, такой \spverb|catch|
перехватит любое исключение, будь то деление на ноль или \spverb|Null|:

\begin{verbatim}
(try
  (/ 1 0)
  (+ 1 nil)
  (catch Throwable e
    (println "I catch everything")))
\end{verbatim}

В отличие от Java, в мире Clojure нет строгих правил о том, какие исключения
перехватывать. Этот вопрос остается на усмотрение разработчика. Здравый смысл
подсказывает, что перехват \spverb|Throwable| опасен. Создается ложное ощущение, что
код работает без ошибок.

В случае в \spverb|ArithmeticException| проблема очевидно в расчетах, но для
\spverb|NullPointerException| это не так. \spverb|Nil| вместо числа говорит о том, что
проблема не в арифметике, а в функции, которая вернула \spverb|nil|. Иными словами,
ошибка кроется в другом месте. Вот почему перехват \spverb|NullPointerException| вредит
разработке.

Форму \spverb|try/catch| с широким классом ставят на верхних уровнях кода. Например,
когда важно, чтобы программа не прекращала работу никогда. Такой подход
используют в HTTP-серверах, при обработке сообщений из очередей, в сетевом ПО.

Иногда мы намеренно бросаем исключения, чтобы сообщить о нештатной
ситуации. Форма \spverb|throw| принимает объект исключения и запускает стандартный
механизм выброса. Оператор \spverb|new| создает новый Java-объект. Ему передают класс и
параметры конструктора:

\begin{verbatim}
(let [e (new Exception "something is wrong")]
  (throw e))
\end{verbatim}

Сообщение такого рода не информативно. Даже если мы указали, что проблема в
арифметике или базе данных, хотелось бы знать, какие именно значения были на
момент ошибки. Поэтому сообщение строят функцией format. Она принимает шаблон и
параметры подстановки:

\begin{verbatim}
(defn add [a b]
  (when-not (and a b)
    (let [message (format "Value error, a: %s, b: %s" a b)]
      (throw (new Exception message))))
  (+ a b))
\end{verbatim}

Если вызвать функцию выше с одним и параметров \spverb|nil|, текст сообщения будет
информативнее:

\begin{verbatim}
Execution error at book.exceptions/add (exceptions.clj:86).
Value error, a: 1, b: null
\end{verbatim}

Функция \spverb|format| хороша тем, что отображает \spverb|nil| как null. Это значимое
преимущество перед \spverb|str|, которая трактует nil как пустую строку. Вариант с
\spverb|str| выглядит так:

\begin{verbatim}
(str "Value error, a:" 1 ", b: " nil)
;; Value error, a:1, b:
\end{verbatim}

Результат вводит в заблуждение. Это мы потеряли значение \spverb|b|? Или \spverb|b| пустая
строка? Непонятно.

\section{Контекст ошибки}

Выше мы упоминали, что запись данных в текст~--- рискованное занятие. Сообщение
может оказаться слишком большим или выдать лишние сведения. Проблему решает
класс \spverb|ExceptionInfo|. Это особое исключение из поставки Clojure. Оно
спроектировано так, чтобы хранить произвольные данные. Вместе с ним Clojure
предлагает набор функций, чтобы упростить работу.

Ключевая функция \spverb|ex-info| создает экземпляр \spverb|ExceptionInfo|. Она принимает
сообщение и словарь данных. Это контекст, в котором возникло
исключение. Например, если не удалось выполнить HTTP-запрос, полезно указать в
словаре HTTP-метод и адрес запроса.

\spverb|Ex-info| только создает исключение, но не бросает его. Поэтому вызов \spverb|ex-info|
сразу передают в \spverb|throw|:

\begin{verbatim}
(throw (ex-info
        "Cannot get the data from remote server."
        {:user 42
         :http-method "POST"
         :http-url "http://some.host/api"}))
\end{verbatim}

В примере выше мы разделили сообщение и данные. Сообщение не выдает номер
пользователя и адрес подсистемы. Текст запишут в лог или отправят пользователю,
а контекст обработают отдельно.

При работе с контекстом помните несколько правил. Словарь не может быть
\spverb|nil|. Конструктор \spverb|ExceptionInfo| проверяет значение на \spverb|Null| и бросает ошибку
входных параметров. Нежелательно хранить в словаре значения, которые не
сериализируются. Например, поток или сетевое подключение. В идеале контекст
можно записать в JSON-документ. Позже мы рассмотрим, что делать с данными
контекста.

Функция \spverb|ex-data| возвращает данные из пойманного исключения. Если это было
\spverb|ExceptionInfo|, мы получим словарь. Если исключение другого типа, то \spverb|nil|.

Вообразим, что в модуле объявлена функция \spverb|authorize-user|. При неудачных
обстоятельствах она выкидывает исключение как в последнем примере. Код из формы
\spverb|catch| получает его контекст и разбивает на отдельные ключи. Затем формирует
строку.

\begin{verbatim}
(try
  (authorize-user 42)
  (catch Exception e
    (let [data (ex-data e)
          {:keys [http-method http-url]} data]
      (format "HTTP error: %s %s" http-method http-url))))

;; HTTP error: POST http://some.host/api
\end{verbatim}

\section{Когда бросать исключения}

На этом этапе читатель наверняка сомневается, в каких случаях кидать исключения,
а когда ограничиться проверкой. Действительно, эту тему обходят стороной
большинство материалов по Clojure. Рассмотрим типовые ситуации и оптимальные
решения.

\emph{При обработке коллекций} вам не нужно бросать исключения. Как правило, в этом
не возникает потребности. Коллекции Clojure спроектированы так, что проблемы
\spverb|nil| пройдут мимо вас незамеченными. Например, значение \spverb|nil| трактуется как
пустая коллекция, поэтому выражения:

\begin{verbatim}
(assoc nil :test 42)
(update nil :test (fnil inc 0))
(into nil [1 2 3])
(merge nil {:test 42})
\end{verbatim}

вернут коллекции. Любой ключ от \spverb|nil| вернет \spverb|nil|, ровно как и разбор словаря
или вектора на отдельные переменные сообщает им \spverb|nil|, если подстановка не
сработала:

\begin{verbatim}
(let [{:keys [a b c]} nil]
  [a b c])

(let [[a b c] nil]
  [a b c])
\end{verbatim}

Оба случая вернут вектор из трех \spverb|nil|, исключения не произойдет.

Термин "nil punning" означает лояльность к \spverb|nil|. С таким подходом ситуацию с
пустым значением разрешают без ошибок. Нельзя утверждать, что Clojure целиком
nil punning. Пустое значение не влияет на коллекции, но не работает с
арифметикой, регулярными выражениями и в других случаях.

Если вы сомневаетесь в коллекции перед ее обработкой, используйте
спеку. Вспомните \spverb|s/valid?| и \spverb|s/conform| из [прошлой главы][clj-spec]. Тем
самым вы отделите стадию проверки от обработки. Если валидация не прошла,
бросайте исключение. Передайте в контекст данные \spverb|s/explain-data|, чтобы
разобрать их позже.

\begin{verbatim}
(require '[clojure.spec.alpha :as s])

(s/def ::data (s/coll-of int?))

(when-let [explain (s/explain-data ::data [1 2 3])]
  (throw (ex-info "Validation failed" {:explain explain})))
\end{verbatim}

Другой случай, когда прибегают к исключениями~--- это \emph{отказ ресурса}. Если не
удалось считать файл, недостаточно просто сказать об этом. Возможны десятки
причин: файла нет, он занят другим процессом, кончилось место на диске, ошибка в
кодировке. От причины зависит, кто будет ее исправлять и как доработать
окружение, чтобы не допустить ошибку снова.

Бывает, функция доступа к ресурсу не бросает исключение. Это справедливо для
различных HTTP API. Согласно протоколу HTTP, ответ со статусом 404 такой же
верный, как и 200. В индустрии нет единого мнения о том, стоит ли бросать
исключение на негативные HTTP-ответы. Как правило, библиотеки предлагают флаг,
который регулирует это поведение.

Посылая HTTP-запрос, мы передаем флаг с семантикой "не бросать исключение". Тем
самым мы гарантируем, что исключение возникнет только в аварийных случаях вроде
проблем соединения. Но сетевое взаимодействие пройдет без ошибок. Затем
анализируем ответ. Если код не был положительным, бросаем исключение. В его
контекст передаем основные части запроса и ответа: метод, адрес, статус.

В примере ниже функция, которая извлекает данные о пользователе из сервиса
авторизации. Это слегка измененный код из реального проекта. Обмен с сервисом
происходит по протоколу HTTP. В качестве клиента используем библиотеку
\spverb|clj-http|.

\begin{verbatim}
(defn auth-user
  [user-id]
  (let [url "http://auth.company.com"
        params {:form-params {:user-id user-id}
                :throw-exceptions? false
                :coerce :always
                :as :json
                :content-type :json}
        response (client/post url params)
        {:keys [status body]} response]

    (if (= status 200)
      body
      (throw (ex-info "Authentication error"
                      {:user-id user-id
                       :url url
                       :http-status status
                       :http-body body})))))
\end{verbatim}

Еще один случай, когда пригодятся исключения~--- \emph{библиотеки}. Весь код условно
делится на два типа: исполнение и координация. Библиотеки относятся с
исполнительному коду. На уровне библиотеки мы не знаем, в разрезе какой логики
будет запущен код. В одной ситуации ошибка критична, в другой нет.

Если бросить исключение на уровне исполнения, бизнес-логика вправе перехватить
его и продолжить работу. Но если исполнитель молча подавляет ошибки, это чревато
неожиданным поведением. Сюда же относится паттерн "вернуть nil и записать в
лог". Это банальное игнорирование проблемы.

\section{Подробнее о цепочках}

Выше мы говорили про цепочки исключений. Рассмотрим, как формировать их на
практике. Функция \spverb|ex-info| принимает третий необязательный параметр
\spverb|cause|. Это либо \spverb|nil|, либо другое исключение. Оно становится частью нового
экземпляра. В примере ниже функция divide перехватывает ошибку деления. Затем
оборачивает ее в другое исключение с контекстом.

\begin{verbatim}
(defn divide [a b]
  (try
    (/ a b)
    (catch ArithmeticException e
      (throw (ex-info
              "Calculation error"
              {:a a :b b}
              e)))))
\end{verbatim}

Функция \spverb|ex-cause| возвращает исключение-причину, если оно было передано в
\spverb|ex-info|. Если причины нет, результат будет nil.

\begin{verbatim}
(try
  (divide 1 0)
  (catch Exception e
    (-> e ex-message println)
    (-> e ex-cause ex-message println)))
\end{verbatim}

Этот код выведет строки:

\begin{verbatim}
Calculation error
Divide by zero
\end{verbatim}

Пример выше неаккуратен. Мы не можем быть уверены, что у исключения строго одна
причина. Их может быть много или ни одной. Напишем функцию, которая вернет
последовательность исключений. Расположим их по убыванию старшинства. На первом
месте самое главное, на втором его причина, затем причина причины и так
далее. Проще всего сделать это формой \spverb|loop|:

\begin{verbatim}
(defn ex-chain [e]
  (loop [e e
         result []]
    (if (nil? e)
      result
      (recur (ex-cause e) (conj result e)))))
\end{verbatim}

Для экспериментов объявим переменную \spverb|e|. Она понадобится здесь и ниже по тексту
главы, чтобы проверять код. Это будет цепочка из трех звеньев. На ее первом
уровне ошибка бизнес-логики: не удалось извлечь данные о пользователе. На втором
уровне техническая проблема, что-то не так с авторизацией. На третьем ошибка
транспорта: не прошел HTTP-запрос.

\begin{verbatim}
(def e
  (ex-info
   "Get user info error"
   {:user-id 42}
   (ex-info "Auth error"
            {:api-key "........."}
            (ex-info "HTTP error"
                     {:method "POST"
                      :url "http://api.site.com"}))))
\end{verbatim}

Это дерево искючений, но не всегда удобно работать с деревом. Плоская структура
лучше поддается обходу. Здесь и пригодится \spverb|ex-chain|. Вот как получить
сообщения всех звеньев в том же порядке:

\begin{verbatim}
(map ex-message (ex-chain e))

("Get user info error" "Auth error" "HTTP error")
\end{verbatim}

А вот как вывести их на экран:

\begin{verbatim}
(doseq [e (ex-chain e)]
  (-> e ex-message println))

;; Get user info error
;; Auth error
;; HTTP error
\end{verbatim}

Выразим \spverb|ex-chain| короче и изящней через \spverb|iterate|. Это функция, которая шаг за
шагом применяет другую функцию к аргументу. Ограничение \spverb|take-while some?| нужно
для того, чтобы остановиться на первом же \spverb|nil|-элементе.

\begin{verbatim}
(defn ex-chain
  [^Exception e]
  (take-while some? (iterate ex-cause e)))
\end{verbatim}

\section{Печать исключения}

Разберемся, что делать с пойманным исключением. В приложении что-то пошло не
так, и форма \spverb|try/catch| на вершине стека вернула экземпляр ошибки. Как с ним
посупить?

Самое простое, что можно сделать с исключением~--- вывести в консоль. Функция
\spverb|println| достаточно умна. Она выводит не только верхний уровень, но и всю
цепочку исключений. Для каждого уровня функция печатает путь к классу, словарь
данных и текст.

Самое нижнее исключение в цепочке иногда наывают корнем, root. Для нашего
удобства \spverb|println| дублирует корень в начале вывода. Так мы сразу увидим
первопричину ошибки. Вот что напечатает выражение \spverb|(println e)|:

\begin{verbatim}
#error {
 :cause HTTP error
 :data {:method POST, :url http://api.site.com}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Get user info error
   :data {:user-id 42}
   :at [clojure.lang.AFn applyToHelper AFn.java 160]}
  {:type clojure.lang.ExceptionInfo
   :message Auth error
   :data {:api-key .........}
   :at [clojure.lang.AFn applyToHelper AFn.java 160]}
  {:type clojure.lang.ExceptionInfo
   :message HTTP error
   :data {:method POST, :url http://api.site.com}
   :at [clojure.lang.AFn applyToHelper AFn.java 156]}]
 :trace
 [[clojure.lang.AFn applyToHelper AFn.java 156]
  [clojure.lang.AFn applyTo AFn.java 144]
  [clojure.lang.Compiler$InvokeExpr eval Compiler.java 3701]
  [clojure.lang.Compiler$DefExpr eval Compiler.java 457]
  [clojure.lang.Compiler eval Compiler.java 7181]
  ..........]}
\end{verbatim}

Многоточия на конце скрывают часть стек-трейса. Это Java-методы, через которые
прошло исключение с момента выброса до перехвата. Каждый элемент трейса это
вектор с именем класса, метода, файла и номера строки.

Выше мы сократили трейс, чтобы не тратить на него полезное пространство. В
реальности трейсы очень длинные и порой достигают нескольких экранов. Это
справедливый упрек в адрес Clojure. Действительно, трейсы несут скудную
информацию и зашумляют вывод.

Цепочки исключений с контекстом несут больше пользы, чем стек-трейс. Фактически,
цепочка~--- это альтернативный трейс, построенный на данных. Различие в том, что
он компактней и в целом больше ориентирован на человека, чем машинный список
методов.

Пакет \spverb|clojure.stacktrace| предлагает несколько функций для печати
исключений. Так, \spverb|print-throwable| печатает класса и данные исключения без
трейса и цепочки причин.

\begin{verbatim}
(clojure.stacktrace/print-throwable e)
\end{verbatim}

Результат:

\begin{verbatim}
clojure.lang.ExceptionInfo: Get user info error
{:user-id 42}
\end{verbatim}

Вывод на печать легко захватить в строку макросом \spverb|with-out-str|. Форма ниже
ничего не напечатает, но вернет строку:

\begin{verbatim}
(with-out-str
  (clojure.stacktrace/print-stack-trace e))
\end{verbatim}

Отдельные функции \spverb|print-stack-trace| и \spverb|print-cause-trace| печатают трейсы
исключений. Вывод каждой из них можно ограничить параметром \spverb|n|, максимальной
глубиной трейса.

\section{Логирование}

Печать исключений считается слабой практикой. Это частный случай, когда мы хотим
зафиксировать ошибку для дальнейшего разбора. Печать в стандартный поток не
подходит для этого по многим причинам.

Для любого сообщения важны его \emph{вспомогательные данные}: время, модуль, номер
процесса. Сообщения различают по уровню критичности: информационное,
предупреждение, ошибка. Оператор печати не сообщает эти сведения, а их ручной
сбор увеличит код.

Если программа работает на многих серверах, сбор сообщений должен быть
\emph{централизованным}. Представьте, что администратор переключается между сотней
машин, чтобы читать логи. Передача сообщений по сети подсказывает, что для
каждого сообщения нужно знать адрес машины, с которой оно было отправлено.

Не все сообщения одинаково полезны. Некоторые библиотеки порождают сотни
отладочных сообщений в минуту. К ним прибегают только в редких случаях,
например, при потере данных. Нужен механизм, чтобы \emph{подавлять лишние
сообщения} по некоторым признакам.

Наконец, консоль или файл~--- далеко \emph{не единственные каналы данных}. Особо
важные сообщения пишут в журнал операционной системы, отправляют на почту, в
чаты с помощью ботов или даже в смс ответственным лицам.

Названные выше проблемы разрешает логирование. Это центральная система, которая
фиксирует сообщения от разных частей программы.

Библиотека \spverb|clojure.tools.logging| предлагает набор функций и макросов, чтобы
записывать сообщения. Это сторонняя библиотека, поэтому перед использованием
добавьте ее в зависимости:

\begin{verbatim}
[org.clojure/tools.logging "0.4.1"]
\end{verbatim}

Импортируем библиотеку и запишем простое сообщение:

\begin{verbatim}
(require '[clojure.tools.logging :as log])

(log/info "A message from my module")
\end{verbatim}

В REPL-сессии появится запись лога:

\begin{verbatim}
INFO: A message from my module
\end{verbatim}

Видим, что лог дополняет сообщение уровнем критичности.

В Clojure логирование устроено из двух уровней. Верхний уровень~--- это макросы
\spverb|log/info|, \spverb|log/error| и другие. Второй уровень называют бекендом. Под ним
понимают Java-библиотеку, которая непосредственно пишет сообщения в файлы,
отправляет их по сети и выполняет всю работу.

Такое устройство на первый взгляд кажется необычным, но на практике несет
преимущества. Исторически сложилось так, что для Java написано много библиотек
логирования. Каждая из них предлагает свои классы и методы. Если проект явно
использует одну из библиотек, то переход на другую вынуждает править код.

В Clojure эту проблему решили на уровне дизайна библиотеки. Модуль \spverb|logging| в
момент старта ищет библиотеки \spverb|Logback|, \spverb|Log4j| и другие. Если ничего не
найдено, он использует стандартный \spverb|java.util.logging|.

Из этого правила следует, что достаточно добавить бекенд логирования в
зависимости, чтобы он начал работать. Большинство библиотек автоматически ищут
свои настройки в текущем пути. Например, если в папку \spverb|resources| подложить
специальный XML-файл для бекенда, он прочтет его в момент старта и применит
настройки.

Из бекендов большой популярностью пользуется проект \spverb|Logback|. От аналогов его
отличает большой выбор т.н. аппендеров (appenders). Так называют пункт
назначения, куда писать сообщения. Это может быть файл с автоматической
ротацией, удаленный \spverb|syslog|, почтовый сервер и много что еще. Чтобы добавить
Logback в проект, добавьте в зависимости запись:

\begin{verbatim}
[ch.qos.logback/logback-classic "1.2.3"]
\end{verbatim}

В папку resources положите файл logback.xml следующего содержания:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <charset>UTF-8</charset>
      <pattern>%date{ISO8601} %-5level %logger{36} - %msg %n</pattern>
    </encoder>
  </appender>
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
\end{verbatim}

Это укороченный пример конфигурации. В данном случае мы задали appender для
вывода в консоль. Под тегом \spverb|pattern| указан шаблон сообщения. Параметры шаблона
начинаются со знака процента. Подстановка \spverb|%msg| означает текст сообщения,
\spverb|%date|~--- дату и ее формат в фигурных скобках.

Теперь записанное сообщение выглядит так:

\begin{verbatim}
(log/info "Hello Logback!")
\end{verbatim}

\begin{verbatim}
2019-05-03 17:36:04,001 INFO  book.exceptions - Hello Logback!
\end{verbatim}

Макросы \spverb|log/info|, \spverb|log/error| и другие допускают, что первым аргументом может
быть не текст, а пойманное исключение. В этом случае бекенд запишет исключение в
лог. Выше мы объявили переменную \spverb|e| для экспериментов. Воспользуемся ей:

\begin{verbatim}
(log/error e "Error while processing the request")
\end{verbatim}

Сокращенный результат:

\begin{verbatim}
2019-05-03 17:41:03,913 ERROR book.exceptions - Error while processing the request
clojure.lang.ExceptionInfo: Get user info error
	at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
	at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
	... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
	at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
	... 31 common frames omitted
\end{verbatim}

Для экономии места мы удалили строки трейса, так как они не несут пользы. Из
примера видно, что цепочка исключений состоит из трех звеньев. Это совпадает с
определением переменной \spverb|e|. Проблема в том, что у каждого звена пропали его
данные. Logback практикует Java-подход в работе с исключениями. В мире Java
принято искать ошибку по стек-трейсу, а не данным.

Logback предлагает несколько модификаций для вывода исключений. Они влияют на
длину и детализацию трейса, но игнорируют данные. Аналогично ведут себя Log4j и
другие библиотеки.

Общее решение проблемы в том, чтобы задать в конфигурации путь к специальному
классу. Как правило, библиотека содержит стандартный класс, который переводит
исключение в строку. Достаточно унаследовать его, переопределить нужный метод и
указать в конфигурации.

Это довольно сложный путь. Чтобы унаследовать класс в Clojure, нужны навыки
работы с Java выше среднего. Придется читать документацию к конкретной
библиотеке, исследовать ее классы и интерфейсы.

Такое решение завязано на конкретную библиотеку. Класс для Logback не будет
работать с Log4j и наоборот. В мире Clojure это называют "не Clojure-way", то
есть не тот способ, которому принято следовать.

Напишем свою функцию для логирования ошибок. Пусть она принимает исключение и
переводит его в текст, как удобно нам. Затем пишет текст в лог с уровнем
\spverb|error|.

Чтобы вывести все данные об ошибке, потребуется обойти цепочку исключений. Выше
мы определили \spverb|ex-chain| для этой цели. Функция \spverb|ex-print| пробегается по
цепочке и печатает данные в консоль. Если нужна строка, вызов \spverb|ex-print|
оборачивают в \spverb|with-out-str|:

\begin{verbatim}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
\end{verbatim}

Результат выглядит приятнее, чем пирамида из трейсов. Четко видны данные,
которые привели к ошибке:

\begin{verbatim}
clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 42}
clojure.lang.ExceptionInfo
  Auth error
  {:api-key "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST", :url "http://api.site.com"}
\end{verbatim}

Осталось собрать функцию для записи в лог. Вот она:

\begin{verbatim}
(defn log-error
  [^Throwable e & [^String message]]
  (log/error
   (with-out-str
     (println (or message "Error"))
     (ex-print e))))
\end{verbatim}

Функцию можно вызвать с дополнительным сообщением или без. Если сообщения не
было, запишем нейтральное "Error". Чтобы сообщение и тело исключения не
слипались, используем \spverb|println|. Эта функция добавляет перенос строки в конец.

\begin{verbatim}
(log-error e)
(log-error e "An error occurred during request")
\end{verbatim}

Последнее выражение запишет в лог следующее:

\begin{verbatim}
2019-05-03 19:00:05,590 ERROR book.exceptions - An error occurred during request
clojure.lang.ExceptionInfo
  Get user info error
  ...
\end{verbatim}

Сообщения об ошибках принято отделять от остальных записей. Для этого заводят
минимум два аппендера: консоль и файл. В консоль выводят все сообщения, чтобы
программист был в курсе дела. Ошибки требуют ответной реакции, поэтому их
записывают в файл. Позже этот файл анализируют вручную или специальными
программами.

\section{Исключения как данные. Сбор исключений}

В прошлом разделе мы придумали как показать исключение в удобном виде. В широком
смысле речь шла о том, как выразить исключение текстом. Это важный рубеж. Как
только способ найден, вы сможете передать исключение в файле, письме и даже на
бумаге.

Недостаток текста в том, что он не структурирован. С точки зрения кода это
цепочка символов, и нет данных о том, что есть что. Наоборот, при сборе ошибок
важно выделить их ключевые данные, например, тип, подсистему, модуль. Это
необходимо по следующим причинам.

\emph{Предотвратить дублирование.} Во время наплыва пользователей может вскрыться
ошибка, которую не заметили ранее. Если каждый раз писать исключение в файл,
получим десятки тысяч одинаковых записей. Это не имеет смысла, расточительно в
плане ресурсов, затрудняет поиск. Вдруг среди них закралось еще одно исключение?

Системы сбора ошибок научились определять схожесть исключений по особым
правилам. С точки зрения текста сообщения "user 1 not found" и "user 2 not
found" отличаются. Но система сбора схлопнет их в одну ошибку и по запросу
покажет все варианты.

\emph{Поиск.} Невозможно устроить эффективный поиск по данным без структуры. Когда
ошибки в виде текста, приходится искать только по вхождению слова или
регулярному выражению. Такой поиск нерелевантен, то есть не учитывает, насколько
точно сущность совпадает с запросом. Еще он не учитывает дубли. Мы бы не хотели
видеть тысячу одинаковых сообщений в выдаче.

\emph{Статистика.} Когда ошибки разобраны на составные части, можно строить
отчеты. Например, сколько ошибок случилось за последний месяц или
год. Группировать данные по системам или командам. Выявить проекты, где ошибки
случаются чаще всего.

\emph{База знаний.} В системе сбора каждая ошибка становится артефактом. К ней
пишут комментарии, прикрепляют скриншоты или записи с экрана. Хорошей практикой
будет ставить ссылку на артефакт в пулл-реквест. В широком плане польза в том,
что на ошибку всегда можно сослаться как на документ. Если ошибки хранятся в
текстовых файлах, это невозможно.

Среди прочих систем достойно выглядит Sentry. Это приложение на Python и
Django. Sentry работает как веб-сервер. На главной страницы видны проекты и
краткая статистика по ним. Каждый проект накапливает ошибки, которые он получил
от клиентов.

Чтобы отправить ошибку в Sentry, приложение обращается к нему HTTP API методом
POST. В теле передают JSON-документ с различными полями. Протокол Sentry
предлагает несколько десятков полей, чтобы описать ошибку. Сюда входят параметры
физической машины, операционной системы, контекст HTTP-запроса, стек-трейс и
другие.

Как правило, приложение не формирует эти данные вручную, а пользуется готовыми
библиотеками. Часто они называются Raven или похожим образом. Имеется в виду,
%% сторожевой ворон (анг. raven) несет вести дозорному (анг. sentry). TODO

%% [sentry-clj]: https://github.com/getsentry/sentry-clj TODO
%% [raven]: https://github.com/exoscale/raven TODO

Для Clojure написаны две библиотеки к Sentry: [getsentry/sentry-clj][sentry-clj]
и [exoscale/raven][raven]. Первая опирается на официальную Java-библиотеку. Это
частая практика в мире Clojure~--- не писать код с нуля, а предоставить обвязку
%% вокруг проверенной Java-библиотеки. TODO

Чтобы воспользоваться sentry-clj, добавьте зависимость в проект:

\begin{verbatim}
[io.sentry/sentry-clj "0.7.2"]
\end{verbatim}

На первом шаге инициализируйте библиотеку с нужным DSN. Под DSN понимают
уникальный адрес проекта в Sentry. Проект объединяет сообщения по какому-то
глобальному признаку. Например, ошибки бекенда в одном проекте, фронтенда~--- во
втором, мобильного приложения~--- в третьем. Получить DSN проекта можно на
странице его дополнительной информации в разделе "интеграция".

\begin{verbatim}
(require '[sentry-clj.core :as sentry])

(def DSN "https://.....@sentry.io/.....")

(sentry/init! DSN)
\end{verbatim}

Теперь когда проект задан, отправим сообщение. Функция \spverb|send-event| принимает
словарь параметров сообщения. Нас интересует сценарий, когда мы поймали
исключение и хотели бы отправить его без лишних усилий. Достаточно передать ключ
\spverb|:throwable| с экземпляром исключения:

\begin{verbatim}
(sentry/send-event {:throwable e})
\end{verbatim}

Sentry вернет номер сообщения, а в проекте появится новая запись Предположим, мы
передали эксземпляр \spverb|e|, который объявили выше. Это цепочка из трех
исключений. В веб-интерфейсе увидим информацию о каждом из них. В поле \spverb|:extra|
будут данные верхнего звена исключения, то есть словарь \spverb|{:user-id 42}|.

Недостаток \spverb|sentry-clj| в том, что он полагается на Java-библиотеку. Вспомним,
что в мире Java не популярны принципы, которые мы обсуждали в этой
главе. Например, хотелось бы иметь данные со всех уровней, а не только
верхнего. Иначе мы не узнаем, какой был API-ключ, по какому адресу мы обращались
в сеть и другие детали. Технически возможно собрать эти данные вручную и
передать в ключ \spverb|:extra|. Но будет привильней научить этому библиотеку.

Это и другие замечания исправлены в \spverb|exoscale/raven|. Библиотека написана на
Clojure и потому более гибка. С недавний версий она передает максимально полные
данные об исключении. Подключите ее в проект:

\begin{verbatim}
[exoscale/raven "0.4.8"]
\end{verbatim}

и отправье исключение \spverb|e|:

\begin{verbatim}
(require '[raven.client :as raven])

(raven/capture! DSN e)
\end{verbatim}

Теперь откройте сообщение в Sentry и промотайте вниз. В секции \spverb|extra| будет
ключ \spverb|:via| с очень детальной информацией:

\begin{verbatim}
[ {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "Get user info error",
  "data" : {
    "user-id" : 42
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 160 ]
}, {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "Auth error",
  "data" : {
    "api-key" : "........."
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 160 ]
}, {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "HTTP error",
  "data" : {
    "method" : "POST",
    "url" : "http://api.site.com"
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 156 ]
} ]
\end{verbatim}

Это вектор словарей, где каждый словарь состоит из класса исключения, его
сообщения и данных. В поле \spverb|:at| вектор четырех элементов. Это класс, метод, имя
файла и строка, на которой возникло исключение. С таким отчетом расследовать
инцидент становится проще.

Структуру выше легко получить в любом месте Clojure. Нам доступна функция
\spverb|Throwable->map|. Она принимает исключение и возвращает словарь с ключами
\spverb|:via|, \spverb|:cause| и другими. В этом словаре вся информация об исключении, в
т.ч. цепочка исключений и трейс.

Зачем нужна функция, если ту же информацию можно извлечь самостоятельно?
Преимущество в том, что результат \spverb|Throwable->map| состоит из структур и типов
Clojure. Это комбинация словарей, векторов и символов. Такой словарь
обрабатывают как обычную Clojure-коллекцию. Его легко записать в форматы EDN или
JSON.

Ключ \spverb|:via| представляет особую ценность. Это те данные, что мы привели выше:
цепочка исключений с данными. Вот как извлечь их:

\begin{verbatim}
(-> e Throwable->map :via)
\end{verbatim}

Теперь когда вы знакомы с логированием и Sentry, напишем защитный декоратор для
Ring-приложения. Напомним, мы разобрали декораторы [в главе про
веб-разработку][clj-web]. Такой декоратор ставят на вершину стека middleware. Он
перехватывает все потенциальные ошибки, отправляет в Sentry и возвращает
нейтральный ответ о том, что запрос не удался.

\begin{verbatim}
(defn wrap-exception
  [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        (try
          (raven/capture! DSN e)
          (catch Exception e-sentry
            (log/errorf e-sentry "Sentry error: %s" DSN)
            (log/error e "HTTP Error"))
          (finally
            {:status 500
             :body "Internal error, please try later"}))))))
\end{verbatim}

Обратите внимание, что запрос к Sentry тоже обернут в \spverb|try/catch|. Как мы
выяснили ранее, обращение в сеть потенциально несет ошибки. Sentry это отдельный
сервис и может быть недоступен. В противном случае мы пишем в файл оба
исключения: и оригинальное, и связанное с Sentry. Это лучше, чем просто
проигнорировать их.

\section{Переходы}

До сих пор мы рассматривали исключения как оповещения об ошибке. Вспомним
ключевое свойство исключения. Оно прерывает исполнение и всплывает вверх, пока
не будет поймано. Поэтому иногда исключения трактуют как моментальный прыжок
вверх по стеку.

Действительно, если бросить какое-то специфичное исключение, например
\spverb|MyGOTOException|, а вызов сверху обернуть в \spverb|catch| с этим классом, то перед
нами классический оператор \spverb|GOTO|:

\begin{verbatim}
(try
  (do-first-step)
  (do-second-step)
  (when (condition)
    (throw (new MyGOTOException)))
  (do-third-step)
  (catch MyGOTOException e
    (println "Skipped the third one")))
\end{verbatim}

Если что-то пошло не так, мы прыгаем через третий шаг. Трюк называют "исключение
как способ управления исполнением".

Это очень противоречивая практика, и прибегать к ней следует с
осторожностью. Исключения не были задуманы для подобных рывков. Тот, кто
злоупотребляет прыжками по коду, использует инструмент не по назначению. Код
становится неочевидным и трудным в поддержке.

Все же, порой бывают моменты, когда нужно прервать текущий запрос на
середине. Например, мы выяснили, что у пользователя нет прав на доступ к
ресурсу, поэтому продолжать нет смысла.

Усложним задачу тем, что требуется выполнить ряд проверок, и на каждом отказе
прерывать исполнение. Для императивных языков это легкая задача. Код на Python
выглядел бы так:

\begin{verbatim}
class AccountHandler(RequestHandler):

  def on_get(self, request):

    if not self.check_this(request):
      return BadRequest("Wrong input data")

    if not self.check_that(request):
      return NotFound("No such an account")

    if not self.check_quotas(request):
      return QuotasReached("Request rate is limited")

    return JSONResponse(self.get_data_from_db())
\end{verbatim}

В Clojure нет оператора \spverb|return|. Результат нескольких форм это результат
последней. Мы не можем расположить несколько форм \spverb|if| на одном уровне друг под
другом. Это не имеет смысла, поскольку даже если какая-то из них вернет ложь,
исполнение перейдет к следующей форме.

Вариант с каскадным деревом работает, но выглядит слишком громоздко. Получилось
то, что называют The Pile of Doom, пирамида судьбы. Чем больше в ней уровней,
тем больше проблем у разработчика. Ради интереса добавьте новое условие в
середину:

\begin{verbatim}
(defn account-handler
  [request]
  (if (check-this request)
    (if (check-that request)
      (if (check-quotas request)
        {:status 200
         :body (get-data-from-db)}
        (quotas-reached "Request rate is limited"))
      (not-found "No such an account"))
    (bad-request "Wrong input data")))
\end{verbatim}

Подобный случай решают разными способами, в том числе исключениями. Библиотека
\spverb|metosin/ring-http-response| предлагает функции, которые выбрасывают исключения
с данными HTTP-ответа. В стек middleware добавляют особый декоратор, который
перехватывает такие исключения и возвращает ответ клиенту.

Добавьте библиотеку в проект:

\begin{verbatim}
[metosin/ring-http-response "0.9.1"]
\end{verbatim}

Теперь обработчик выглядит так:

\begin{verbatim}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler
  [request]

  (when-not (check-this request)
    (bad-request! "Wrong input data"))

  (when-not (check-that request)
    (not-found! "No such an account"))

  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))

  {:status 200
   :body (get-data-from-db)})
\end{verbatim}

Такой код похож на императивный. Некоторых разработчиков уязвляет факт, что в
Clojure мы пользуемся императивным подходом. Это нормально. Наша задача --
сделать так, чтобы код был максимально понятным и удобным в поддержке. Вопрос
какую парадигму при этом использовать остается на усмотрение команды.

Функции из модуля \spverb|ring.util.http-response| бывают с восклицательным знаком на
конце и без него. Это сигнал о том, что функция несет побочный эффект, в данном
случае бросает исключение. Так, \spverb|not-found!| бросает знакомый нам \spverb|ex-info|, в
теле которого HTTP-ответ со статусом 404.

Чтобы схема работала, добавим в стек middleware декоратор
\spverb|wrap-http-response|. Он ловит ошибки, выброшенные функциями с восклицательным
знаком, достает из них ответ и возвращает пользователю.

\begin{verbatim}
(require '[ring.middleware.http-response
           :refer [wrap-http-response]])

(def app
  (-> app-naked
      wrap-params
      wrap-session
      wrap-cookies
      wrap-http-response))
\end{verbatim}

Не злоупотребляйте исключениями для переходов. Убедитесь, что это крайняя
мера. Хорошо, если вы используете библиотеку, а не сиюминутное
решение. Преимущество библиотеки в том, что она несет документацию и опыт других
людей.

\section{Finally и контекстный менеджер}

Иногда мы выполняем код в рамках какого-то ресурса. Это может быть файл, сетевой
порт или база данных. В начале работы эти ресурсы "открывают", а в конце
"закрывают". В других терминах говорят, что кто-то занял ресурс, а затем
освободил его.

Когда ресурс занят, другие клиенты не могут пользоваться им в полной
мере. Например, открытый кем-то файл можно только читать, но не
изменять. Считается правильным освобождать ресурс сразу же, как только в нем
отпала потребность. Технически это сводится к вызову метода \spverb|.close| у объекта.

Этому может помешать непредвиденная ошибка. Если код, который работает с
ресурсом, не перехватил исключение, то файл или порт останется занятым до конца
работы программы. Чтобы гарантированно закрыть ресурс даже в случае ошибки,
прибегают к форме \spverb|finally|.

Эту форму ставят последней внутри \spverb|try|. Исключения в JVM устроены так, что
управление переходит в \spverb|finally| даже в случае исключения. Если ошибки не было,
\spverb|finally| срабатывает после основного кода из \spverb|try|. Если ошибка возникла,
\spverb|finally| будет выполнен в промежутке между ее появлением и выбрасыванием.

Вот как выглядит низкоуровневый доступ к файлу. В примере ниже мы записываем в
него несколько байт. Форма \spverb|finally| гаранитрует, что файл будет закрыт, даже
если если что-то пойдет не так.

\begin{verbatim}
(import '[java.io File FileWriter])

(let [out (new FileWriter (new File "test.txt"))]
  (try
    (.write out "Hello")
    (.write out " ")
    (.write out "Clojure")
    (finally
      (.close out))))
\end{verbatim}

Чтобы программист не забыл закрыть файл, современные языки предлагают
контекстные менеджеры. В зависимости от платформы это может быть класс, оператор
или макрос. Менеджер исполняет произвольный блок кода с дополнительными
эффектами. Он гарантирует, что перед блоком сработает логика входа, а после него
-- логика выхода. При этом выход сработает даже в том случае, если блок выбросил
исключение. Платформа удержит его, выполнит логику выхода и снова бросит.

В языке Python контекстный менеджер выполнен изящно. Это оператор \spverb|with|,
который ожидает объект. У объекта должны быть методы \spverb|__enter__| и \spverb|__exit__|,
которые вызываются в момент входа и выхода. Чаще всего \spverb|with| используют при
чтении файла. В методе \spverb|__exit__| срабатывает его закрытие:

\begin{verbatim}
with open("/path/to/file.txt", "w") as f:
    f.write("test")
\end{verbatim}

Не составит труда написать такой же менеджер в Clojure. Это будет макрос,
который принимает символ объекта для записи и путь к файлу. Объект назначается
первому символу. Форма \spverb|finally| гарантирует, что файл будет закрыт при выходе
из тела макроса.

\begin{verbatim}
(defmacro with-file-writer
  [[bind path] & body]
  `(let [~bind (new FileWriter (new File ~path))]
     (try
       ~@body
       (finally
         (.close ~bind)))))
\end{verbatim}

Пример:

\begin{verbatim}
(with-file-writer [out "test.txt"]
  (.write out "Hello macro!"))
\end{verbatim}

Принято называть контекстные менеджеры с префикса \spverb|with-|. Так вы делаете акцент
на том, что код работает в рамках временного ресурса.

В библиотеке Clojure уже предусмотрен макрос \spverb|with-open|. Это улучшенная версия
кода, что мы написали выше. В отличии от нашего примера, \spverb|with-open| работает с
более абстрактной сущностью \spverb|Reader|. Это источник данных, который может быть в
том числе и файлом. Выход из макроса, даже с ошибкой, гарантирует закрытие
источника.

Как правило, в форме \spverb|finally| нет смысла при обработке коллекций или действий
без побочных эффектов. Пользуйтесь ей только если источник данных должен быть
занят и освобожден.

\section{Исключения на предикатах}

Система \spverb|try/catch| работает на классах и наследовании. Это значит, если
требуется отловить особый случай, мы создаем специальный класс и бросаем его
экземпляр.

Типичный проект на Java или Python несет на борту отдельный модуль с
собственными исключениями. Как правило, это базовое \spverb|CommonProjectException| и
унаследованные от него \spverb|UserNotFound|, \spverb|UserAccessDenied| и другие. Это длинный
однообразный код, написанный вручную.

В главе про \spverb|clojure.spec| мы упоминали, что предикаты мощнее типов. Это верно и
для исключений. Если бы можно было перехватить исключение функцией, нам бы не
потребовались классы. В Clojure это возможно при помощи библиотеки \spverb|Slingshot|
(анг. рогатка).

Библиотека предлагает улучшенные версии \spverb|try|, \spverb|catch| и \spverb|throw|. Новичкам
покажется это странным, но в Clojure с ее мощной системой макросов можно сделать
очень много. В том числе определить иной способ работы с исключениями.
Пользователи других языков ждут новый оператор годами, а в Clojure это решается
библиотекой.

Автор Slingshot предположил, что ошибкой может быть не только экземпляр
исключения, а любое значение в принципе. Например, строка, число, словарь. Выше
мы выяснили, что контекст~--- самый важный элемент исключения. Поэтому логично
сосредоточить внимание на словарях, а не Java классах.

В техническом плане библиотека реализует макросы \spverb|throw+| и \spverb|try+|. Оба они
совместимы с обычными \spverb|throw| и \spverb|try|. Если заменить стандартные формы на версии
с плюсом, ничего не изменится. Однако новые формы дают следующие преимущества.

Макрос throw+ принимает не только исключение, но и \emph{любой
Java-объект}. Словарь лучше всего подходит на роль этого объекта, потому что
передает несколько значений и их семантику по имени ключей. Пример ниже выбросит
\spverb|ex-info| с переданным словарем:

\begin{verbatim}
(require '[slingshot.slingshot
           :refer [try+ throw+]])

(throw+ {:user-id 42
         :action :create})
\end{verbatim}

Более детальная форма этого макроса: словарь, причина (cause), сообщение и
переметры форматирования:

\begin{verbatim}
(let [path "/var/lib/file.txt"]
  (try
    (slurp path)
    (catch Exception e
      (throw+ {:path path} e "Cannot open a file %s" path))))
\end{verbatim}

Форма \spverb|catch| внутри \spverb|try+|, помимо классов, ловит исключения по \emph{селектору и
предикату}. Под селектором понимают вектор, где нечетный элемент ключ словаря,
а четный~--- значение. Селектор проверяет, что такие ключи и значения есть в
контексте исключения. Если да, исключение считается пойманным, и управление
переходит в форму \spverb|catch| с этим селектором.

\begin{verbatim}
(try+
 (throw+ {:type ::user-error
          :user 42
          :action :update
          :data {:name "Ivan"}})
 (catch [:type ::user-error] e
   (clojure.pprint/pprint e)))
\end{verbatim}

Считается хорошей практикой добавлять в словарь поле \spverb|:type|. В него записывают
тип исключения с текущим простанстом имен. В нашем случе это
\spverb|:book.exceptions/user-error|. При отлове исключений прибегают к этому же
полю. Пространство гарантирует, что мы не отреагируем на \spverb|:user-error| из
другого модуля.

Пример выше напечатает в консоль переданный словарь. Макрос \spverb|catch| достаточно
умен и подставляет в переменную \spverb|e| не исключение, а данные, что мы выбросили.

Вариант с предикатом аналогичен примеру выше. Разница лишь в том, что вместо
селектора указывают функцию одного аргумента. Она принимает исключение или
данные и возвращает истину или ложь. Функция должна быть готова к тому, что ее
параметр разного типа.

Пример ниже предполагает, что операции над пользователем с номером 1 заслуживают
особого внимания. В этом есть смысл, потому что первый пользователь, как
правило, это супер-админ, основатель фирмы или системный пользователь.

\begin{verbatim}
(defn special-user-case?
  [data]
  (when (map? data)
    (let [{:keys [type user]} data]
      (and (= type ::user-error)
           (= user 1)))))
\end{verbatim}

С таким предикатом любой пользователь сможет удалить себя из системы, но не
админ:

\begin{verbatim}
(try+
 (throw+ {:type ::user-error
          :user 1
          :action :delete})
 (catch special-user-case? e
   (println "Attempt to delete a system account")))
\end{verbatim}

Рассмотрим пример из реального проекта. Это предикат для проверки исключения при
работе с Java AWS SDK. При определенных обстоятельствах возможен случай, когда
исключение возникло после того, как файл загружен в S3. Такая загрузка считается
неудачной, и мы должны удалить файл, чтобы он не занимал место. К сожалению, для
этого сценария не существует отдельного класса. Приходится ловить стандартный
AmazonS3Exception и проверять его регулярным выражением.

\begin{verbatim}
(defn aws-special-case?
  [e]
  (and
   (instance? AmazonS3Exception e)
   (some?
    (re-find
     #"(?i)The Content-Md5 you specified did not match"
     (ex-message e)))))
\end{verbatim}

Библиотеку Slingshot используют другие проекты, например \spverb|clj-http|. Это
популярный HTTP-клиент для Clojure. В случае ошибки он кидает ответ через
\spverb|throw+|. Если код оборачивает HTTP-запрос в \spverb|try+|, вам доступен более тонкий
разбор ошибок. Например, отдельные ветки для статуса 500 и негативного ответа в
целом.

\begin{verbatim}
(require '[clj-http.client :as client])

(try+
 (client/get "http://example.com/test")
 (catch [:status 500] e
   (println "The service is unavailable"))
 (catch [:type :client/unexceptional-status] e
   (println "The response was not 200")))
\end{verbatim}

Подход Slingshot дает несколько преимуществ. Он скрывает внутренний механизм
классов и наследования, дает новый слой абстракции. Чем меньше мы прибегаем к
взаимодействию с JVM, тем лучше Clojure-код. Невозможно избежать этого
полностью, но по крайней мере доступ к JVM становится изолирован.

Библиотека выводит на первое место данные, а не классы. Это хорошая практика, и
она всячески поощряется языком. Clojure спроектирована так, что данные занимают
в ней первое место.

Slingshot относится к расширенной технике Clojure. Начинающим не очевидны плюсы,
которые библиотека несет в проект. Это нормально. Автор советует сначала
разобраться со стандартными формами \spverb|try/catch|. Подключайте Slingshot только
если вы остро чувствуете в нем потребность.

\section{Приемы и функции}

В последнем разделе мы рассмотрим несколько интересных функций. Их объединяет
тема исключений. Функции достаточно просты и потому не стоят того, чтобы
выносить их в отдельную библиотеку. Как правило, их копируют из проекта в проект
с небольшими изменениями. Автор уверен, у каждого Clojure-разработчика найдется
что-то подобное.

\emph{Безопасный вызов функции.} В замечательном языке Lua нет операторов \spverb|try| и
\spverb|catch|. Чтобы обезопасить вызов функции от ошибки, используют \spverb|pcall|. Это
сокращение от protected call, защищенный вызов.

В \spverb|pcall| передают целевую функцию и аргументы. Результатом будет пара и более
элементов (в Lua функция может вернуть несколько значений). Первый их них
определяет успех выполнения. Если истина, то на втором месте результат
вычисления. Если ложь, то экземпляр исключения.

Тот же самое в Clojure:

\begin{verbatim}
(defn pcall
  [f & args]
  (try
    [true (apply f args)]
    (catch Exception e
      [false e])))
\end{verbatim}

Чтобы получить доступ к элементам пары, пользуйтесь векторным разбиением в форме
\spverb|let|:

\begin{verbatim}
(let [[ok? result-error] (pcall inc 1)]
  (if ok?
    (println (str "The result is " result-error))
    (println "Failure")))
\end{verbatim}

\emph{Ошибка и результат.} В мире JavaScript популярны функции-колбеки. Они
выполняются асинхронно и поэтому не прерывают главный тред в случае
ошибки. Существует особое соглашение, что коллбек принимает аргументы \spverb|error| и
\spverb|result|. Функция pcall-js это измененный вариант \spverb|pcall|, который возвращает
пару "ошибка-результат" по этому соглашению.

\begin{verbatim}
(defn pcall-js
  [f & args]
  (try
    [nil (apply f args)]
    (catch Exception e
      [e nil])))
\end{verbatim}

\emph{Попытки с задержкой.} Иногда функция не гарантирует, что отработает
успешно. Такое случается, когда мы обращаемся ко внешнему нестабильному
сервису. Функция \spverb|pcall-retry| пытается выполнить целевую функцию за несколько
попыток. Первый же удачный вызов станет результатом. Если была ошибка, но число
попыток еще не превысило порога, то функция ждет небольшой интервал времени и
повторяет вызов. Когда все попытки закончились, функция вызывает исключение.

\begin{verbatim}
(defn pcall-retry
  [n f & args]
  (loop [attempt n]
    (let [[ok? res] (apply pcall f args)]
      (cond
        ok? res

        (< attempt n)
        (do
          (Thread/sleep (* attempt 1000))
          (recur (inc n)))

        :else
        (throw res)))))
\end{verbatim}

Это наивная версия функции, и в реальных проектах ее дорабатывают. Например,
меняют стратегию задержки, добавляют логирование. Но основа остается прежней.

Любопытно, что функции выше стыкуются между собой. Чтобы предотвратить выброс
исключения из \spverb|pcall-retry|, завернем ее в \spverb|pcall|:

\begin{verbatim}
(pcall pcall-retry get-user-by-id 42)
\end{verbatim}

Тогда даже в случае ошибки получим пару \spverb|[ok? result]|.

Форма \spverb|loop| заслуживает особого упоминания. Ее дочерняя форма \spverb|recur| не может
располагаться внутри \spverb|try/catch|. Пример ниже не просто ошибочный в плане
семантики. При при попытке ее скомпилировать вы получите исключение "Can only
recur from tail position":

\begin{verbatim}
(defn pcall-retry
  [n f & args]
  (loop [attempt n]
    (try
      (apply pcall f args)
      (catch Exception e
        (recur (inc n))))))
\end{verbatim}

Это один их тех случаев, когда мы не можем использовать \spverb|try/catch|. На помощь
приходит \spverb|pcall| и его вариации.

\emph{Throw in place.} До сих пор мы кидали исключения двумя формами: \spverb|ex-info| и
\spverb|throw|. Первая формирует исключение, а вторая его бросает. Логично совместить
их в функцию \spverb|error!|. Заодно сделаем часть аргументов необязательными:

\begin{verbatim}
(defn error!
  [message & [data e]]
  (throw (ex-info message (or data {}) e)))
\end{verbatim}

Теперь достаточно написать:

\begin{verbatim}
(error! "Some error!" {:type ::error})
\end{verbatim}

, чтобы кинуть исключение с нужными данными.

\emph{Форматированное сообщение.} Иногда нам нужен не контекст, а подробное
сообщение об ошибке. В этом случае \spverb|ex-info| избыточен, поскольку без контекста
он не имеет смысла. Достаточно выкинуть \spverb|Exception| с форматированным
сообщением. В параметры функции передают шаблон и значения для подстановки. В
этом и других примерах часть \spverb|f| на конце означает форматирование.

\begin{verbatim}
(defn errorf!
  [template & args]
  (let [message (apply format template args)]
    (throw (new Exception ^String message))))

(errorf! "Cannot process a user %s with the action %s" "AAA" :UPDATE)
\end{verbatim}

\emph{Безопасный макрос.} Примеры выше можно переписать на макросах. Преимущество
макросов в том, что они изящней встраиваются в код. С другой стороны, на них
нельзя ссылаться как на объект. Макрос нельзя передать в \spverb|apply|, \spverb|map| и другие
высшие функции.

Пример ниже показывает, как выполнить часть кода в безопасном режиме, игнорируя
ошибку:

\begin{verbatim}
(defmacro with-safe
  [& body]
  `(try
     ~@body
     (catch Exception e#)))
\end{verbatim}

Пустая форма catch возвращает nil. Мы получим его, если случится ошибка:

\begin{verbatim}
(with-safe (/ 0 0))
nil
\end{verbatim}

\spverb|Nil| может быть положительным результатом кода, который мы передали в
макрос. На практике ошибку передают другим значением. Обычно это кейворд
\spverb|:error| или \spverb|:invalid|. По такому принципу работает пакет \spverb|clojure.spec|,
который мы разобрали в прошлой главе. Если валидация не прошла, результат будет
\spverb|:clojure.spec.alpha/invalid|.

В реальности редко бывает так, что нам безразлично, была ошибка или нет. Поэтому
на практике макрос дорабатывают: добавляют в форму \spverb|catch| код для записи
исключения в лог или отправки в Sentry.

\section{Заключение}

Перечислим основные тезисы главы. Clojure использует систему исключений
Java. Эта система работает на классах и дереве наследования. Формы \spverb|try| и
\spverb|catch| похожи на одноименные операторы Java.

Особая форма \spverb|finally| дает шанс закрыть ресурс в случае ошибки. Чтобы упростить
работу с ресурсом, пользуйтесь контекстными менеджерами. Это макросы вида
\spverb|with-<something>|. Для доступа к файлам Clojure предлагает макрос \spverb|with-open|.

Класс \spverb|ExceptionInfo| разработан специально для Clojure. Его преимущество в поле
\spverb|data|, куда можно записать любой словарь. Функция \spverb|ex-info| упрощает создание
этого исключения.

У каждой ошибки может быть причина, \spverb|cause|. Если вы поймали исключение, лучше
бросить новое с текущим контекстом и причиной-оригинальным исключением. Так
исключения собираются в цепочку.

В приложении должен быть код, который решает, что делать с пойманным
исключением. Лучше всего отправить его в единую систему сбора ошибок. Sentry
будет хорошим решением. Проследите, что ваш клиент к Sentry передает всю нужную
информацию, а не только стек-трейс.

В особых случаях исключениями пользуются, чтобы мгновенно перейти в другое место
в коде. На это у вас должны быть веские причины.

Проект Slingshot предлагает улучшенную схему \spverb|try/catch|. При таком подходе мы
оперируем не исключениями, а данными.

Ряд функций и макросов упрощают контроль над исключениями. Изучите их, чтобы
уменьшить код.

%% [source]: https://github.com/igrishaev/book-sessions/blob/master/src/book/exceptions.clj TODO

Код этой главы доступен [в одном модуле][source] на Гитхабе.
