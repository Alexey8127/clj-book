\chapter{Исключения}

\begin{teaser}
В этой главе мы рассмотрим исключения в Clojure: как они устроены и чем
отличаются от аналогов Java. Когда лучше кидать, а когда перехватывать
исключения. Как и что писать в лог, чтобы расследовать инцидент было легко.
\end{teaser}

Возможно, читателю покажется странным, что на эту тему написано так
много. Считается, что исключения просты: их можно кинуть, поймать и записать в
лог. В теории этих знаний достаточно, чтобы работать в проекте.

Исключения просты с технической стороны, но несут обширную
\emph{семантику}. Когда именно кидать исключения, а когда перехватывать? Как
извлечь полезную информацию из их цепочки? Куда их записывать? Возможно ли
ловить исключения предикатами? Мы прочли теорию, но на практике тонем во
множестве частных случаев.

Начинающие программисты пишут код, следуя только положительному пути. Отчасти
поэтому так трудно расследовать ошибки. Сервер вернул статус 500. Почему?
Возможны сотни причин, по которым запрос не удался. Но запись в логе слишком
скупа, чтобы расследовать инцидент.

Хороший программист внимателен к ошибкам. С опытом становится ясно: экономия на
исключениях не дает выигрыша. Да, мы быстрее закроем задачу, и кода получится
меньше. Позже на нас повесят новые задачи по расследованию ошибок.

Исключения в системах столь же равноправны, как и нормальное поведение. Избегайте
мысли, что это недоразумение, которое не случится с вами. Частые задачи на
непойманные ошибки~--- верный признак того, что пора разобраться с темой.

\section{Основы исключений}

Прежде чем углубляться в детали, вспомним, что такое исключения и как они себя
ведут.

Исключение~--- это объект, чаще всего экземпляр класса \spverb|Exception|. От
других классов он отличается тем, что его можно \emph{выбросить}. В разных
языках для этого служат операторы \spverb|throw|, \spverb|raise| и другие.

Брошенный объект прерывает исполнение и всплывает вверх по стеку
вызовов. Возможны два исхода: либо его поймали оператором \spverb|catch| на
одном из уровней, либо перехват не состоялся.

В первом случае программист получит \emph{объект} исключения. К нему обращаются
как обычно: читают поля, вызывают методы, передают в функции. Дальнейшее
поведение зависит от логики программы. Когда-то исключение пишут в лог и
завершают программу, в других случаях продолжают работу.

Когда исключение не поймали, программа завершится с ошибкой. Если не
предусмотрено иное, перед выходом программа запишет его в \spverb|stderr| (канал
ошибок). Мы увидем класс исключения, его сообщение и то, что называют
<<стектрейс>>. Это цепочка вызовов, по которому всплыло исключение.

Отдельные платформы позволяют задать реакцию на не пойманное
исключение. Например, чтобы записать его в файл или завершить программу особым
способом.

Clojure это гостевой язык (анг. \emph{hosted language}). Он пользуется
возможностями, которые предлагает домашняя платформа, \emph{хост}.
Исключения~--- одна из областей, в которую Clojure не вмешивается.
По умолчанию Clojure опирается на формы \spverb|try| и \spverb|catch|,
аналогичные Java.

Рассмотрим исключения в Java. Платформа содержит базовый класс
\spverb|Throwable|. Это общий предок всех исключений. Другие классы наследуют
\spverb|Throwable| и расширяют его семантику. Например, наследники первого
уровня это классы \spverb|Error| и \spverb|Exception|. Его наследует
\spverb|RuntimeException| и так далее. Это видно на схеме.

\begin{tikzpicture}[auto, node distance=1.5cm]

\node (obj) [entity] {Object};
\node (thr) [entity, below of=obj] {Throwable};
\node (err) [entity, below left = of thr, yshift=0.5cm, xshift=2cm] {Error};
\node (exc) [entity, below right = of thr, yshift=0.5cm, xshift=-2cm] {Exception};
\node (rex) [entity, below right = of exc, yshift=0.5cm, xshift=-2cm] {RuntimeException};

\draw [arrow] (obj) -- (thr);
\draw [arrow] (thr) -| (err);
\draw [arrow] (thr) -| (exc);
\draw [arrow] (exc) -| (rex);

\end{tikzpicture}

Пакеты Java несут дополнительные исключения, унаследованные от описанных
выше. Например, \spverb|java.io.IOException| для ошибок ввода-вывода,
\spverb|java.net.ConnectException| для сетевых проблем другие. Бросать
\spverb|Throwable| считается дурным тоном. Он несет слишком мало информации о
том, что случилось.

В дереве исключений каждый класс дополняет семантику предка. Рассмотрим
исключение \spverb|FileNotFoundException|. Оно возникает, когда обращаются к
файлу, которого нет на диске. Его полная родословная выглядит так:

\begin{verbatim}
java.lang.Object
  java.lang.Throwable
    java.lang.Exception
      java.io.IOException
        java.io.FileNotFoundException
\end{verbatim}

Схему читают как <<выбрасываемое $\to$ исключение $\to$ ошибка ввода-вывода
$\to$ файл не найден>>. По имени \spverb|FileNotFoundException| легко
догадаться, с чем связана проблема. Если же разработчик выбросил
\spverb|Throwable|, это осложнит поиск причины.

Различают \spverb|checked| и \spverb|unchecked| исключения, они же проверяемые и
нет. Разница между ними в семантике. Разработчик должен предвидеть
\spverb|checked| исключения и обработать их в коде. При чтении файла справедливо
ожидать, что его не окажется на диске. Поэтому \spverb|FileNotFoundException|
относится к категории \spverb|checked|.

Предвидеть нехватку памяти трудно, поэтому \spverb|OutOfMemoryError| относится к
непроверяемым исключениям. Когда оборудование на пределе, любое действие может
исчерпать память. Перехватывать это исключение нет смысла, поскольку при
нехватке памяти система ведет себя непредсказуемо.

Классы, унаследованные от \spverb|Error| и \spverb|RuntimeException| относятся к
непроверяемым (unchecked) исключениям. Унаследованные от \spverb|Exception|~---
проверяемые (checked).

Чтобы бросить исключение, его экземпляр передают в оператор
\spverb|throw|. Оператор \spverb|catch| перехватывает потенциальные
исключения. В Java и других языках отлов исключений устроен на иерархии
классов. Например, если искомый тип \spverb|IOException|, мы поймаем все
исключения, унаследованные от этого класса.

Чем выше класс в дереве наследования, тем больше исключений поймает
\spverb|catch|. В мире Java считается плохим тоном ловить ошибки классами
\spverb|Throwable| или \spverb|Exception|. Современные IDE выдают предупреждение
<<too wide catch expression>>, слишком широкий охват. Класс \spverb|Exception|
заменяют на несколько более точных исключений. Например, отдельно ошибки
ввода-вывода, сети и другие.

Одного класса недостаточно, чтобы понять причину исключения. У
\spverb|FileNotFoundException| нет поля \spverb|file|, чтобы отследить, какой
именно файл не удалось найти. Большинство исключений принимают строку с
сообщением об ошибке. Сообщение формируют так, чтобы было удобно
человеку. Например, <<File С:/work/test.txt not found>>.

Иногда текста не хватает, чтобы объяснить причину ошибки. Предположим, данные не
прошли валидацию, и нам хотелось бы исследовать их позже. Если записать данные в
сообщение, текст получится слишком большим, и это небезопасно. В данных могут
быть личные данные или ключи доступа. Такое сообщение нельзя писать в лог или
показывать пользователю. Даже путь к файлу способен выдать важную информацию.

Сообщение принято отделять от данных. Если нужно передать информацию для
расследования, создают новый класс исключения. У такого класса отдельные поля
для данных, из-за которых произошла ошибка. Поля заполняют в конструкторе
исключения. Сообщение пишут так, чтобы оно не выдало деликатную информацию.

\section{Цепочки и контекст}

Исключения строятся в цепочку. Каждый экземпляр принимает необязательный
аргумент \spverb|cause| (анг. \emph{причина}). Он может быть либо \spverb|Null|,
либо ссылкой на другое исключение.

Цепочки образуются, когда код перехватил исключение, но не знает, что с ним
делать. Это нормально, потому что на низких уровнях код не видит всего
контекста. Например, метод пишет даные в файл. У него нет полномочий решать что
делать, если файла нет, поэтому метод бросит исключение. Код выше перехватывает
его, но тоже не знает, что делать. Он бросит новое исключение со ссылкой на
изначальное. Это и есть цепочка.

В конце управление перейдет к методу, который знает, что делать. Его логика
зависит от типа исключения и бизнес-правил. Например, если файла нет, программа
создаст его или продолжит поиск в других папках. Если не удалось извлечь данные
для работы, выведет понятный текст и завершится.

В системе должен быть последний рубеж, где отлавливают \emph{все}
исключения. Если ошибка дошла до этого уровня, значит, ее не поймали правила
рангом ниже. Это говорит о нештатном поведении системы. Клиенту выводят
нейтральный текст о том, что запрос не прошел. Чтобы расследовать причину,
исключение пишут в лог и передают сборщику ошибок.

На верхнем уровне кода лежит бизнес-логика. Это шаги, которые диктует
руководство, чтобы заработать больше денег. При спуске вниз начинается переход в
техническую часть. Представим, что функция \spverb|get-user| извлекает
пользователя по его номеру. Снаружи это черный ящик: мы не знаем, откуда
приходят данные. Скорей всего, это база данных. В крупных системах пользователей
выносят в сетевой сервис. Выразим это на псевдокоде:

\begin{verbatim}
func get-user(id):
  let url = "http://api.company.com/user/" + str(id)
  return http.GET(url).body.json()
\end{verbatim}

Если вызвать функцию с номером, которого нет в системе, получим исключение
\spverb|HTTP Error: status 404|. Текст ничего не говорит о пользователе. Если
встретить эту запись в журнале, то мы даже не поймем, к какому сервису
обращались.

Чем больше мы углубляемся в технические детали, тем меньше знаем о бизнесе. В
мире HTTP нет понятия пользователя. Известны лишь метод, адрес и другие
поля. Разделим ошибку на две половины. Ее верхняя часть называет бизнес-причину:
не найден пользователь с номером 42. Почему? Из-за технического сбоя: запрос
\spverb|GET| к адресу \spverb|http://api.company.com/user/42| вернул ответ с
кодом 404.

Расставим в коде дополнительные \spverb|try/catch|. Когда исключение пришло из
технических недр, мы дополняем его контекстом и отправляем наверх. Этот паттерн
называется \spverb|re-throw|, повторный выброс.

Улучшенный псевдокод:

\begin{verbatim}
func get-user(id):
  try {
    let url = "http://api.company.com/user/" + str(id)
    return http.GET(url).body.json()
  } catch error {
    let message = "Cannot fetch a user #" + str(id)
    throw Error(message, cause=error)
  }
\end{verbatim}

Новое исключение описывает бизнес-проблему, но и при этом ссылается на
техническую. Это еще не конечая точка, у HTTP-ошибки тоже своя причина. Это
может быть сбой сети, устаревший сертификат, не тот пароль. Так образуется
цепочка исключений. В реальных проектах они достигают пять и более звеньев.

Спуск по цепочке напоминает допрос. На каждое <<почему>> мы получаем новую пищу
для размышлений, пока не доберемся до сути. Это не значит, что самое нижнее
исключение важнее других. Одно лишь \spverb|HTTPError| не описывает
ситуацию. Важно то, как мы к нему пришли.

Так работают исключения в промышленных языках: Java, Python и других. Каждая
платформа несет особенности, но в целом картина не меняется. Теперь рассмотрим,
что предлагает Clojure.

\section{Переходим к Clojure}

Чтобы познакомиться с исключением, спровоцируем его. Подойдет старый, как мир,
прием~--- поделить число на ноль. Откройте сеанс REPL и выполните:

\begin{verbatim}
(/ 1 0)
\end{verbatim}

\noindent
Появится похожий текст:

\begin{verbatim}
Execution error (ArithmeticException) at user/eval5848...
Divide by zero
\end{verbatim}

Это отчет об ошибке. В зависимости от редактора и настроек оно выглядит
по-разному. Например, Emacs с модулем Cider откроет дополнительный буфер
\spverb|*cider-error*| с подробной информацией.

Заметим, что исключение в REPL не завершает его. От нас по-прежнему ждут
команды. В боевом режиме программы на Clojure ведут себя как обычно. Если в
главном потоке не поймано исключение, программа остановится.

Чтобы поймать исключение, код помещают в форму \spverb|try|. За ним следует одна
и более форм \spverb|catch|. В них указывают, какие классы перехватывать и что
делать с экземпляром. Вот как безопасно разделить число:

\begin{verbatim}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
\end{verbatim}

Форма \spverb|catch| принимает класс и произвольный символ. С ним будет связано
исключение, если управление перейдет в эту ветку. В нашем случае мы указали
\spverb|ArithmeticException| и символ \spverb|e|. После класса и символа идет
произвольный код. В нем с исключением работают как с локальной переменной
\spverb|e|.

Мы вывели на экран текст, что вычисления прошли неудачно. Это слишком
поверхностное объяснение. Метод \spverb|.getMessage| возвращает сообщение,
которое назначили исключению при его создании. С версии 1.10 Clojure предлагает
функцию \spverb|ex-message|, которая делает то же самое:

\begin{verbatim}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println (ex-message e))))
;; Divide by zero
\end{verbatim}

Класс \spverb|ArithmeticException| ловит не все ошибки вычислений. Что случится,
если сложить 1 и \spverb|nil|? Даже если поместить расчеты в \spverb|try/catch|,
исключение мы не поймаем:

\begin{verbatim}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics")))

;; Execution error (NullPointerException) at user/eval6159
\end{verbatim}

Дело в том, что классы \spverb|ArithmeticException| и
\spverb|NullPointerException| не пересекаются. У них разные пути в дереве
исключений, которое мы обсудили в начале главы. Перехват одного не влияет на
другой. Это правильно, потому что у классов разная семантика. Ошибка в
арифметике это не то же самое, что \spverb|Null| вместо значения.

\emph{Примечание:} класс \spverb|NullPointerException|~--- частый гость в мире
Java, и для краткости его называют \spverb|NPE|.

Форма \spverb|try| принимает несколько веток \spverb|catch|. Вот как перехватить
оба случая:

\begin{verbatim}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics"))
  (catch NullPointerException e
    (println "You've got a null value")))
\end{verbatim}

Макрос перебирает классы из каждого \spverb|catch|. Он остановится на первом
подходящем варианте. Результатом \spverb|try| станет последнее выражения из
блока \spverb|catch|, который подошел по классу. В примере выше результат будет
\spverb|nil|, потому что его вернет \spverb|println|. Если ни один вариант не
подошел, оно продолжит путь вверх по стеку вызовов.

Мы упоминали, что чем выше класс исключения в дереве, тем больше случаев он
поймает. Если заменить \spverb|ArithmeticException| на \spverb|Throwable|, такой
ветка поймает любое исключение, будь то деление на ноль или \spverb|NPE|:

\begin{verbatim}
(try
  (/ 1 0)
  (+ 1 nil)
  (catch Throwable e
    (println "I catch everything")))
\end{verbatim}

В отличие от Java, в Clojure нет строгих правил о том, какие исключения
перехватывать. Это остается на усмотрение разработчика. Здравый смысл
подсказывает, что перехват \spverb|Throwable| опасен. Создается ложное ощущение,
что код работает без ошибок.

В случае с \spverb|ArithmeticException| проблема в расчетах, но для
\spverb|NullPointerException| это не так. \spverb|Nil| вместо числа говорит о
том, что проблема не в арифметике, а в функции, которая вернула
\spverb|nil|. Иными словами, \emph{ошибка кроется в другом месте}. Вот почему
перехват \spverb|NullPointerException| вредит разработке.

Форму \spverb|try/catch| с широким классом ставят на верхний уровень
кода. Например, когда важно, чтобы программа не остановилось никогда. Так
работают веб-серверы, очереди сообщений, сетевое ПО.

Иногда мы намеренно бросаем исключение, чтобы сообщить о нештатной
ситуации. Оператор \spverb|new| создает новый Java-объект. Ему передают класс и
параметры конструктора. Форма \spverb|throw| принимает исключение и запускает
механизм выброса.

\begin{verbatim}
(let [e (new Exception "Something is wrong!")]
  (throw e))
\end{verbatim}

Сообщение такого рода не информативно. Даже если мы указали, что проблема в
арифметике или базе данных, хотелось бы знать, какие именно значения были на
момент ошибки. Поэтому сообщение строят функцией \spverb|format|. Она принимает
шаблон и параметры подстановки:

\begin{verbatim}
(defn add [a b]
  (when-not (and a b)
    (let [message (format "Value error, a: %s, b: %s" a b)]
      (throw (new Exception message))))
  (+ a b))
\end{verbatim}

\noindent
Если вызвать функцию выше с одним и параметров \spverb|nil|, сообщение станет
понятнее:

\begin{verbatim}
Execution error at book.exceptions/add (exceptions.clj:86).
Value error, a: 1, b: null
\end{verbatim}

Функция \spverb|format| полезна тем, что отображает \spverb|nil| как
\spverb|null|. Это преимущество перед \spverb|str|, которая приводит
\spverb|nil| к пустой строке. Вариант с \spverb|str| выглядит так:

\begin{verbatim}
(str "Value error, a:" 1 ", b: " nil)
;; Value error, a:1, b:
\end{verbatim}

\noindent
Текст вводит в заблуждение. Мы не указали \spverb|b|? Или \spverb|b| пустая
строка? Непонятно.

\section{Контекст ошибки}

Выше мы упоминали, что данные в тексте приводят к риску. Сообщение может
оказаться слишком большим или выдать лишние сведения. Проблему решает класс
\spverb|ExceptionInfo|. Это особое исключение из поставки Clojure. Оно устроено
так, чтобы хранить произвольные данные. Дополнительно в Clojure набор функций
для работы с ним.

Ключевая функция \spverb|ex-info| создает экземпляр \spverb|ExceptionInfo|. Она
принимает сообщение и словарь данных. Это контекст, в котором возникло
исключение. Например, если HTTP-запрос не удался, в словарь помещают метод,
адрес и код ответа.

\spverb|Ex-info| только создаст исключение, но не бросит его. Результат передают
в форму \spverb|throw|:

\begin{verbatim}
(throw (ex-info
        "Cannot fetch a user."
        {:user-id 42
         :http-status 404
         :http-method "GET"
         :http-url "https://host.com/users/42"}))
\end{verbatim}

Здесь мы разделили сообщение и данные. Сообщение не выдает номер пользователя и
адрес подсистемы. Его запишут в лог или отправят пользователю, а контекст
обработают отдельно.

В работе с контекстом помните несколько правил. Словарь не может быть
\spverb|nil|. Это редкий случай, когда Clojure отличает его от
коллекции. Нежелательно хранить в словаре значения, которые не
сериализируются. Например, поток или сетевое подключение. В идеале контекст
можно записать в JSON-файл. Позже мы рассмотрим, что делать с контекстом.

Функция \spverb|ex-data| возвращает данные из исключения. Если это <<родное>>
\spverb|ExceptionInfo|, получим словарь. Если исключение другого типа, то
\spverb|nil|.

Вообразим, как бы мы поймали исключение, которое бросили выше. В форме
\spverb|catch| укажем класс \spverb|ExceptionInfo|. В ее теле функция
\spverb|ex-data| вернет словарь, который передали в \spverb|ex-info|. Разделим
словарь на поля и построим сообщение.

\begin{verbatim}
(try
  (get-user 42)
  (catch clojure.lang.ExceptionInfo e
    (let [data (ex-data e)
          {:keys [http-method http-url]} data]
      (format "HTTP error: %s %s" http-method http-url))))
;; HTTP error: GET https://host.com/users/42
\end{verbatim}

\section{Когда бросать исключения}

Наверняка читатель сомневается, когда бросать исключения, а когда ограничиться
проверкой. Рассмотрим типичные ситуации и оптимальные решения.

\emph{При обработке коллекций} исключения бросать не нужно. Как правило, в этом
нет смысла. В Clojure коллекции устроены так, что проблемы \spverb|nil| пройдут
мимо вас незамеченными. Все <<коробочные>> функции трактуют \spverb|nil| как
пустую коллекцию. Выражения:

\begin{verbatim}
(assoc nil :test 42)
(update nil :test (fnil inc 0))
(into nil [1 2 3])
(merge nil {:test 42})
\end{verbatim}

\noindent
вернут списки или словари. Ключ от \spverb|nil| вернет \spverb|nil|. Разбор
словаря или вектора сообщит переменным \spverb|nil|, если подстановка не
сработала:

\begin{verbatim}
(let [{:keys [a b c]} nil]
  [a b c])

(let [[a b c] nil]
  [a b c])
\end{verbatim}

\noindent
Оба примера вернут вектор из трех \spverb|nil|.

Термин <<nil punning>> означает лояльность к \spverb|nil|. С таким подходом
ситуацию с пустым значением решают без ошибок. Нельзя утверждать, что Clojure
полностью <<nil punning>>. \spverb|Nil| дружит с коллекциями, но не работает с
арифметикой и регулярными выражениями.

%% Todo REF

Если вы сомневаетесь в коллекции, используйте спеку. Вспомните \spverb|s/valid?|
и \spverb|s/conform| из прошлой главы. Тем самым вы отделите проверку от работы
с данными. Если валидация не прошла, бросайте исключение. Передайте в контекст
данные \spverb|explain|, чтобы разобрать их позже.

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
(s/def ::data (s/coll-of int?))
(when-let [explain (s/explain-data ::data [1 2 nil])]
  (throw (ex-info "Validation failed" {:explain explain})))
\end{verbatim}

Другой случай, когда прибегают к исключениями~--- это \emph{отказ ресурса}. Если
не удалось прочитать файл, недостаточно сказать об этом. Возможны десятки
причин: файла нет, он занят другим процессом, кончилось место на диске, ошибка в
кодировке. От ошибки зависит, кто за нее отвечает и что нужно исправить, чтобы
не допустить ее снова.

Бывает, доступ к ресурсу \emph{не бросает исключение}, и мы делаем это
намеренно. Согласно протоколу HTTP, ответ со статусом 404 такой же верный, как и
200. В индустрии нет единого мнения о том, бросать ли исключение на негативный
статус. Продвинутые библиотеки предлагают флаг, чтобы управлять этим поведением.

Предположим, наш клиент не бросает исключение на <<плохой>> ответ. Но логика
программы такова, что продолжать не имеет смысла. Проверим статус и бросим
исключение со всеми подробностями:

\begin{verbatim}
(defn auth-user [user-id]
  (let [url "http://auth.company.com"
        params {:as :json :form-params {:user-id user-id}}
        response (client/post url params)
        {:keys [status body]} response]
    (if (= status 200)
      body
      (throw (ex-info "Authentication error"
                      {:user-id user-id
                       :http-url url
                       :http-status status
                       :http-body body})))))
\end{verbatim}

Исключения полезны \emph{в библиотеках}. Код условно делится на два типа:
исполнение и координация. Библиотеки относятся с исполнительному коду. На уровне
библиотеки мы не знаем, в разрезе какой логики работает код. Если бросить
исключение в исполнительном коде, бизнес-логика перехватит его и продолжит
работу. Но если исполнитель молча подавляет ошибки, это влечет
неприятности. Сюда же относится паттерн <<вернуть \spverb|nil| и записать в
лог>>. Это игнорирование проблемы.

\section{Подробнее о цепочках}

Мы говорили про цепочки исключений. Рассмотрим, как строить их на
практике. Функция \spverb|ex-info| принимает третий необязательный параметр
\spverb|cause|. Это либо \spverb|nil|, либо другое исключение; оно становится
частью нового. Ниже функция \spverb|divide| ловит ошибку арифметики и
оборачивает в другое исключение с контекстом.

\begin{verbatim}
(defn divide [a b]
  (try
    (/ a b)
    (catch ArithmeticException e
      (throw (ex-info
              "Calculation error"
              {:a a :b b}
              e)))))
\end{verbatim}

Функция \spverb|ex-cause| возвращает причину исключения, если оно было передано
в \spverb|ex-info|. Если причины нет, результат будет \spverb|nil|.

\begin{verbatim}
(try
  (divide 1 0)
  (catch Exception e
    (-> e ex-message println)
    (-> e ex-cause ex-message println)))
\end{verbatim}

\noindent
Код выведет:

\begin{verbatim}
Calculation error
Divide by zero
\end{verbatim}

Нельзя утверждать, что у исключения строго одна причина. Их может быть много или
ни одной. Напишем функцию, которая вернет список исключений. Расположим их по
убыванию старшинства. На первом месте самое главное, на втором его причина,
далее причина причины и так далее. Проще всего сделать это формой \spverb|loop|:

\begin{verbatim}
(defn ex-chain [e]
  (loop [e e
         result []]
    (if (nil? e)
      result
      (recur (ex-cause e) (conj result e)))))
\end{verbatim}

Для экспериментов объявим переменную \spverb|e|. Это цепь исключений из трех
звеньев. На первом уровне ошибка бизнес-логики: не удалось извлечь
пользователя. На втором уровне техническая проблема: что-то не так с
авторизацией. На третьем ошибка транспорта: не прошел HTTP-запрос.

\begin{verbatim}
(def e
  (ex-info
   "Get user info error"
   {:user-id 42}
   (ex-info "Auth error"
            {:api-key "........."}
            (ex-info "HTTP error"
                     {:method "POST"
                      :url "http://api.site.com"}))))
\end{verbatim}

Получилось дерево искючений, но не всегда удобно работать с деревом. Плоская
структура лучше поддается обходу. Пригодится функция \spverb|ex-chain|, которую
мы написали. Вот как получить сообщения всех исключений:

\begin{verbatim}
(map ex-message (ex-chain e))
("Get user info error" "Auth error" "HTTP error")
\end{verbatim}

\noindent
А вот как вывести на экран построчно:

\begin{verbatim}
(doseq [e (ex-chain e)]
  (-> e ex-message println))

;; Get user info error
;; Auth error
;; HTTP error
\end{verbatim}

Выразим \spverb|ex-chain| короче через \spverb|iterate|. Это функция, которая
шаг за шагом применяет другую функцию к аргументу. Ограничение
\spverb|take-while some?| нужно для того, чтобы остановиться на первом же
\spverb|nil|-элементе.

\begin{verbatim}
(defn ex-chain [^Exception e]
  (take-while some? (iterate ex-cause e)))
\end{verbatim}

\section{Печать исключения}

Разберемся, что делать с пойманным исключением. В приложении что-то пошло не
так, и форма \spverb|try/catch| вернула ошибку. Как с ней посупить?

Самое простое, что можно сделать с исключением~--- напечатать в консоль. Функция
\spverb|println| достаточно умна: перед выводом она переводит исключение в
словарь. Это удобно для редакторов и IDE, потому что словарь легко разобрать на
части. Например, показать только ту часть стек-трейса, что касается Clojure.

Последнее исключение в цепочке иногда наывают корнем, \emph{root}. Для нашего
удобства \spverb|println| дублирует корень в начале вывода. Так сразу видно
первопричину. Вот что выведет \spverb|(println e)|:

\begin{verbatim}
#error {
 :cause HTTP error
 :data {:method POST, :url http://api.site.com}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Get user info error
   :data {:user-id 42}}
  {:type clojure.lang.ExceptionInfo
   :message Auth error
   :data {:api-key .........}}
  {:type clojure.lang.ExceptionInfo
   :message HTTP error
   :data {:method POST, :url http://api.site.com}}]
 :trace
 [[clojure.lang.AFn applyToHelper AFn.java 156]
  [clojure.lang.AFn applyTo AFn.java 144]
  [clojure.lang.Compiler$InvokeExpr eval Compiler.java 3701]
  ..........]}
\end{verbatim}

Вектор \spverb|:trace| называют стек-трейсом. Это Java-методы, по которым прошло
исключение с выброса до перехвата. Каждый элемент трейса это вектор с именем
класса, метода, файла и номера строки.

Мы сократили трейс, чтобы не тратить на него слишком много места. В реальности
трейсы занимают несколько экранов. Они показывают Java-код, который получился из
Clojure, и это сбивает с толку. Шумные трейсы~--- справедливый упрек в адрес
Clojure. С другой стороны, ими страдают многие JVM-языки.

В пакете \spverb|clojure.stacktrace| несколько функций для печати
исключений. Так, \spverb|print-throwable| выводит только сообщение, текст
и словарь данных:

\begin{verbatim}
(clojure.stacktrace/print-throwable e)
clojure.lang.ExceptionInfo: Get user info error
{:user-id 42}
\end{verbatim}

Вывод в консоль легко захватить макросом \spverb|with-out-str|. Форма ниже
ничего не печатает, но вернет строку:

\begin{verbatim}
(with-out-str
  (clojure.stacktrace/print-stack-trace e))
\end{verbatim}

Функции \spverb|print-stack-trace| и \spverb|print-cause-trace| печатают трейс с
небольшими отличиями. Параметр \spverb|n| задает максимальную глубину трейса.

\section{Логирование}

Вывод в консоль помогает в отладке, не не подходит для боевого
запуска. Перечислим, что еще ожидают от кода, который ловит ислючения.

Для любого сообщения важны его \emph{вспомогательные данные}: время, модуль,
номер процесса. Сообщения различают по уровню важности: информационное,
предупреждение, ошибка и другие. Печать не несет этих сведений, а их ручной сбор
увеличит код.

Если программа работает на многих серверах, сбор сообщений делают
\emph{централизованным}. Представьте, что админ переключается между сотней
машин, чтобы читать логи. Идея сообщений по сети подсказывает, что для каждого
сообщения нужно знать адрес машины, с которой оно пришло.

Не все сообщения одинаково важны. Иногда библиотеки порождают сотни отладочных
сообщений в минуту. Нужен механизм, чтобы \emph{подавлять сообщения} по
некоторым признакам.

Наконец, консоль или файл~--- \emph{не единственные каналы данных}. Особо важные
сообщения пишут в журнал операционной системы, отправляют на почту, в чаты с
помощью ботов или даже в смс ответственным лицам.

Перечисленные проблемы решает логирование. Это система, которая принимает
сообщения из кода и пересылает в нужные каналы. Библиотека
\spverb|clojure.tools.logging| предлагает функции и макросы, чтобы логировать
сообщения. Это сторонний проект, поэтому добавьте его в зависимости:

\begin{verbatim}
[org.clojure/tools.logging "0.4.1"]
\end{verbatim}

\noindent
Запишем простое сообщение:

\begin{verbatim}
(require '[clojure.tools.logging :as log])
(log/info "A message from my module")
\end{verbatim}

В REPL появится строка:

\begin{verbatim}
INFO: A message from my module
\end{verbatim}

\noindent
По умлочанию лог дополняет сообщение уровнем важности.

В Clojure логирование устроено из двух уровней. Верхний уровень~--- это макросы
\spverb|log/info|, \spverb|log/error| и другие. Второй уровень называют
бекендом. Под ним понимают Java-библиотеку, которая выполняет основную работу:
пишет сообщения в файлы, отправляет их по сети и так далее.

Такое устройство несет преимущества. Исторически сложилось так, что для Java
написано много библиотек логирования. Каждая из них предлагает свои классы и
методы. Если проект использует одну из библиотек, переход на другую вынудит
править код.

В Clojure эту проблему решили на уровне дизайна. При старте модуль
\spverb|logging| ищет библиотеки \spverb|Logback|, \spverb|Log4j| и другие. Если
ничего не найдено, он использует стандартный пакет
\spverb|java.util.logging|. Вызов \spverb|log/info| сводится к вызову классов
найденной библиотеки.

Чтобы нужный бекенд <<подхватился>>, добавьте его в зависимости. Многие
библиотеки ищут конфигурацию в стандартных местах. Например, если в папку
\spverb|resources| положить XML-файл для бекенда, он прочтет его при старте.

Из бекендов популярностью пользуется проект \spverb|Logback|. От аналогов его
отличает большой выбор т.н. аппендеров (анг. \emph{appenders}). Так называют
пункт назначения, куда писать сообщения. Это может быть файл, удаленный
\spverb|syslog|, почтовый сервер.

Подключите \spverb|Logback| к проекту:

\begin{verbatim}
[ch.qos.logback/logback-classic "1.2.3"]
\end{verbatim}

\noindent
В папку \spverb|resources| положите файл \spverb|logback.xml| следующего содержания:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <charset>UTF-8</charset>
      <pattern>%date{ISO8601} %-5level %logger{36} - %msg %n</pattern>
    </encoder>
  </appender>
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
\end{verbatim}

Это укороченная конфигурация. Мы задали appender для вывода в консоль. Под тегом
\spverb|pattern| указан шаблон сообщения. Параметры шаблона начинаются со знака
процента. Подстановка \spverb|\%msg| означает текст сообщения,
\spverb|\%date{ISO8601}|~--- дату и ее формат в фигурных скобках. Сообщение в
логе выглядит так:

\begin{verbatim}
(log/info "Hello Logback!")
2019-05-03 17:36:04,001 INFO  book.exceptions - Hello Logback!
\end{verbatim}

Макросы \spverb|log/info|, \spverb|log/error| и другие допускают, что первым
аргументом может быть не текст, а исключение. В этом случае бекенд запишет его в
лог. Выше мы объявили переменную \spverb|e| для экспериментов. Запишем ее в лог:

\begin{verbatim}
(log/error e "Error while processing the request")

2019-05-03 17:41:03,913 ERROR book.exceptions - Error while processing the request
clojure.lang.ExceptionInfo: Get user info error
    at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 31 common frames omitted
\end{verbatim} 

Для экономии мы удалили часть трейса, которая не несет пользы. Из примера видно,
что цепочка состоит из трех звеньев. Это совпадает с тем, как мы задали
\spverb|e|. Проблема в том, что у каждого звена пропали данные. \spverb|Logback|
не знает о том, что поле \spverb|data| класса \spverb|ExceptionInfo| так важно
для нас.

Библиотека предлагает несколько способов напечатать исключение. Они влияют на
длину и детализацию трейса, но игнорируют данные. Аналогично ведут себя
\spverb|Log4j| и другие проекты.

В Java проблему решают новым классом. Как правило, библиотека содержит
стандартный класс, который переводит исключение в строку. Его наследуют и
заменяют нужные методы. В конфигурации логирования указывают путь к этому
классу.

Способ работает и в Clojure, но здесь проступают его недостатки. Чтобы
унаследовать класс в Clojure, нужны навыки работы с Java выше среднего. Придется
читать документацию к конкретной библиотеке, исследовать ее классы и интерфейсы.

Решение завязано на конкретную библиотеку. Класс для \spverb|Logback| придется
менять, если проект переедет на \spverb|Log4j| и наоборот. Это называют <<не
Clojure-way>>, то есть не тот способ, которому следуют в языке.

Напишем функцию для логирования ошибок. Она принимает исключение и переводит его
в текст, как удобно нам. Затем пишет лог с уровнем \spverb|error|.

Чтобы вывести данные об ошибке, обойдем цепочку исключений. Выше мы задали
\spverb|ex-chain| для этой цели. Функция \spverb|ex-print| пробегает по ее
результату и печатает данные в консоль.

\begin{verbatim}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
\end{verbatim}

Результат выглядит приятнее, чем пирамида из трейсов. Четко видны данные,
которые привели к ошибке:

\begin{verbatim}
clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 42}
clojure.lang.ExceptionInfo
  Auth error
  {:api-key "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST", :url "http://api.site.com"}
\end{verbatim}

Осталось собрать функцию для записи в лог. Чтобы перехватить печать на экран,
вызов \spverb|ex-print| оборачивают в \spverb|with-out-str|:

\begin{verbatim}
(defn log-error
  [^Throwable e & [^String message]]
  (log/error
   (with-out-str
     (println (or message "Error"))
     (ex-print e))))
\end{verbatim}

Функцию \spverb|log-error| можно вызвать с дополнительным сообщением. Если его
не передали, запишем нейтральное <<Error>>. Чтобы сообщение и тело не слиплись,
используем \spverb|println|. Эта функция добавляет перенос строки в конец.

\begin{verbatim}
(log-error e)
(log-error e "An error occurred during request")
\end{verbatim}

Последнее выражение запишет в лог следующее:

\begin{verbatim}
2019-05-03 19:00:05,590 ERROR book.exceptions - An error occurred during request
clojure.lang.ExceptionInfo
  Get user info error
  ...
\end{verbatim}

Сообщения об ошибках принято отделять от остальных записей. Для этого заводят
минимум два аппендера: консоль и файл. В консоль выводят все сообщения, чтобы
программист был в курсе дела. Ошибки требуют ответной реакции, поэтому их пишут
в файл или пересылают по сети. Позже их анализируют вручную или специальными
программами.

В следующей главе мы расскажем, как сделать так, чтобы макрос
\spverb|(log/error)| сводился к функции \spverb|log-error|. Пока что об этом
говорить преждевременно.

\section{Сбор исключений}

В прошлом разделе мы придумали, как выразить исключение текстом. Теперь можно
записать его в файл, отправить письмом или даже распечатать. Недостаток в том,
что у текста нет структуры. С точки зрения кода это символы, и неясно, где что.
При сборе ошибок важно выделить их ключевые данные, например, тип, подсистему,
модуль. Это необходимо по следующим причинам.

\emph{Предотвратить дублирование.} Во время наплыва клиентов может вскрыться
ошибка, которую не заметили ранее. Если каждый раз писать ее в файл, получим
тысячи одинаковых сообщений. Это не имеет смысла, расточительно в плане ресурсов
и затрудняет поиск.

Системы сбора определяют схожесть исключений по особым правилам. С точки зрения
текста сообщения <<user 1 not found>> и <<user 2 not found>> отличаются. Сборщик
схлопнет их в одну ошибку и по запросу покажет все варианты.

\emph{Поиск.} Нельзя построить эффективный поиск без структуры. Когда ошибки в
виде текста, можно искать только по вхождению или регулярному выражению. Такой
поиск нерелевантен, то есть не учитывает, насколько точно сущность совпадает с
запросом. Еще он не учитывает дубли. Мы бы не хотели видеть тысячу одинаковых
сообщений в выдаче.

\emph{Статистика.} Когда ошибки разобрали на части, можно строить
отчеты. Например, сколько ошибок случилось за последний месяц или
год. Группировать данные по проектам или командам. Выявить проекты, где ошибки
случаются чаще всего.

\emph{База знаний.} В системе сбора каждая ошибка становится артефактом. К ней
пишут комментарии, прикрепляют скриншоты или записи с экрана. На ошибку можно
сослаться как на документ в задаче или ревью кода. Если исключения хранят в
логах, это невозможно.

Среди прочих систем достойно выглядит Sentry, веб-приложение на Django. На
главной страницы видны проекты и краткая статистика по ним. Каждый проект
накапливает ошибки, которые получает от клиентов.

Чтобы отправить ошибку в Sentry, к нему обращаются по HTTP методом POST. В теле
передают JSON-документ с различными полями. Протокол Sentry предлагает несколько
десятков полей, чтобы описать ошибку. Сюда входят параметры машины, операционной
системы, детали HTTP-запроса, стек-трейс и другие.

Как правило, приложение не собирает эти данные вручную, а пользуется
библиотеками. Часто они называются Raven или похожим образом. Семантика в том,
что \emph{сторожевой ворон} (анг. raven) несет вести \emph{дозорному}
(анг. sentry).

Для Clojure написаны две библиотеки к \spverb|Sentry|:
\spverb|getsentry/sentry-clj|\footurl{https://github.com/getsentry/sentry-clj} и
\spverb|exoscale/raven|\footurl{https://github.com/exoscale/raven}. Первая опирается на
официальную Java-библиотеку. Это частая практика в мире Clojure~--- не писать
код с нуля, а повторно использовать код на Java.

Проверим \spverb|sentry-clj| в действии. Добавьте в проект зависимость:

\begin{verbatim}
[io.sentry/sentry-clj "0.7.2"]
\end{verbatim}

Инициализируйте библиотеку с нужным DSN. Под DSN понимают адрес проекта в
Sentry. Проект объединяет сообщения по глобальному признаку. Например, ошибки
бекенда в одном проекте, фронтенда~--- во втором, мобильного приложения~--- в
третьем. DSN находится в настройках проекта в разделе <<интеграция>>.

\begin{verbatim}
(require '[sentry-clj.core :as sentry])
(def DSN "https://.....@sentry.io/.....")
(sentry/init! DSN)
\end{verbatim}

Теперь когда проект задан, отправим сообщение. Функция \spverb|send-event|
принимает словарь параметров. Нас интересует случай, когда мы поймали исключение
и хотели бы отправить его без лишних усилий. Для этого служит ключ
\spverb|:throwable|:

\begin{verbatim}
(sentry/send-event {:throwable e})
\end{verbatim}

В ответ получим номер события, а в проекте появится новая запись. Предположим,
мы передали экземпляр \spverb|e|, который задали выше (цепочку из трех
исключений). В веб-интерфейсе увидим информацию о каждом из них. В поле
\spverb|:extra| будут данные верхнего исключения, то есть словарь
\spverb|{:user-id 42}|.

Недостаток \spverb|sentry-clj| в том, что она недостаточно гибка. Хотелось бы
видеть данные всех уровней, а не только верхнего. Иначе мы не узнаем, какой был
API-ключ, по какому адресу мы обратились в сеть и другие детали. Технически
возможно собрать данные вручную и передать в ключ \spverb|:extra|. Однако лучше
поручить это стороннему коду.

Библиотека \spverb|exoscale/raven| целиком написана на Clojure и потому более
гибка. С недавней версии она передает максимально полные данные об
исключении. Подключите ее в проект:

\begin{verbatim}
[exoscale/raven "0.4.8"]
\end{verbatim}

\noindent
и отправье исключение \spverb|e|:

\begin{verbatim}
(require '[raven.client :as raven])
(raven/capture! DSN e)
\end{verbatim}

Откройте сообщение в интерфейсе Sentry и мотайте вниз. В секции \spverb|extra|
появится ключ \spverb|:via| с детальной информацией (приведем фрагмент):

\begin{verbatim}
[ {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "Get user info error",
  "data" : {
    "user-id" : 42
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 160 ]
}, {
  "type" : "clojure.lang.ExceptionInfo",
  "message" : "Auth error",
  "data" : {
    "api-key" : "........."
  },
  "at" : [ "clojure.lang.AFn", "applyToHelper", "AFn.java", 160 ]
} ]
\end{verbatim}

Это JSON-данные, вектор словарей. Каждый словарь состоит из класса исключения,
его сообщения и данных. В поле \spverb|:at| вектор четырех элементов: класс,
метод, имя файла и строка, на которой возникло исключение. С таким отчетом найти
причину будет проще.

Структуру выше легко получить в любом месте Clojure. Функция
\spverb|Throwable->map| принимает исключение и отдает словарь с ключами
\spverb|:via|, \spverb|:cause| и другими. Классы и методы это не ссылки, а
символы, поэтому результат \spverb|Throwable->map| легко записать в JSON или
EDN.

\section{Sentry и Ring}

%% TODO ref
%% Мы разобрали декораторы в главе про веб-разработку.

Теперь когда вы знакомы с логированием и Sentry, напишем защитный декоратор для
Ring-приложения. Его ставят на вершину стека middleware. Декоратор ловит все
ошибки, отправляет в Sentry и возвращает нейтральный ответ о том, что запрос не
удался.

\begin{verbatim}
(defn wrap-exception
  [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        (try
          (raven/capture! DSN e)
          (catch Exception e-sentry
            (log/errorf e-sentry "Sentry error: %s" DSN)
            (log/error e "Request failed"))
          (finally
            {:status 500
             :body "Internal error, please try later"}))))))
\end{verbatim}

Обратите внимание, что запрос к Sentry тоже обернут в \spverb|try/catch|. Sentry
это отдельный сервис и может быть недоступен. В таком случае в лог пишут оба
исключения: и первичное, и связанное с Sentry. Это лучше, чем игнорировать их.

\section{Переходы}

До сих пор мы рассматривали исключение как сигнал об ошибке. Вспомним ключевое
свойство исключения. Оно прерывает программу и всплывает вверх, пока его не
поймают. Иногда исключенем пользуются, чтобы прыгнуть вверх по стеку. Если
бросить особое исключение, например \spverb|MyGOTOException|, а сверху обернуть
код в \spverb|catch| с этим классом, то получим классический оператор
\spverb|GOTO|:

\begin{verbatim}
(try
  (do-first-step)
  (do-second-step)
  (when (condition)
    (throw (new MyGOTOException)))
  (do-third-step)
  (catch MyGOTOException e
    (println "Skipped the third step")))
\end{verbatim}

В этим примере, если что-то пошло не так, мы пропустим третий шаг. В литературе
трюк называют <<исключение как способ управления исполнением>>.

Это противоречивая практика; применяйте ее осторожно. Тот, кто злоупотребляет
прыжками по коду, использует инструмент не по назначению. Код становится
неочевидным и трудным в поддержке.

Все же бывают моменты, когда нужно прервать запрос на середине. Например, мы
выяснили, что у пользователя нет прав к ресурсу, поэтому продолжать нет
смысла. Усложним задачу: пусть проверок несколько, и на каждой исполнение
прерывают. В императивных языках это легкая задача. Код на Python выглядел бы
так:

\begin{verbatim}
class AccountHandler(RequestHandler):
  def on_get(self, request):
    if not self.check_this(request):
      return BadRequest("Wrong input data")
    if not self.check_that(request):
      return NotFound("No such an account")
    if not self.check_quotas(request):
      return QuotasReached("Request rate is limited")
    return JSONResponse(self.get_data_from_db())
\end{verbatim}

В Clojure нет оператора \spverb|return|. Результат нескольких форм это результат
последней. Мы не можем расположить несколько \spverb|when| на одном уровне друг
под другом. В этом нет смысла, поскольку даже если какая-то из них вернет ложь,
исполнение перейдет к следующей форме.

Вариант с каскадом \spverb|if/else| работает, но выглядит громоздко. Получилось
то, что называют <<The Pile of Doom>>. Чем ниже ее вложенность, тем больше
проблем в поддержке. Ради интереса добавьте новое условие в середину:

\begin{verbatim}
(defn account-handler [request]
  (if (check-this request)
    (if (check-that request)
      (if (check-quotas request)
        {:status 200
         :body (get-data-from-db)}
        (quotas-reached "Request rate is limited"))
      (not-found "No such an account"))
    (bad-request "Wrong input data")))
\end{verbatim}

Пирамиду решают разными способами, в том числе исключениями. Библиотека
\spverb|metosin/ring-http-response| предлагает функции, которые бросают
исключения с HTTP-ответом. В стек middleware добавляют особый декоратор, который
ловит такие исключения и возвращает ответ клиенту. Добавьте библиотеку в проект:

\begin{verbatim}
[metosin/ring-http-response "0.9.1"]
\end{verbatim}

Перепишем \spverb|account-handler| на новый лад:

\begin{verbatim}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler [request]
  (when-not (check-this request)
    (bad-request! "Wrong input data"))
  (when-not (check-that request)
    (not-found! "No such an account"))
  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))
  {:status 200
   :body (get-data-from-db)})
\end{verbatim}

Новый код похож на императивный. Некоторых уязвляет факт, что в Clojure
пользуются императивным подходом. Это нормально. Наша задача~--- сделать так,
чтобы код был понятным и удобным в поддержке. Вопрос парадигмы при этом не так
важен.

Функции из модуля \spverb|ring.util.http-response| бывают с восклицательным
знаком и без него. Это сигнал о том, что функция бросает исключение. Так,
\spverb|not-found!| бросает \spverb|ex-info|, в теле которого HTTP-ответ со
статусом 404.

Чтобы схема работала, добавим в стек middleware декоратор
\spverb|wrap-http-response|. Он ловит ошибки, брошенные функциями с
восклицательным знаком. Затем достает из них ответ и возвращает клиенту.

\begin{verbatim}
(require '[ring.middleware.http-response
           :refer [wrap-http-response]])

(def app
  (-> app-naked
      wrap-params
      wrap-session
      wrap-cookies
      wrap-http-response))
\end{verbatim}

Не злоупотребляйте исключениями для переходов. Убедитесь, что это крайняя мера:
вы должны что-то выиграть, например, сократить код. Пользуйтесь библиотекой, а
не сиюминутным решением. Библиотека несет документацию и опыт других людей.

\section{Finally и контекстный менеджер}

Иногда код выполняют в рамках ресурса. Это может быть файл, сетевой порт или
база данных. В начале работы ресурс <<открывают>>, а в конце
<<закрывают>>. Открытый ресурс считается занятым. Когда ресурс занят, другие
клиенты не могут пользоваться им в полной мере. Например, открытый кем-то файл
можно читать, но не изменять. Принято освобождать ресурс сразу же, как только он
стал не нужен. Технически это сводится к методу \spverb|.close|
(\spverb|.disconnect|, \spverb|.shutdown| и т.д.) у объекта.

Освобождению может помешать ошибка. Если код, который работает с ресурсом, не
поймал исключение, файл или порт останется занятыми до конца работы. Чтобы
закрыть ресурс даже в случае ошибки, прибегают к форме \spverb|finally|.

Форму ставят последней внутри \spverb|try|. Исключения в JVM устроены так, что
управление переходит в \spverb|finally| даже в случае исключения. Если ошибки не
было, \spverb|finally| сработает после основного кода из \spverb|try|. Если
ошибка возникла, \spverb|finally| получит управление в промежутке между ее
появлением и броском.

Рассмотрим ручной доступ к файлу. Мы пишем в него несколько байт. Форма
\spverb|finally| гаранитрует, что файл закроется, даже если если что-то пойдет
не так.

\begin{verbatim}
(import '[java.io File FileWriter])

(let [out (new FileWriter (new File "test.txt"))]
  (try
    (.write out "Hello")
    (.write out " ")
    (.write out "Clojure")
    (finally
      (.close out))))
\end{verbatim}

Чтобы вы не забыли закрыть файл, современные языки предлагают \emph{контекстные
  менеджеры}. Это может быть класс, оператор или макрос. Менеджер исполняет блок
кода с дополнительными эффектами. Перед блоком сработает логика входа, а после
него~--- логика выхода. Последний сработает даже в том случае, если в блок
бросил исключение. Платформа удержит его, выполнит логику выхода и снова бросит.

В Python контекстный менеджер выполнен изящно. Это оператор \spverb|with|,
который ожидает объект. У объекта должны быть методы \spverb|__enter__| и
\spverb|__exit__|, которые вызывают при входе и выходе. \spverb|With| используют
для файлов, транзакций базы данных, фикстур в тестах. Пример с файлом:

\begin{verbatim}
with open("/path/to/file.txt", "w") as f:
    f.write("test")
\end{verbatim}

Напишем похожий менеджер для Clojure. Это макрос, который принимает символ и
путь к файлу. В теле макроса файл связан с символом. Форма \spverb|finally|
гарантирует, что файл закроется при выходе из макроса.

\begin{verbatim}
(defmacro with-file-writer
  [[bind path] & body]
  `(let [~bind (new FileWriter (new File ~path))]
     (try
       ~@body
       (finally
         (.close ~bind)))))
\end{verbatim}


\noindent
Выполните код и проверьте файл \spverb|test.txt|:

\begin{verbatim}
(with-file-writer [out "test.txt"]
  (.write out "Hello macro!")
  (\ 0 0))
\end{verbatim}

Контекстные менеджеры именуют с префиксом \spverb|with-|. Так делают акцент на
том, что код работает в рамках временного ресурса.

В библиотеке Clojure уже предусмотрен макрос \spverb|with-open|. Это улучшенная
версия кода, что мы написали выше. В отличии от нашего примера,
\spverb|with-open| работает с более абстрактным классом \spverb|Reader|. Это
источник данных, который \emph{в том числе} может быть и файлом. Выход из
макроса, даже с ошибкой, закрывает источник.

В форме \spverb|finally| нет смысла при работе с коллекциями или чистыми
функциями. Пользуйтесь ей только если ресурс занят и должен быть освобожден.

\section{Исключения на предикатах}

Система \spverb|try/catch| работает на классах и наследовании. Если требуется
отловить особый случай, пишут новый класс и бросают его экземпляр.

Типичный проект на Java или Python несет на борту модуль с исключениями. Как
правило, это базовое \spverb|ProjectException| и унаследованные от него
\spverb|UserNotFound|, \spverb|UserAccessDenied| и другие. Это длинный
однообразный код, написанный вручную.

%% TODO ref

В главе про \spverb|clojure.spec| мы говорили, что предикаты мощнее типов. Это
верно и для исключений. Если бы можно было поймать исключение функцией, не
потребовались бы классы. В Clojure это возможно при помощи библиотеки
\spverb|Slingshot|\footurl{https://github.com/scgilardi/slingshot} (анг. рогатка).

Библиотека предлагает улучшенные версии \spverb|try|, \spverb|catch| и
\spverb|throw|. В Clojure с ее системой макросов можно сделать многое, в том
числе задать другой способ работы с исключениями. В других языках новый оператор
ждут годами, а в Clojure это решается библиотекой.

В \spverb|Slingshot| можно бросить не только исключение, но и любой тип: строку,
число, словарь. Библиотека предлагает макросы \spverb|throw+| и
\spverb|try+|. Они совместимы с обычными \spverb|throw| и \spverb|try|: если
заменить старые формы на версии с плюсом, ничего не изменится. Однако новые
формы несут преимущества.

Макрос \spverb|throw+| принимает не только исключение, но и \emph{любой
  Java-объект}. Лучше всего на эту роль подходит словарь: он несет несколько
значений и их семантику в ключах. Пример ниже бросит \spverb|ex-info| с заданным
словарем:

\begin{verbatim}
(require '[slingshot.slingshot :refer [try+ throw+]])
(throw+ {:user-id 42 :action :create})
\end{verbatim}

Другая запись этого макроса: словарь, причина \emph{(cause)}, сообщение и
переметры форматирования:

\begin{verbatim}
(let [path "/var/lib/file.txt"]
  (try
    (slurp path)
    (catch Exception e
      (throw+ {:path path} e "File error: %s" path))))
\end{verbatim}

Кроме классов, форма \spverb|catch| внутри \spverb|try+| ловит исключения по
\emph{селектору и предикату}. Под селектором понимают вектор, где нечетный
элемент это ключ словаря, а четный~--- значение. Селектор проверяет, что ключи и
значения входят в контекст. Если да, исключение поймали, и управление переходит
в ветку с этим селектором.

\begin{verbatim}
(try+
 (throw+ {:type ::user-error
          :user 42
          :action :update
          :data {:name "Ivan"}})
 (catch [:type ::user-error] e
   (clojure.pprint/pprint e)))
\end{verbatim}

Когда бросаете словарь, добавляйте поле \spverb|:type|. В нем указывают ключ с
текущим простанстом. В нашем случе это \spverb|:book.exceptions/user-error|. При
отлове исключений указывают пару \spverb|[:type ::user-error]|. Пространство
гарантирует, что мы не поймаем \spverb|:user-error| из другого модуля.

Пример выше напечатает брошенный словарь. Макрос \spverb|catch| достаточно умен
и подставляет в переменную \spverb|e| не исключение, а данные, которые бросили.

Предикат работает аналогично. Разница лишь в том, что вместо селектора указывают
функцию одного аргумента. Она принимает исключение или данные и возвращает
истину или ложь. Функция должна быть готова к тому, что тип параметра может быть
разным.

В примере ниже мы считаем, что операции над пользователем 1 заслуживают особого
внимания. В этом есть смысл, потому что первый пользователь, как правило, это
супер-админ:

\begin{verbatim}
(defn system-user-case? [data]
  (when (map? data)
    (let [{:keys [type user]} data]
      (and (= type ::user-error)
           (= user 1)))))
\end{verbatim}

С таким предикатом любой пользователь удалит себя из системы, кроме
администратора:

\begin{verbatim}
(try+
 (throw+ {:type ::user-error
          :user 1
          :action :delete})
 (catch system-user-case? e
   (println "Cannot delete a system account")))
\end{verbatim}

Пример из проекта, где загружают файлы в Amazon S3. В особых случаях Java SDK
бросает исключение уже после того, как файл загрузился. Обычно это связано с
контрольными суммами. Загрузка считается неудачной, и мы должны удалить файл,
чтобы он не занимал место. Для этого сценария нет отдельного класса. Поэтому
ловим класс AmazonS3Exception и проверяем его сообщение по шаблону.

\begin{verbatim}
(defn aws-checksum-error? [e]
  (and (instance? AmazonS3Exception e)
       (some?
        (re-find
         #"(?i)The Content-Md5 you specified did not match"
         (ex-message e)))))
\end{verbatim}

\spverb|Slingshot| используют другие проекты, например,
\spverb|clj-http|\footurl{https://github.com/dakrone/clj-http}, популярный HTTP-клиент
для Clojure. В случае ошибки он бросает ответ через \spverb|throw+|. Если
обернуть запрос в \spverb|try+|, откроется более тонкий разбор ошибок. Например,
отдельные ветки для статуса 500 и негативного ответа в целом.

\begin{verbatim}
(require '[clj-http.client :as client])

(try+
 (client/get "http://example.com/test")
 (catch [:status 500] e
   (println "The service is unavailable"))
 (catch [:type :client/unexceptional-status] e
   (println "Negative response")))
\end{verbatim}

\spverb|Slingshot| делает ставку на данные, а не классы, что поощрается в
Clojure. Начинающим не очевидны плюсы, которые библиотека несет в проект. Это
нормально: для начала советуем читателю разобраться с обычными
\spverb|try/catch|. Подключайте \spverb|Slingshot| только если чувствуете в ней
потребность.

\spverb|Slingshot| не единственный пример <<своих>> исключений. Обратите
внимание на \spverb|ex|\footurl{https://github.com/exoscale/ex}~--- аналог, которым
пользуются в Exoscale. Библиотека учитывает семантику (\spverb|:fault|,
\spverb|:conflict|), наследование ключей, поддерживает \spverb|manifold| и
многое другое.

\section{Приемы и функции}

Рассмотрим несколько функций на тему исключений. Они просты и потому не стоят
того, чтобы выносить их в отдельную библиотеку. Как правило, их копируют из
проекта в проект с небольшими изменениями. Автор уверен, у каждого разработчика
найдется что-то подобное.

\emph{Безопасный вызов функции.} В замечательном языке Lua нет операторов
\spverb|try| и \spverb|catch|. Чтобы обезопасить вызов функции от ошибки,
используют \spverb|pcall|\footurl{https://www.lua.org/pil/8.4.html}. Это
сокращение от \emph{protected call}, защищенный вызов.

В \spverb|pcall| передают функцию и аргументы. Результатом будет пара и более
элементов (в Lua функция может вернуть несколько значений). Первый из них
означает успех выполнения. Если истина, то на втором месте результат вычислений,
а иначе экземпляр ошибки. Тот же самое в Clojure:

\begin{verbatim}
(defn pcall [f & args]
  (try
    [true (apply f args)]
    (catch Exception e [false e])))
\end{verbatim}

Чтобы получить доступ к элементам пары, разбейте результат в \spverb|let|:

\begin{verbatim}
(let [[ok? result-error] (pcall inc 1)]
  (if ok?
    (println (str "The result is " result-error))
    (println "Failure")))
\end{verbatim}

\emph{Ошибка и результат.} В мире JavaScript популярны функции-колбеки. По
соглашению колбек принимает аргументы \spverb|error| и \spverb|result|. Функция
\spverb|pcall-js| это измененный вариант \spverb|pcall|, который возвращает пару
<<ошибка и результат>>.

\begin{verbatim}
(defn pcall-js [f & args]
  (try
    [nil (apply f args)]
    (catch Exception e [e nil])))
\end{verbatim}
%% ---------------
\emph{Попытки с задержкой.} Иногда функция не гарантирует, что отработает
успешно. Такое случается, когда мы обращаемся ко внешнему нестабильному
сервису. Функция \spverb|pcall-retry| пытается выполнить целевую функцию за
несколько попыток. Первый же удачный вызов станет результатом. Если была ошибка,
но число попыток еще не превысило порога, то функция ждет небольшой интервал
времени и повторяет вызов. Когда все попытки закончились, функция вызывает
исключение.

\begin{verbatim}
(defn pcall-retry
  [n f & args]
  (loop [attempt n]
    (let [[ok? res] (apply pcall f args)]
      (cond
        ok? res

        (< attempt n)
        (do
          (Thread/sleep (* attempt 1000))
          (recur (inc n)))

        :else
        (throw res)))))
\end{verbatim}

Это наивная версия функции, и в реальных проектах ее дорабатывают. Например,
меняют стратегию задержки, добавляют логирование. Но основа остается прежней.

Любопытно, что функции выше стыкуются между собой. Чтобы предотвратить выброс
исключения из \spverb|pcall-retry|, завернем ее в \spverb|pcall|:

\begin{verbatim}
(pcall pcall-retry get-user-by-id 42)
\end{verbatim}

Тогда даже в случае ошибки получим пару \spverb|[ok? result]|.

Форма \spverb|loop| заслуживает особого упоминания. Ее дочерняя форма \spverb|recur| не может
располагаться внутри \spverb|try/catch|. Пример ниже не просто ошибочный в плане
семантики. При при попытке ее скомпилировать вы получите исключение "Can only
recur from tail position":

\begin{verbatim}
(defn pcall-retry
  [n f & args]
  (loop [attempt n]
    (try
      (apply pcall f args)
      (catch Exception e
        (recur (inc n))))))
\end{verbatim}

Это один их тех случаев, когда мы не можем использовать \spverb|try/catch|. На помощь
приходит \spverb|pcall| и его вариации.

\emph{Throw in place.} До сих пор мы кидали исключения двумя формами: \spverb|ex-info| и
\spverb|throw|. Первая формирует исключение, а вторая его бросает. Логично совместить
их в функцию \spverb|error!|. Заодно сделаем часть аргументов необязательными:

\begin{verbatim}
(defn error!
  [message & [data e]]
  (throw (ex-info message (or data {}) e)))
\end{verbatim}

Теперь достаточно написать:

\begin{verbatim}
(error! "Some error!" {:type ::error})
\end{verbatim}

, чтобы кинуть исключение с нужными данными.

\emph{Форматированное сообщение.} Иногда нам нужен не контекст, а подробное
сообщение об ошибке. В этом случае \spverb|ex-info| избыточен, поскольку без контекста
он не имеет смысла. Достаточно выкинуть \spverb|Exception| с форматированным
сообщением. В параметры функции передают шаблон и значения для подстановки. В
этом и других примерах часть \spverb|f| на конце означает форматирование.

\begin{verbatim}
(defn errorf!
  [template & args]
  (let [message (apply format template args)]
    (throw (new Exception ^String message))))

(errorf! "Cannot process a user %s with the action %s" "AAA" :UPDATE)
\end{verbatim}

\emph{Безопасный макрос.} Примеры выше можно переписать на макросах. Преимущество
макросов в том, что они изящней встраиваются в код. С другой стороны, на них
нельзя ссылаться как на объект. Макрос нельзя передать в \spverb|apply|, \spverb|map| и другие
высшие функции.

Пример ниже показывает, как выполнить часть кода в безопасном режиме, игнорируя
ошибку:

\begin{verbatim}
(defmacro with-safe
  [& body]
  `(try
     ~@body
     (catch Exception e#)))
\end{verbatim}

Пустая форма catch возвращает nil. Мы получим его, если случится ошибка:

\begin{verbatim}
(with-safe (/ 0 0))
nil
\end{verbatim}

\spverb|Nil| может быть положительным результатом кода, который мы передали в
макрос. На практике ошибку передают другим значением. Обычно это кейворд
\spverb|:error| или \spverb|:invalid|. По такому принципу работает пакет \spverb|clojure.spec|,
который мы разобрали в прошлой главе. Если валидация не прошла, результат будет
\spverb|:clojure.spec.alpha/invalid|.

В реальности редко бывает так, что нам безразлично, была ошибка или нет. Поэтому
на практике макрос дорабатывают: добавляют в форму \spverb|catch| код для записи
исключения в лог или отправки в Sentry.

\section{Заключение}

Перечислим основные тезисы главы. Clojure использует систему исключений
Java. Эта система работает на классах и дереве наследования. Формы \spverb|try| и
\spverb|catch| похожи на одноименные операторы Java.

Особая форма \spverb|finally| дает шанс закрыть ресурс в случае ошибки. Чтобы упростить
работу с ресурсом, пользуйтесь контекстными менеджерами. Это макросы вида
\spverb|with-<something>|. Для доступа к файлам Clojure предлагает макрос \spverb|with-open|.

Класс \spverb|ExceptionInfo| разработан специально для Clojure. Его преимущество в поле
\spverb|data|, куда можно записать любой словарь. Функция \spverb|ex-info| упрощает создание
этого исключения.

У каждой ошибки может быть причина, \spverb|cause|. Если вы поймали исключение, лучше
бросить новое с текущим контекстом и причиной-оригинальным исключением. Так
исключения собираются в цепочку.

В приложении должен быть код, который решает, что делать с пойманным
исключением. Лучше всего отправить его в единую систему сбора ошибок. Sentry
будет хорошим решением. Проследите, что ваш клиент к Sentry передает всю нужную
информацию, а не только стек-трейс.

В особых случаях исключениями пользуются, чтобы мгновенно перейти в другое место
в коде. На это у вас должны быть веские причины.

Проект Slingshot предлагает улучшенную схему \spverb|try/catch|. При таком подходе мы
оперируем не исключениями, а данными.

Ряд функций и макросов упрощают контроль над исключениями. Изучите их, чтобы
уменьшить код.

%% [source]: https://github.com/igrishaev/book-sessions/blob/master/src/book/exceptions.clj TODO

Код этой главы доступен [в одном модуле][source] на Гитхабе.
