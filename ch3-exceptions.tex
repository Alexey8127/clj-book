\chapter{Исключения}

\begin{teaser}
В этой главе мы рассмотрим исключения в Clojure: как они устроены и чем
отличаются от аналогов Java. Когда лучше кидать, а когда перехватывать
исключения. Как и что писать в лог, чтобы расследовать инцидент было легко.
\end{teaser}

Возможно, читателю покажется странным, что исключениям отдана целая глава. Тему
считают простой: исключения можно кинуть, поймать и записать в лог. В теории
этого хватит, чтобы работать в проекте.

Исключения просты с технической стороны, но несут обширную
\emph{семантику}. Когда именно кидать исключения, а когда перехватывать? Как
извлечь полезную информацию из их цепочки? Куда их записывать? Можно ли ловить
исключения предикатами? На практике мы тонем во множестве частных случаев.

Новички следуют только положительному пути, поэтому в их коде тяжело
расследовать ошибки. Сервер вернул статус 500. Почему?  Возможны сотни причин,
по которым запрос не удался. Запись в логе слишком скудна, чтобы понять, что
произошло.

Хороший программист внимателен к ошибкам. С опытом становится ясно: экономия на
исключениях не дает выигрыша. Да, мы быстрее закроем задачу, и кода получится
меньше. Однако позже возникнут задачи на устранение ошибок и их детализацию.

Исключения в коде столь же равноправны, как и нормальное поведение. Избегайте
мысли, что это недоразумение, которое не случится с вами. Если в проекте много
задач на непойманные ошибки, это значит, пора разобраться с темой.

\section{Основы исключений}

Прежде чем углубляться в детали, вспомним, что такое исключения~и как они себя
ведут.

Исключение это объект, чаще всего экземпляр класса \spverb|Exception|. От других
классов он отличается тем, что его можно \emph{бросить}. В разных языках для
этого служат операторы \spverb|throw|, \spverb|raise| и другие.

Брошенный объект прерывает исполнение и всплывает по стеку вызовов. Возможны два
исхода: либо его поймали оператором \spverb|catch| на одном из уровней, либо
перехват не состоялся.

В первом случае мы получим \emph{объект} исключения. К нему обращаются как
обычно: читают поля, вызывают методы, передают в функции. Дальнейшее поведение
зависит от логики программы. Иногда исключение пишут в лог и завершают
программу, в других случаях продолжают работу.

Когда исключение не поймали, программа завершится с ошибкой. Если не
предусмотрено иное, перед выходом программа запишет его в \spverb|stderr| (канал
ошибок). Мы увидем класс исключения, его текст и то, что называют
<<стектрейс>>. Это цепочка вызовов, которые прошло исключение.

Отдельные платформы позволяют задать реакцию на не пойманное
исключение. Например, записать его в файл или завершить программу особым
способом.

Clojure это гостевой язык (анг. hosted language). Он опирается на возможности,
которые предлагает домашняя платформа, \emph{хост}.  Исключения~--- одна из
областей, в которую Clojure не вмешивается. По умолчанию Clojure использует
формы \spverb|try| и \spverb|catch|, аналогичные Java.

Рассмотрим исключения в Java. Платформа содержит базовый класс
\spverb|Throwable|, общий предок всех исключений. Другие классы наследуют его и
расширяют семантику. Наследники первого уровня это классы \spverb|Error| и
\spverb|Exception|. Последний это предок \spverb|RuntimeException| и так далее.

\chart{chart-ex-tree}

Пакеты Java несут дополнительные исключения, унаследованные от описанных
выше. Например, \spverb|java.io.IOException| для ошибок ввода-вывода,
\spverb|java.net.ConnectException| для сетевых проблем другие. Бросать
\spverb|Throwable| считается дурным тоном. Этот класс несет слишком мало
информации о том, что случилось.

В дереве исключений каждый класс дополняет семантику предка. Рассмотрим
исключение \spverb|FileNotFoundException|. Оно возникает, когда файла не
оказалось на диске. Родословная класса выглядит так:

\begin{english}
  \begin{text}
java.lang.Object
  java.lang.Throwable
    java.lang.Exception
      java.io.IOException
        java.io.FileNotFoundException
  \end{text}
\end{english}

Схему читают <<объект \arr выбрасываемое \arr исключение \arr ошибка
ввода-вывода \arr файл не найден>>. По имени \spverb|FileNotFoundException|
легко догадаться, с чем связана проблема. Если же разработчик бросил
\spverb|Throwable|, это усложнит поиск причины.

Различают \spverb|checked| и \spverb|unchecked| исключения, проверяемые и
нет. Разница между ними в семантике. Разработчик должен предвидеть
\spverb|checked| исключения и обработать в коде. При чтении файла справедливо
ожидать, что его не окажется на диске. Поэтому \spverb|FileNotFoundException|
относится к категории \spverb|checked|.

Предсказать нехватку памяти трудно, поэтому \spverb|OutOfMemoryError|
непроверяемое исключение. Когда оборудование на пределе, любое действие может
исчерпать память. Перехватывать это исключение нет смысла, поскольку при
нехватке памяти система нестабильна.

Классы, унаследованные от \spverb|Error| и \spverb|RuntimeException| это
непроверяемые (unchecked) исключения. Унаследованные от \spverb|Exception|~---
проверяемые (checked).

Чтобы бросить исключение, его экземпляр передают оператору
\spverb|throw|. Оператор \spverb|catch| перехватывает исключения. В Java и
других языках он устроен на иерархии классов. Если искомый тип
\spverb|IOException|, мы поймаем все исключения, унаследованные от этого класса.

Чем выше класс в дереве наследования, тем больше исключений поймает
\spverb|catch|. В Java считается плохим тоном ловить ошибки классами
\spverb|Throwable| или \spverb|Exception|. Современные IDE выдают предупреждение
<<too wide catch expression>>, что значит слишком широкий охват. Класс
\spverb|Exception| заменяют на несколько более точных исключений. Например,
отдельно ошибки ввода-вывода, сети и другие.

Одного класса недостаточно, чтобы понять причину
исключения. У~\spverb|FileNotFoundException| нет поля \spverb|file|, чтобы
отследить, какой именно файл не удалось найти. Большинство исключений принимают
строку с сообщением об ошибке. Сообщение должно быть понятно человеку, например
<<File С:/work/test.txt not found>>.

Иногда текста не хватает, чтобы объяснить причину ошибки. Предположим, данные не
прошли валидацию, и нам хотелось бы исследовать их позже. Если записать данные в
сообщение, текст получится слишком большим. Это небезопасно: в данных могут быть
личные данные или ключи доступа. Такое сообщение нельзя писать в лог или
показывать пользователю. Даже путь к файлу может выдать важную информацию.

Если нужно сохранить данные для расследования, создают новый класс исключения. У
него отдельное поле для данных, из-за которых произошла ошибка. Поле заполняют в
конструкторе исключения. Сообщение формируют так, чтобы оно не выдало приватную
информацию.

\section{Цепочки и контекст}

Исключения строятся в цепочку. Каждый экземпляр принимает необязательный
аргумент \spverb|cause| (анг. причина). Он хранит либо \spverb|Null|, либо
ссылку на другое исключение.

Цепочки образуются, когда код перехватил исключение, но не знает, как с ним
поступить.  Это нормально, потому что на низком уровне код не видит полной
картины. Предположим, метод пишет данные в файл. У него нет полномочий решить
что делать, если файла нет, поэтому метод бросит исключение. Его перехватит
метод, который тоже не принимает решений. Остается бросить новое исключение со
ссылкой на первое. Это и есть цепочка.

В конце управление перейдет к методу, который знает, что делать. Логика зависит
от типа исключения и бизнес-правил. Если файла нет, программа создаст его или
выполнит поиск в другом месте. Если в HTTP-запросе произошел сбой, выждать
секунду и повторить его. После третьей попытки завершить программу.

В системе должен быть последний рубеж, где перехватывают все исключения. Если
ошибка дошла до этого уровня, значит, ее не поймали правила рангом ниже. Это
говорит о нештатном поведении системы. Клиенту выводят нейтральный текст о том,
что запрос не прошел. Чтобы расследовать причину, исключение пишут в лог и
передают сборщику ошибок.

На верхнем уровне кода лежит бизнес-логика. Это шаги, которые диктует бизнес,
чтобы заработать больше денег. При спуске вниз начинается техническая
часть. Представим, что функция \spverb|get-user| находит пользователя по
номеру. Снаружи это черный ящик: мы не знаем, откуда приходят
данные. Предположим, из сетевого сервиса. Выразим это на псевдокоде:

\begin{english}
  \begin{python}
def get-user(id):
  url = "http://api.company.com/user/" + str(id)
  return http.GET(url).body.json()
  \end{python}
\end{english}

Если вызвать функцию с номером, которого нет в системе, получим исключение
\spverb|HTTP Error: status 404|. Текст ничего не говорит о пользователе. Если
встретить эту запись в журнале, мы даже не поймем, к какому сервису обращались.

Чем больше мы углубляемся в технические детали, тем меньше знаем о бизнесе. В
HTTP нет понятия пользователя. Известны лишь метод, адрес и другие поля
запроса. Разделим ошибку на две половины. Верхняя часть называет бизнес-причину:
не найден пользователь с номером 42. Почему? Из-за технического сбоя: запрос GET
к адресу \spverb|http://api.company.com/user/42| вернул статус 404.

Расставим в коде дополнительные \spverb|try/catch|. Когда исключение пришло из
технических недр, дополним его контекстом и отправляем наверх. Этот паттерн
называется \spverb|re-throw|, повторный выброс. Улучшенный псевдокод:

\begin{english}
  \begin{js}
def get-user(id):
  try {
    url = "http://api.company.com/user/" + str(id)
    return http.GET(url).body.json()
  } catch error {
    message = "Cannot fetch user " + str(id)
    throw Error(message, cause=error)
  }
  \end{js}
\end{english}

Новое исключение описывает бизнес-проблему и при этом ссылается на
техническую. У ошибки HTTP тоже может быть причина: устаревший сертификат,
проблемы соединения. Образуется цепочка исключений. В проектах они достигают
пять и более звеньев.

Спуск по цепочке напоминает допрос. На каждое <<почему>> мы получаем новую пищу
для размышлений, пока не доберемся до сути. Это не значит, что самое нижнее
исключение важнее других: одно лишь \spverb|HTTPError| не описывает
ситуацию. Важно то, как к нему пришли.

Так работают исключения в промышленных языках: Java, Python и других. У каждой
платформы особенности, но в целом картина не меняется. Теперь рассмотрим, что
предлагает Clojure.

\section{Переходим к Clojure}

Чтобы познакомиться с исключением, спровоцируем его. Подойдет старый при\"{е}м~---
поделить число на ноль. Включите REPL и выполните \spverb|(/ 1 0)|. Появится
текст:

\begin{english}
  \begin{text}
Execution error (ArithmeticException)...
Divide by zero
  \end{text}
\end{english}

Это отч\"{е}т об ошибке. В зависимости от редактора и настроек оно выглядит
по-разному. Например, Emacs с модулем Cider откроет буфер \spverb|*cider-error*|
с подробной информацией.

Заметим, что исключение в REPL не завершает его: от нас по-прежнему ждут
команды. В боевом запуске программы на Clojure ведут себя как обычно. Если в
главном потоке не поймано исключение, программа остановится.

Чтобы поймать исключение, код помещают в форму \spverb|try|. За ним следует одна
и более \spverb|catch|. В них указывают, какие классы перехватывать и что делать
с исключением. Вот как безопасно разделить число:

\begin{english}
  \begin{clojure}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
  \end{clojure}
\end{english}

Форма \spverb|catch| принимает класс и произвольный символ. С ним будет связано
исключение, если управление перейдет в эту ветку. Далее ид\"{е}т произвольный код. В
нем исключение доступно как локальная переменная \spverb|e|.

Мы вывели на экран текст, что вычисления прошли неудачно. Это слишком
поверхностное объяснение. Метод \spverb|.getMessage| верн\"{е}т сообщение, которое
назначили исключению при создании. С версии 1.10 Clojure предлагает функцию
\spverb|ex-message|, которая делает то же самое:

\begin{english}
  \begin{clojure}
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println (ex-message e))))
;; Divide by zero
  \end{clojure}
\end{english}

Класс \spverb|ArithmeticException| ловит не все ошибки вычислений. Что случится,
если сложить 1 и \spverb|nil|? Даже если поместить расчеты в \spverb|try/catch|,
мы не поймаем исключение:

\begin{english}
  \begin{clojure}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics")))
;; Execution error (NullPointerException)...
  \end{clojure}
\end{english}

Дело в том, что классы \spverb|ArithmeticException| и
\spverb|NullPointerException| не пересекаются. У них разные пути в дереве
наследования, поэтому перехват одного не влияет на другое. Это правильно, потому
что у классов разная семантика. Ошибка в арифметике это не то же самое, что
\spverb|Null| вместо значения.

Форма \spverb|try| принимает несколько \spverb|catch|. Перехватим оба случая:

\begin{english}
  \begin{clojure}
(try
  (+ 1 nil)
  (catch ArithmeticException e
    (println "Weird arithmetics"))
  (catch NullPointerException e
    (println "You've got a null value")))
  \end{clojure}
\end{english}

Макрос перебирает классы из каждого \spverb|catch| и остановится на первом
подходящем варианте. Результатом \spverb|try| станет последнее выражение из
блока \spverb|catch|, который подошел. В примере выше результат будет
\spverb|nil|, потому что его верн\"{е}т \spverb|println|. Если ни одна ветка не
подошла, исключение продолжит путь вверх по стеку вызовов.

Чем выше класс исключения в дереве, тем больше случаев он поймает. Если заменить
\spverb|ArithmeticException| на \spverb|Throwable|, ветка захватит любое
исключение, будь то деление на ноль или \spverb|NPE|:

\begin{english}
  \begin{clojure}
(try
  (/ 1 0)
  (+ 1 nil)
  (catch Throwable e
    (println "I catch everything!")))
  \end{clojure}
\end{english}

В отличие от Java, в Clojure нет строгих правил о том, какие исключения
перехватывать. Это остается на ваше усмотрение. Здравый смысл подсказывает, что
перехват \spverb|Throwable| опасен: возникает ложное ощущение, что код работает
без ошибок.

В случае с \spverb|ArithmeticException| проблема в расчетах, но для \spverb|NPE|
это не так. \spverb|Nil| вместо числа говорит о том, что проблема в функции,
которая вернула \spverb|nil|, а не в арифметике. Вот почему перехват
\spverb|NPE| вреден.

Форму \spverb|try/catch| с широким охватом ставят на верхний уровень кода. Это
нужно, чтобы программа не остановилась никогда. Так работают веб-серверы,
очереди сообщений, сетевое ПО.

Иногда мы намеренно бросаем исключение, чтобы сообщить о нештатной
ситуации. Оператор \spverb|new| создает новый Java-объект. Ему передают класс и
параметры конструктора. Форма \spverb|throw| принимает исключение и запускает
механизм выброса.

\begin{english}
  \begin{clojure}
(let [e (new Exception "Something is wrong!")]
  (throw e))
  \end{clojure}
\end{english}

Такое сообщение не информативно. Даже если мы указали, что проблема в арифметике
или базе данных, хотелось бы знать, какие именно значения вызвали ошибку. Для
этого сообщение строят функцией \spverb|format|. Она принимает шаблон и
параметры подстановки:

\begin{english}
  \begin{clojure}
(defn add [a b]
  (if (and a b)
    (+ a b)
    (let [message (format "Value error, a: %s, b: %s" a b)]
      (throw (new Exception message)))))
  \end{clojure}
\end{english}

\noindent
Если вызвать \spverb|add| с одним и параметров \spverb|nil|, сообщение станет
понятнее:

\begin{english}
  \begin{clojure}
Execution error at book.exceptions/add (exceptions.clj:86).
Value error, a: 1, b: null
  \end{clojure}
\end{english}

Функция \spverb|format| полезна тем, что отображает \spverb|nil| как
\spverb|null|. Это преимущество перед \spverb|str|, которая приводит
\spverb|nil| к пустой строке. Вариант со \spverb|str| выглядит так:

\begin{english}
  \begin{clojure}
(str "Value error, a:" 1 ", b: " nil)
;; Value error, a:1, b:
  \end{clojure}
\end{english}

\noindent
Текст вводит в заблуждение: \spverb|b| это \spverb|nil| или пустая строка?
Непонятно.

\section{Контекст}

Данные в тексте приводят к риску. Сообщение может оказаться слишком большим или
выдать лишние сведения. Проблему решает класс \spverb|ExceptionInfo|~---
исключение из поставки Clojure. Оно устроено так, чтобы хранить данные. Clojure
предлагает ряд функций для работы с ним.

Ключевая функция \spverb|ex-info| создает экземпляр \spverb|ExceptionInfo|. Она
принимает сообщение и словарь данных. Это контекст, в котором возникло
исключение. Например, если HTTP-запрос не удался, в словарь помещают метод,
адрес и код ответа.

\spverb|Ex-info| только создает исключение, но не бросает его. Результат
передают в \spverb|throw|:

\begin{english}
  \begin{clojure}
(throw (ex-info
        "Cannot fetch user."
        {:user-id 42
         :http-status 404
         :http-method "GET"
         :http-url "https://host.com/users/42"}))
  \end{clojure}
\end{english}

Мы разделили сообщение и данные. Текст не выдает номер пользователя и адрес
сервиса. Его запишут в лог или отправят пользователю, а контекст обработают
отдельно.

При работе с контекстом помните несколько правил. Словарь не может быть
\spverb|nil|. Это редкий случай, когда Clojure отличает \spverb|nil| от
коллекции. Не храните в словаре значения, которые нельзя записать в файл,
например поток или сетевое подключение. В идеале контекст это данные, которые
пишут в JSON. Позже мы рассмотрим, что делать с контекстом.

Функция \spverb|ex-data| верн\"{е}т данные из исключения. Если это <<родное>>
\spverb|ExceptionInfo|, получим словарь. Для других классов результат будет
\spverb|nil|.

Теперь поймаем исключение: в форме \spverb|catch| укажем класс
\spverb|ExceptionInfo|. Функция \spverb|ex-data| извлекает словарь, который
передали в \spverb|ex-info|. Разделим его на поля и построим сообщение.

\begin{english}
  \begin{clojure}
(try
  (get-user 42)
  (catch clojure.lang.ExceptionInfo e
    (let [{:keys [http-method http-url]} (ex-data e)]
      (format "HTTP error: %s %s" http-method http-url))))
;; HTTP error: GET https://host.com/users/42
  \end{clojure}
\end{english}

\section{Когда бросать исключения}

До сих пор не ясно, когда бросать исключения, а когда ограничиться
проверкой. Рассмотрим типичные ситуации и решения.

При обходе коллекций нет смысла бросать исключения. \spverb|Nil| ведет себя как
пустая коллекция того типа, который имеет в виду функция. Выражения:

\begin{english}
  \begin{clojure}
(assoc nil :test 42)
(update nil :test (fnil inc 0))
(into nil [1 2 3])
(merge nil {:test 42})
  \end{clojure}
\end{english}

\noindent
вернут списки и словари. Ключ от \spverb|nil| верн\"{е}т \spverb|nil|. Разбор
словаря или вектора сообщит переменным \spverb|nil|, если поля не совпали. Оба
\spverb|let| вернут вектор из трех \spverb|nil|.

\begin{english}
  \begin{clojure}
(let [{:keys [a b c]} nil]
  [a b c])

(let [[a b c] nil]
  [a b c])
  \end{clojure}
\end{english}

\noindent


Термин <<nil punning>> означает лояльность к \spverb|nil|. С таким подходом
пустые значения не вызывают ошибок. Нельзя утверждать, что Clojure полностью
<<nil punning>>. \spverb|Nil| дружит с коллекциями, но не работает с~арифметикой
и регулярными выражениями.

Если вы сомневаетесь в коллекции, используйте спеку. Функции \spverb|s/valid?| и
\spverb|s/conform| из прошлой главы \page{spec-conform} помогут убедиться, что
коллекция верна. Этим вы отделите проверку от работы с данными. Если валидация
не прошла, бросайте исключение. Передайте в контекст данные \spverb|explain|,
чтобы разобрать их позже.

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
(s/def ::data (s/coll-of int?))
(when-let [explain (s/explain-data ::data [1 2 nil])]
  (throw (ex-info "Some item is not an integer"
                  {:explain explain})))
  \end{clojure}
\end{english}

Другой случай, когда прибегают к исключению~--- отказ ресурса. Если не удалось
прочитать файл, недостаточно сказать об этом. Возможны десятки причин: файла
нет, он занят другим процессом, кончилось место на диске, ошибка в кодировке. От
ошибки зависит, кто ее исправляет и как не допустить ее снова.

В индустрии нет единого мнения о том, бросать ли исключение на негативный
HTTP-ответ. Согласно протоколу, ответ со статусом 404 такой же верный, как и
200. Продвинутые библиотеки предлагают флаг, чтобы управлять этим поведением.

Предположим, наш HTTP-клиент не бросает исключение. Сделаем это вручную:
проверим статус и бросим исключение с подробностями:

\begin{english}
  \begin{clojure}
(defn authenticate-user [user-id]
  (let [url "http://auth.company.com"
        params {:as :json :form-params {:user-id user-id}}
        response (client/post url params)
        {:keys [status body]} response]
    (if (= status 200)
      body
      (throw (ex-info "Authentication error"
                      {:user-id user-id
                       :http-url url
                       :http-status status
                       :http-body body})))))
  \end{clojure}
\end{english}

Исключения полезны в библиотеках. Код условно делится на два типа: исполнение и
координация. Библиотеки относятся с исполнительному коду. На уровне библиотеки
мы не знаем, в какой семантике работает код. Если бросить исключение,
бизнес-логика перехватит его и продолжит работу. Но если молча подавлять ошибки,
потребители будут недовольны. Это касается и паттерна <<вернуть \spverb|nil| и
записать в лог>>, что значит проигнорировать проблему.

\section{Подробнее о цепочках}

Рассмотрим цепочки исключений на практике. Функция \spverb|ex-info|
принимает третий необязательный параметр \spverb|cause|. Это либо \spverb|nil|,
либо другое исключение, которое станет частью нового. Ниже функция
\spverb|divide| ловит ошибку арифметики и бросает новое исключение с контекстом.

\label{re-throw-example}

\begin{english}
  \begin{clojure}
(defn divide [a b]
  (try
    (/ a b)
    (catch ArithmeticException e
      (throw (ex-info
              "Calculation error"
              {:a a :b b}
              e)))))
  \end{clojure}
\end{english}

Функция \spverb|ex-cause| возвращает причину исключения. Если ее не было,
получим \spverb|nil|.

\begin{english}
  \begin{clojure}
(try
  (divide 1 0)
  (catch Exception e
    (println (ex-message e))
    (println (ex-message (ex-cause e)))))
  \end{clojure}
\end{english}

\noindent
Код выведет:

\begin{english}
  \begin{text}
Calculation error
Divide by zero
  \end{text}
\end{english}

Напишем функцию, которая верн\"{е}т список исключений. Расположим их по убыванию
старшинства. На первом месте исходное исключение, на втором его причина, далее
причина причины и так далее. Проще всего сделать это формой \spverb|loop|:

\begin{english}
  \begin{clojure}
(defn ex-chain [e]
  (loop [e e
         result []]
    (if (nil? e)
      result
      (recur (ex-cause e) (conj result e)))))
  \end{clojure}
\end{english}

Для экспериментов объявим переменную \spverb|e|. Это цепь исключений из трех
звеньев. На первом уровне ошибка бизнес-логики: не удалось извлечь
пользователя. На втором уровне проблема с авторизацией. На третьем ошибка
транспорта: HTTP-запрос вернул статус 403.

\begin{english}
  \begin{clojure}
(def e
  (ex-info
   "Get user info error"
   {:user-id 42}
   (ex-info "Auth error"
            {:api-key "........."}
            (ex-info "HTTP error"
                     {:method "POST"
                      :url "http://api.site.com"}))))
  \end{clojure}
\end{english}

Получилось дерево искючений, но не всегда удобно работать с деревом. Плоская
структура лучше поддается обходу. Пригодится функция \spverb|ex-chain|, которую
мы написали. Вот как получить сообщения всех исключений:

\begin{english}
  \begin{clojure}
(map ex-message (ex-chain e))
("Get user info error" "Auth error" "HTTP error")
  \end{clojure}
\end{english}

\noindent
А так напечатать построчно:

\begin{english}
  \begin{clojure}
(doseq [e (ex-chain e)]
  (-> e ex-message println))

;; Get user info error
;; Auth error
;; HTTP error
  \end{clojure}
\end{english}

Выразим \spverb|ex-chain| короче через \spverb|iterate|. Это функция, которая
шаг за шагом применяет другую функцию к аргументу. Ограничение
\spverb|take-while| нужно, чтобы остановиться на первом пустом элементе.

\begin{english}
  \begin{clojure}
(defn ex-chain [^Exception e]
  (take-while some? (iterate ex-cause e)))
  \end{clojure}
\end{english}

\section{Печать исключений}

Что-то пошло не так, и мы оказались в ветке \spverb|catch|. На искючение
ссылается локальная переменная. Как с ней посупить?

Самое простое, что можно сделать с исключением~--- напечатать в консоль. Функция
\spverb|println| достаточно умна: перед выводом она переводит исключение в
словарь. Это удобно для редакторов и IDE, потому что словарь легко разобрать на
части. Например, показать только ту часть стек-трейса, что касается Clojure.

Последнее исключение в цепочке наывают корнем, \emph{root}. Для удобства
\spverb|println| дублирует корень в начале, чтобы сразу было видно
первопричину. Вот что выведет \spverb|(println e)|:

\begin{english}
  \begin{clojure}
#error {
 :cause HTTP error
 :data {:method POST, :url http://api.site.com}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Get user info error
   :data {:user-id 42}}
  {:type clojure.lang.ExceptionInfo
   :message Auth error
   :data {:api-key .........}}
  {:type clojure.lang.ExceptionInfo
   :message HTTP error
   :data {:method POST, :url http://api.site.com}}]
 :trace
 [[clojure.lang.AFn applyToHelper AFn.java 156]
  [clojure.lang.AFn applyTo AFn.java 144]
  [clojure.lang.Compiler$InvokeExpr eval Compiler.java 3701]
  ..........]}
  \end{clojure}
\end{english}

Вектор \spverb|:trace| называют стек-трейсом. Это методы Java, по которым прошло
исключение с момента выброса до перехвата. Элемент трейса это вектор с именем
класса, метода, файла и номера строки.

Мы сократили трейс, чтобы не тратить на него место. В реальности трейсы занимают
несколько экранов. Они показывают Java-код, который получился из Clojure, и это
сбивает с толку. Шумные трейсы~--- справедливый упрек в адрес Clojure. С другой
стороны, ими страдают многие JVM-языки.

В пакете \spverb|clojure.stacktrace| несколько функций для печати
исключений. \spverb|Print-throwable| выводит сообщение и словарь:

\begin{english}
  \begin{clojure}
(clojure.stacktrace/print-throwable e)
clojure.lang.ExceptionInfo: Get user info error
{:user-id 42}
  \end{clojure}
\end{english}

Макрос \spverb|with-out-str| перехватывает вывод в консоль. Код ниже ничего не
печатает, но верн\"{е}т строку:

\begin{english}
  \begin{clojure}
(with-out-str
  (clojure.stacktrace/print-stack-trace e))
  \end{clojure}
\end{english}

Функции \spverb|print-stack-trace| и \spverb|print-cause-trace| печатают трейс с
небольшими отличиями. Они принимают параметр \spverb|n|, чтобы задать глубину
трейса.

\section{Логирование}

Вывод в консоль помогает в отладке, не не подходит для боевого
запуска. Перечислим, что ожидают от кода, который ловит ислючения.

Для любого сообщения важны его вспомогательные данные: время, модуль, номер
процесса. Сообщения различают по уровню важности: информационное,
предупреждение, тревога и другие. Печать не несет этих сведений, а их ручной
сбор увеличит код.

Если программа работает на многих серверах, сбор сообщений
централизован. Представьте, что админ переключается между сотней машин, чтобы
читать логи. Если сообщение пришло по сети, нужно запомнить адрес источника.

Не все сообщения одинаково важны. Иногда библиотеки порождают сотни отладочных
сообщений в минуту. Нужен механизм, чтобы отбрасывать их по некоторым признакам.

Наконец, консоль и файл~--- не единственные каналы данных. Особо важные
сообщения пишут в журнал операционной системы, шлют на почту, ботам в чате или в
смс ответственным лицам.

Указанные проблемы решает логирование. Это система, которая принимает сообщения
и пересылает в нужные каналы. Библиотека \spverb|clojure.tools.logging|
предлагает функции и макросы, чтобы логировать сообщения. Это сторонний проект,
поэтому добавьте зависимость:

\begin{english}
  \begin{clojure}
[org.clojure/tools.logging "0.4.1"]
  \end{clojure}
\end{english}

\noindent
Запишем простое сообщение:

\begin{english}
  \begin{clojure}
(require '[clojure.tools.logging :as log])
(log/info "A message from my module")
  \end{clojure}
\end{english}

\noindent
В REPL появится строка. По умолчанию лог добавляет уровень важности. В нашем
случае это информационный уровень, \spverb|INFO|.

\begin{english}
  \begin{text}
INFO: A message from my module
  \end{text}
\end{english}

%% ---------------

В Clojure логирование устроено из двух уровней. Первый это входная точка,
макросы \spverb|log/info|, \spverb|log/error| и другие. Второй уровень называют
бекендом. Под ним понимают Java-библиотеку, которая выполняет основную работу:
пишет сообщения в файлы, отправляет их по сети и так далее.

Такое устройство несет преимущества. Исторически сложилось так, что для Java
написано много библиотек логирования. Каждая из них предлагает свои классы и
методы. Если проект использует конкретный Java-бекенд, не получится сменить его
без правок в коде.

В Clojure эту проблему решили дизайном. При старте модуль \spverb|logging| ищет
библиотеки \spverb|Logback|, \spverb|Log4j| и другие. Если ничего не найдено, он
использует стандартный пакет \spverb|java.util.logging|. Вызов \spverb|log/info|
сводится к вызову класса из найденной библиотеки.

Чтобы нужный бекенд <<подхватился>>, добавьте его в зависимости. Особенно
популярен проект \spverb|Logback|. От аналогов его отличает большой выбор
\emph{аппендеров} (анг. appenders). Так называют пункт назначения, куда писать
сообщения. Это может быть файл, удаленный syslog, почтовый сервер.

Добавьте Logback к проекту:

\begin{english}
  \begin{clojure}
[ch.qos.logback/logback-classic "1.2.3"]
  \end{clojure}
\end{english}

Библиотеки логирования ищут настройки в стандартных местах. Если в папку
\spverb|resources| положить XML-файл для бекенда, он прочтет его при
старте. Запишите туда следующий файл \spverb|logback.xml|:

\begin{english}
  \begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="...ConsoleAppender">
    <encoder>
      <charset>UTF-8</charset>
      <pattern>%date %-5level %logger{36} - %msg %n</pattern>
    </encoder>
  </appender>
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
  \end{xml}
\end{english}

Мы задали appender для вывода в консоль. В теге \spverb|pattern| указан
шаблон сообщения. Параметры шаблона начинаются со знака процента. Подстановка
\spverb|\%msg| означает сообщение, \spverb|\%date|~--- дату. Ее формат
задают в фигурных скобках, например \spverb|%date{ISO8601}|. Залогируйте
что-нибудь в REPL. Вывод изменится:

\begin{english}
  \begin{clojure}
(log/info "Hello Logback!")
;; 2019-05-03 17:36:04,001 INFO book.exceptions - Hello Logback!
  \end{clojure}
\end{english}

\label{log-ex-param}

Макросы \spverb|log/info|, \spverb|log/error| и другие допускают, что первым
аргументом может быть не текст, а исключение. Выше мы объявили переменную
\spverb|e| для экспериментов. Запишем ее в лог:

\begin{english}
  \begin{clojure}
(log/error e "HTTP Error")

2019-05-03 17:41:03,913 ERROR book.exceptions - HTTP Error
clojure.lang.ExceptionInfo: Get user info error
    at java.lang.Thread.run(Thread.java:745)
Caused by: clojure.lang.ExceptionInfo: Auth error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 30 common frames omitted
Caused by: clojure.lang.ExceptionInfo: HTTP error
    at clojure.lang.Compiler$InvokeExpr.eval(Compiler.java:3701)
    ... 31 common frames omitted
  \end{clojure}
\end{english}

Для экономии мы удалили часть трейса. Из примера видно, что цепочка состоит из
трех звеньев~--- как и задали \spverb|e|. Проблема в том, что у каждого звена
пропали данные. Logback не подозревает, что поле \spverb|data| класса
\spverb|ExceptionInfo| так важно для нас.

Библиотека предлагает несколько шаблонов для исключения: \spverb|%xEx|,
\spverb|%xException| и другие. Они влияют на длину и детализацию трейса, но
игнорируют данные. Похоже ведут себя Log4j и другие проекты.

В Java проблему решают новым классом. Как правило, библиотека содержит класс,
который переводит исключение в строку. Его наследуют и заменяют нужный метод. В
настройках логирования указывают путь к этому классу.

Способ работает и в Clojure, но с неудобствами. Чтобы наследовать класс в
Clojure, нужен отдельный модуль с директивой \spverb|:gen-class|. прид\"{е}тся
читать документацию к библиотеке, исследовать ее классы и интерфейсы. Решение
будет завязано на конкретный бекенд. Если проект переедет на Log4j, прид\"{е}тся
наследовать другой класс. Это не тот способ, которому следуют в Clojure.

Напишем функцию логирования ошибок. Это об\"{е}ртка над \spverb|log/error| с
небольшой разницей: перед записью в лог исключение переходит в текст, как удобно
нам. Чтобы собрать данные об ошибке, построим цепочку исключений с помощью
\spverb|ex-chain|. Функция \spverb|ex-print| пробегает по ней и печатает данные
в консоль.

\begin{english}
  \begin{clojure}
(defn ex-print
  [^Throwable e]
  (let [indent "  "]
    (doseq [e (ex-chain e)]
      (println (-> e class .getCanonicalName))
      (print indent)
      (println (ex-message e))
      (when-let [data (ex-data e)]
        (print indent)
        (clojure.pprint/pprint data)))))
  \end{clojure}
\end{english}

Результат выглядит приятнее, чем пирамида трейсов. Четко видны данные, которые
привели к ошибке:

\begin{english}
  \begin{clojure}
clojure.lang.ExceptionInfo
  Get user info error
  {:user-id 42}
clojure.lang.ExceptionInfo
  Auth error
  {:api-key "........."}
clojure.lang.ExceptionInfo
  HTTP error
  {:method "POST", :url "http://api.site.com"}
  \end{clojure}
\end{english}

Чтобы перехватить печать на экран, вызов \spverb|ex-print| оборачивают в
\spverb|with-out-str|:

\begin{english}
  \begin{clojure}
(defn log-error
  [^Throwable e & [^String message]]
  (log/error
   (with-out-str
     (println (or message "Error"))
     (ex-print e))))
  \end{clojure}
\end{english}

Вторым аргументом в \spverb|log-error| передают сообщение. Если его нет, запишем
нейтральное <<Error>>. Чтобы сообщение и тело не слиплись, используем
\spverb|println| для переноса строки.

\begin{english}
  \begin{clojure}
(log-error e)
(log-error e "HTTP Error 500")
  \end{clojure}
\end{english}

Второй вызов запишет в лог следующее:

\begin{english}
  \begin{text}
2019-05-03 19:00:05,590 ERROR book.exceptions - HTTP Error 500
clojure.lang.ExceptionInfo
  Get user info error
  ...
  \end{text}
\end{english}

Доработайте \spverb|log-error| так, чтобы сообщение было шаблоном, а функция
принимала параметры подстановки:

\begin{english}
  \begin{clojure}
(log-error e "Cannot find user %s, status %s" 42 404)
  \end{clojure}
\end{english}

Сообщения об ошибках отделяют от прочих записей. Для этого заводят минимум два
аппендера: консоль и файл. В консоль выводят все сообщения, чтобы программист
был в курсе дела. Ошибки требуют реакции, поэтому их пишут в файл или пересылают
по сети. Позже их анализируют вручную или специальными программами.

В главе про изменяемость мы расскажем, как сделать так, чтобы макрос
\spverb|log/error| сводился к вызову \spverb|log-error| \page{install-logger}.
Так мы избавимся от импорта \spverb|log-error| в каждый модуль, где логируют ошибку.
Однако сейчас об этом говорить преждевременно.

%% --------------

\section{Сбор исключений}

Мы придумали, как выразить исключение текстом. Теперь можно записать его в файл,
отправить письмом или даже распечатать. Недостаток в том, что у текста нет
структуры. С точки зрения кода это поток символов, и неясно, где что. При сборе
ошибок важно выделить их ключевые данные: тип, подсистему, модуль. Это нужно по
следующим причинам.

\textbf{Предотвратить дублирование.} Во время наплыва клиентов может вскрыться
ошибка, которую не заметили ранее. Если каждый раз писать ее в файл, получим
тысячи одинаковых сообщений. Это расточительно в плане ресурсов и затрудняет
поиск.

Сборщик определяет схожесть ошибок по особым правилам. Сообщения <<user 1 not
found>> и <<user 2 not found>> отличаются, но сборщик схлопнет их в одну запись
и по запросу покажет остальные.

\textbf{Поиск.} Нельзя построить эффективный поиск без структуры. Когда ошибки в
виде текста, можно искать только по вхождению слова или регулярному
выражению. Такой поиск нерелевантен, то есть не учитывает, насколько точно
элемент подходит запросу. Ещ\"{е} он не отсекает дубли: не хотелось бы видеть тысячу
одинаковых сообщений в выдаче.

\textbf{Статистика.} Когда ошибки разобрали на части, можно строить по ним
отч\"{е}ты. Например, сколько ошибок случилось за прошлый месяц или
год. Группировать данные по проектам или командам. Выявить проекты, где ошибки
случаются чаще всего.

\textbf{База знаний.} В системе сбора каждая ошибка становится артефактом. К ней
пишут комментарии, прикрепляют скриншоты и записи с экрана. На ошибку можно
сослаться в задаче или ревью. Если исключения хранят в логах, это невозможно.

Среди прочих систем достойно выглядит Sentry\footurl{https://sentry.io},
веб-приложение на Django. В нем заводят проекты, которые накапливают ошибки от
клиентов. Чтобы отправить ошибку в Sentry, к нему обращаются по HTTP методом
POST. В теле передают JSON с различными полями. Sentry предлагает десятки полей,
чтобы описать ошибку. Сюда входят параметры машины, операционной системы, детали
HTTP-запроса, стек-трейс и другие.

Как правило, приложение не собирает эти данные вручную, а пользуется
библиотеками. Часто они называются Raven или похожим образом. Семантика в том,
что \emph{сторожевой ворон} (анг. raven) несет вести \emph{дозорному}
(анг. sentry).

Для Clojure написаны библиотеки Sentry-clj\footurl{https://github.com/getsentry/sentry-clj}
и Exoscale Raven\footurl{https://github.com/exoscale/raven}. Первая опирается
на официальную Java-библиотеку. Добавьте ее в проект:

\begin{english}
  \begin{clojure}
[io.sentry/sentry-clj "0.7.2"]
  \end{clojure}
\end{english}

Задайте библиотеке нужный DSN. Под DSN понимают адрес проекта в Sentry. Проект
объединяет сообщения по глобальному признаку: ошибки бекенда в одном проекте,
фронтенда~--- во втором, мобильного приложения~--- в третьем. DSN находится в
настройках проекта в разделе <<интеграция>>.

\begin{english}
  \begin{clojure}
(require '[sentry-clj.core :as sentry])
(def DSN "https://.....@sentry.io/.....")
(sentry/init! DSN)
  \end{clojure}
\end{english}

Когда DSN задан, отправим сообщение с помощью функции \spverb|send-event|. Среди
прочих параметров нас интересует \spverb|:throwable|, в который передают
исключение.

\begin{english}
  \begin{clojure}
(sentry/send-event {:throwable e})
  \end{clojure}
\end{english}

В ответ получим номер события, а в проекте появится новая запись. Предположим,
мы передали экземпляр \spverb|e|, который задали выше (цепочку из трех
исключений). В интерфейсе Sentry увидим информацию о каждом из них. В поле
\spverb|:extra| окажутся данные верхнего исключения,
словарь \spverb|{:user-id 42}|.

Недостаток \spverb|sentry-clj| в том, что она недостаточно гибка. Хотелось бы
видеть данные всех уровней, а не только верхнего. Иначе мы не узнаем, какой был
API-ключ, по какому адресу мы обратились в сеть и другие детали. Не хватает
всего контекста; можно собрать его вручную и передать в ключ \spverb|:extra|, но
это увеличит код.

Библиотека Exoscale Raven написана на Clojure и потому учитывает тонкости
языка. С недавней версии она передает полные данные об исключении. Подключите ее
в проект и отправье исключение \spverb|e|:

\begin{english}
  \begin{clojure}
[exoscale/raven "0.4.8"]

(require '[raven.client :as raven])
(raven/capture! DSN e)
  \end{clojure}
\end{english}

Откройте событие в Sentry и промотайте вниз. В секции \spverb|extra| появится
ключ \spverb|:via| с детальной информацией (приведем фрагмент):

\begin{english}
  \begin{json}
[ {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Get user info error",
  "data": {
    "user-id": 42
  },
  "at": ["clojure.lang.AFn", "applyToHelper", "AFn.java", 160]
}, {
  "type": "clojure.lang.ExceptionInfo",
  "message": "Auth error",
  "data": {
    "api-key": "........."
  },
  "at": ["clojure.lang.AFn", "applyToHelper", "AFn.java", 160]
} ]
  \end{json}
\end{english}

Каждый словарь состоит из класса исключения, сообщения и данных. В поле
\spverb|:at| вектор четырех элементов: класс, метод, имя файла и строка, на
которой возникло исключение. С таким отч\"{е}том найти причину будет проще.

Структуру выше получили функцией \spverb|Throwable->map|. Она принимает
исключение и отдает словарь с ключами \spverb|:via|, \spverb|:cause| и
другими. Элементы словарей это строки и символы, поэтому результат легко
записать в JSON или EDN.

\section{Sentry и Ring}

Теперь когда вы знакомы с Sentry, напишем защитный декоратор для
Ring-приложения. Он ловит ошибки, отправляет в Sentry и возвращает нейтральный
ответ о том, что запрос не удался. Декоратор ставят на вершину стека middleware.

\begin{english}
  \begin{clojure}
(defn wrap-exception
  [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        (try
          (raven/capture! DSN e)
          (catch Exception e-sentry
            (log/errorf e-sentry "Sentry error: %s" DSN)
            (log/error e "Request failed"))
          (finally
            {:status 500
             :body "Internal error, please try later"}))))))
  \end{clojure}
\end{english}

Обратите внимание, что запрос к Sentry тоже обернут в \spverb|try/catch|. Sentry
это отдельный сервис, который может быть недоступен. В этом случае в лог пишут
оба исключения: и первичное, и связанное с Sentry. Если вы забыли, как работают
декораторы и middleware, вернитесь к главе про веб-резработку \page{decorator}.

\section{Переходы}

До сих пор мы рассматривали исключение как сигнал об ошибке. Вспомним ключевое
свойство: исключение прерывает программу и всплывает вверх, пока его не
поймают. Иногда этим пользуются, чтобы перейти вверх по стеку. Если бросить
условное \spverb|MyGOTOException|, а сверху поставить \spverb|catch| с этим
классом, получим оператор \spverb|GOTO|:

\begin{english}
  \begin{clojure}
(try
  (do-first-step)
  (do-second-step)
  (when (condition)
    (throw (new MyGOTOException)))
  (do-third-step)
  (catch MyGOTOException e
    (println "The third step has been skipped")))
  \end{clojure}
\end{english}

Если \spverb|(condition)| верн\"{е}т истину, мы пропустим третий шаг. В литературе
трюк называют <<исключение как способ управления исполнением>>. Это
противоречивая практика; применяйте ее осторожно. Код становится неочевидным и
трудным в поддержке.

Все же бывают моменты, когда нужно прервать исполнение. Например, мы выяснили,
что у пользователя нет прав к ресурсу. Усложним задачу: пусть проверок
несколько, и на каждой нужно пресечь запрос. В императивных языках это легкая
задача. Код на Python выглядел бы так:

\begin{english}
  \begin{python}
class AccountHandler(RequestHandler):
  def on_get(self, request):
    if not self.check_params(request):
      return BadRequest("Wrong input data")
    if not self.check_account(request):
      return NotFound("No such an account")
    if not self.check_quotas(request):
      return QuotasReached("Request rate is limited")
    return JSONResponse(self.get_data_from_db())
  \end{python}
\end{english}

В Clojure нет оператора \spverb|return|. Результат нескольких форм это результат
последней. Мы не можем расположить несколько \spverb|when| на одном уровне друг
под другом. Даже если одна из них верн\"{е}т ложь, исполнение перейдет к следующей
форме.

Вариант с каскадом \spverb|if/else| работает, но выглядит громоздко. По-другому
его называют <<Pyramid of Doom>>. Чем ниже вложенность, тем больше проблем у
разработчика. Ради интереса добавьте условие в середину:

\begin{english}
  \begin{clojure}
(defn account-handler [request]
  (if (check-this request)
    (if (check-that request)
      (if (check-quotas request)
        {:status 200
         :body (get-data-from-db)}
        (quotas-reached "Request rate is limited"))
      (not-found "No such an account"))
    (bad-request "Wrong input data")))
  \end{clojure}
\end{english}

Пирамиду решают разными способами, в том числе исключениями. Библиотека <<Ring
HTTP Response>> предлагает функции, чтобы кидать исключения с HTTP-ответом. В
middleware добавляют декоратор, который ловит такие исключения и возвращает из
них ответ. Добавьте библиотеку в проект:

\begin{english}
  \begin{clojure}
[metosin/ring-http-response "0.9.1"]
  \end{clojure}
\end{english}

\noindent
Напишем \spverb|account-handler| по-другому:

\begin{english}
  \begin{clojure}
(require '[ring.util.http-response
           :refer [not-found!
                   bad-request!
                   enhance-your-calm!]])

(defn account-handler [request]
  (when-not (check-params request)
    (bad-request! "Wrong input data"))
  (when-not (check-account request)
    (not-found! "No such an account"))
  (when-not (check-quotas request)
    (enhance-your-calm! "Request rate is limited"))
  {:status 200
   :body (get-data-from-db)})
  \end{clojure}
\end{english}

Новый код похож на императивный. Некоторых уязвляет факт, что в Clojure
пользуются императивным подходом. Все в порядке: наша задача сделать так, чтобы
код был удобным в поддержке. Вопрос парадигмы при этом не важен.

Функции из модуля \spverb|ring.util.http-response| бывают с восклицательным
знаком и без него. Это сигнал о том, что функция бросает исключение. Например,
\spverb|not-found!| породит \spverb|ex-info|, в теле которого HTTP-ответ со
статусом 404.

Чтобы схема работала, добавим декоратор \spverb|wrap-http-response|. Он ловит
ошибки от функций с восклицательным знаком, достает из них ответ и возвращает
клиенту.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.http-response
           :refer [wrap-http-response]])

(def app
  (-> app-naked
      wrap-params
      wrap-session
      wrap-cookies
      wrap-http-response))
  \end{clojure}
\end{english}

Избегайте исключений для прыжков по коду. Убедитесь, что это крайняя мера: вы
должны что-то выиграть: сократить код или оперативно решить горящую
проблему. Если пришлось идти на этот шаг, возьмите библиотеку, чтобы сослаться
на примеры и опыт других людей.

%% --------------

\section{Finally и контекстный менеджер}

Иногда код выполняют в рамках ресурса. Это может быть файл, сокет или транзакция
базы данных. В начале работы ресурс <<открывают>>, а в конце
<<закрывают>>. Открытый ресурс считается занятым. Когда ресурс занят, другие
клиенты не могут пользоваться им в полной мере. Открытый кем-то файл можно
читать, но не менять.

Закрывайте ресурс сразу же, как только в нем отпала нужда. Этому может помешать
ошибка. Если код, который работает с ресурсом, не поймал исключение, файл или
порт останутся открытыми до конца работы. Чтобы закрыть ресурс даже в случае
ошибки, прибегают к форме \spverb|finally|.

Форму ставят последней в \spverb|try|. Управление переходит в \spverb|finally|
даже в случае исключения. Если его не было, \spverb|finally| сработает после
основного кода из \spverb|try|. Когда ошибка возникла, \spverb|finally|
сработает в промежутке между ее появлением и выбросом.

Рассмотрим ручной доступ к файлу: запишем в него несколько
байт. \spverb|Finally| гаранитрует, что файл закроется, даже если если что-то
пойдет не так.

\begin{english}
  \begin{clojure}
(import '[java.io File FileWriter])

(let [out (new FileWriter (new File "test.txt"))]
  (try
    (.write out "Hello")
    (.write out " ")
    (.write out "Clojure")
    (finally
      (.close out))))
  \end{clojure}
\end{english}

Чтобы вы не забыли закрыть файл, современные языки предлагают контекстные
менеджеры. Это может быть класс, оператор или макрос. Менеджер исполняет блок
кода с дополнительными эффектами. Перед блоком сработает логика входа, а после
него~--- логика выхода. Последний получит управление даже если блок бросил
исключение. Платформа удержит его, выполнит код выхода и снова бросит.

Особо изящно менеджер устроен в Python. Это оператор \spverb|with|, который
ожидает объект. У объекта должны быть методы \spverb|__enter__| и
\spverb|__exit__|, которые сработают при входе и выходе. \spverb|With| применяют
для файлов, транзакций базы данных, фикстур в тестах. Пример с файлом:

\begin{english}
  \begin{python}
with open("/path/to/file.txt", "w") as f:
    f.write("test")
  \end{python}
\end{english}

Напишем похожий менеджер для Clojure. Это макрос, который принимает символ и
путь к файлу. Внутри макроса файл связан с символом. \spverb|Finally|
гарантирует, что файл закроется при выходе из блока.

\begin{english}
  \begin{clojure}
(defmacro with-file-writer
  [[bind path] & body]
  `(let [~bind (new FileWriter (new File ~path))]
     (try
       ~@body
       (finally
         (.close ~bind)))))
  \end{clojure}
\end{english}

\noindent
Выполните код и проверьте файл \spverb|test.txt|:

\begin{english}
  \begin{clojure}
(with-file-writer [out "test.txt"]
  (.write out "Hello macro!")
  (\ 0 0))
  \end{clojure}
\end{english}

Контекстные менеджеры именуют с префиксом \spverb|with-|. Так делают акцент на
том, что код работает в рамках ресурса.

В Clojure предусмотрен макрос \spverb|with-open|. Это улучшенная версия кода,
что мы написали. В отличии от нашего примера, \spverb|with-open| работает с
более абстрактным источником, в том числе и файлом. Выход из макроса, даже с
ошибкой, закрывает источник.

В \spverb|finally| нет смысла при работе с коллекциями или чистыми
функциями. Пользуйтесь им только если ресурс занят и должен быть освобожден.

\section{Исключения на предикатах}

Система \spverb|try/catch| работает на классах и наследовании. Если нужно
поймать особый случай, пишут класс и бросают его экземпляр. Типичный проект на
Java или Python несет на борту модуль с исключениями. Среди них базовый класс
\spverb|ProjectException| и унаследованные от него \spverb|UserNotFound|,
\spverb|AccessDenied| и другие. Это однообразный код, написанный вручную.

В главе про Spec мы говорили, что предикаты мощнее типов
\page{type-and-pred}. Это верно и для исключений: если можно поймать их
функцией, не понадобится класс. Подход на предикатах предлагает библиотека
Slingshot\footurl{https://github.com/scgilardi/slingshot} (анг. <<рогатка>>). В
ней находятся улучшенные версии \spverb|try|, \spverb|catch| и \spverb|throw|.

Это удивит тех, кто не знаком с Clojure. С помощью макросов в ней меняют даже
такие фундаментальные вещи как перехват исключений. В других языках подобные
изменения ждут годами, а в Clojure подключают библиотеку.

Slingshot предлагает макросы \spverb|throw+| и \spverb|try+|. Они совместимы с
обычными \spverb|throw| и \spverb|try|: если заменить старые формы на версии с
плюсом, ничего не изменится. Однако новые формы несут преимущества.

Макрос \spverb|throw+| принимает не только исключение, но и любой объект. На эту
роль подходит словарь: он несет несколько значений и их семантику в
ключах. Пример ниже бросит \spverb|ex-info| с заданным словарем:

\begin{english}
  \begin{clojure}
(require '[slingshot.slingshot :refer [try+ throw+]])
(throw+ {:user-id 42 :action :create})
  \end{clojure}
\end{english}

Кроме объекта, \spverb|throw+| принимает причину, шаблон сообщения и параметры
подстановки. Обратите внимание, что порядок аргументов отличается от
\spverb|ex-info|.

\begin{english}
  \begin{clojure}
(let [path "/var/lib/file.txt"]
  (try
    (slurp path)
    (catch Exception e
      (throw+ {:path path} e "File error: %s" path))))
  \end{clojure}
\end{english}

Кроме классов, форма \spverb|catch| внутри \spverb|try+| ловит исключения по
селектору и предикату. Под селектором понимают вектор, где неч\"{е}тный элемент это
ключ словаря, а ч\"{е}тный~--- значение. Селектор проверяет, что ключи и значения
входят в контекст. Если да, управление переходит в ветку с этим селектором.

\begin{english}
  \begin{clojure}
(try+
 (throw+ {:type ::user-error
          :user 42
          :action :update
          :data {:name "Ivan"}})
 (catch [:type ::user-error] e
   (clojure.pprint/pprint e)))
  \end{clojure}
\end{english}

Когда бросают словарь, добавляют поле \spverb|:type|. В нем указывают ключ с
текущим простанстом. В нашем случе это \spverb|::user-error|. При отлове
исключений указывают \spverb|[:type :book.exceptions/user-error]|. Пространство
гарантирует, что мы не поймаем \spverb|:user-error| из другого модуля.

Пример выше напечатает брошенный словарь. Внутри \spverb|catch| переменная
\spverb|e| ссылается не на исключение, а данные, которые передали в
\spverb|throw+|.

Вместо селектора может быть предикат, функция одного аргумента. Если класс
ошибки \spverb|ExceptionInfo|, предикат получит словарь данных, а иначе объект
исключения. Функция должна учесть, что тип аргумента может быть разным. Когда
предикат вернул истину, управление переходит в его ветку \spverb|catch|.

Предикатами пользуются, когда нужно тонкое условие перехвата. Рассмотрим
загрузку файла в Amazon S3. В особых случаях Java SDK бросает исключение уже
после того, как файл загружен. Это случается из-за разницы в контрольных
суммах. Загрузка считается неудачной, и мы должны удалить файл, чтобы он не
занимал место.

К сожалению, в SDK нет класса \spverb|ChecksumError| или аналога. Вместо него
приходит обычный \spverb|AmazonS3Exception| с длинным текстом. Чтобы выделить
наш случай, сравним сообщение с шаблоном. Вынесем проверку в функцию:

\begin{english}
  \begin{clojure}
(defn aws-checksum-error? [e]
  (and (instance? AmazonS3Exception e)
       (some?
        (re-find
         #"(?i)The Content-Md5 you specified did not match"
         (ex-message e)))))
  \end{clojure}
\end{english}

\noindent
Поместим ее в \spverb|try+|, чтобы поймать случай с контрольной суммой:

\begin{english}
  \begin{clojure}
(try+
  (s3/put-object...)
  (catch aws-checksum-error? e
    (s3/delete-object...)))
  \end{clojure}
\end{english}

Slingshot используют в Clj-http\footurl{https://github.com/dakrone/clj-http},
популярном HTTP-клиенте для Clojure. В случае ошибки он бросает ответ через
\spverb|throw+|. Если обернуть запрос в \spverb|try+|, получим более тонкий
разбор ошибок. Например, отдельные ветки для статуса 500 и негативного ответа в
целом.

\begin{english}
  \begin{clojure}
(require '[clj-http.client :as client])

(try+
 (client/get "http://example.com/test")
 (catch [:status 500] e
   (println "The service is unavailable"))
 (catch [:type :client/unexceptional-status] e
   (println "Negative response")))
  \end{clojure}
\end{english}

Slingshot делает ставку на данные, а не классы, что поощрается
в~Clojure. Начинающим не всегда очевидны плюсы этого подхода. Советуем читателю
сперва разобраться с обычными \spverb|try/catch|. Подключайте Slingshot только
если чувствуете в ней потребность.

Slingshot не единственный пример <<кложурных>> исключений. Обратите внимание на
Ex\footurl{https://github.com/exoscale/ex}~--- аналог, которым пользуются в
Exoscale. Библиотека учитывает семантику ключей (\spverb|:fault|,
\spverb|:conflict|), их наследование, поддерживает \spverb|manifold| и многое
другое.

\section{При\"{е}мы и функции}

Рассмотрим несколько техник для исключений. Они просты и потому не стоят того,
чтобы выносить их в отдельную библиотеку. Чаще всего их копируют из проекта в
проект с небольшими изменениями.

\textbf{Безопасный вызов функции.} В языке Lua нет операторов \spverb|try| и
\spverb|catch|. Чтобы обезопасить вызов от ошибки, используют
\spverb|pcall|\footurl{https://www.lua.org/pil/8.4.html}. Это сокращение от
<<protected call>>, защищенный вызов. Иногда при\"{е}м полезен и в Clojure.

В \spverb|pcall| передают функцию и аргументы. Результатом будет пара
значений. Первое означает успех выполнения. Если это истина, то на втором месте
результат вычислений, а иначе экземпляр ошибки. Тот же самое в Clojure:

\begin{english}
  \begin{clojure}
(defn pcall [f & args]
  (try
    [true (apply f args)]
    (catch Exception e [false e])))
  \end{clojure}
\end{english}

\noindent
Для краткости разбейте результат в \spverb|let|:

\begin{english}
  \begin{clojure}
(let [[ok? result-error] (pcall inc 1)]
  (if ok?
    (println (str "The result is " result-error))
    (println "Failure")))
  \end{clojure}
\end{english}

В JavaScript популярна другая семантика. Функции-колбеки принимают
аргументы \spverb|error| и \spverb|result|. Функция \spverb|pcall-js| это
измененный вариант \spverb|pcall|, который верн\"{е}т пару \tuple{ошибка, результат}.

\begin{english}
  \begin{clojure}
(defn pcall-js [f & args]
  (try
    [nil (apply f args)]
    (catch Exception e [e nil])))
  \end{clojure}
\end{english}

\noindent
Разбиение выглядит по-другому:

\begin{english}
  \begin{clojure}
(let [[e user] (pcall-js get-user-by-id 42)]
  (if e
    (println (ex-message e))
    (println user)))
  \end{clojure}
\end{english}

\textbf{Попытки с задержкой.} Иногда сторонний сервис нестабилен, и к нему
обращаются несколько раз. Чтобы не копировать код, обернем повтор в
функцию. \spverb|Pcall-retry| пытается выполнить целевую функцию за несколько
подходов. Первый удачный вызов станет результатом. Если была ошибка, но попытки
ещ\"{е} не кончились, функция ждет и повторяет вызов. Когда попытки закончились,
функция бросит исключение. Внутри используется \spverb|pcall|, который мы задали
выше.

\begin{english}
  \begin{clojure}
(defn pcall-retry [n f & args]
  (loop [attempt n]
    (let [[ok? res] (apply pcall f args)]
      (cond
        ok? res

        (< attempt n)
        (do (Thread/sleep (* attempt 1000))
            (recur (inc n)))

        :else (throw res)))))
  \end{clojure}
\end{english}

Это наивная версия, и в реальности ее улучшают: меняют стратегию ожидания,
добавляют логи. Однако принцип остается прежним.

Любопытно, что функции стыкуются между собой. Построим комбинацию из
\spverb|pcall-retry| в \spverb|pcall|. Даже если сервис недоступен и мы
стучались в него много раз, получим пару \spverb|[ok? result]|.

\begin{english}
  \begin{clojure}
(pcall pcall-retry get-user-by-id 42)
  \end{clojure}
\end{english}

\textbf{Исключения в Loop.} Форма \spverb|loop| устроена особо: ее часть
\spverb|recur| не может быть внутри \spverb|try|. Предположим, мы хотим написать
функцию повтора без \spverb|pcall|. Фрагмент кода:

\begin{english}
  \begin{clojure}
(defn pcall-retry [n f & args]
  (loop [attempt n]
    ...
    (try
      (apply f args)
      (catch Exception e
        (recur (inc n))))))
  \end{clojure}
\end{english}

Компилятор не примет код с сообщением <<Can only recur from tail
position>>. Чтобы исправить ошибку, нужно вынести \spverb|recur| из
\spverb|try|. Проще всего это сделать с помощью \spverb|pcall| как в примере с
\spverb|pcall-retry|.

\textbf{Throw in place.} До сих пор мы кидали исключения с помощью
\spverb|ex-info| и \spverb|throw|. Первая строит исключение, а вторая
бросает. Совместим их в функцию \spverb|error!| и упростим аргументы:

\begin{english}
  \begin{clojure}
(defn error! [message & [data e]]
  (throw (ex-info message (or data {}) e)))
  \end{clojure}
\end{english}

Чтобы вызвать исключение, нужна только строка, а остальное по желанию:

\begin{english}
  \begin{clojure}
(error! "error")
(error! "error" {:type ::error})
(error! "error" {:type ::error} e)
  \end{clojure}
\end{english}

\textbf{Сообщение с параметрами.} Иногда нужен не контекст, а подробное
сообщение. В этом плане \spverb|ex-info| избыточен, потому что требует
словарь. Напишем функцию, которая бросает \spverb|Exception| с форматированным
сообщением. В не\"{е} передают шаблон и значения подстановки. Частичка \spverb|f| на
конце имени означает форматирование.

\begin{english}
  \begin{clojure}
(defn errorf! [template & args]
  (let [message (apply format template args)]
    (throw (new Exception ^String message))))

(errorf! "Error, user: %s, action: %s" 42 :delete)
  \end{clojure}
\end{english}

\textbf{Безопасный макрос.} Перехват исключений работает и в макросах. Код с
макросами обычно короче и выразительней, чем обычная функция. Следующий пример
показывает, как выполнить код в безопасном режиме, игнорируя ошибку:

\begin{english}
  \begin{clojure}
(defmacro with-safe [& body]
  `(try
     ~@body
     (catch Exception e#)))
  \end{clojure}
\end{english}

Пустая форма \spverb|catch| верн\"{е}т \spverb|nil|. Мы получим его, если случится
ошибка:

\begin{english}
  \begin{clojure}
(with-safe (/ 0 0))
nil
  \end{clojure}
\end{english}

На практике \spverb|nil| не всегда означает ошибку, поэтому возвращают ключи
\spverb|:error| или \spverb|:invalid|. Так работает Spec, которую мы разобрали в
прошлой главе \page{spec-invalid}. Иногда в \spverb|catch| добавляют запись в
лог или обращение к Sentry. Подавляйте ошибку только если результат
действительно неважен.

\section{Заключение}

Исключения в Clojure устроены как в Java. Формы \spverb|try| и \spverb|catch|
похожи на одноим\"{е}нные операторы. Перехват работает на классах и
наследовании. Чем выше класс в иерархии, тем больше ошибок он покрывает.

Класс \spverb|ExceptionInfo| создан специально для Clojure. Его поле
\spverb|data| принимает любой словарь. Тип исключения определяют по полю
\spverb|:type| словаря. Функция \spverb|ex-info| это конструктор исключения.

У ошибки может быть причина, \spverb|cause|. Если вы поймали исключение, но не
знаете, что с ним делать, бросьте новое с контекстом и ссылкой на исходное. Так
собираются цепочки исключений. Чтобы выяснить причину, пригодятся данные со всей
цепочки, а не только верхнего звена.

Код на вершине приложения решает, что делать с исключением. Лучше всего
отправить его в систему сбора ошибок. На эту роль подходит Sentry и
аналоги. Убедитесь, что клиент к Sentry передает всю информацию об ошибке, а не
только стек-трейс.

В \spverb|finally| обычно закрывают ресурс, чтобы он не остался открытым при
ошибке. Доступ к ресуру упрощает контекстный менеджер. Это макрос вида
\spverb|with-<something>|, который оборачивает блок кода в
\spverb|try/finally|. Для файлов Clojure предлагает макрос \spverb|with-open|.

Иногда исключением пользуются, чтобы перейти в другое место в коде. Это
противоречивый подход, и на него должны быть причины.

Slingshot предлагает улучшенную схему \spverb|try/catch|. В таком подходе
ошибки ловят не классами, а селекторами и предикатами. Исключения заменяют на
словари.

Ряд функций упрощают контроль за исключениями. Возьмите их на заметку, чтобы
сократить код.
