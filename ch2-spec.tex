\chapter{Clojure.spec}

\begin{teaser}
В этой главе мы рассмотрим clojure.spec~--- библиотеку для проверки данных в
Clojure. Это особенная библиотека: на ней пишут валидаторы и парсеры, с ее
помощью генерируют данные для тестов. Spec фундаментальна по своей природе,
поэтому уделим ей пристальное внимание.
\end{teaser}

Название <<spec>> происходит от specification (анг. спецификация, описание). Это
набор функций и макросов, чтобы схематично описать данные. Например, из каких
ключей состоит словарь и каких типов его значения. Запись называют
спецификацией данных или сокращенно спекой. Далее мы будем
использовать короткий термин.

Специальные функции проверяют, подходят ли данные к спеке. Если нет, получим
отчет в каком месте произошла ошибка и почему.

Spec входит в поставку Clojure начиная с версии 1.9. Полностью модуль называется
\spverb|clojure.spec.alpha|. Не волнуйтесь о частичке <<alpha>> на конце
имени: она осталась по историческим причинам.

Spec стала важной вехой в развитии Clojure. Ключевое свойство Spec в том, что
она фундаментальна. Валидация данных это малая часть ее возможностей. Spec не
только проверяет данные, но и преобразует их. На Spec легко написать процессор
данных или парсер.

Формально Spec это обычная библиотека. Но ее абстракции оказались настолько
мощны, что Clojure переиспользует их. С версии 1.10 компилятор Clojure
анализирует код с помощью Spec. Так проекты дополняют друг друга.

Прежде чем браться за техническую часть, разберемся с теорией. Вспомним, как
связаны между собой классы, типы и валидация.

\section{Типы и классы}

\label{type-and-pred}

Принято считать, что код на языке со статической типизацией безопаснее, чем с
динамической. Компилятор не позволит сложить число и~строку еще до того, как мы
запустим программу. Однако тип переменной это лишь одно из многих
ограничений. Редко случается так, что тип задает все допустимые значения. Чаще
всего вместе с типом учитывают границы, длину, попадание в интервалы и
перечисления. Иногда значения верны по отдельности, но не могут стоять в паре
друг с другом.

Рассмотрим, как выразить в коде сетевой порт. Для операционной системы это число
от 0 до $2^{16}-1$. Целые типы обычно описаны степенями двойки, поэтому найдется
условный \spverb|unsigned int|, который охватит именно этот диапазон. У нулевого
порта особая семантика, и в прикладных программах его не используют. Правильно
считать порт с единицы. Вероятность, что в языке предусмотрен тип от~1
до~$2^{16}-1$ крайне мала.

Лучше всего увидеть проблему на диапазоне дат. Единичная дата может быть сколь
угодно разумной, но диапазон накладывает ограничение: начало строго меньше
конца. Бизнес дополняет: разница не больше недели, обе даты в рамках текущего
месяца.

В ООП знают об этой проблеме и решают ее классами \spverb|UnixPort| и
\spverb|DateRange|. Условный \spverb|UnixPort| это класс с конструктором. Он
принимает целое число и выполняет проверку на диапазон. Если число выходит за
рамки 1\dots$2^{16}-1$, конструктор бросит исключение. Программист уверен, что
создал новый тип. Это неверно~--- классы и типы не тождественны.

Конструктор это обычный валидатор. Он неявно сработает, когда мы напишем
\spverb|new UnixPort(8080)|. Из-за неявности возникнет иллюзия, что мы создали
тип. На деле это валидация и синтаксический сахар.

В промышленных языках нельзя описать класс так, чтобы выражение
\spverb|new UnixPort(-42)| привело к ошибке компиляции. Найти ее могут
только сторонние утилиты и плагины IDE.

Код конструктора нельзя использовать повторно. Представим классы
\spverb|UnixPort| и \spverb|NetPort|. Первый класс проверяет порт на~диапазон
и~бросает исключение. Выгодно пользоваться этим классом, поскольку он совмещен
с~валидацией. Однако сторонняя библиотека принимает \spverb|NetPort|. Возникает
проблема конвертации: нужно извлечь <<сырой>> порт из \spverb|UnixPort|
и~передать в~\spverb|NetPort|. Это лишний код и путаница с классами.

Признаки удобной валидации это независимость и компоновка. Независимость
означает, что данные не привязаны к валидации. Нет ничего плохого в том, что
порт это целое число. Пусть библиотека принимает \spverb|integer|, а разработчик
сам решит, как его проверить. Появится выбор, насколько строгой должна быть
проверка.

Компоновка означает, что полезно иметь несколько простых проверок, чтобы
составить из них сложные. Пусть заданы проверки <<это>> и <<то>>, и теперь нужны
их комбинации: <<это \emph{и} то>>, <<это \emph{или} то>>. В идеале компоновка
занимает пару строк и считается тривиальной задачей.

Оба тезиса ложатся на функцию. Это объект, на который действует одна
операция~--- вызов. Функция принимает значение и возвращает истину или ложь. Это
ответ на вопрос, было ли значение правильными или нет. Функция это объект
высшего порядка, поэтому другие функции порождают их комбинации.

\section{Основы spec}

С багажом рассуждений мы подходим к Spec. Подключим модуль в текущее
пространство:

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
  \end{clojure}
\end{english}

Синоним \spverb|s| нужен, чтобы избежать конфликтов имен с
\spverb|clojure.core|. Модуль Spec несет макросы \spverb|s/and|, \spverb|s/or| и
другие, у которых ничего общего с обычными \spverb|and| и \spverb|or|. Считается
дурным тоном, если имена одного модуля затеняют другие, поэтому обращаемся к
Spec через синоним.

Главная операция в Spec~--- задать новую \emph{спеку}:

\begin{english}
  \begin{clojure}
(s/def ::string string?)
  \end{clojure}
\end{english}

Макрос \spverb|s/def| принимает ключ и предикат. Он создал объект спеки из
функции \spverb|string?| и поместил ее в глобальный реестр с~ключом
\spverb|::string|.

Важно понимать, что \spverb|::string|~--- это не спека, а псевдоним. Макросы
Spec принимают не объект спеки, а ключ. Далее они сами найдут спеку в
реестре. Это удобно, потому что ключи глобальны. В любом месте можно сослаться
на \spverb|::string| без лишних импортов.

Вторым аргументом идет предикат \spverb|string?|. Предикат это функция, которая
возвращает истину или ложь. Функция это не спека, а строительный материал для
нее. Спека оборачивает функцию в особый объект. Технически на него можно
сослаться: функция \spverb|s/get-spec| по ключу спеки возвращает ее объект. На
практике он не нужен, потому что везде указывают ключи.

\begin{english}
  \begin{clojure}
(s/get-spec ::string)
;; #object[clojure.spec.alpha$reify 0x3e9dde1d]
  \end{clojure}
\end{english}

Спеки хранятся в глобальном реестре под своими ключами. Макрос \spverb|s/def| не
проверяет, была ли уже такая спека. Если была, мы потеряем ее старую версию.

Spec не работает с ключами без пространства, например \spverb|:name| или
\spverb|:email|. Это повышает риск конфликта ключей. Чтобы назначить ключу
текущее пространство, поставьте два двоеточия: \spverb|::name|, \spverb|::email|.

Самое простое, что можно сделать со спекой~--- проверить, подходит ли ей
значение. Функция \spverb|s/valid?| принимает ключ спеки, значение и~возвращает
\spverb|true| или \spverb|false|.

\begin{english}
  \begin{clojure}
(s/valid? ::string 1)      ;; false
(s/valid? ::string "test") ;; true
  \end{clojure}
\end{english}

Пустая строка пройдет валидацию, но чаще всего это не имеет смысла. Пустые имя
или заголовок означают ошибку. Объявим спеку, которая дополнительно проверит,
что строка не пустая. Наивный способ это сделать~--- усложнить предикат:

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (fn [val]
    (and (string? val)
         (not (empty? val)))))
  \end{clojure}
\end{english}

\noindent
Быстрая проверка:

\begin{english}
  \begin{clojure}
(s/valid? ::ne-string "test") ;; true
(s/valid? ::ne-string "")     ;; false
  \end{clojure}
\end{english}

Ключ \spverb|::ne-string| это сокращение от <<\textbf{n}on-\textbf{e}mpty
string>>. Спека встречается часто, поэтому логично сэкономить на ее имени.

Более изящный способ задать эту спеку~--- объединить предикаты через
\spverb|every-pred|. Функция принимает предикаты и возвращает супер-предикат. Он
вернет истину только если истинны все предикаты.

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (every-pred string? not-empty))
  \end{clojure}
\end{english}

Мы собираем новую сущность из базовых, что короче и следует функциональному
стилю. Но еще лучше комбинировать не предикаты, а спеки. Макрос \spverb|s/and|
объединяет несколько предикатов и спек в новую спеку:

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (s/and ::string not-empty))
  \end{clojure}
\end{english}

Так в Clojure строят сложные спеки: объявляют примитивы и наращивают их
комбинации.

\section{Исключения}

Во время проверки Spec не перехватывает исключения; о них заботится
программист. Рассмотрим спеку для проверки URL. Проще всего это сделать
регулярным выражением:

\begin{english}
  \begin{clojure}
(s/def ::url
  (partial re-matches #"(?i)^http(s?)://.*"))

(s/valid? ::url "test")            ;; false
(s/valid? ::url "http://test.com") ;; true
  \end{clojure}
\end{english}

\noindent
Что-то отличное от строки вызовет ошибку:

\begin{english}
  \begin{clojure}
(s/valid? ::url nil)
;; Execution error (NullPointerException)
;; at java.util.regex.Matcher...
  \end{clojure}
\end{english}

Примечание: класс \spverb|NullPointerException| частый гость в мире Java. Для
краткости его называют \spverb|NPE|.

Причина в том, что \spverb|nil| попал в функцию \spverb|re-matches|. Функция
трактует аргумент как строку, что приводит к \spverb|NPE|. Пишите спеки так,
чтобы они не бросали исключения. В примере с \spverb|::url| сначала убедимся,
что это строка, и только потом проверим на регулярное выражение.

\begin{english}
  \begin{clojure}
(s/def ::url
  (s/and ::ne-string
         (partial re-matches #"(?i)^http(s?)://.*")))

(s/valid? ::url nil) ;; false
  \end{clojure}
\end{english}

Макрос \spverb|s/and| устроен так, что на первой неудаче цепь
оборв\"{е}тся. Все, что после \spverb|::ne-string| не сработает, и исключения не
будет.

По аналогии проверим возраст пользователя. Это предикаты на~число и~диапазон.

\begin{english}
  \begin{clojure}
(s/def ::age
  (s/and int? #(<= 0 % 150)))

(s/valid? ::age nil) ;; false
(s/valid? ::age -1)  ;; false
(s/valid? ::age 42)  ;; true
  \end{clojure}
\end{english}

\section{Спеки-коллекции}

Выше мы проверяли примитивные типы или \emph{скаляры}. Это удобно для примеров,
но редко встречается на практике. В~основном проверяют не скаляры,
а~коллекции. Spec предлагает макросы, чтобы задать спеки-коллекции из
примитивов.

Макрос \spverb|s/coll-of| принимает предикат или ключ и возвращает
спеку-коллекцию. Она проверяет, что каждый элемент проходит валидацию. Вот так
мы определим список URL:

\begin{english}
  \begin{clojure}
(s/def ::url-list (s/coll-of ::url))
  \end{clojure}
\end{english}

\noindent
Быстрая проверка:

\begin{english}
  \begin{clojure}
(s/valid? ::url-list ["http://test.com" "http://ya.ru"])
;; true

(s/valid? ::url-list ["http://test.com" "dunno.com"])
;; false
  \end{clojure}
\end{english}

Макрос \spverb|s/map-of| описывает словарь. Вспомним поле \spverb|:params| из
главы про веб-разработку \page{ring-params}. Его ключи кейворды, а значения
строки. На языке спеки это выглядит так:

\begin{english}
  \begin{clojure}
(s/def ::params
  (s/map-of keyword? string?))

(s/valid? ::params {:foo "test"})  ;; true
(s/valid? ::params {"foo" "test"}) ;; false
  \end{clojure}
\end{english}

Проверка \spverb|s/map-of| довольно слабая, чтобы покрыть все варианты. Факт
того, что значения строки не несет полезной информации. Важнее убедиться, что в
словаре именно те ключи, что мы ожидаем. К тому же редко бывает так, что тип
значений одинаковый. Наоборот словарь несет разные сведения о сущности: имя,
возраст, дату.

В таких случаях используют макрос \spverb|s/keys|, в котором перечислены
спеки. Имена спек совпадают с ключами словаря. Значения ключей проверяются
одноименными спеками.

Представим веб-страницу с адресом и описанием. Объявим примитивы:

\begin{english}
  \begin{clojure}
(s/def :page/address ::url)
(s/def :page/description ::ne-string)
  \end{clojure}
\end{english}

Обратите внимание на пространство ключей. Адрес и описание относятся к странице,
поэтому им задают свое пространство. У статьи или книги тоже могут быть адрес и
описание. Пространство обещает, что спеки \spverb|:page/address| и
\spverb|:book/address| не заменят друг друга.

Составим спеку страницы:

\begin{english}
  \begin{clojure}
(s/def ::page
  (s/keys :req-un [:page/address
                   :page/description]))
  \end{clojure}
\end{english}

В параметре \spverb|:req-un| указан вектор спек. Для каждой из них спека ищет в
словаре ключ с таким же именем и проверяет значение. Рассмотрим, что означает
\spverb|:req-un| и какие еще параметры принимает \spverb|s/keys|.

Имя \spverb|:req-un| состоит из частей <<req>> и <<un>>. Это признаки наличия
ключа и его типа. Req (анг. required) означает, что ключи обязательно должны
быть в словаре. Если хотя бы одного ключа нет, получим ошибку. Противоположный
по смыслу параметр называется <<opt>> (анг. optional). В нем указаны ключи,
которых может не быть. Их валидация происходит, только если они были в словаре.

Частичка <<un>> означает unqualified, неполный ключ. При проверке un-ключей
спека не учитывает их пространство. Например, если указать
\spverb|:page/address| в списке \spverb|:req-un|, то в словаре ищется ключ
\spverb|:address|, а не \spverb|:page/address|.

Неполные ключи встречаются часто. Мы получаем данные из чужих API и баз данных,
которые не знают о пространствах имен. В Clojure пространства нужны, чтобы
разделить одноименные поля у разных сущностей, например \spverb|:user/name| и
\spverb|:project/name|. Исключения бывают, когда весь стек фирмы построен на
Clojure. В этом случае клиент и сервер шлют данные с полными ключами.

Различают следующие комбинации \spverb|req|, \spverb|opt| и \spverb|un|:

\begin{itemize}

\item
  \spverb|:req|~--- необходимые полные ключи,

\item
  \spverb|:req-un|~--- необходимые краткие ключи,

\item
  \spverb|:opt|~--- опциональные полные ключи,

\item
  \spverb|:opt-un|~--- опциональные краткие ключи.

\end{itemize}

У спеки \spverb|::page| ключи обязательны и не учитывают пространство. Ниже
примеры данных с ошибками. Это может быть неправильный адрес, пустое описание,
пропавший ключ. Если каждый из словарей подставить в выражение
\spverb|(s/valid? ::page ...)|, результат будет ложью.

\begin{english}
  \begin{clojure}
{:address "clojure.org" ;; not a URL
 :description "Clojure Language"}

{:address "https://clojure.org/"
 :description ""} ;; empty string

{:address "https://clojure.org/"} ;; missing key

{:page/address "https://clojure.org/" ;; full keys
 :page/description "Clojure Language"}
  \end{clojure}
\end{english}

Обратите внимание на последний случай. Значения верны, но у ключей пространство
\spverb|:page|. Валидация не сработает, потому что спека ищет \spverb|:address|,
а не \spverb|:page/address|. Чтобы исправить последний пример, замените тип
ключей \spverb|:req-un| на \spverb|:req| (необходимые полные).

\begin{english}
  \begin{clojure}
(s/def ::page-fq
  (s/keys :req [:page/address
                :page/description]))

(s/valid? ::page-fq
          {:page/address "https://clojure.org/"
           :page/description "Clojure Language"})
;; true
  \end{clojure}
\end{english}

Усложним пример: добавим странице статус, который мы получили при
последнем обращении к ней. Поле опционально, потому что если к странице еще не
обращались, в него нечего записать. Новая спека:

\begin{english}
  \begin{clojure}
(s/def :page/status int?)

(s/def ::page-status
  (s/keys :req-un [:page/address
                   :page/description]
          :opt-un [:page/status]))
  \end{clojure}
\end{english}

\noindent
Словари с правильным статусом и без него пройдут валидацию:

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"})

(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status 200})
  \end{clojure}
\end{english}

Заметим, что \spverb|s/keys| различает \spverb|nil| и наличие ключа. Если статус
\spverb|nil|, он есть в словаре. Сработает проверка \spverb|nil| на
\spverb|int?|, что приведет к ошибке. Это редкий случай, когда пустое значение
не равно его отсутствию.

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status nil})
;; false
  \end{clojure}
\end{english}

\section{Вывод значений}

\label{spec-conform}

До сих пор мы проверяли данные с помощью \spverb|s/valid?|. Функция вернет
истину или ложь, что значит данные верны или нет. Но одной проверки
недостаточно: иногда значения корректны, но требуется привести их к нужному
типу.

На вход поступило число в виде строки. Мы убедились, что строка состоит из цифр
и не превышает допустимой длины. После валидации значение по-прежнему строка, и
придется парсить его вручную. Хотелось бы, чтобы типы выводил за нас какой-то
механизм.

Spec предлагает такие возможности. Это функции \spverb|s/conformer| и
\spverb|s/conform| (анг. conform~--- подчиняться).

\label{spec-invalid}

Сначала пишут функцию вывода. Она принимает исходное значение и возвращает либо
новое, либо ключ \spverb|::s/invalid|, что означает ошибку. Затем функцию
оборачивают в \spverb|s/conformer|, чтобы получить спеку. \spverb|S/conform|
принимает спеку-конформер и данные. Если вывод прошел без ошибок, получим новое
значение, иначе ключ \spverb|::s/invalid|.

Рассмотрим вывод числа из строки. Чтобы отличить конформер от валидатора, к
имени добавляют стрелку, что означает приведение типа.

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/conformer
   (fn [value]
     (try
       (Integer/parseInt value)
       (catch Exception e
         ::s/invalid)))))
  \end{clojure}
\end{english}

\noindent
Эту спеку передают в \spverb|s/conform| с данными:

\begin{english}
  \begin{clojure}
(s/conform ::->int "42") ;; 42

(s/conform ::->int "dunno")
:clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

\spverb|S/conform| не ловит исключения при работе, а вывод типов богат на
них. Будет правильно перехватить исключение и вернуть \spverb|::s/invalid|, как
в примере выше.

Обе спеки~--- валидатор и конформер~--- можно объединить через \spverb|s/and|,
чтобы проверить тип перед выводом. В нашем случае убедимся, что значение
строка. Так мы не допустим, чтобы в \spverb|parseInt| попал \spverb|nil| или
что-то другое:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and ::ne-string ::->int))

(s/conform ::->int nil)
:clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

Рассмотрим, как восстановить из строки дату. Это старая проблема веба: JSON не
поддерживает даты, поэтому их передают строкой ISO или числом секунд. Возникает
вопрос, как привести их к объекту на сервере.

Понадобится парсер строки и небольшая обвязка, чтобы подружить его со
спекой. Функция \spverb|read-instant-date| из модуля \spverb|clojure.instant|
читает дату из строки. Она лояльна к формату и учитывает разные
комбинации. Например, датой может быть только год.

\begin{english}
  \begin{clojure}
(require '[clojure.instant :refer [read-instant-date]])
(read-instant-date "2019")
#inst "2019-01-01T00:00:00.000-00:00"
  \end{clojure}
\end{english}

\noindent
Обернем функцию в спеку:

\begin{english}
  \begin{clojure}
(s/def ::->date
  (s/and
   ::ne-string
   (s/conformer
    (fn [value]
      (try
        (read-instant-date value)
        (catch Exception e
          ::s/invalid))))))
  \end{clojure}
\end{english}

Перед разбором мы делаем минимальные проверки. Убеждаемся, что это непустая
строка, чтобы отсечь \spverb|nil| и прочий мусор. Разбор даты:

\begin{english}
  \begin{clojure}
(s/conform ::->date "2019-12-31")
#inst "2019-12-31T00:00:00.000-00:00"
  \end{clojure}
\end{english}

\noindent
Дата и время:

\begin{english}
  \begin{clojure}
(s/conform ::->date "2019-12-31T23:59:59")
#inst "2019-12-31T23:59:59.000-00:00"
  \end{clojure}
\end{english}

\section{Спеки-перечисления}

Иногда известно заранее, какие значения принимает поле. При вызове API клиент
передает архитектуру системы~--- 32 или 64 бита. Ради двух значений нет смысла
парсить число: подойдет \spverb|case| или словарь.

вариант с макросом \spverb|case|. Если ничего не найдено, сигналим об ошибке
ключом \spverb|::s/invalid|. Заметим, что \spverb|case| это не линейный перебор:
он строит индексы веток и не пробегает их все, а переходит на нужную.

\begin{english}
  \begin{clojure}
(s/def ::->bits
  (s/conformer
   (fn [value]
     (case value
       "32" 32
       "64" 64
       ::s/invalid))))

(s/conform ::->bits "32") ;; 32
(s/conform ::->bits "42") :clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

Вариант со словарем для перевода значения. Удобно, что словарь живет в отдельной
переменной. Его легко дополнить или вынести в конфигурацию, при этом логика
валидации не изменится.

\begin{english}
  \begin{clojure}
(def bits-map {"32" 32 "64" 64})

(s/def ::->bits
  (s/conformer
   (fn [value]
     (get bits-map value ::s/invalid))))
  \end{clojure}
\end{english}

Похожим образом читают логические значения из строк. Нет единого соглашения о
том, как передать истину и ложь в тексте. Это может быть \spverb|True|,
\spverb|TRUE|, \spverb|1|, \spverb|yes| для истины и противоположности:
\spverb|FALSE|, \spverb|no|. При разборе значений их приводят к одному
регистру. В Clojure \spverb|FALSE| и \spverb|false| это разные строки, даже если
отправитель имел в виду одно и то же. Сценарий выглядит так:

\begin{itemize}

\item
  убедиться, что значение это строка;

\item
  привести ее к нижнему регистру;

\item
  найти значение по словарю или перебором.

\end{itemize}

\noindent
Код вывода:

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ::ne-string
   (s/conformer clojure.string/lower-case)
   (s/conformer
    (fn [value]
      (case value
        ("true" "1" "on" "yes") true
        ("false" "0" "off" "no") false
        ::s/invalid)))))

  \end{clojure}
\end{english}

\noindent
В действии:

\begin{english}
  \begin{clojure}
(s/conform ::->bool "True") ;; true
(s/conform ::->bool "yes")  ;; true
(s/conform ::->bool "0")    ;; false
  \end{clojure}
\end{english}

\section{Продвинутые техники}

Мы написали достаточно кода, чтобы увидеть одинаковые участки~--- паттерны. В
этом разделе мы вынесем их в функции и~макросы, которые ускорят вашу работу.

\subsection{Множества}

Когда значения известны, на роль спеки подходит множество. Оно ведет себя как
функция: если аргумент найден в множестве, получим его же. Если нет, результат
будет \spverb|nil|. Представим, что статус задачи может быть строкой
\spverb|todo|, \spverb|in_progress| и \spverb|done|. Опишем спеку множеством
этих значений:

\begin{english}
  \begin{clojure}
(s/def ::status #{"todo" "in_progres" "done"})
(s/valid? ::status "todo") ;; true
  \end{clojure}
\end{english}

\subsection{Перечисления}

Множество не подходит в случаях, когда \spverb|false| и \spverb|nil| считают
верными значениями. \spverb|S/valid?| трактует их как неудачу. Если \spverb|nil|
или \spverb|false| допустимы, их проверяют функцией \spverb|contains?|:

\begin{english}
  \begin{clojure}
(contains? #{1 :a nil} nil) ;; true
  \end{clojure}
\end{english}

Чтобы не повторяться, напишем функцию \spverb|enum|. Она принимает значения и
возвращает предикат. В свою очередь предикат принимает аргумент и проверяет,
есть ли такой среди исходных значений.

\begin{english}
  \begin{clojure}
(defn enum [& args]
  (let [arg-set (set args)]
    (fn [value]
      (contains? arg-set value))))
  \end{clojure}
\end{english}

Функция внутри замкнута на переменной \spverb|arg-set|. Это множество, которое
получили из списка аргументов. Мы создали его один раз, чтобы не делать это
постоянно при вызове предиката. Новые перечисления выглядят коротко и ясно:

\begin{english}
  \begin{clojure}
(s/def ::status
  (enum "todo" "in_progres" "done"))
  \end{clojure}
\end{english}

\subsection{With-conformer}

Конформеры требуют особого внимания. В них легко допустить ошибку: не
перехватить исключение или не обернуть функцию в \spverb|s/conformer|. Вынесем
рутину в макрос \spverb|with-conformer|. Он принимает символ переменной и
произвольное тело. Макрос порождает функцию одного аргумента, которая выполнит
тело в блоке \spverb|try/catch|. Если исключения не было, получим последнее
выражение тела. В противном случае вернется \spverb|::s/invalid|.

\begin{english}
  \begin{clojure}
(defmacro with-conformer
  [[bind] & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))))
  \end{clojure}
\end{english}

\noindent
Вывод числа:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (with-conformer [val]
     (Integer/parseInt val))))
  \end{clojure}
\end{english}

\noindent
и булева типа:

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ->lower
   (with-conformer [val]
     (case val
       ("true"  "1" "on"  "yes") true
       ("false" "0" "off" "no" ) false))))
  \end{clojure}
\end{english}

\noindent
Переменная \spverb|->lower| это обертка для приведения регистра:

\begin{english}
  \begin{clojure}
(def ->lower
  (s/and
    string?
    (s/conformer clojure.string/lower-case)))
  \end{clojure}
\end{english}

В \spverb|case| необязательно указывать \spverb|::s/invalid| на конце
макроса. Если \spverb|case| не нашел ветку и не задан вариант по умолчанию,
он~бросит исключение. \spverb|With-conformer| перехватит его и вернет
\spverb|invalid|.

\section{Логические пути}

Функция \spverb|s/conform| не всегда возвращает то, что мы ожидаем. Некоторые
спеки оборачивают результат в вектор, где первый элемент~--- логический путь. Он
появляется там, где проверка ветвится.

\spverb|S/and| обходит дочерние по порядку и проверяет данные. Иногда линейного
обхода недостаточно: нужна развилка. Например, если значение число, то оставить
его есть, а если строка, то привести к числу. Такие спеки называют условными
(анг. conditional).

Макрос \spverb|s/or| принимает теги и дочерние спеки. Он применяет их к значению
до первого совпадения. Результат будет парой, где первый элемент тег, а
второй~--- значение из спеки, которая подошла.

Тег становится частью пути, по которому шла проверка. Логический путь помогает
расследовать, в каком месте произошла ошибка. Для простых спек это не проблема,
но на практике условная спека вложена в другую условную, та тоже и так
далее. Найти ошибку без логического пути будет трудно.

Если валидация не прошла, логический путь получают из отладочной информации. Ее
возвращают функции семейства \spverb|s/explain*|, которые мы рассмотрим ниже.

Напишем спеку сетевого порта, которая принимает число или строку. Во втором
случае спека выводит число. Это полезно, если значение приходит из переменной
среды или ini-файла.

\begin{english}
  \begin{clojure}
(s/def ::smart-port
  (s/or :string ::->int :num int?))
  \end{clojure}
\end{english}

\noindent
Теперь \spverb|s/conform| вернет не просто значение, а пару с тегом:

\begin{english}
  \begin{clojure}
(s/conform ::smart-port 8080)
[:num 8080]

(s/conform ::smart-port "8080")
[:string 8080]
  \end{clojure}
\end{english}

Если в спеке была развилка (\spverb|s/or|, \spverb|s/alt|), то структура
\spverb|s/conform| отличается от входных данных: на месте скаляра появится
вектор. Покажем это на вложенных данных. Пусть порт~--- одно из полей
подключения к базе:

\begin{english}
  \begin{clojure}
(s/def :conn/port ::smart-port)
(s/def ::conn
  (s/keys :req-un [:conn/port]))
  \end{clojure}
\end{english}

Топология результата будет другой, и это нужно учесть. Если передать поле
\spverb|:port| в подключение, получим ошибку типов.

\begin{english}
  \begin{clojure}
(s/conform ::conn {:port "9090"})
{:port [:string 9090]}
  \end{clojure}
\end{english}

\section{Обратное действие}

У функции \spverb|unform| противоположный смысл: по спеке и результату она
вернет исходное значение. Выше мы получили словарь, где поле \spverb|:port| это
вектор. Чтобы вернуться к исходным данным, выполните:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:num 9090]})
{:port 9090}
  \end{clojure}
\end{english}

\noindent
Если передать пару со строкой, получим ошибку:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:string 9090]})
;; Execution error (IllegalStateException)
;; no unform fn for conformer
  \end{clojure}
\end{english}

Дело в том, что тегу \spverb|:num| мы задали предикат. Он ничего не выводит,
поэтому для предиката \spverb|unform| отбросит тег и вернет значение. Тег
\spverb|:string| указывает на спеку типа \spverb|conformer|, которая
\emph{меняет} значение. Чтобы выполнить \spverb|unform|, нужно сказать ей, как
это делать.

Первый аргумент \spverb|s/conformer| это функция, которая выводит тип. К ней
обращается \spverb|s/conform|, когда его вызывают. Второй необязательный
аргумент это функция с обратным эффектом: по результату \spverb|conform| вернуть
прежнее значение. Функция сработает в момент \spverb|s/unform|.

Изменим \spverb|::->int|, чтобы он поддерживал \spverb|unform|:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (s/conformer
    (fn [string]
      (Integer/parseInt string))
    (fn [integer]
      (str integer)))))
  \end{clojure}
\end{english}

\noindent
Теперь порт со строкой не вызовет ошибки:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:string 9090]})
{:port "9090"}
  \end{clojure}
\end{english}

\spverb|Unform| полезен, если вы утратили исходные данные, но сохранили их
\spverb|conform|-вариант.

Читатель заметит, что наша цель была вывести порт из строки, однако из-за
\spverb|conform| и \spverb|unform| вс\"{е} пошло не так. \spverb|Conform| вывел тип,
но добавил в результат теги, из-за чего изменилась структура. \spverb|Unform|
убрал теги, но вернул строку на место числа. В ч\"{е}м этом смысл?

Если коротко, \spverb|conform| и теги незаменимы для парсинга данных и их
обхода. Далее мы покажем, как с помощью \spverb|conform| получить синтаксическое
дерево, без которого не обходится ни один компилятор. Что касается
\spverb|unform|, его поведение можно исправить хитростью.

В спеке \spverb|::->int| в \spverb|unform|-части мы переводим число в обратно
строку. Если вернуть число без изменений, оно встанет на место \spverb|:port| в
итоговом словаре:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (s/conformer
    (fn [string]
      (Integer/parseInt string))
    (fn [integer]
      integer))))

(s/unform ::conn {:port [:string 9090]})
{:port 9090}
  \end{clojure}
\end{english}

Для большей краткости вторым аргументом передают \spverb|identity|~--- функцию,
которая вернет переданный ей аргумент. С таким подходом \spverb|unform| всегда
вернет то, что получили на этапе \spverb|conform|. Полный цикл \spverb|conform|
и \spverb|unform|:

\begin{english}
  \begin{clojure}
(->> {:port "9090"}
     (s/conform ::conn)
     (s/unform ::conn))
{:port 9090}
  \end{clojure}
\end{english}

Чтобы не забыть \spverb|unfrom| в спеке, сделайте его частью макроса
\spverb|with-conformer|:

\begin{english}
  \begin{clojure}
(defmacro with-conformer
  [[bind] & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))
    identity))
  \end{clojure}
\end{english}

\section{Анализ ошибок}

Когда данные неверны, \spverb|s/valid?| и \spverb|s/conform| возвращают
\spverb|false| и \spverb|::s/invalid|. Этого недостаточно, чтобы понять причину
ошибки. Представьте, что у вас спека пользователя. В ней несколько адресов, в
каждом адресе несколько строк,... и проверка вернула \spverb|false|. Ручной
поиск ошибки займет час.

Функции семейства \spverb|s/explain| принимают спеку и данные. Если проверка не
удалась, получим отчет. Это словарь, где указаны проблемные значения, спеки,
пути к ним и другие данные. Разница между функциями в том, как они поступают с
отчетом.

\begin{itemize}

\item
  \spverb|s/explain| печатает его в стандартный поток (на экран);

\item
  \spverb|s/explain-str| возвращает отчет в виде строки;

\item
  \spverb|s/explain-data| возвращает словарь. Это самый полный отчет об ошибке.

\end{itemize}

Попробуем функции в действии. Их результат одинаковый, разница в том, куда он
приходит~--- в консоль или переменную. Подготовим простую спеку:

\begin{english}
  \begin{clojure}
(s/def :sample/username ::ne-string)

(s/def ::sample
  (s/keys :req-un [:sample/username]))
  \end{clojure}
\end{english}

\noindent
На корректных данных функции не проявляют себя:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username "some user"})
Success!
nil

(s/explain-data ::sample {:username "some user"})
nil
  \end{clojure}
\end{english}

\noindent
Попробуем число вместо имени:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username 42})
;; 42 - failed: string? in: [:username]
;; at: [:username] spec: ::string
  \end{clojure}
\end{english}

Вывод читается так: значение \spverb|42| не прошло проверку предикатом
\spverb|string?|. Путь к значению внутри словаря \spverb|[:username]|. Ключ
спеки, где случилась ошибка -- \spverb|::string|.

Отчет показывает наиболее вложенные спеки и предикаты. Вспомним, что
\spverb|::ne-string| это комбинация \spverb|::string| и
\spverb|not-empty|. Ошибка случилась на этапе \spverb|::string|, о чем и было
сказано.

Для пустой строки вывод будет другим. На этот раз причиной станет
\spverb|not-empty|. Проверим это:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username ""})
;; "" - failed: not-empty in: [:username]
;; at: [:username] spec: ::ne-string
  \end{clojure}
\end{english}

\spverb|Explain| это быстрый способ сообщить о проблеме в конфигурации или
JSON-файле. Со временем вы научитесь читать его. Но чем сложнее данные, тем
меньше понятен \spverb|explain|. Когда в коллекции больше трех уровней, отчет
заливает экран. Трудно даже разбить его на части, не говоря уж о
понимании. Чтобы подружиться с \spverb|explain|, нужно промежуточное звено, речь
о котором в следующем разделе.

\section{Понятные ошибки}

\label{spec-messages}

Когда проверяют данные, важен не только факт ошибки. Еще важнее объяснить
клиенту, где именно он ошибся. Под клиентом не обязательно имеют в виду
человека. Даже если это другая программа, в ответ добавляют понятный текст. Он
попад\"{е}т в логи, которые читают сотрудники.

Часто мы видим сообщения вроде <<Ошибка: DATAERROR>> без каких-либо деталей. Или
красную надписью <<проверьте данные>> над формой в два экрана. Этих глупостей
можно было избежать, умей программисты переводить язык машины на человеческий.

Фраза \spverb|"" - failed: not-empty in: [:username]| не только ничего не скажет
пользователю, но и отпугнет его машинной природой. Кажется, что в интерфейсе
брешь, и пользователь видит то, что не должен. Это резко снижает доверие к
системе.

Чтобы составить сообщение, вернемся к функции \spverb|s/explain-data|.  Она
возвращает словарь с нужной информацией. Пример такого отчета:

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username ""})

#:clojure.spec.alpha
{:problems
 ({:path [:username]
   :pred clojure.core/not-empty
   :val ""
   :via [::sample ::ne-string]
   :in [:username]})
 :spec ::sample
 :value {:username ""}}
  \end{clojure}
\end{english}

На первый взгляд непонятно, что с ним делать. Некоторые инженеры сдаются и
говорят, что Spec не подходит для ошибок. Это не так: в отчете все необходимые
данные, нужно только правильно их обработать.

Новички задают вопрос~--- почему бы не сделать понятные сообщения на уровне
библиотеки? Например, назначить спеке поле с текстом <<введите правильный
адрес>>? Почему не взять пример с библиотек для Python или JavaScript?

Ответ на этот вопрос не устраивает новичков. Вспомним тезис из начала главы:
Spec это \emph{фундаментальная библиотека}. То, что мы проверяем ей
HTML-форму~--- всего лишь частный случай. У спеки разные области применения,
поэтому структура ошибки тоже фундаментальна.

Трудно создать систему ошибок, которая устроит всех. В каждом проекте свои
правила о том, как показывать ошибки. Иногда это фиксированное сообщение, а в
других случаях шаблон. Где-то учитывают язык пользователя. Все вместе это
сложные сценарии.

Если бы разработчики Spec занялись ошибками, их фокус был бы смещен с главной
цели. Вместо Spec мы бы получили валидаторы по типу тех, что пишут десятками для
Python и JavaScript. Они скучны, не гибки и без концепции.

Словарь \spverb|explain-data| содержит ключи \spverb|:spec|, \spverb|:value| и
\spverb|:problems| с пространством \spverb|clojure.spec.alpha|. Первые два это
спека и значение, которые приняли участие в проверке. Нас интересует
\spverb|:problems|. Это список словарей, где каждый описывает ошибку
валидации. Перечислим их поля и семантику.

\begin{itemize}

\item
  \spverb|:path|~--- логический путь валидации. Вектор ключей, где спеки
  чередуются с тегами-развилками. Условные спеки вроде \spverb|s/or| пишут сюда
  свои метки.

\item
  \spverb|:pred|~--- символ полный предиката, например
  \spverb|clojure.core/string?|.

\item
  \spverb|:val|~--- значение, для которого предикат вернул ложь. Например, 42,
  \spverb|nil|, элемент словаря.

\item
  \spverb|:via|~--- вектор спек, по которым прошло значение от верхнего уровня к
  нижнему.

\item
  \spverb|:in|~--- физический путь к значению. Вектор ключей и индексов, который
  передают в функцию \spverb|get-in|. Если выполнить \spverb|(get-in <данные> <:in>)|,
  получим значение, которое вызвало ошибку.

\end{itemize}

В отчете все, что нам нужно. Из \spverb|:val| возьмем проблемное
значение. Спека, на которой остановилась валидация это последний элемент вектора
\spverb|:via|.

Составим словарь, где ключ~--- спека, а значение~--- понятный текст или
шаблон. Зная спеку, которая вызвала ошибку, получим из словаря текст. В нашем
случае последний элемент \spverb|:via| это \spverb|::ne-string|. Назначим ей
сообщение <<Строка не должна быть пустой>> или что-то похожее.

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"})
  \end{clojure}
%% \end{english}

Напишем функцию, которая принимает словарь ошибки (один из элементов
\spverb|::s/problems|) и возвращает сообщение:

%% \begin{english}
  \begin{clojure}
(defn get-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (get spec-errors spec)))

(get-message {:via [::sample ::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

Проверим способ на других полях. Добавим в спеку \spverb|::sample| адрес почты:

\begin{english}
  \begin{clojure}
(s/def ::email
  (s/and
   ::ne-string
   (partial re-matches #"(.+?)@(.+?)\.(.+?)")))

(s/def :sample/email ::email)

(s/def ::sample
  (s/keys :req-un [:sample/username
                   :sample/email]))
  \end{clojure}
\end{english}

Спека \spverb|::email| проверяет, что строка не пустая и совпадает с шаблоном
адреса. Шаблон требует, чтобы в строке был символ \spverb|@| и точка.

Если передать в \spverb|email| пустую строку, последним элементом \spverb|via|
будет \spverb|::ne-string|. Для экономии места сократим вывод
\spverb|explain-data|:

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username "test" :email ""})

{:path [:email]
 :pred clojure.core/not-empty
 :val ""
 :via [::sample ::email ::ne-string]
 :in [:email]}
  \end{clojure}
\end{english}

Вызво \spverb|get-message| с этой вернет сообщение о пустой строке. Попробуем
почту, которая не совпала с шаблоном. Последним элементом \spverb|:via| станет
\spverb|:sample/email|. Словарь ошибки выглядит так:

\begin{english}
  \begin{clojure}
{:path [:email]
 :pred
 (clojure.core/partial
  clojure.core/re-matches
  #"(.+?)@(.+?)\.(.+?)")
 :val "test"
 :via [::sample ::email]
 :in [:email]}
  \end{clojure}
\end{english}

Чтобы \spverb|get-message| вернул другое сообщение, добавим в словарь ошибок
ключ \spverb|::email|:

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   ::email "Введите правильный почтовый адрес"})
  \end{clojure}
%% \end{english}

Осталось наполнить его другими спеками и сообщениями, пока не покроем все
варианты. Теперь рассмотрим, как улучшить этот подход.

\subsubsection{Сообщение по умолчанию}

Что случится, если перевода нет в словаре? В этом случае вернем нейтральное
<<исправьте ошибку в данных>>. Заодно запишем в лог событие с именем спеки. Лог
настроен так, что сообщения из этого модуля идут в отдельный файл. Позже
локализаторы прочтут его и~добавят перевод.

%% \begin{english}
  \begin{clojure}
(def default-message
  "Исправьте ошибку в данных")
  \end{clojure}
%% \end{english}

\begin{english}
  \begin{clojure}
(defn get-better-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (do (log/debugf "missing message for spec %s" spec)
            default-message))))
  \end{clojure}
\end{english}

\subsubsection{Гибкий поиск}

Упростим поиск ключа в словаре. Поле \spverb|email| встречается в разных спеках:
\spverb|:account/email|, \spverb|:patient/email| и других. Согласно методу выше,
каждый ключе должен быть в словаре, что склоняет нас к повторам.

Чтобы не засорять словарь, пойдем на хитрость. Пусть функция ищет перевод по
полному ключу, а если его нет, то по имени. Тогда хватит ключа \spverb|:email|,
чтобы все емейлы сошлись в этот перевод. Если для конкретного
\spverb|:account/email| нужна особая фраза, добавим полную версию:

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   :email "Введите правильный почтовый адрес"
   :account/email "Почтовый адрес сотрудника содержит ошибки"})
  \end{clojure}
%% \end{english}

\noindent
Обновим поиск с учетом неполного ключа и фразы по умолчанию:

\begin{english}
  \begin{clojure}
(defn get-better-message
  [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (get spec-errors (-> spec name keyword))
        default-message)))
  \end{clojure}
\end{english}

Система переводов, которую мы построили, довольно проста. Ее легко тестировать и
менять под нужды конкретного проекта. Доработанные версии этой системы работают
в бою. В одном из них формы проверяют на клиенте до отправки на
сервер. Сообщение для виджетов получают тем тем же способом. Это возможно,
поскольку мощь Spec в полной мере доступна в ClojureScript.

\subsubsection{Мультиметод}

Возможно, система переводов понравится вашим коллегам, и они захотят ее
использовать. Разумно вынести код в библиотеку и подключить в зависимости. Тогда
в плане сообщений проекты будут одинаковы.

Минус словаря в том, что его трудно расширить со стороны. Чтобы добавить
перевод, нужно выпустить новую версию библиотеки. Предоставим клиентам только
механизм перевода, а содержимое они наполнят сами.

Для этого заменим словарь на мультиметод. Его диспатчер принимает словарь ошибки
и находит виновную спеку. Далее расширим мультиметод спеками. С таким подходом
каждый добавит свои переводы или заменит чужие, если они не подошли.

Объявим мультиметод с одним переводом:

%% \begin{english}
  \begin{clojure}
(defmulti problem->text
  (fn [{:keys [via]}]
    (peek via)))

(defmethod problem->text ::ne-string [_]
  "Строка не должна быть пустой")
  \end{clojure}
%% \end{english}

Пример его работы:

%% \begin{english}
  \begin{clojure}
(problem->text {:val "" :via [::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

Ключ \spverb|:default| отвечает за действие по умолчанию. Если перевод не
найден, вернем стандартную фразу:

\begin{english}
  \begin{clojure}
(defmethod problem->text :default [_]
  default-message)
  \end{clojure}
\end{english}

Вспомним сообщение для почты. Хотелось бы, чтобы \spverb|:account/email| и
\spverb|:client/email| сходились в общий \spverb|::email|, но так, чтобы можно
было задать им частный перевод. Это возможно с помощью иерархии ключей. Если у
мультиметода нет ключа, но ключ наследует родителя, мультиметод выполнит поиск
для родителя.

Добавим перевод почты и унаследуем ключ \spverb|:account/email| от
\spverb|::email|. Если ошибка случится в спеке \spverb|:account/email|, получим
общий перевод для любой почты.

%% \begin{english}
  \begin{clojure}
(defmethod problem->text ::email [_]
  "Введите правильный почтовый адрес")

(derive :account/email ::email)

(problem->text {:val "" :via [:account/email]})
"Введите правильный почтовый адрес"
  \end{clojure}
%% \end{english}

\noindent
Если нужен особый перевод, расширим мультиметод:

%% \begin{english}
  \begin{clojure}
(defmethod problem->text :account/email [_]
  "Введите почту сотрудника")
  \end{clojure}
%% \end{english}

Заметим, что каждый метод принимает словарь ошибки. Мы затенили его символом
\spverb|_|, потому что перевод зависит от ключа. В особых случаях можно
построить фразу в зависимости от других полей. Например, добавить текущее
значение:

%% \begin{english}
  \begin{clojure}
(defmethod problem->text :account/email
  [{:keys [val]}]
  (format "Ошибка в адресе почты: %s" val))

(problem->text {:val "test" :via [:account/email]})
"Ошибка в адресе почты: test"
  \end{clojure}
%% \end{english}

\subsubsection{Шаблон}

Если варианты выше показались сложными, попробуйте сообщение по~шаблону. Оно
складывается из имени поля и значения, например: <<в~поле email неверное
значение test>>. Сообщение легко получить функцией \spverb|format|. В нем слышна
машинная природа, зато способ быстрый и дешевый.

Имя поля получим как последний отличный от цифры элемент \spverb|:in|. Цифры
означают индекс вектора, поэтому их отбрасывают. Значение, которое привело к
ошибке, получим из поля \spverb|:val|.

\begin{english}
  \begin{clojure}
(defn get-common-message [problem]
  (let [{:keys [in val]} problem
        field (last (remove int? in))]
    (format "The field '%s' has got an incorrect value '%s'."
            (name field) val)))
  \end{clojure}
\end{english}

Поле и значение обернем в кавычки, чтобы выделить из общего текста. Проверим,
что вернет функция:

\begin{english}
  \begin{clojure}
(get-common-message {:in [::user :user/email] :val "test"})
The field 'email' has got an incorrect value 'test'.
  \end{clojure}
\end{english}

\subsection{Открытые вопросы}

За рамками остались несколько вопросов. Они слишком общие, чтобы претендовать на
одно решение. В этом разделе мы не будем писать код, а только порассуждаем.

Что делать, если требуется локализация, то есть текст на русском или английском
в зависимости от настроек? Переделаем словарь ошибок. В нем станет два уровня:
на первом код локали (\spverb|ru|, \spverb|en|), а на втором переводы спек.

По локали мы получим словарь переводов, затем переводим сообщение как делали
выше. С кодом локали можно схитрить, чтобы облегчить поиск. Для отдельных фраз
выделяют более точные локали, например, американский и британский английский
с~кодами \spverb|en_US| и \spverb|en_GB|. Напишем поиск так, что сперва он ищет
по младшей локали (\spverb|en_US|), а затем по старшей (\spverb|en|). Если
британского текста не оказалось, получим общий английский. Так устроен перевод
сообщений в широком смысле, не только ошибок.

Вопрос откуда читать локаль остается на ваше усмотрение. Можно хранить ее в
сессии, параметрах запроса, базе данных, словом~--- как это удобно в проекте.

Второй вопрос~--- как связать ошибки с интерфейсом. Принято отделять модель от
ее представления, что касается и форм. Удобно, когда форма это структура данных,
вложенный словарь. Операции над ней это чистые функции, которые легко
поддерживать.

Представим форму в виде дерева. Ключи это поля, а значения виджеты. Виджет
содержит тип поля, текущее значение и ошибку. На каждый из них подписан
React-компонент. При изменении виджета он рисует HTML-элемент, например поле
ввода с текущим текстом. Если ошибка не \spverb|nil|, над полем ввода появится
красный текст.

Валидаця принимает форму и строит дерево значений. У него такая же топология, но
на месте виджетов значения полей ввода. С помощью спеки мы проверяем значения и
выводим типы из строк. В случае ошибки получим отчет \spverb|explain|. Для
каждого элемента из поле \spverb|problems| находим путь, спеку и сообщение об
ошибке. Это сообщение добавляем виджету в поле \spverb|:error|. Компонент,
который подписан на виджет, заново отрисует его с ошибкой над полем.

Мы упомянули формы, React и проблемы интерфейса. Все вместе это называется
\emph{фронтенд}. Мы не будем на нем останавливаться, потому что фронтенд~---
сложная тема, достойная отдельной книги.

\section{Парсинг}

Мы научились проверять данные и выводить типы. Перейдем к более сложной
операции~--- парсингу. Под термином понимают разбор данных на части, поиск
структуры там, где прежде ее не было.

Возможно, вам приходилось писать регулярные выражения. Это шаблоны, которые
описывают структуру текста. Специальные функции принимают строку и регулярное
выражение. Они возвращают фрагменты текста, которые совпали с шаблоном.

Пример регулярного выражения это IP-адрес. Он состоит из четырех групп с
точками. Каждая группа это число от 0 до 255.

\begin{english}
  \begin{text}
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
  \end{text}
\end{english}

В шаблоне мы ставим косую черту перед точкой. Это служебный символ, поэтому его
экранируют.

В регулярных выражениях применяют операторы \spverb|+|, \spverb|?|, \spverb|*| и
другие. Они указывают, сколько раз встречается шаблон перед ними: один и более
раз, ни одного или один, произвольное число. В зависимости от оператора шаблон
захватывает разные части текста.

Представьте, что регулярные выражения откусывают текст частями. Та часть, что
легла на шаблон, уходит в результат. Остаток переходит к следующему шаблону, и
так далее.

Регулярные выражения подводят нас к \spverb|regex|-спекам. Это особые спеки для
разбора данных по шаблону. Разница в том, что входные данные это коллекции, а не
текст.

\subsection{Простой разбор}

Предположим, нужно разобрать массив пользователей. Каждый из них это кортеж
\tuple{номер, почта, статус}. Все значения строки. Для каждого пользователя
требуется:

\begin{itemize}

\item
  убедиться, что в кортеже именно три элемента;

\item
  привести номер к числу;

\item
  проверить почту на минимальные критерии;

\item
  привести статус к перечислению (константе).

\item
  получить словарь с верными значениями.

\end{itemize}

Мы уже знакомы с \spverb|s/conformer|. Можно написать функцию, которая примет
кортеж и выполнит действия выше. Это несложно, но функция будет монолитом со
слишком большим \emph{скоупом}. Рассмотрим другой способ.

Спека \spverb|s/cat| служит для разбора коллекций. Она принимает набор тегов и
других спек. На вход подают коллекцию, и \spverb|s/cat| накладывает ее элементы
на спеки. Если они совпали, результатом будет словарь. Ключи словаря теги,
значения~--- вызов дочерней спеки с элементом.

Составим спеку для разбора кортежа. Прогодится код, который мы писали для чисел
и почты. Опишем статус и соберем композицию спек:

\begin{english}
  \begin{clojure}
(s/def :user/status
  (s/and ->lower
         (with-conformer [val]
           (case val
             "active"  :USER_ACTIVE
             "pending" :USER_PENDING))))

(s/def ::user
  (s/cat :id ::->int
         :email ::email
         :status :user/status))
  \end{clojure}
\end{english}

\noindent
Положительный случай:

\begin{english}
  \begin{clojure}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1
 :email "test@test.com"
 :status :USER_ACTIVE}
  \end{clojure}
\end{english}

Варианты с плохим номером, почтой или статусом не пройдут разбор. Примеры ниже
вернут \spverb|::s/invalid|:

\begin{english}
  \begin{clojure}
(s/conform ::user ["" "test@test.com" "active"])
(s/conform ::user ["1" "@test.com" "active"])
(s/conform ::user ["1" "test@test.com" "unknown"])
  \end{clojure}
\end{english}

\subsection{Условный разбор}

Представим, что работаем с устаревшим форматом данных. В нем условие: если перед
номером стоит метка <<blocked>>, пользователь заблокирован. Например:

\begin{english}
  \begin{text}
blocked;1;test@test.com;active
  \end{text}
\end{english}

Это усложняет задачу, ведь теперь кортеж состоит из трех \emph{или} четырех
элементов. Сдвигается семантика полей: первый элемент не только номер, но и флаг
блокировки. Бывают и более сложные условия, особенно в старых данных.

В императивных языках они порождают каскад \spverb|if/else|. В Clojure
проблему решают декларативно. Объявим спеку блокировки:

\begin{english}
  \begin{clojure}
(s/def ::blocked
  (s/and
   ->lower
   (s/conformer (partial = "blocked"))))
  \end{clojure}
\end{english}

Добавим ее в итоговую \spverb|s/cat|, но укажем, что она встречается ни разу или
только один раз. Для этого \spverb|::blocked| оборачивают спеку в \spverb|s/?|.
В регулярных выражениях знак вопроса делает то же самое.

\begin{english}
  \begin{clojure}
(s/def ::user
  (s/cat :blocked (s/? ::blocked)
         :id ::->int
         :email ::email
         :status :user/status))
  \end{clojure}
\end{english}

Теперь оба кортежа совпадают со спекой \spverb|::user|. Если пользователь
заблокирован, в словаре будет поле \spverb|:blocked|:

\begin{english}
  \begin{clojure}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1 :email "test@test.com" :status :USER_ACTIVE}

(s/conform ::user ["BLOCKED" "1" "test@test.com" "active"])
{:blocked true :id 1 :email "test@test.com" :status ...}
  \end{clojure}
\end{english}

Представим, что на входе коллекция кортежей. Чтобы не утруждать себя итерацией,
объявим спеку-коллекцию:

\begin{english}
  \begin{clojure}
(s/def ::users (s/coll-of ::user))

(def user-data
  [["1" "test@test.com" "active"]
   ["Blocked" "2" "joe@doe.com" "pending"]])

(s/conform ::users user-data)
[{:id 1 :email "test@test.com" :status :USER_ACTIVE}
 {:blocked true :id 2 :email "joe@doe.com" :status ...}]
  \end{clojure}
\end{english}

Отсеять заблокированных пользователей можно функцией \spverb|filter| с
предикатом \spverb|(complement :blocked)|.

\subsection{Практика}

С помощью Spec парсят не только данные, но и текст. Рассмотрим, как прочитать
INI-файл в словарь данных. INI\footurl{https://en.wikipedia.org/wiki/INI\_file}
это старый формат для конфигурации. Он состоит из заголовков и пар полей и
значений. Пример условного \spverb|config.ini|:

\begin{english}
  \begin{ini}
[database]
host=localhost
port=5432
user=test

[server]
host=127.0.0.1
port=8080
  \end{ini}
\end{english}

Наша цель~--- получить словарь, где на первом уровне заголовки, а под ними поля
и значения.

\begin{english}
  \begin{clojure}
{:database {:host "localhost"
            :port 5432}
 :server {:host "127.0.0.1"}}
  \end{clojure}
\end{english}

Если отбросить пустые строки и комментарии, формат сводится к~грамматике
\spverb|([title], (key=value)*)*|, где звездочка означает сколько угодно раз, в
том числе ничего.

Для начала прочитаем строки из файла. Спеки не должны иметь побочных эффектов,
поэтому чтение выносят в отдельную функцию. Форма \spverb|doall| нужна, чтобы
прочитать строки до выхода из \spverb|with-open|.

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(defn get-ini-lines [path]
  (with-open [src (io/reader path)]
    (doall (line-seq src))))
  \end{clojure}
\end{english}

Переходим к парсеру. Это спека, которая принимает список строк. Алгоритм
следующий:

\begin{itemize}

\item
  удалить пустые строки и комментарии;

\item
  сгруппировать оставшиеся строки по заголовкам;

\item
  разбить поля и значения по знаку равенства;

\item
  построить вложенный словарь;

\item
  вывести типы и проверить результат.

\end{itemize}

Будем писать по принципу <<сверху вниз>>, словно все компоненты готовы. Ниже~---
спека, которая решает задачу:

\begin{english}
  \begin{clojure}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)
   (s/conformer remap-ini-data)
   ::ini-config))
  \end{clojure}
\end{english}

Напишем недостающие элементы. Функция \spverb|clear-ini-lines| убирает пустые
строки и комментарии. В INI они начинаются с символа решетки.

\begin{english}
  \begin{clojure}
(require '[clojure.string :as str])

(defn comment? [line]
  (str/starts-with? line "#"))

(defn clear-ini-lines [lines]
  (remove (some-fn comment? str/blank?) lines))
  \end{clojure}
\end{english}

Спека \spverb|(s/* :ini/section)| читается как <<ноль и более секций>>. Под
секцией понимают заголовок и прилегающие поля и значения. Запишем ее в виде
\spverb|s/cat|:

\begin{english}
  \begin{clojure}
(s/def :ini/section
  (s/cat :title :ini/title :fields (s/* :ini/field)))
  \end{clojure}
\end{english}

Объявим спеку \spverb|:ini/title|. Она проверяет, что строка это
заголовок. Согласно формату, заголовок пишут в квадратных скобках. Если первый и
последний символы строки это скобки, отбросим их:

\begin{english}
  \begin{clojure}
(s/def :ini/title
  (s/and
   #(str/starts-with? % "[")
   #(str/ends-with? % "]")
   (with-conformer [line]
     (subs line 1 (dec (count line))))))
  \end{clojure}
\end{english}

\noindent
Вариант с регулярным выражением:

\begin{english}
  \begin{clojure}
(s/def :ini/title
  (with-conformer [line]
    (or (second (re-matches #"^\[(.+)\]$" line))
        ::s/invalid)))
  \end{clojure}
\end{english}

Спека \spverb|:ini/field| парсит поле и значение. Строку разбивают по знаку
равенства. Цифра 2 означает, что в результате должно быть не более двух
элементов: ключ и значение. Это важно, потому что в значении может быть знак
равенства, например если это base64-строка. Если не получили пару, сигналим об
ошибке.

\begin{english}
  \begin{clojure}
(s/def :ini/field
  (with-conformer [line]
    (let [pair (str/split line #"=" 2)]
      (if (= (count pair) 2)
        pair
        ::s/invalid))))
  \end{clojure}
\end{english}

Не терпится проверить нашу работу. Обернем черновую спеку в функцию
\spverb|parse-ini|, которая читает файл.

\begin{english}
  \begin{clojure}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)))

(defn parse-ini [path]
  (let [lines (get-ini-lines path)]
    (s/conform ::->ini-config lines)))
  \end{clojure}
\end{english}

\noindent
Пробный результат:

\begin{english}
  \begin{clojure}
(parse-ini "config.ini")

[{:title "database"
  :fields [["host" "localhost"]
           ["port" "5432"]
           ["user" "test"]]}
 {:title "server"
  :fields [["host" "127.0.0.1"]
           ["port" "8080"]]}]
  \end{clojure}
\end{english}

Разбор прошел удачно, хотя структура отличается от той, что мы планировали. Это
неважно: мы вывели данные из текста, а привести словарь к нужному виду
легко. Напишем функцию \spverb|remap-ini-data|:

\begin{english}
  \begin{clojure}
(defn remap-ini-data [data-old]
  (reduce
   (fn [data-new entry]
     (let [{:keys [title fields]} entry]
       (assoc data-new title (into {} fields))))
   {}
   data-old))
  \end{clojure}
\end{english}

\noindent
Если передать в нее вектор из последнего шага, получим то словарь:

\begin{english}
  \begin{clojure}
{"database" {"host" "localhost" "port" "5432" "user" "test"}
 "server" {"host" "127.0.0.1" "port" "8080"}}
  \end{clojure}
\end{english}

Напишем спеку для вывода типов и проверки. Номера портов приводим к числам, хост
и пользователь не пустые строки.

\begin{english}
  \begin{clojure}
(s/def :db/host ::ne-string)
(s/def :db/port ::->int)
(s/def :db/user ::ne-string)

(s/def ::database
  (s/keys :req-un [:db/host :db/port :db/user]))

(s/def :server/host ::ne-string)
(s/def :server/port ::->int)

(s/def ::server
  (s/keys :req-un [:server/host :server/port]))

(s/def ::ini-config
  (s/keys :req-un [::database ::server]))
  \end{clojure}
\end{english}

Последний штрих~--- исправить тип ключей в словаре. Сейчас это строки, но спека
\spverb|::ini-config| ожидает кейворды. Модуль \spverb|walk| предлагает функцию
\spverb|keywordize-keys| на этот случай. Она обходит словарь любой вложенности и
меняет ключи. Итоговая спека:

\begin{english}
  \begin{clojure}
(require '[clojure.walk :as walk])

(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)
   (s/conformer remap-ini-data)
   (s/conformer walk/keywordize-keys)
   ::ini-config))
  \end{clojure}
\end{english}

\noindent
Результат:

\begin{english}
  \begin{clojure}
(parse-ini "config.ini")

{:database {:host "localhost"
            :port 5432
            :user "test"}
 :server {:host "127.0.0.1"
          :port 8080}}
  \end{clojure}
\end{english}

Получились аккуратные данные из текста. Обратите внимание, что в коде нет
состояния, и в целом он выглядит как цепочка шагов. Каждый шаг легко исправить
или добавить новый между ними.

Устраните мелкие недостатки в коде. Пусть пара \spverb|"foo="| становится
\spverb|{:foo nil}|, а не \spverb|{:foo ""}|.  Удалите пустые символы из имен
полей и значений. Опробуйте код на больших ini-файлах.

\section{Разбор кода (теория)}

В завершение темы поговорим о том, как парсить код. Мы уже видели, что Spec
подходит для разбора коллекций. Код на Clojure состоит из списков. Это приводит
к неожиданному решению: код можно проверить спекой и вернуть ошибку до того, как
он запущен.

Проверку удобно делать в макросах. Это особые функции, которые работают на этапе
компиляции. Макрос принимает код в виде списка символов. В коде могут быть
ошибки, но макрос об этом ничего не знает: для него это просто символы.

Задача макроса в том, чтобы перестроить список в другой, понятный
Clojure. Компилятор заменит вызов макроса на то, что он вернул, и запустит
код. Макросы это отдельная веха в изучении Clojure. Пока что рассмотрим, как
проверить макрос спекой.

Каждый макрос это мини-язык с соглашением о том, что подавать на вход. В простых
случаях код парсят функциями \spverb|first|, \spverb|rest| и условиями. Сложные
макросы разбирают грамматиками, как мы делали это с INI-файлом. Если код
нарушает правила, мы должны объяснить, в чем ошибка.

Иногда один и тот же макрос допускает разную запись. Хорошим примером служит
\spverb|defn|, определение функции. Кроме обязательных параметров он принимает
дополнительные: строку документации, пре- и пост-проверки. У функции может быть
несколько тел:

%% --------------

\noindent
\begin{tabular}{ @{}p{2.5cm} @{}p{4.5cm} @{}p{3cm} }

\begin{english}
  \begin{clojure}
(defn my-inc
  [x]
  (+ x 1))
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(defn my-inc
  "Increase the number."
  [x]
  {:pre [(int? x)]
   :post [(int? %)]}
  (+ x 1))
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(defn my-inc
  ([x]
   (my-inc x 1))
  ([x delta]
   (+ x delta)))
  \end{clojure}
\end{english}

\end{tabular}

Это одна и та же функция, записанная по-разному. Очевидно, разобрать все
варианты вручную тяжело. До версии Clojure 1.10 каждый макрос парсил код как
придется. Это было неорганизованно. С выходом Spec основные макросы перешли на
спеку. Появился общий подход, которым легко управлять.

Разберем устно, как бы мы построили спеку для разбора \spverb|defn|. Это список,
поэтому на верхнем уровне поместим \spverb|s/cat|. Первый его элемент~--- символ
\spverb|defn|. Второй~--- символ с именем функции. После имени следует строка
документации (ее может и не быть). Далее~--- тело или список тел. Пока мы не
ушли удалеко, набросаем черновик:

\begin{english}
  \begin{clojure}
(s/def ::defn
  (s/cat :tag (partial = 'defn)
         :name symbol?
         :doc (s/? string?)
         :body :defn/body*))
  \end{clojure}
\end{english}

Что скрыто за спекой \spverb|:defn/body*| пока неизвестно. Считаем, что тело
начинается с вектора параметров. После него идет опциональный словарь пре- и
пост- проверок. Затем произвольные формы, из которых состоит тело функции.

\begin{english}
  \begin{clojure}
(s/def :defn/body
  (s/cat :args vector?
         :prepost (s/? map?)
         :code (s/* any?)))
  \end{clojure}
\end{english}

Проблема в том, что \spverb|defn| принимает либо одно тело, либо несколько
обернутых в списки. Сравните первый и третий столбики в примере с
\spverb|my-inc|. Обернем спеку \spverb|:defn/body| так, чтобы она учитывала оба
случая. Обозначим эту спеку звездочкой:

\begin{english}
  \begin{clojure}
(s/def :defn/body*
  (s/alt :single :defn/body
         :multi (s/+ (s/spec :defn/body))))
  \end{clojure}
\end{english}

Теперь <<заморозим>> форму \spverb|defn| с помощью апострофа; получится список
символов. Отправим его в \spverb|s/conform|:

\begin{english}
  \begin{clojure}
(s/conform
 ::defn
 '(defn my-inc
    "Increase a number"
    [x]
    {:pre [(int? x)]
     :post [(int? %)]}
    (+ x 1)))
  \end{clojure}
\end{english}

\noindent
Результат:

\begin{english}
  \begin{clojure}
{:tag defn
 :name my-inc
 :doc "Increase a number"
 :body
 [:single
  {:args [x]
   :prepost {:pre [(int? x)] :post [(int? %)]}
   :code [(+ x 1)]}]}
  \end{clojure}
\end{english}

Заметим, как ведет себя поле \spverb|:body|. Это вектор из метки и
результата. Для одного тела получим метку \spverb|:single| и словарь. Для
нескольких тел метка будет \spverb|:multi|, а значение~--- вектор словарей:

\begin{english}
  \begin{clojure}
[:multi [{:args [x] :code [(println 1)]}
         {:args [x y] :code [(println 2)]}]]
  \end{clojure}
\end{english}

Чтобы проверить метку (одно тело или несколько), пригодится оператор
\spverb|case|. Ниже в переменой \spverb|result| записан результат
парсинга. Функция \spverb|process-body| обрабатывает словарь тела:

\begin{english}
  \begin{clojure}
(let [{:keys [body]} result
      [tag body] body]
  (case tag
    :single
    (process-body body)
    :multi
    (doseq [body body]
      (process-body body))))
  \end{clojure}
\end{english}

\subsection{Самостоятельная работа}

Каждый уровень спеки расширяется вглубь. Доработаем аргументы функции: разделим
их на обязательные и необязательные. Например, чтобы параметры \spverb|[x y & other]|
предстали в виде словаря:

\begin{english}
  \begin{clojure}
{:req [x y] :opt other}
  \end{clojure}
\end{english}

\noindent
По аналогии разберите словари пре- и пост- проверок.

Передайте в спеку данные с ошибками. Что делать в таком случае? Как составить
\emph{понятное} сообщение о том, где именно ошибка и что вы ожидали? Подойдет ли
словарь переводов? Получится ли у вас сделать ошибки лучше, чем в промышленных
языках?

Данные, которые вернула спека-парсер, называются
\emph{абстрактным синтаксическим деревом}\footurl{https://en.wikipedia.org/wiki/Abstract\_syntax\_tree}
(анг. abstract syntax tree, AST). Это вложенная структура, которую получают из
текста. AST~--- важный этап компиляции программы. Только построив дерево, можно
выполнить логику, которая стоит за ним.

Spec работает в том числе как парсер грамматик. Можно разобрать любые данные и
построить дерево. Вы в шаге от того, чтобы написать простой интерпретатор~---
программу, которая читает код и выполняет его. Узлы дерева это функции, а
потомки~--- их аргументы. Напишите функцию, которая обходит дерево и вычисляет
его в верном порядке. Даже если это курсовая работа, свой язык или компилятор
улучшит ваши навыки.

\section{Спецификация функций}

Поговорим о том, как Spec связана с функциями. Мы уже упоминали проблему с
входными данными. Даже если параметры верного типа, это не говорит об их
семантике. Вспомним функцию, которая принимает диапазон дат. Случай, когда ее
вызвали с параметрами \spverb|start=2019.01.01| и \spverb|end=2009.01.01| не
имеет смысла.

Опишем параметры функции спекой. Это \spverb|s/cat|, которая <<откусывает>> от
аргументов две даты и помещает в словарь с ключами \spverb|:start| и
\spverb|:end|.

\begin{english}
  \begin{clojure}
(s/def ::date-range-args
  (s/and
   (s/cat :start inst? :end inst?)
   (fn [{:keys [start end]}]
     (<= (compare start end) 0))))
  \end{clojure}
\end{english}

Вторая функция в \spverb|s/and| принимает этот словарь и сравнивает даты. Для
сравнения дат используют специальную функцию \spverb|compare|, которая возвращает
-1, 0 и 1 для случаев меньше, равно и больше. Быстрая проверка:

\begin{english}
  \begin{clojure}
(s/valid? ::date-range-args [#inst "2019" #inst "2020"]) ;; true
(s/valid? ::date-range-args [#inst "2020" #inst "2019"]) ;; false
  \end{clojure}
\end{english}

Витает мысль написать декоратор, который принимает функцию и спеку. Перед тем,
как запустить функцию, он проверит аргументы и в случае ошибки бросит
исключение. То же самое проделаем с результатом функции.

Писать декоратор не придется, потому что его включили в Spec. Это функция
\spverb|instrument| из модуля \spverb|clojure.spec.test.alpha|
(анг. instrument~--- оснастить, оборудовать). Обратите внимание на пространство:
в него закралась частичка <<test>>. Оснащение функций вынесли в отдельный
модуль.

\spverb|Instrument| принимает символ функции, которую <<заряжают>>. Таким же
символом задают особую спеку для функции. \spverb|Instrument| подменяет исходную
функцию на такую же, но с проверками. Это своего рода <<monkey patch>>, когда
один модуль изменяет другой.

Функциональную спеку объявляют макросом \spverb|s/fdef|. Ему передают символ
функции, которую оснащают. Макрос принимает дочерние спеки для входящих
параметров, результата и их композиции.

Напишем функцию и спеку к ней. Пусть функция считает разницу между датами в
секундах. Допускаем случай, когда первая дата больше второй. В этом случае
разница отрицательная.

\begin{english}
  \begin{clojure}
(import 'java.util.Date)

(defn date-range-sec
  "Return the difference between two dates in seconds."
  [^Date date1 ^Date date2]
  (quot (- (.getTime date2)
           (.getTime date1))
        1000))
  \end{clojure}
\end{english}

Теги \spverb|^Date| нужны, чтобы компилятор знал тип объектов \spverb|date1| и
\spverb|date2|. Иначе тип вычисляется во время исполнения, что отнимает
ресурсы. Посчитаем разницу в сутках:

\begin{english}
  \begin{clojure}
(date-range-sec #inst "2019-01-01" #inst "2019-01-02")
86400
  \end{clojure}
\end{english}

\noindent
Если поменять даты местами, результат будет отрицательным.

Опишем функциональную спеку. Ее символ \spverb|date-range-sec|. Под ключом
\spverb|:args| указывают спеку входящих параметров. Это список, поэтому
пригодится \spverb|s/cat|. Он разбивает список на словарь, чтобы спеки ниже
работали с ключами.

В \spverb|:ret| указана спека выходного значения. Чаще всего это проверка на
число или строку. Например, \spverb|int?|, \spverb|string?| или их
\emph{nilable}-версии, которые допускают \spverb|nil|: \spverb|(s/nilable int)|
и так далее.

Так выглядит спека \spverb|date-range-sec|. Она проверяет входные параметры и
результат:

\begin{english}
  \begin{clojure}
(s/fdef date-range-sec
  :args (s/cat :start inst? :end inst?)
  :ret int?)
  \end{clojure}
\end{english}

В ключи \spverb|:args| и \spverb|:ret| можно передать уже объявленные спеки. Это
полезно для их повторного использования. У вас может быть несколько спек для
диапазона дат.

При создании функциональная спека не меняет функцию. Она только объявляет
проверки, но не запускает их. Чтобы подменить функцию на ее оснащенную версию,
вызывают \spverb|instrument|:

\begin{english}
  \begin{clojure}
(require '[clojure.spec.test.alpha :refer [instrument]])
(instrument `date-range-sec)
  \end{clojure}
\end{english}

Символ функции должен быть полным, то есть с пространством. Чтобы подставить в
символ текущее пространство, перед ним ставят обратную кавычку \spverb|`|.

Теперь \spverb|date-range-sec| проверит аргументы и результат. Что случится,
если передать в <<заряженную>> функцию не тот аргумент, например \spverb|nil|?
Получим исключение \spverb|ExceptionInfo|:

\begin{english}
  \begin{clojure}
(date-range-sec nil #inst "2019")
  \end{clojure}
\end{english}

Его сообщение и тело нам знакомы. В поле \spverb|message| идет текст из функции
\spverb|s/explain-str|:

\begin{english}
  \begin{clojure}
Execution error - invalid arguments to date-range-sec
nil - failed: inst? at: [:start]
  \end{clojure}
\end{english}

В поле \spverb|data| отчет из функции \spverb|s/explain-data|. Чтобы получить
данные исключения, его передают в функцию \spverb|(ex-data e)|.

\subsection{Документация}

Функциональная спека улучшает документацию. Функция \spverb|doc| из модуля
\spverb|clojure.repl| выводит справку о запрошенной функции. С появлением Spec
ее поведение изменилось. Кроме документации она выводит спеку функции, если она
задана. Вот как выглядит справка lkz \spverb|date-range-sec| после того, как
объявили спеку:

\begin{english}
  \begin{clojure}
(clojure.repl/doc date-range-sec)
-------------------------
([date1 date2])
  Return the difference between two dates in seconds.
Spec
  args: (cat :start inst? :end inst?)
  ret: int?
  \end{clojure}
\end{english}

На функцию \spverb|doc| полагаются IDE и редакторы, чтобы подсказывать аргументы
в коде. Утилиты для документации, например
Autodoc\footurl{https://github.com/tomfaulhaber/autodoc} или
Codox\footurl{https://github.com/weavejester/codox}, добавляют спеки в
HTML-файлы.

\subsection{Производительность}

\spverb|Instrument| помогает в тестировании. На время тестов функции
<<заряжают>>, чтобы выявить ошибки. Это делают с помощью модуля, который
выполняет серию \spverb|(instrument ...)| при загрузке. Проект устроен так, что
модуль загружается только во время тестов. Если функция получила не те
аргументы, это станет заметно.

\spverb|Instrument| не подходит для боевого режима, потому что замедляет
код. Напишем бенчмарк, который вызовет исходную функцию десять тысяч раз:

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
"Elapsed time: 1.783962 msecs"
  \end{clojure}
\end{english}

Сделаем то же самое после оснащения:

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
"Elapsed time: 116.984496 msecs"
  \end{clojure}
\end{english}

Разница в сто раз! Проверка в рантайме \emph{существенно} замедляет приложение.
Вот почему \spverb|instrument| не претендует на запуск в бою: замедление кода в
сто раз~--- слишком дорогая цена. Однако в тестах нас не волнует скорость. На
время прогона код покрывают как можно б\'{о}льшим числом проверок, чтобы поймать
все ошибки.

\section{Повторное использование спек}

В Clojure принято снабжать библиотеки спеками, чтобы помочь другим. Если
библиотека активно работает с какой-то структурой данных, опишите ее
спекой. Хорошим примером служит JDBC\footurl{https://github.com/clojure/java.jdbc},
обертка для реляционных баз данных.

Подключение к базе задают словарем с ключами \spverb|:host|, \spverb|:port|,
\spverb|:user| и другими. Обычно словарь читают из конфигурации. Перед
подключением его нужно проверить, чтобы не получить \spverb|NPE| и другие
странности. Модуль \spverb|clojure.java.jdbc.spec| несет на борту спеки
подключения и основных функций. Импортируйте модуль, чтобы спеки попали в
глобальный реестр.

Предположим, конфигурация описана в edn-файле. Ключ \spverb|:db| задает
подключение к базе.

\begin{english}
  \begin{clojure}
{:db {:dbtype "mysql"
      :host "127.0.0.1"
      :port 3306
      :dbname "project"
      :user "user"
      :password "********"
      :useSSL true}}
  \end{clojure}
\end{english}

Ключи \spverb|:dbtype|, \spverb|:host| и другие уже описаны в библиотеке.
Используем их повторно:

\begin{english}
  \begin{clojure}
(require '[clojure.java.jdbc.spec :as jdbc])
(s/def ::db ::jdbc/db-spec)
(s/def ::config (s/keys :req-un [::db]))
  \end{clojure}
\end{english}

Прочитаем конфигурацию из файла и проверим спекой:

\begin{english}
  \begin{clojure}
(def config (read-string (slurp "config.edn")))
(s/valid? ::config config)
  \end{clojure}
\end{english}

\label{jdbc-conform-warning}

Будьте внимательны с \spverb|::jdbc/db-spec|. Это сложная спека с макросами
\spverb|s/or|, которые порождают развилки. Если передать ее в
\spverb|s/conform|, получим результат с тегами:

\begin{english}
  \begin{clojure}
(s/conform ::config config)
{:db
 [:friendly
  {:dbtype   [:name "mysql"]
   :host     "127.0.0.1"
   :port     [:port 3306]
   :dbname   "project"
   :user     "user"
   :password "********"
   :useSSL   true}]}
  \end{clojure}
\end{english}

Такой вектор не работает с \spverb|jdbc/query| и другими функциями JDBC. Мы
ограничились \spverb|s/valid?|, чтобы оставить структуру прежней.

Иногда спеки выносят в отдельную библиотеку. Так поступили разработчики
Alia\footurl{https://github.com/mpenet/alia}~--- клиента для БД
Cassandra. Проект \spverb|qbits.alia| несет основные функции для работы с
базой. Спеки идут в пакете \spverb|cc.qbits/alia-spec|, который подключают
отдельно.

\section{Дополнения}

Spec входит в поставку Clojure и меняется не так часто, как хотелось бы
разработчикам. Дополнения к Spec выпускают в виде отдельных библиотек. Среди
прочих заслуживают внимания два проекта: Expound и Spec.tools. В этом разделе мы
опишем возможности каждого.

Библиотека Expound\footurl{https://github.com/bhb/expound} улучшает сообщения об
ошибках, делает их понятней для человека. Сигнатура функции \spverb|expound|
аналогична \spverb|s/explain|: она тоже принимает спеку и данные. Сообщение об
ошибке выглядит так:

\begin{english}
  \begin{clojure}
(expound/expound string? 1)
-- Spec failed --------------------
  1
should satisfy
  string?
-------------------------
Detected 1 error
  \end{clojure}
\end{english}

Отчет выглядит машинным, и мы не можем показать его пользователю. Вс\"{е} же он
лучше, чем сырой \spverb|s/explain|. Этот текст прочтут коллеги DevOps, которые
не знают Clojure. \spverb|Expound| подойдет для проверки конфигурации на старте
приложения. Конфигурацию обновляют часто, поэтому внятный отчет об ошибке
полезен.

Разработчики Metosin собрали улучшения к Spec в проекте
Spec.tools\footurl{https://github.com/metosin/spec-tools}. В сердце этой
библиотеки лежит объект \spverb|Spec|. Он оборачивает стандартную спеку и
дополняет ее различными методами. С помощью Spec.tools формируют JSON-схему или
описывают REST API по стандарту Swagger. Библиотека играет роль посредника между
REST-фреймворком и спекой.

Обе библиотеки просты в техническом плане. Читателю не составит труда
разобраться с ними, когда возникнет потребность.

\section{Будущее спеки}

На сегодняшний день пакет Spec вс\"{е} еще не избавился от частички <<alpha>> в
названии. Авторы экспериментируют со спекой, ищут лучшие способы валидации. Это
смущает некоторых разработчиков. Опасаясь, что по окончании эксперимента от Spec
избавятся, они берут альтернативы:
Schema\footurl{https://github.com/plumatic/schema},
Bouncer\footurl{https://github.com/leonardoborges/bouncer} и другие.

Отдельные группы пишут обертки над спекой, чтобы расширить ее
возможности. Например, подружить ее с JSON-схемой и популярными инструментами
вроде Swagger. Это путь Spec.tools, который мы только что рассмотрели.

В докладе <<Maybe Not>>\footurl{https://youtube.com/watch?v=YR5WdGrpoug} Рич
Хикки анонсировал вторую версию спеки. В ней упростят работу со словарями (спека
\spverb|select|) и множественными типами (когда значение строка или
число). Разработка идет в открытом режиме, но еще рано говорить о
результатах. Обсуждение новой спеки выходит за рамки главы.

\section{Итог}

Spec это библиотека Clojure, которая идет в поставке с языком. Spec предлагает
набор функций и макросов. Ими описывают правила, которым подчиняются
данные. Правила это предикаты, т.е. функции, которые возвращают истину или ложь.

Предикаты гибче и мощнее типов. Если о значении известно, что оно верного типа,
это не гарантирует корректность. Значение \spverb|-1| не может быть
Unix-портом. Классы-обертки вроде \spverb|UnixPort| это не типы, а валидация в
рантайме. Она привязана к вызову класса с помощью синтаксиса.

В отличие от классов, предикаты компонуются друг с другом. Легко написать
предикат с логикой <<каждый из>>, <<любой из>> и другие.

Библиотека выводит новые данные из старых. Функция \spverb|s/conform|
оборачивает другую функцию для вывода значения. Этим пользуются для парсинга
чисел и дат.

Spec предлагает regex-спеки, похожие на регулярные выражения. От обычных спек
они отличаются тем, что захватывают часть коллекции. На regex-спеках пишут
парсеры данных, в том числе для нужд самой Clojure. Основные макросы проверяют
тело с помощью Spec.

Библиотека полезна в тестах. Функция \spverb|instrument| изменяет другую функцию
так, что ее аргументы проверяются спекой. Это замедляет вызов, но делает тесты
надежней. Функциональная спека становится частью документации.

Spec не предлагает решения для понятных сообщений об ошибках. Как их строить и
выводить клиенту зависит от проекта. Один из подходов основан на словаре, где
ключи~--- спеки, а значения~--- текст ошибки или тег перевода.

Мы рассмотрели основные возможности библиотеки. В обсуждение не попали
комбинаторы вроде \spverb|s/alt|, генераторы, мульти-спеки и другие интересные
вещи. Все это читатель найдет в официальной документации. Мы не прощаемся со
спекой: в следующих главах мы вернемся к ней.
