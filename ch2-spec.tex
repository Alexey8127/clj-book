\chapter{Clojure.spec}

\label{chapter-spec}

\index{spec}

\begin{teaser}
В этой главе мы рассмотрим clojure.spec~--- библиотеку для проверки данных в
Clojure. Это особенная библиотека: на ней пишут валидаторы и парсеры, с е\"{е}
помощью генерируют данные для тестов. Spec фундаментальна по своей природе,
поэтому уделим ей пристальное внимание.
\end{teaser}

Название <<spec>> происходит от specification (анг. спецификация, описание). Это
набор функций и макросов, чтобы схематично описать данные. Например, из каких
ключей состоит словарь и типы значений. Запись называют спецификацией данных или
сокращенно <<спекой>>. Далее мы будем использовать короткий термин.

Специальные функции проверяют, подходят ли данные к спеке. Если нет, получим
отч\"{е}т в каком месте произошла ошибка и почему.

\index{модули!clojure.spec.alpha}

Spec входит в поставку Clojure начиная с версии 1.9. Полностью модуль называется
\spverb|clojure.spec.alpha|. Не волнуйтесь о частичке <<alpha>> на конце
имени: она осталась по историческим причинам.

\index{валидация}
\index{парсинг}

Spec стала важной вехой в развитии Clojure. Ключевое свойство Spec в том, что
она фундаментальна. Валидация данных это малая часть е\"{е} возможностей. Spec
не только проверяет данные, но и преобразует их. На Spec легко писать парсеры.

Формально Spec это обычная библиотека. Но е\"{е} абстракции настолько мощны, что
Clojure переиспользует их. С версии 1.10 компилятор Clojure анализирует главные
макросы с помощью Spec. Так проекты дополняют друг друга.

Прежде чем браться за техническую часть, разбер\"{е}мся с теорией. Вспомним, как
связаны между собой классы, типы и валидация.

\section{Типы и классы}

\label{type-and-pred}

\index{типизация!статическая}
\index{типизация!динамическая}

Считается, что код на языке со статической типизацией безопаснее, чем с
динамической. Компилятор не позволит сложить число и~строку ещ\"{е} до того, как
мы запустим программу. Однако тип переменной это лишь одно из многих
ограничений. Редко случается так, что тип зада\"{е}т все допустимые
значения. Чаще всего вместе с типом учитывают границы, длину, попадание в
интервалы и перечисления. Иногда значения верны по отдельности, но не могут
стоять в паре друг с другом.

\index{порт}

Рассмотрим, как выразить в коде сетевой порт. В операционной системе это число
от 0 до $2^{16}-1$. Целые типы обычно описаны степенями двойки, поэтому
найд\"{е}тся условный \spverb|unsigned int|, который охватит именно этот
диапазон. У нулевого порта особая семантика, и в прикладных программах его не
используют. Вероятность, что в языке предусмотрен тип от~1 до~$2^{16}-1$ крайне
мала.

Легче всего увидеть проблему на диапазоне дат. Единичная дата может быть сколь
угодно разумной, но диапазон накладывает ограничение: начало строго меньше
конца. Бизнес дополняет: разница не больше недели, обе даты в рамках текущего
месяца.

\index{валидация}

В ООП знают об этой проблеме и решают е\"{е} классами \spverb|UnixPort| и
\spverb|DateRange|. Условный \spverb|UnixPort| это класс с конструктором. Он
принимает целое число и выполняет проверку на диапазон. Если число выходит за
рамки 1\dots$2^{16}-1$, конструктор бросит исключение. Программист уверен, что
создал новый тип. Это неверно~--- классы и типы не тождественны.

Конструктор это обычный валидатор. Он неявно сработает, когда мы напишем
\spverb|new UnixPort(8080)|. Из-за неявности возникает иллюзия, что мы создали
тип. На деле это валидация и синтаксический сахар.

\index{синтаксический сахар}

В промышленных языках нельзя описать класс так, чтобы выражение
\spverb|new UnixPort(-42)| привело к ошибке компиляции. Найти е\"{е} могут
только сторонние утилиты и плагины для IDE.

Конструктор нельзя использовать повторно. Представим классы \spverb|UnixPort| и
\spverb|NetPort|. Первый класс проверяет порт на~диапазон и~бросает
исключение. Выгодно пользоваться этим классом, поскольку он совмещен
с~валидацией. Однако сторонняя библиотека принимает \spverb|NetPort|. Возникает
проблема конвертации: нужно извлечь <<сырой>> порт из \spverb|UnixPort|
и~передать в~\spverb|NetPort|. Это лишний код и путаница с классами.

\index{классы}

Признаки удобной валидации это независимость и компоновка. Независимость
означает, что данные не привязаны к валидации. Нет ничего зазорного в том, что
порт это целое число. Пусть библиотека принимает \spverb|integer|, а разработчик
сам решит, как его проверить. Появится выбор, насколько строгой должна быть
проверка.

\index{функции!композиция}

Компоновка означает, что полезно иметь несколько простых проверок, чтобы
составить из них сложные. Пусть заданы проверки <<это>> и <<то>>, и теперь нужны
комбинации <<это \emph{и} то>>, <<это \emph{или} то>>. В идеале компоновка
занимает пару строк и считается тривиальной задачей.

\index{функции}

Оба тезиса ложатся на функцию. На не\"{е} действует одна операция~--- вызов, что
упрощает схему. Функция принимает значение и возвращает истину или ложь. Это
ответ на вопрос, было ли значение правильными или нет. Функция~--- объект
высшего порядка, поэтому другие функции порождают из них комбинации.

\section{Основы spec}

С багажом рассуждений мы подходим к Spec. Подключим модуль в~текущее
пространство:

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
  \end{clojure}
\end{english}

Синоним \spverb|s| нужен, чтобы избежать конфликтов имен с
\spverb|clojure.core|. Модуль Spec несет макросы \spverb|s/and|, \spverb|s/or| и
другие, у которых ничего общего с обычными \spverb|and| и \spverb|or|. Считается
дурным тоном, если имена одного модуля затеняют другие, поэтому обращаемся к
Spec через синоним.

\index{spec!def}

Главная операция в Spec~--- создать новую \emph{спеку}:

\begin{english}
  \begin{clojure}
(s/def ::string string?)
  \end{clojure}
\end{english}

\index{clojure.core!string?}

Макрос \spverb|s/def| принимает ключ и предикат. Он создал объект спеки из
функции \spverb|string?| и поместил в глобальный реестр с~ключом
\spverb|::string|.

Важно понимать, что \spverb|::string|~--- это не спека, а псевдоним. Макросы
Spec работают не с объектами спеки, а ключам. Они сами найдут спеку в
реестре. Это удобно, потому что ключи глобальны. В любом месте можно сослаться
на \spverb|::string| без лишних импортов.

\index{spec!get-spec}

Вторым аргументом ид\"{е}т предикат \spverb|string?|. Предикат это функция,
которая возвращает истину или ложь. Функция это не спека, а строительный
материал для не\"{е}. Спека оборачивает функцию в особый объект. Технически на
него можно сослаться: функция \spverb|s/get-spec| по~ключу спеки верн\"{е}т
е\"{е} объект. На практике он не нужен, потому что везде указывают ключи.

\begin{english}
  \begin{clojure}
(s/get-spec ::string)
;; #object[clojure.spec.alpha$reify 0x3e9dde1d]
  \end{clojure}
\end{english}

\index{spec!регистр}

Спеки хранятся в глобальном реестре под своими ключами. Макрос \spverb|s/def| не
проверяет, была ли уже такая спека перед тем, как поместить е\"{е} в
реестр. Если была, мы потеряем старую версию.

\index{конфликты!ключей}

Spec не работает с ключами без пространства, например \spverb|:name| или
\spverb|:email|. Это повышает риск конфликта ключей. Чтобы назначить ключу
текущее пространство, поставьте два двоеточия: \spverb|::name|, \spverb|::email|.

\index{пространства им\"{е}н!текущее}

Самое простое, что можно сделать со спекой~--- проверить, подходит ли ей
значение. Функция \spverb|s/valid?| принимает ключ спеки, значение и~возвращает
\spverb|true| или \spverb|false|.

\begin{english}
  \begin{clojure}
(s/valid? ::string 1)      ;; false
(s/valid? ::string "test") ;; true
  \end{clojure}
\end{english}

Пустая строка пройдет валидацию, но чаще всего в этом нет смысла. Пустые имя или
заголовок означают ошибку. Объявим спеку, которая дополнительно проверит, что
строка не пустая. Наивный способ это сделать~--- усложнить предикат:

\index{spec!::ne-string}

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (fn [val]
    (and (string? val)
         (not (empty? val)))))
  \end{clojure}
\end{english}

\noindent
Быстрая проверка:

\begin{english}
  \begin{clojure}
(s/valid? ::ne-string "test") ;; true
(s/valid? ::ne-string "")     ;; false
  \end{clojure}
\end{english}

Ключ \spverb|::ne-string| это сокращение от <<\textbf{n}on-\textbf{e}mpty
string>>. Спека встречается часто, поэтому логично сэкономить на е\"{е} имени.

Более изящный способ задать эту спеку~--- объединить предикаты через
\spverb|every-pred|. Функция принимает предикаты и возвращает супер-предикат. Он
верн\"{е}т истину только если истинны все предикаты.

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (every-pred string? not-empty))
  \end{clojure}
\end{english}

\index{spec!and}
\index{clojure.spec!every-pred}
\index{предикаты}

%% ---------------

Мы собираем новую сущность из базовых, что короче и следует функциональному
стилю. Но ещ\"{е} лучше комбинировать не предикаты, а спеки. Макрос \spverb|s/and|
объединяет несколько предикатов и спек в новую спеку:

\begin{english}
  \begin{clojure}
(s/def ::ne-string
  (s/and ::string not-empty))
  \end{clojure}
\end{english}

Так в Clojure строят сложные спеки: объявляют примитивы и наращивают их
комбинации.

\section{Исключения}

\index{исключения}

Во время проверки Spec не перехватывает исключения; о них заботится
программист. Рассмотрим спеку для проверки URL. Проще всего это сделать
регулярным выражением:

\index{clojure.core!re-matches}
\index{регулярные выражения}

\begin{english}
  \begin{clojure}
(s/def ::url
  (partial re-matches #"(?i)^http(s?)://.*"))

(s/valid? ::url "test")            ;; false
(s/valid? ::url "http://test.com") ;; true
  \end{clojure}
\end{english}

\noindent
Что-то отличное от строки вызовет ошибку:

\index{исключения}
\index{классы!NullPointerException}

\begin{english}
  \begin{clojure}
(s/valid? ::url nil)
;; Execution error (NullPointerException)
;; at java.util.regex.Matcher...
  \end{clojure}
\end{english}

\index{NPE}

Примечание: класс \spverb|NullPointerException| частый гость в мире Java. Для
краткости его называют \spverb|NPE|.

Причина в том, что \spverb|nil| попал в функцию \spverb|re-matches|. Функция
трактует аргумент как строку, что приводит к \spverb|NPE|. Пишите спеки так,
чтобы они не бросали исключения. В примере с \spverb|::url| сначала убедимся,
что это строка, и только потом проверим на регулярное выражение.

\begin{english}
  \begin{clojure}
(s/def ::url
  (s/and ::ne-string
         (partial re-matches #"(?i)^http(s?)://.*")))

(s/valid? ::url nil) ;; false
  \end{clojure}
\end{english}

\index{spec!::ne-string}

Макрос \spverb|s/and| устроен так, что на первой неудаче цепь
оборв\"{е}тся. Все, что после \spverb|::ne-string| не сработает, и исключения не
будет.

По аналогии проверим возраст пользователя. Это предикаты на~число и~диапазон.

\index{clojure.core!int?}

\begin{english}
  \begin{clojure}
(s/def ::age
  (s/and int? #(<= 0 % 150)))

(s/valid? ::age nil) ;; false
(s/valid? ::age -1)  ;; false
(s/valid? ::age 42)  ;; true
  \end{clojure}
\end{english}

\section{Спеки-коллекции}

\index{коллекции}
\index{скаляры}

Выше мы проверяли примитивные типы или \emph{скаляры}. Это удобно для примеров,
но редко встречается на практике. В~основном проверяют не скаляры,
а~коллекции. Spec предлагает макросы, чтобы задать спеки-коллекции из
примитивов.

\index{spec!coll-of}

Макрос \spverb|s/coll-of| принимает предикат или ключ и возвращает
спеку-коллекцию. Она проверяет, что каждый элемент проходит валидацию. Вот так
мы определим список URL:

\begin{english}
  \begin{clojure}
(s/def ::url-list (s/coll-of ::url))
  \end{clojure}
\end{english}

\noindent
Быстрая проверка:

\begin{english}
  \begin{clojure}
(s/valid? ::url-list ["http://test.com" "http://ya.ru"])
;; true

(s/valid? ::url-list ["http://test.com" "dunno.com"])
;; false
  \end{clojure}
\end{english}

\index{spec!map-of}
\index{HTTP!параметры}

Макрос \spverb|s/map-of| описывает словарь. Вспомним поле \spverb|:params| из
главы про веб-разработку \page{ring-params}. Его ключи кейворды, а значения
строки. На языке спеки это выглядит так:

\begin{english}
  \begin{clojure}
(s/def ::params
  (s/map-of keyword? string?))

(s/valid? ::params {:foo "test"})  ;; true
(s/valid? ::params {"foo" "test"}) ;; false
  \end{clojure}
\end{english}

Проверка \spverb|s/map-of| довольно слабая, чтобы покрыть все варианты. Факт
того, что значения строки не несет полезной информации. Важнее убедиться, что в
словаре именно те ключи, что мы ожидаем. К тому же редко бывает так, что тип
значений одинаковый. Наоборот словарь несет разные сведения о сущности: имя,
возраст, дату.

\index{spec!keys}

В таких случаях используют макрос \spverb|s/keys|, в котором перечислены
спеки. Имена спек совпадают с ключами словаря. Значения ключей проверяются
одноим\"{е}нными спеками.

Представим веб-страницу с адресом и описанием. Объявим примитивы:

\begin{english}
  \begin{clojure}
(s/def :page/address ::url)
(s/def :page/description ::ne-string)
  \end{clojure}
\end{english}

\index{пространства им\"{е}н}

Обратите внимание на пространство ключей. Адрес и описание относятся к странице,
поэтому им задают свое пространство. У статьи или книги тоже могут быть адрес и
описание. Пространство обещает, что спеки \spverb|:page/address| и
\spverb|:book/address| не заменят друг друга.

Составим спеку страницы:

\begin{english}
  \begin{clojure}
(s/def ::page
  (s/keys :req-un [:page/address
                   :page/description]))
  \end{clojure}
\end{english}

\index{spec!:req-un}

В параметре \spverb|:req-un| указан вектор спек. Для каждой из них спека ищет в
словаре ключ с таким же именем и проверяет значение. Рассмотрим, что означает
\spverb|:req-un| и какие ещ\"{е} параметры принимает \spverb|s/keys|.

Имя \spverb|:req-un| состоит из частей <<req>> и <<un>>. Это признаки наличия
ключа и его типа. Req (анг. required) означает, что ключи обязательно должны
быть в словаре. Если хотя бы одного ключа нет, получим ошибку. Противоположный
по смыслу параметр называется <<opt>> (анг. optional). В нем указаны ключи,
которых может не быть. Их валидация происходит, только если они были в словаре.

\index{spec!:un}

Частичка <<un>> означает unqualified, неполный ключ. При проверке un-ключей
спека не учитывает их пространство. Например, если указать
\spverb|:page/address| в списке \spverb|:req-un|, то в словаре ищется ключ
\spverb|:address|, а не \spverb|:page/address|.

Неполные ключи встречаются часто. Мы получаем данные из чужих API и баз данных,
которые не знают о пространствах имен. В Clojure пространства нужны, чтобы
разделить одноим\"{е}нные поля у разных сущностей, например \spverb|:user/name| и
\spverb|:project/name|. Исключения бывают, когда весь стек фирмы построен на
Clojure. В этом случае клиент и сервер шлют данные с полными ключами.

Различают следующие комбинации \spverb|req|, \spverb|opt| и \spverb|un|:

\begin{itemize}

\item
  \spverb|:req|~--- необходимые полные ключи,

\item
  \spverb|:req-un|~--- необходимые краткие ключи,

\index{spec!:opt}

\item
  \spverb|:opt|~--- опциональные полные ключи,

\index{spec!:opt-un}

\item
  \spverb|:opt-un|~--- опциональные краткие ключи.

\end{itemize}

У спеки \spverb|::page| ключи обязательны и не учитывают пространство. Ниже
примеры данных с ошибками. Это может быть неправильный адрес, пустое описание,
пропавший ключ. Если каждый из словарей подставить в выражение
\spverb|(s/valid? ::page ...)|, результат будет ложью.

\begin{english}
  \begin{clojure}
{:address "clojure.org" ;; not a URL
 :description "Clojure Language"}

{:address "https://clojure.org/"
 :description ""} ;; empty string

{:address "https://clojure.org/"} ;; missing key

{:page/address "https://clojure.org/" ;; full keys
 :page/description "Clojure Language"}
  \end{clojure}
\end{english}

Обратите внимание на последний случай. Значения верны, но у ключей пространство
\spverb|:page|. Валидация не сработает, потому что спека ищет \spverb|:address|,
а не \spverb|:page/address|. Чтобы исправить последний пример, замените тип
ключей \spverb|:req-un| на \spverb|:req| (необходимые полные).

\index{spec!valid?}

\begin{english}
  \begin{clojure}
(s/def ::page-fq
  (s/keys :req [:page/address
                :page/description]))

(s/valid? ::page-fq
          {:page/address "https://clojure.org/"
           :page/description "Clojure Language"})
;; true
  \end{clojure}
\end{english}

Усложним пример: добавим странице статус, который мы получили при
последнем обращении к ней. Поле опционально, потому что если к странице ещ\"{е} не
обращались, в него нечего записать. Новая спека:

\begin{english}
  \begin{clojure}
(s/def :page/status int?)

(s/def ::page-status
  (s/keys :req-un [:page/address
                   :page/description]
          :opt-un [:page/status]))
  \end{clojure}
\end{english}

\noindent
Словари с правильным статусом и без него пройдут валидацию:

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"})

(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status 200})
  \end{clojure}
\end{english}

\index{nil}

Заметим, что \spverb|s/keys| различает \spverb|nil| и наличие ключа. Если статус
\spverb|nil|, он есть в словаре. Сработает проверка \spverb|nil| на
\spverb|int?|, что приведет к ошибке. Это редкий случай, когда пустое значение
не равно его отсутствию.

\begin{english}
  \begin{clojure}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status nil})
;; false
  \end{clojure}
\end{english}

\section{Вывод значений}

\label{spec-conform}

\index{вывод значений}

До сих пор мы проверяли данные с помощью \spverb|s/valid?|. Функция верн\"{е}т
истину или ложь, что значит данные верны или нет. Но одной проверки
недостаточно: иногда значения корректны, но требуется привести их к нужному
типу.

На вход поступило число в виде строки. Мы убедились, что строка состоит из цифр
и не превышает допустимой длины. После валидации значение по-прежнему строка, и
прид\"{е}тся парсить его вручную. Хотелось бы, чтобы типы выводил за нас какой-то
механизм.

\index{spec!conform}

Spec предлагает такие возможности. Это функции \spverb|s/conformer| и
\spverb|s/conform| (анг. conform~--- подчиняться).

\label{spec-invalid}

\index{spec!conformer}

\index{spec!::invalid}

Сначала пишут функцию вывода. Она принимает исходное значение и возвращает либо
новое, либо ключ \spverb|::s/invalid|, что означает ошибку. Затем функцию
оборачивают в \spverb|s/conformer|, чтобы получить спеку. \spverb|S/conform|
принимает спеку-конформер и данные. Если вывод прошел без ошибок, получим новое
значение, иначе ключ \spverb|::s/invalid|.

Рассмотрим вывод числа из строки. Чтобы отличить конформер от валидатора, к
имени добавляют стрелку, что означает приведение типа.

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/conformer
   (fn [value]
     (try
       (Integer/parseInt value)
       (catch Exception e
         ::s/invalid)))))
  \end{clojure}
\end{english}

\noindent
Эту спеку передают в \spverb|s/conform| с данными:

\begin{english}
  \begin{clojure}
(s/conform ::->int "42") ;; 42

(s/conform ::->int "dunno")
:clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

\index{исключения}

\spverb|S/conform| не ловит исключения при работе, а вывод типов богат на
них. Будет правильно перехватить исключение и вернуть \spverb|::s/invalid|, как
в примере выше.

Обе спеки~--- валидатор и конформер~--- можно объединить через \spverb|s/and|,
чтобы проверить тип перед выводом. В нашем случае убедимся, что значение
строка. Так мы не допустим, чтобы в \spverb|parseInt| попал \spverb|nil| или
что-то другое:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and ::ne-string ::->int))

(s/conform ::->int nil)
:clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

Рассмотрим, как восстановить из строки дату. Это старая проблема веба: JSON не
поддерживает даты, поэтому их передают строкой ISO или числом секунд. Возникает
вопрос, как привести их к объекту на сервере.

\index{модули!clojure.instant}
\index{функции!read-instant-date}

Понадобится парсер строки и небольшая обвязка, чтобы подружить его со
спекой. Функция \spverb|read-instant-date| из модуля \spverb|clojure.instant|
читает дату из строки. Она лояльна к формату и учитывает разные
комбинации. Например, датой может быть только год.

\index{даты}

\begin{english}
  \begin{clojure}
(require '[clojure.instant :refer [read-instant-date]])
(read-instant-date "2019")
#inst "2019-01-01T00:00:00.000-00:00"
  \end{clojure}
\end{english}

\noindent
Обернем функцию в спеку:

\begin{english}
  \begin{clojure}
(s/def ::->date
  (s/and
   ::ne-string
   (s/conformer
    (fn [value]
      (try
        (read-instant-date value)
        (catch Exception e
          ::s/invalid))))))
  \end{clojure}
\end{english}

Перед разбором мы делаем минимальные проверки. Убеждаемся, что это непустая
строка, чтобы отсечь \spverb|nil| и прочий мусор. Разбор даты:

\begin{english}
  \begin{clojure}
(s/conform ::->date "2019-12-31")
#inst "2019-12-31T00:00:00.000-00:00"
  \end{clojure}
\end{english}

\noindent
Дата и время:

\begin{english}
  \begin{clojure}
(s/conform ::->date "2019-12-31T23:59:59")
#inst "2019-12-31T23:59:59.000-00:00"
  \end{clojure}
\end{english}

\section{Спеки-перечисления}

\index{spec!перечисления}

Иногда известно заранее, какие значения принимает поле. При вызове API клиент
передает архитектуру системы~--- 32 или 64 бита. Ради двух значений нет смысла
парсить число: подойдет \spverb|case| или словарь.

Вариант с макросом \spverb|case|. Если ничего не найдено, сигналим об ошибке
ключом \spverb|::s/invalid|. Заметим, что \spverb|case| это не линейный перебор:
он строит индексы веток и не пробегает их все, а переходит на нужную.

\index{clojure.core!case}

\begin{english}
  \begin{clojure}
(s/def ::->bits
  (s/conformer
   (fn [value]
     (case value
       "32" 32
       "64" 64
       ::s/invalid))))

(s/conform ::->bits "32") ;; 32
(s/conform ::->bits "42") :clojure.spec.alpha/invalid
  \end{clojure}
\end{english}

\index{конфигурация}

Вариант со словарем для перевода значения. Удобно, что словарь живет в отдельной
переменной. Его легко дополнить или вынести в конфигурацию, при этом логика
валидации не изменится.

\begin{english}
  \begin{clojure}
(def bits-map {"32" 32 "64" 64})

(s/def ::->bits
  (s/conformer
   (fn [value]
     (get bits-map value ::s/invalid))))
  \end{clojure}
\end{english}

Похожим образом читают логические значения из строк. Нет единого соглашения о
том, как передать истину и ложь в тексте. Это может быть \spverb|True|,
\spverb|TRUE|, \spverb|1|, \spverb|yes| для истины и противоположности:
\spverb|FALSE|, \spverb|no|. При разборе значений их приводят к одному
регистру. В Clojure \spverb|FALSE| и \spverb|false| это разные строки, даже если
отправитель имел в виду одно и то же. Сценарий выглядит так:

\begin{itemize}

\item
  убедиться, что значение это строка;

\item
  привести е\"{е} к нижнему регистру;

\item
  найти значение по словарю или перебором.

\end{itemize}

\noindent
Код вывода:

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ::ne-string
   (s/conformer clojure.string/lower-case)
   (s/conformer
    (fn [value]
      (case value
        ("true" "1" "on" "yes") true
        ("false" "0" "off" "no") false
        ::s/invalid)))))

  \end{clojure}
\end{english}

\noindent
В действии:

\begin{english}
  \begin{clojure}
(s/conform ::->bool "True") ;; true
(s/conform ::->bool "yes")  ;; true
(s/conform ::->bool "0")    ;; false
  \end{clojure}
\end{english}

\section{Продвинутые техники}

\index{паттерны}

Мы написали достаточно кода, чтобы увидеть одинаковые участки~--- паттерны. В
этом разделе мы вынесем их в функции и~макросы, которые ускорят вашу работу.

\subsection{Множества}

\index{множества}

Когда значения известны, на роль спеки подходит множество. Оно ведет себя как
функция: если аргумент найден в множестве, получим его же. Если нет, результат
будет \spverb|nil|. Представим, что статус задачи может быть строкой
\spverb|todo|, \spverb|in_progress| и \spverb|done|. Опишем спеку множеством
этих значений:

\begin{english}
  \begin{clojure}
(s/def ::status #{"todo" "in_progres" "done"})
(s/valid? ::status "todo") ;; true
  \end{clojure}
\end{english}

\subsection{Перечисления}

\index{clojure.core!contains?}

Множество не подходит в случаях, когда \spverb|false| и \spverb|nil| считают
верными значениями. \spverb|S/valid?| трактует их как неудачу. Если \spverb|nil|
или \spverb|false| допустимы, их проверяют функцией \spverb|contains?|:

\begin{english}
  \begin{clojure}
(contains? #{1 :a nil} nil) ;; true
  \end{clojure}
\end{english}

Чтобы не повторяться, напишем функцию \spverb|enum|. Она принимает значения и
возвращает предикат. В свою очередь предикат принимает аргумент и проверяет,
есть ли такой среди исходных значений.

\begin{english}
  \begin{clojure}
(defn enum [& args]
  (let [arg-set (set args)]
    (fn [value]
      (contains? arg-set value))))
  \end{clojure}
\end{english}

Функция внутри замкнута на переменной \spverb|arg-set|. Это множество, которое
получили из списка аргументов. Мы создали его один раз, чтобы не делать это
постоянно при вызове предиката. Новые перечисления выглядят коротко и ясно:

\begin{english}
  \begin{clojure}
(s/def ::status
  (enum "todo" "in_progres" "done"))
  \end{clojure}
\end{english}

\subsection{With-conformer}

\index{макросы!with-conformer}
\index{try/catch}
\index{исключения}

Конформеры требуют особого внимания. В них легко допустить ошибку: не
перехватить исключение или не обернуть функцию в \spverb|s/conformer|. Вынесем
рутину в макрос \spverb|with-conformer|. Он принимает символ переменной и
произвольное тело. Макрос порождает функцию одного аргумента, которая выполнит
тело в блоке \spverb|try/catch|. Если исключения не было, получим последнее
выражение тела. В противном случае верн\"{е}тся \spverb|::s/invalid|.

\begin{english}
  \begin{clojure}
(defmacro with-conformer
  [[bind] & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))))
  \end{clojure}
\end{english}

\noindent
Вывод числа:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (with-conformer [val]
     (Integer/parseInt val))))
  \end{clojure}
\end{english}

\noindent
и булева типа:

\begin{english}
  \begin{clojure}
(s/def ::->bool
  (s/and
   ->lower
   (with-conformer [val]
     (case val
       ("true"  "1" "on"  "yes") true
       ("false" "0" "off" "no" ) false))))
  \end{clojure}
\end{english}

\index{функции!\arr{}lower}

\noindent
Переменная \spverb|->lower| это об\"{е}ртка для приведения регистра:

\begin{english}
  \begin{clojure}
(def ->lower
  (s/and
    string?
    (s/conformer clojure.string/lower-case)))
  \end{clojure}
\end{english}

В \spverb|case| необязательно указывать \spverb|::s/invalid| на конце
макроса. Если \spverb|case| не нашел ветку и не задан вариант по умолчанию,
он~бросит исключение. \spverb|With-conformer| перехватит его и верн\"{е}т
\spverb|invalid|.

\section{Логические пути}

\index{spec!логические пути}

Функция \spverb|s/conform| не всегда возвращает то, что мы ожидаем. Некоторые
спеки оборачивают результат в вектор, где первый элемент~--- логический путь. Он
появляется там, где проверка ветвится.

\spverb|S/and| обходит дочерние по порядку и проверяет данные. Иногда линейного
обхода недостаточно: нужна развилка. Например, если значение число, то оставить
его есть, а если строка, то привести к числу. Такие спеки называют условными
(анг. conditional).

Макрос \spverb|s/or| принимает теги и дочерние спеки. Он применяет их к значению
до первого совпадения. Результат будет парой, где первый элемент тег, а
второй~--- значение из спеки, которая подошла.

Тег становится частью пути, по которому шла проверка. Логический путь помогает
расследовать, в каком месте произошла ошибка. Для простых спек это не проблема,
но на практике условная спека вложена в другую условную, та тоже и так
далее. Найти ошибку без логического пути будет трудно.

\index{spec!explain}

Если валидация не прошла, логический путь получают из отладочной информации. Е\"{е}
возвращают функции семейства \spverb|s/explain*|, которые мы рассмотрим ниже.

Напишем спеку сетевого порта, которая принимает число или строку. Во втором
случае спека выводит число. Это полезно, если значение приходит из переменной
среды или ini-файла.

\begin{english}
  \begin{clojure}
(s/def ::smart-port
  (s/or :string ::->int :num int?))
  \end{clojure}
\end{english}

\noindent
Теперь \spverb|s/conform| верн\"{е}т не просто значение, а пару с тегом:

\begin{english}
  \begin{clojure}
(s/conform ::smart-port 8080)
[:num 8080]

(s/conform ::smart-port "8080")
[:string 8080]
  \end{clojure}
\end{english}

\index{скаляры}
\index{spec!развилки}

Если в спеке была развилка (\spverb|s/or|, \spverb|s/alt|), то структура
\spverb|s/conform| отличается от входных данных: на месте скаляра появится
вектор. Покажем это на вложенных данных. Пусть порт~--- одно из полей
подключения к базе:

\begin{english}
  \begin{clojure}
(s/def :conn/port ::smart-port)
(s/def ::conn
  (s/keys :req-un [:conn/port]))
  \end{clojure}
\end{english}

Топология результата будет другой, и это нужно учесть. Если передать поле
\spverb|:port| в подключение, получим ошибку типов.

\begin{english}
  \begin{clojure}
(s/conform ::conn {:port "9090"})
{:port [:string 9090]}
  \end{clojure}
\end{english}

\section{Обратное действие}

\index{spec!unform}

У функции \spverb|unform| противоположный смысл: по спеке и результату она
верн\"{е}т исходное значение. Выше мы получили словарь, где поле \spverb|:port| это
вектор. Чтобы вернуться к исходным данным, выполните:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:num 9090]})
{:port 9090}
  \end{clojure}
\end{english}

\noindent
Если передать пару со строкой, получим ошибку:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:string 9090]})
;; Execution error (IllegalStateException)
;; no unform fn for conformer
  \end{clojure}
\end{english}

Дело в том, что тегу \spverb|:num| мы задали предикат. Он ничего не выводит,
поэтому для предиката \spverb|unform| отбросит тег и верн\"{е}т значение. Тег
\spverb|:string| указывает на спеку типа \spverb|conformer|, которая
\emph{меняет} значение. Чтобы выполнить \spverb|unform|, нужно сказать ей, как
это делать.

\index{spec!conformer}

Первый аргумент \spverb|s/conformer| это функция, которая выводит тип. К ней
обращается \spverb|s/conform|, когда его вызывают. Второй необязательный
аргумент это функция с обратным эффектом: по результату \spverb|conform| вернуть
прежнее значение. Функция сработает в момент \spverb|s/unform|.

Изменим \spverb|::->int|, чтобы он поддерживал \spverb|unform|:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (s/conformer
    (fn [string]
      (Integer/parseInt string))
    (fn [integer]
      (str integer)))))
  \end{clojure}
\end{english}

\noindent
Теперь порт со строкой не вызовет ошибки:

\begin{english}
  \begin{clojure}
(s/unform ::conn {:port [:string 9090]})
{:port "9090"}
  \end{clojure}
\end{english}

\spverb|Unform| полезен, если вы утратили исходные данные, но сохранили их
\spverb|conform|-вариант.

Читатель заметит, что наша цель была вывести порт из строки, однако из-за
\spverb|conform| и \spverb|unform| вс\"{е} пошло не так. \spverb|Conform| вывел тип,
но добавил в результат теги, из-за чего изменилась структура. \spverb|Unform|
убрал теги, но вернул строку на место числа. В ч\"{е}м этом смысл?

Если коротко, \spverb|conform| и теги незаменимы для парсинга данных и их
обхода. Далее мы покажем, как с помощью \spverb|conform| получить синтаксическое
дерево, без которого не обходится ни один компилятор. Что касается
\spverb|unform|, его поведение можно исправить хитростью.

В спеке \spverb|::->int| в \spverb|unform|-части мы переводим число в обратно
строку. Если вернуть число без изменений, оно встанет на место \spverb|:port| в
итоговом словаре:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/and
   ::ne-string
   (s/conformer
    (fn [string]
      (Integer/parseInt string))
    (fn [integer]
      integer))))

(s/unform ::conn {:port [:string 9090]})
{:port 9090}
  \end{clojure}
\end{english}

\index{clojure.core!identity}

Для большей краткости вторым аргументом передают \spverb|identity|~--- функцию,
которая верн\"{е}т переданный ей аргумент. С таким подходом \spverb|unform| всегда
верн\"{е}т то, что получили на этапе \spverb|conform|. Полный цикл \spverb|conform|
и \spverb|unform|:

\begin{english}
  \begin{clojure}
(->> {:port "9090"}
     (s/conform ::conn)
     (s/unform ::conn))
{:port 9090}
  \end{clojure}
\end{english}

Чтобы не забыть \spverb|unfrom| в спеке, сделайте его частью макроса
\spverb|with-conformer|:

\begin{english}
  \begin{clojure}
(defmacro with-conformer
  [[bind] & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))
    identity))
  \end{clojure}
\end{english}

\section{Анализ ошибок}

\index{ошибки!spec}

\label{spec-explain}

Когда данные неверны, \spverb|s/valid?| и \spverb|s/conform| возвращают
\spverb|false| и \spverb|::s/invalid|. Этого недостаточно, чтобы понять причину
ошибки. Представьте, что у вас спека пользователя. В ней несколько адресов, в
каждом адресе несколько строк,... и проверка вернула \spverb|false|. Ручной
поиск ошибки займет час.

Функции семейства \spverb|s/explain| принимают спеку и данные. Если проверка не
удалась, получим отч\"{е}т. Это словарь, где указаны проблемные значения, спеки,
пути к ним и другие данные. Разница между функциями в том, как они поступают с
отч\"{е}том.

\begin{itemize}

\index{spec!explain}
\index{spec!explain-str}
\index{spec!explain-data}
\index{spec!отч\"{е}т}
\index{отч\"{е}т!spec}

\item
  \spverb|s/explain| печатает его в стандартный поток (на экран);

\item
  \spverb|s/explain-str| возвращает отч\"{е}т в виде строки;

\item
  \spverb|s/explain-data| возвращает словарь. Это самый полный отч\"{е}т об ошибке.

\end{itemize}

Попробуем функции в действии. Их результат одинаковый, разница в том, куда он
приходит~--- в консоль или переменную. Подготовим простую спеку:

\begin{english}
  \begin{clojure}
(s/def :sample/username ::ne-string)

(s/def ::sample
  (s/keys :req-un [:sample/username]))
  \end{clojure}
\end{english}

\noindent
На корректных данных функции не проявляют себя:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username "some user"})
Success!
nil

(s/explain-data ::sample {:username "some user"})
nil
  \end{clojure}
\end{english}

\noindent
Попробуем число вместо имени:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username 42})
;; 42 - failed: string? in: [:username]
;; at: [:username] spec: ::string
  \end{clojure}
\end{english}

Вывод читается так: значение \spverb|42| не прошло проверку предикатом
\spverb|string?|. Путь к значению внутри словаря \spverb|[:username]|. Ключ
спеки, где случилась ошибка -- \spverb|::string|.

Отч\"{е}т показывает наиболее вложенные спеки и предикаты. Вспомним, что
\spverb|::ne-string| это комбинация \spverb|::string| и
\spverb|not-empty|. Ошибка случилась на этапе \spverb|::string|, о чем и было
сказано.

Для пустой строки вывод будет другим. На этот раз причиной станет
\spverb|not-empty|. Проверим это:

\begin{english}
  \begin{clojure}
(s/explain ::sample {:username ""})
;; "" - failed: not-empty in: [:username]
;; at: [:username] spec: ::ne-string
  \end{clojure}
\end{english}

\spverb|Explain| это быстрый способ сообщить о проблеме в конфигурации или
JSON-файле. Со временем вы научитесь читать его. Но чем сложнее данные, тем
меньше понятен \spverb|explain|. Когда в коллекции больше трех уровней, отч\"{е}т
заливает экран. Трудно даже разбить его на части, не говоря уж о
понимании. Чтобы подружиться с \spverb|explain|, нужно промежуточное звено, речь
о котором в следующем разделе.

\section{Понятные ошибки}

\index{сообщения}
\index{spec!ошибки}

\label{spec-messages}

Когда проверяют данные, важен не только факт ошибки. Ещ\"{е} важнее объяснить
клиенту, где именно он ошибся. Под клиентом не обязательно имеют в виду
человека. Даже если это другая программа, в ответ добавляют понятный текст. Он
попад\"{е}т в логи, которые читают сотрудники.

Часто мы видим сообщения вроде <<Ошибка: DATAERROR>> без каких-либо деталей. Или
красную надписью <<проверьте данные>> над формой в два экрана. Этих глупостей
можно было избежать, умей программисты переводить язык машины на человеческий.

\index{интерфейс}
\index{пользователь}

Фраза \spverb|"" - failed: not-empty in: [:username]| не только ничего не скажет
пользователю, но и отпугнет его машинной природой. Кажется, что в интерфейсе
брешь, и пользователь видит то, что не должен. Это резко снижает доверие к
системе.

Чтобы составить сообщение, вернемся к функции \spverb|s/explain-data|.  Она
возвращает словарь с нужной информацией. Пример такого отч\"{е}та:

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username ""})

#:clojure.spec.alpha
{:problems
 ({:path [:username]
   :pred clojure.core/not-empty
   :val ""
   :via [::sample ::ne-string]
   :in [:username]})
 :spec ::sample
 :value {:username ""}}
  \end{clojure}
\end{english}

\index{языки!Python}
\index{языки!JavaScript}

На первый взгляд непонятно, что с ним делать. Некоторые инженеры сдаются и
говорят, что Spec не подходит для ошибок. Это не так: в отч\"{е}те все необходимые
данные, нужно только правильно их обработать.

Новички задают вопрос~--- почему бы не сделать понятные сообщения на уровне
библиотеки? Например, назначить спеке поле с текстом <<введите правильный
адрес>>? Почему не взять пример с библиотек для Python или JavaScript?

\index{фундаментальность}

Ответ на этот вопрос не устраивает новичков. Вспомним тезис из начала главы:
Spec это \emph{фундаментальная библиотека}. То, что мы проверяем ей
HTML-форму~--- всего лишь частный случай. У спеки разные области применения,
поэтому структура ошибки тоже фундаментальна.

Трудно создать систему ошибок, которая устроит всех. В каждом проекте свои
правила о том, как показывать ошибки. Иногда это фиксированное сообщение, а в
других случаях шаблон. Где-то учитывают язык пользователя. Все вместе это
сложные сценарии.

Если бы разработчики Spec занялись ошибками, их фокус был бы смещен с главной
цели. Вместо Spec мы бы получили валидаторы по типу тех, что пишут десятками для
Python и JavaScript. Они скучны, не гибки и без концепции.

Словарь \spverb|explain-data| содержит ключи \spverb|:spec|, \spverb|:value| и
\spverb|:problems| с пространством \spverb|clojure.spec.alpha|. Первые два это
спека и значение, которые приняли участие в проверке. Нас интересует
\spverb|:problems|. Это список словарей, где каждый описывает ошибку
валидации. Перечислим их поля и семантику.

\index{spec!развилки}

\begin{itemize}

\item
  \spverb|:path|~--- логический путь валидации. Вектор ключей, где спеки
  чередуются с тегами-развилками. Условные спеки вроде \spverb|s/or| пишут сюда
  свои метки.

\item
  \spverb|:pred|~--- символ полный предиката, например
  \spverb|clojure.core/string?|.

\item
  \spverb|:val|~--- значение, для которого предикат вернул ложь. Например, 42,
  \spverb|nil|, элемент словаря.

\item
  \spverb|:via|~--- вектор спек, по которым прошло значение от верхнего уровня к
  нижнему.

\item
  \spverb|:in|~--- физический путь к значению. Вектор ключей и индексов, который
  передают в функцию \spverb|get-in|. Если выполнить \spverb|(get-in <данные> <:in>)|,
  получим значение, которое вызвало ошибку.

\end{itemize}

В отч\"{е}те вс\"{е}, что нам нужно. Из \spverb|:val| возьмем проблемное
значение. Спека, на которой остановилась валидация это последний элемент вектора
\spverb|:via|.

Составим словарь, где ключ~--- спека, а значение~--- понятный текст или
шаблон. Зная спеку, которая вызвала ошибку, получим из словаря текст. В нашем
случае последний элемент \spverb|:via| это \spverb|::ne-string|. Назначим ей
сообщение <<Строка не должна быть пустой>> или что-то похожее.

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"})
  \end{clojure}
%% \end{english}

Напишем функцию, которая принимает словарь ошибки (один из элементов
\spverb|::s/problems|) и возвращает сообщение:

\index{функции!get-message}

%% \begin{english}
  \begin{clojure}
(defn get-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (get spec-errors spec)))

(get-message {:via [::sample ::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

Проверим способ на других полях. Добавим в спеку \spverb|::sample| адрес почты:

\index{регулярные выражения}
\index{clojure.core!re-matches}

\begin{english}
  \begin{clojure}
(s/def ::email
  (s/and
   ::ne-string
   (partial re-matches #"(.+?)@(.+?)\.(.+?)")))

(s/def :sample/email ::email)

(s/def ::sample
  (s/keys :req-un [:sample/username
                   :sample/email]))
  \end{clojure}
\end{english}

Спека \spverb|::email| проверяет, что строка не пустая и совпадает с шаблоном
адреса. Шаблон требует, чтобы в строке был символ \spverb|@| и точка.

Если передать в \spverb|email| пустую строку, последним элементом \spverb|via|
будет \spverb|::ne-string|. Для экономии места сократим вывод
\spverb|explain-data|:

\begin{english}
  \begin{clojure}
(s/explain-data ::sample {:username "test" :email ""})

{:path [:email]
 :pred clojure.core/not-empty
 :val ""
 :via [::sample ::email ::ne-string]
 :in [:email]}
  \end{clojure}
\end{english}

Вызов \spverb|get-message| с этой верн\"{е}т сообщение о пустой строке. Попробуем
почту, которая не совпала с шаблоном. Последним элементом \spverb|:via| станет
\spverb|:sample/email|. Словарь ошибки выглядит так:

\begin{english}
  \begin{clojure}
{:path [:email]
 :pred
 (clojure.core/partial
  clojure.core/re-matches
  #"(.+?)@(.+?)\.(.+?)")
 :val "test"
 :via [::sample ::email]
 :in [:email]}
  \end{clojure}
\end{english}

Чтобы \spverb|get-message| вернул другое сообщение, добавим в словарь ошибок
ключ \spverb|::email|:

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   ::email "Введите правильный почтовый адрес"})
  \end{clojure}
%% \end{english}

Осталось наполнить его другими спеками и сообщениями, пока не покроем все
варианты. Теперь рассмотрим, как улучшить этот подход.

\subsubsection{Сообщение по умолчанию}

Что случится, если перевода нет в словаре? В этом случае вернем нейтральное
<<исправьте ошибку в данных>>. Заодно запишем в лог событие с именем спеки. Лог
настроен так, что сообщения из этого модуля идут в отдельный файл. Позже
локализаторы прочтут его и~добавят перевод.

%% \begin{english}
  \begin{clojure}
(def default-message
  "Исправьте ошибку в данных")
  \end{clojure}
%% \end{english}

\begin{english}
  \begin{clojure}
(defn get-better-message [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (do (log/debugf "missing message for spec %s" spec)
            default-message))))
  \end{clojure}
\end{english}

\subsubsection{Гибкий поиск}

\index{поиск}

Упростим поиск ключа в словаре. Поле \spverb|email| встречается в разных спеках:
\spverb|:account/email|, \spverb|:patient/email| и других. Согласно методу выше,
каждый ключе должен быть в словаре, что склоняет нас к повторам.

Чтобы не засорять словарь, пойдем на хитрость. Пусть функция ищет перевод по
полному ключу, а если его нет, то по имени. Тогда хватит ключа \spverb|:email|,
чтобы все емейлы сошлись в этот перевод. Если для конкретного
\spverb|:account/email| нужна особая фраза, добавим полную версию:

%% \begin{english}
  \begin{clojure}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   :email "Введите правильный почтовый адрес"
   :account/email "Почтовый адрес сотрудника содержит ошибки"})
  \end{clojure}
%% \end{english}

\noindent
Обновим поиск с учетом неполного ключа и фразы по умолчанию:

\begin{english}
  \begin{clojure}
(defn get-better-message
  [problem]
  (let [{:keys [via]} problem
        spec (peek via)]
    (or (get spec-errors spec)
        (get spec-errors (-> spec name keyword))
        default-message)))
  \end{clojure}
\end{english}

\index{перевод}
\index{языки!ClojureScript}

Система переводов, которую мы построили, довольно проста. Е\"{е} легко тестировать и
менять под нужды конкретного проекта. Доработанные версии этой системы работают
в бою. В одном из них формы проверяют на клиенте до отправки на
сервер. Сообщение для виджетов получают тем тем же способом. Это возможно,
поскольку мощь Spec в полной мере доступна в ClojureScript.

\subsubsection{Мультиметод}

Возможно, система переводов понравится вашим коллегам, и они захотят е\"{е}
использовать. Разумно вынести код в библиотеку и подключить в зависимости. Тогда
в плане сообщений проекты будут одинаковы.

Минус словаря в том, что его трудно расширить со стороны. Чтобы добавить
перевод, нужно выпустить новую версию библиотеки. Предоставим клиентам только
механизм перевода, а содержимое они наполнят сами.

Для этого заменим словарь на мультиметод. Его диспатчер принимает словарь ошибки
и находит виновную спеку. Далее расширим мультиметод спеками. С таким подходом
каждый добавит свои переводы или заменит чужие, если они не подошли.

Объявим мультиметод с одним переводом:

\index{мультиметоды!problem\arr{}text}

%% \begin{english}
  \begin{clojure}
(defmulti problem->text
  (fn [{:keys [via]}]
    (peek via)))

(defmethod problem->text ::ne-string [_]
  "Строка не должна быть пустой")
  \end{clojure}
%% \end{english}

Пример его работы:

%% \begin{english}
  \begin{clojure}
(problem->text {:val "" :via [::ne-string]})
"Строка не должна быть пустой"
  \end{clojure}
%% \end{english}

Ключ \spverb|:default| отвечает за действие по умолчанию. Если перевод не
найден, вернем стандартную фразу:

\begin{english}
  \begin{clojure}
(defmethod problem->text :default [_]
  default-message)
  \end{clojure}
\end{english}

\index{наследование}

Вспомним сообщение для почты. Хотелось бы, чтобы \spverb|:account/email| и
\spverb|:client/email| сходились в общий \spverb|::email|, но так, чтобы можно
было задать им частный перевод. Это возможно с помощью иерархии ключей. Если у
мультиметода нет ключа, но ключ наследует родителя, мультиметод выполнит поиск
для родителя.

Добавим перевод почты и унаследуем ключ \spverb|:account/email| от
\spverb|::email|. Если ошибка случится в спеке \spverb|:account/email|, получим
общий перевод для любой почты.

\index{clojure.core!derive}

%% \begin{english}
  \begin{clojure}
(defmethod problem->text ::email [_]
  "Введите правильный почтовый адрес")

(derive :account/email ::email)

(problem->text {:val "" :via [:account/email]})
"Введите правильный почтовый адрес"
  \end{clojure}
%% \end{english}

\noindent
Если нужен особый перевод, расширим мультиметод:

%% \begin{english}
  \begin{clojure}
(defmethod problem->text :account/email [_]
  "Введите почту сотрудника")
  \end{clojure}
%% \end{english}

Заметим, что каждый метод принимает словарь ошибки. Мы затенили его символом
\spverb|_|, потому что перевод зависит от ключа. В особых случаях можно
построить фразу в зависимости от других полей. Например, добавить текущее
значение:

%% \begin{english}
  \begin{clojure}
(defmethod problem->text :account/email
  [{:keys [val]}]
  (format "Ошибка в адресе почты: %s" val))

(problem->text {:val "test" :via [:account/email]})
"Ошибка в адресе почты: test"
  \end{clojure}
%% \end{english}

\subsubsection{Шаблон}

\index{шаблоны}

Если варианты выше показались сложными, попробуйте сообщение по~шаблону. Оно
складывается из имени поля и значения, например: <<в~поле email неверное
значение test>>. Сообщение легко получить функцией \spverb|format|. В нем слышна
машинная природа, зато способ быстрый и дешевый.

Имя поля получим как последний отличный от цифры элемент \spverb|:in|. Цифры
означают индекс вектора, поэтому их отбрасывают. Значение, которое привело к
ошибке, получим из поля \spverb|:val|.

\begin{english}
  \begin{clojure}
(defn get-common-message [problem]
  (let [{:keys [in val]} problem
        field (last (remove int? in))]
    (format "The field '%s' has got an incorrect value '%s'."
            (name field) val)))
  \end{clojure}
\end{english}

Поле и значение обернем в кавычки, чтобы выделить из общего текста. Проверим,
что верн\"{е}т функция:

\begin{english}
  \begin{clojure}
(get-common-message {:in [::user :user/email] :val "test"})
The field 'email' has got an incorrect value 'test'.
  \end{clojure}
\end{english}

\subsection{Открытые вопросы}

За рамками остались несколько вопросов. Они слишком общие, чтобы претендовать на
одно решение. В этом разделе мы не будем писать код, а только порассуждаем.

Что делать, если требуется локализация, то есть текст на русском или английском
в зависимости от настроек? Переделаем словарь ошибок. В нем станет два уровня:
на первом код локали (\spverb|ru|, \spverb|en|), а на втором переводы спек.

\index{локаль}
\index{перевод}

По локали мы получим словарь переводов, затем переводим сообщение как делали
выше. С кодом локали можно схитрить, чтобы облегчить поиск. Для отдельных фраз
выделяют более точные локали, например, американский и британский английский
с~кодами \spverb|en_US| и \spverb|en_GB|. Напишем поиск так, что сперва он ищет
по младшей локали (\spverb|en_US|), а затем по старшей (\spverb|en|). Если
британского текста не оказалось, получим общий английский. Так устроен перевод
сообщений в широком смысле, не только ошибок.

Вопрос откуда читать локаль остается на ваше усмотрение. Можно хранить е\"{е} в
сессии, параметрах запроса, базе данных, словом~--- как это удобно в проекте.

Второй вопрос~--- как связать ошибки с интерфейсом. Принято отделять модель от
е\"{е} представления, что касается и форм. Удобно, когда форма это структура данных,
вложенный словарь. Операции над ней это чистые функции, которые легко
поддерживать.

Представим форму в виде дерева. Ключи это поля, а значения виджеты. Виджет
содержит тип поля, текущее значение и ошибку. На каждый из них подписан
React-компонент. При изменении виджета он рисует HTML-элемент, например поле
ввода с текущим текстом. Если ошибка не \spverb|nil|, над полем ввода появится
красный текст.

Валидаця принимает форму и строит дерево значений. У него такая же топология, но
на месте виджетов значения полей ввода. С помощью спеки мы проверяем значения и
выводим типы из строк. В случае ошибки получим отч\"{е}т \spverb|explain|. Для
каждого элемента из поле \spverb|problems| находим путь, спеку и сообщение об
ошибке. Это сообщение добавляем виджету в поле \spverb|:error|. Компонент,
который подписан на виджет, заново отрисует его с ошибкой над полем.

\index{фронтенд}
\index{интерфейс}
\index{фреймворки!React}

Мы упомянули формы, React и проблемы интерфейса. Все вместе это называется
\emph{фронтенд}. Мы не будем на нем останавливаться, потому что фронтенд~---
сложная тема, достойная отдельной книги.

\section{Парсинг}

Мы научились проверять данные и выводить типы. Перейдем к более сложной
операции~--- парсингу. Под термином понимают разбор данных на части, поиск
структуры там, где прежде е\"{е} не было.

Возможно, вам приходилось писать регулярные выражения. Это шаблоны, которые
описывают структуру текста. Специальные функции принимают строку и регулярное
выражение. Они возвращают фрагменты текста, которые совпали с шаблоном.

Пример регулярного выражения это IP-адрес. Он состоит из четырех групп с
точками. Каждая группа это число от 0 до 255.

\index{парсинг}
\index{регулярные выражения}

\begin{english}
  \begin{text}
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
  \end{text}
\end{english}

В шаблоне мы ставим косую черту перед точкой. Это служебный символ, поэтому его
экранируют.

В регулярных выражениях применяют операторы \spverb|+|, \spverb|?|, \spverb|*| и
другие. Они указывают, сколько раз встречается шаблон перед ними: один и более
раз, ни одного или один, произвольное число. В зависимости от оператора шаблон
захватывает разные части текста.

Представьте, что регулярные выражения откусывают текст частями. Та часть, что
легла на шаблон, уходит в результат. Остаток переходит к следующему шаблону, и
так далее.

Регулярные выражения подводят нас к \spverb|regex|-спекам. Это особые спеки для
разбора данных по шаблону. Разница в том, что входные данные это коллекции, а не
текст.

\index{spec!regex}

\subsection{Простой разбор}

Предположим, нужно разобрать массив пользователей. Каждый из них это кортеж
\tuple{номер, почта, статус}. Все значения строки. Для каждого пользователя
требуется:

\begin{itemize}

\item
  убедиться, что в кортеже именно три элемента;

\item
  привести номер к числу;

\item
  проверить почту на минимальные критерии;

\item
  привести статус к перечислению (константе).

\item
  получить словарь с верными значениями.

\end{itemize}

Мы уже знакомы с \spverb|s/conformer|. Можно написать функцию, которая примет
кортеж и выполнит действия выше. Это несложно, но функция будет монолитом со
слишком большим \emph{скоупом}. Рассмотрим другой способ.

\index{spec!cat}

Спека \spverb|s/cat| служит для разбора коллекций. Она принимает набор тегов и
других спек. На вход подают коллекцию, и \spverb|s/cat| накладывает е\"{е} элементы
на спеки. Если они совпали, результатом будет словарь. Ключи словаря теги,
значения~--- вызов дочерней спеки с элементом.

Составим спеку для разбора кортежа. Прогодится код, который мы писали для чисел
и почты. Опишем статус и соберем композицию спек:

\begin{english}
  \begin{clojure}
(s/def :user/status
  (s/and ->lower
         (with-conformer [val]
           (case val
             "active"  :USER_ACTIVE
             "pending" :USER_PENDING))))

(s/def ::user
  (s/cat :id ::->int
         :email ::email
         :status :user/status))
  \end{clojure}
\end{english}

\noindent
Положительный случай:

\begin{english}
  \begin{clojure}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1
 :email "test@test.com"
 :status :USER_ACTIVE}
  \end{clojure}
\end{english}

Варианты с плохим номером, почтой или статусом не пройдут разбор. Примеры ниже
вернут \spverb|::s/invalid|:

\begin{english}
  \begin{clojure}
(s/conform ::user ["" "test@test.com" "active"])
(s/conform ::user ["1" "@test.com" "active"])
(s/conform ::user ["1" "test@test.com" "unknown"])
  \end{clojure}
\end{english}

\subsection{Условный разбор}

Представим, что работаем с устаревшим форматом данных. В нем условие: если перед
номером стоит метка <<blocked>>, пользователь заблокирован. Например:

\begin{english}
  \begin{text}
blocked;1;test@test.com;active
  \end{text}
\end{english}

Это усложняет задачу, ведь теперь кортеж состоит из трех \emph{или} четырех
элементов. Сдвигается семантика полей: первый элемент не только номер, но и флаг
блокировки. Бывают и более сложные условия, особенно в старых данных.

В императивных языках они порождают каскад \spverb|if/else|. В Clojure
проблему решают декларативно. Объявим спеку блокировки:

\begin{english}
  \begin{clojure}
(s/def ::blocked
  (s/and
   ->lower
   (s/conformer (partial = "blocked"))))
  \end{clojure}
\end{english}

\index{spec!?}

Добавим е\"{е} в итоговую \spverb|s/cat|, но укажем, что она встречается ни разу или
только один раз. Для этого \spverb|::blocked| оборачивают спеку в \spverb|s/?|.
В регулярных выражениях знак вопроса делает то же самое.

\begin{english}
  \begin{clojure}
(s/def ::user
  (s/cat :blocked (s/? ::blocked)
         :id ::->int
         :email ::email
         :status :user/status))
  \end{clojure}
\end{english}

Теперь оба кортежа совпадают со спекой \spverb|::user|. Если пользователь
заблокирован, в словаре будет поле \spverb|:blocked|:

\begin{english}
  \begin{clojure}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1 :email "test@test.com" :status :USER_ACTIVE}

(s/conform ::user ["BLOCKED" "1" "test@test.com" "active"])
{:blocked true :id 1 :email "test@test.com" :status ...}
  \end{clojure}
\end{english}

Представим, что на входе коллекция кортежей. Чтобы не утруждать себя итерацией,
объявим спеку-коллекцию:

\begin{english}
  \begin{clojure}
(s/def ::users (s/coll-of ::user))

(def user-data
  [["1" "test@test.com" "active"]
   ["Blocked" "2" "joe@doe.com" "pending"]])

(s/conform ::users user-data)
[{:id 1 :email "test@test.com" :status :USER_ACTIVE}
 {:blocked true :id 2 :email "joe@doe.com" :status ...}]
  \end{clojure}
\end{english}

\index{clojure.core!filter}
\index{clojure.core!complement}

Отсеять заблокированных пользователей можно функцией \spverb|filter| с
предикатом \spverb|(complement :blocked)|.

\subsection{Практика}

\index{форматы!INI}
\index{парсинг}

С помощью Spec парсят не только данные, но и текст. Рассмотрим, как прочитать
INI-файл в словарь данных. INI\footurl{https://en.wikipedia.org/wiki/INI\_file}
это старый формат для конфигурации. Он состоит из заголовков и пар полей и
значений. Пример условного \spverb|config.ini|:

\begin{english}
  \begin{ini}
[database]
host=localhost
port=5432
user=test

[server]
host=127.0.0.1
port=8080
  \end{ini}
\end{english}

Наша цель~--- получить словарь, где на первом уровне заголовки, а под ними поля
и значения.

\begin{english}
  \begin{clojure}
{:database {:host "localhost"
            :port 5432}
 :server {:host "127.0.0.1"}}
  \end{clojure}
\end{english}

Если отбросить пустые строки и комментарии, формат сводится к~грамматике
\spverb|([title], (key=value)*)*|, где звездочка означает сколько угодно раз, в
том числе ничего.

\index{clojure.core!doall}
\index{clojure.core!with-open}

Для начала прочитаем строки из файла. Спеки не должны иметь побочных эффектов,
поэтому чтение выносят в отдельную функцию. Форма \spverb|doall| нужна, чтобы
прочитать строки до выхода из \spverb|with-open|.

\index{итерация!doall}

\index{clojure.core!doall}

\begin{english}
  \begin{clojure}
(require '[clojure.java.io :as io])

(defn get-ini-lines [path]
  (with-open [src (io/reader path)]
    (doall (line-seq src))))
  \end{clojure}
\end{english}

Переходим к парсеру. Это спека, которая принимает список строк. Алгоритм
следующий:

\begin{itemize}

\item
  удалить пустые строки и комментарии;

\item
  сгруппировать оставшиеся строки по заголовкам;

\item
  разбить поля и значения по знаку равенства;

\item
  построить вложенный словарь;

\item
  вывести типы и проверить результат.

\end{itemize}

Будем писать по принципу <<сверху вниз>>, словно все компоненты готовы. Ниже~---
спека, которая решает задачу:

\begin{english}
  \begin{clojure}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)
   (s/conformer remap-ini-data)
   ::ini-config))
  \end{clojure}
\end{english}

\index{функции!clear-ini-lines}

Напишем недостающие элементы. Функция \spverb|clear-ini-lines| убирает пустые
строки и комментарии. В INI они начинаются с символа решетки.

\begin{english}
  \begin{clojure}
(require '[clojure.string :as str])

(defn comment? [line]
  (str/starts-with? line "#"))

(defn clear-ini-lines [lines]
  (remove (some-fn comment? str/blank?) lines))
  \end{clojure}
\end{english}

\index{spec!*}

Спека \spverb|(s/* :ini/section)| читается как <<ноль и более секций>>. Под
секцией понимают заголовок и прилегающие поля и значения. Запишем е\"{е} в виде
\spverb|s/cat|:

\begin{english}
  \begin{clojure}
(s/def :ini/section
  (s/cat :title :ini/title :fields (s/* :ini/field)))
  \end{clojure}
\end{english}

Объявим спеку \spverb|:ini/title|. Она проверяет, что строка это
заголовок. Согласно формату, заголовок пишут в квадратных скобках. Если первый и
последний символы строки это скобки, отбросим их:

\begin{english}
  \begin{clojure}
(s/def :ini/title
  (s/and
   #(str/starts-with? % "[")
   #(str/ends-with? % "]")
   (with-conformer [line]
     (subs line 1 (dec (count line))))))
  \end{clojure}
\end{english}

\noindent
Вариант с регулярным выражением:

\begin{english}
  \begin{clojure}
(s/def :ini/title
  (with-conformer [line]
    (or (second (re-matches #"^\[(.+)\]$" line))
        ::s/invalid)))
  \end{clojure}
\end{english}

\index{алгоритмы!base64}

Спека \spverb|:ini/field| парсит поле и значение. Строку разбивают по знаку
равенства. Цифра 2 означает, что в результате должно быть не более двух
элементов: ключ и значение. Это важно, потому что в значении может быть знак
равенства, например если это base64-строка. Если не получили пару, сигналим об
ошибке.

\begin{english}
  \begin{clojure}
(s/def :ini/field
  (with-conformer [line]
    (let [pair (str/split line #"=" 2)]
      (if (= (count pair) 2)
        pair
        ::s/invalid))))
  \end{clojure}
\end{english}

Не терпится проверить нашу работу. Обернем черновую спеку в функцию
\spverb|parse-ini|, которая читает файл.

\begin{english}
  \begin{clojure}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)))

(defn parse-ini [path]
  (let [lines (get-ini-lines path)]
    (s/conform ::->ini-config lines)))
  \end{clojure}
\end{english}

\noindent
Пробный результат:

\begin{english}
  \begin{clojure}
(parse-ini "config.ini")

[{:title "database"
  :fields [["host" "localhost"]
           ["port" "5432"]
           ["user" "test"]]}
 {:title "server"
  :fields [["host" "127.0.0.1"]
           ["port" "8080"]]}]
  \end{clojure}
\end{english}

Разбор прошел удачно, хотя структура отличается от той, что мы планировали. Это
неважно: мы вывели данные из текста, а привести словарь к нужному виду
легко. Напишем функцию \spverb|remap-ini-data|:

\begin{english}
  \begin{clojure}
(defn remap-ini-data [data-old]
  (reduce
   (fn [data-new entry]
     (let [{:keys [title fields]} entry]
       (assoc data-new title (into {} fields))))
   {}
   data-old))
  \end{clojure}
\end{english}

\noindent
Если передать в не\"{е} вектор из последнего шага, получим то словарь:

\begin{english}
  \begin{clojure}
{"database" {"host" "localhost" "port" "5432" "user" "test"}
 "server" {"host" "127.0.0.1" "port" "8080"}}
  \end{clojure}
\end{english}

Напишем спеку для вывода типов и проверки. Номера портов приводим к числам, хост
и пользователь не пустые строки.

\begin{english}
  \begin{clojure}
(s/def :db/host ::ne-string)
(s/def :db/port ::->int)
(s/def :db/user ::ne-string)

(s/def ::database
  (s/keys :req-un [:db/host :db/port :db/user]))

(s/def :server/host ::ne-string)
(s/def :server/port ::->int)

(s/def ::server
  (s/keys :req-un [:server/host :server/port]))

(s/def ::ini-config
  (s/keys :req-un [::database ::server]))
  \end{clojure}
\end{english}

\index{модули!clojure.walk}
\index{функции!keywordize-keys}

Последний штрих~--- исправить тип ключей в словаре. Сейчас это строки, но спека
\spverb|::ini-config| ожидает кейворды. Модуль \spverb|walk| предлагает функцию
\spverb|keywordize-keys| на этот случай. Она обходит словарь любой вложенности и
меняет ключи. Итоговая спека:

\begin{english}
  \begin{clojure}
(require '[clojure.walk :as walk])

(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)
   (s/conformer remap-ini-data)
   (s/conformer walk/keywordize-keys)
   ::ini-config))
  \end{clojure}
\end{english}

\noindent
Результат:

\begin{english}
  \begin{clojure}
(parse-ini "config.ini")

{:database {:host "localhost"
            :port 5432
            :user "test"}
 :server {:host "127.0.0.1"
          :port 8080}}
  \end{clojure}
\end{english}

Получились аккуратные данные из текста. Обратите внимание, что в коде нет
состояния, и в целом он выглядит как цепочка шагов. Каждый шаг легко исправить
или добавить новый между ними.

Устраните мелкие недостатки в коде. Пусть пара \spverb|"foo="| становится
\spverb|{:foo nil}|, а не \spverb|{:foo ""}|.  Удалите пустые символы из имен
полей и значений. Опробуйте код на больших ini-файлах.

\section{Разбор кода (теория)}

\index{парсинг}
\index{макросы}

В завершение темы поговорим о том, как парсить код. Мы уже видели, что Spec
подходит для разбора коллекций. Код на Clojure состоит из списков. Это приводит
к неожиданному решению: код можно проверить спекой и вернуть ошибку до того, как
он запущен.

Проверку удобно делать в макросах. Это особые функции, которые работают на этапе
компиляции. Макрос принимает код в виде списка символов. В коде могут быть
ошибки, но макрос об этом ничего не знает: для него это просто символы.

Задача макроса в том, чтобы перестроить список в другой, понятный
Clojure. Компилятор заменит вызов макроса на то, что он вернул, и запустит
код. Макросы это отдельная веха в изучении Clojure. Пока что рассмотрим, как
проверить макрос спекой.

Каждый макрос это мини-язык с соглашением о том, что подавать на вход. В простых
случаях код парсят функциями \spverb|first|, \spverb|rest| и условиями. Сложные
макросы разбирают грамматиками, как мы делали это с INI-файлом. Если код
нарушает правила, мы должны объяснить, в чем ошибка.

\index{clojure.core!defn}

Иногда один и тот же макрос допускает разную запись. Хорошим примером служит
\spverb|defn|, определение функции. Кроме обязательных параметров он принимает
дополнительные: строку документации, пре- и пост-проверки. У функции может быть
несколько тел:

\noindent
\begin{tabular}{ @{}p{2.5cm} @{}p{4.5cm} @{}p{3cm} }

\begin{english}
  \begin{clojure}
(defn my-inc
  [x]
  (+ x 1))
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(defn my-inc
  "Increase the number."
  [x]
  {:pre [(int? x)]
   :post [(int? %)]}
  (+ x 1))
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(defn my-inc
  ([x]
   (my-inc x 1))
  ([x delta]
   (+ x delta)))
  \end{clojure}
\end{english}

\end{tabular}

Это одна и та же функция, записанная по-разному. Очевидно, разобрать все
варианты вручную тяжело. До версии Clojure 1.10 каждый макрос парсил код как
прид\"{е}тся. Это было неорганизованно. С выходом Spec основные макросы перешли на
спеку. Появился общий подход, которым легко управлять.

\index{spec!cat}

Разберем устно, как бы мы построили спеку для разбора \spverb|defn|. Это список,
поэтому на верхнем уровне поместим \spverb|s/cat|. Первый его элемент~--- символ
\spverb|defn|, второй~--- символ с именем функции. После имени следует строка
документации (е\"{е} может и не быть). Далее~--- тело или список тел. Набросаем
черновик:

\begin{english}
  \begin{clojure}
(s/def ::defn
  (s/cat :tag (partial = 'defn)
         :name symbol?
         :doc (s/? string?)
         :body :defn/body*))
  \end{clojure}
\end{english}

Что скрывается за спекой \spverb|:defn/body*| пока неизвестно. Считаем, что тело
начинается с вектора параметров. После него ид\"{е}т опциональный словарь пре- и
пост-проверок. Затем произвольные формы, из которых состоит тело функции.

\begin{english}
  \begin{clojure}
(s/def :defn/body
  (s/cat :args vector?
         :prepost (s/? map?)
         :code (s/* any?)))
  \end{clojure}
\end{english}

Проблема в том, что \spverb|defn| принимает либо одно тело, либо их список.
Сравните первый и третий столбики в примере с \spverb|my-inc|. Обернем спеку
\spverb|:defn/body| так, чтобы она учитывала оба случая. Обозначим е\"{е}
звездочкой. Вызов \spverb|s/spec| необходим, чтобы сгруппировать результат
\spverb|:defn/body|.

\begin{english}
  \begin{clojure}
(s/def :defn/body*
  (s/alt :single :defn/body
         :multi (s/+ (s/spec :defn/body))))
  \end{clojure}
\end{english}

\index{заморозка}
\index{синтаксис!\textbf{'} (заморозка)}

Заморозим код с \spverb|defn| с помощью апострофа. Получится список
символов. Отправим его в \spverb|s/conform|:

\begin{english}
  \begin{clojure}
(s/conform
 ::defn
 '(defn my-inc
    "Increase a number"
    [x]
    {:pre [(int? x)]
     :post [(int? %)]}
    (+ x 1)))
  \end{clojure}
\end{english}

\noindent
Результат:

\begin{english}
  \begin{clojure}
{:tag defn
 :name my-inc
 :doc "Increase a number"
 :body
 [:single
  {:args [x]
   :prepost {:pre [(int? x)] :post [(int? %)]}
   :code [(+ x 1)]}]}
  \end{clojure}
\end{english}

Обратите внимание на поле \spverb|:body|. Это вектор из метки и результата. Для
одного тела получим метку \spverb|:single| и словарь. Для нескольких тел метка
будет \spverb|:multi|, а значение~--- вектор словарей:

\begin{english}
  \begin{clojure}
[:multi [{:args [x] :code [(println 1)]}
         {:args [x y] :code [(println 2)]}]]
  \end{clojure}
\end{english}

Чтобы проверить метку (одно тело или несколько), пригодится оператор
\spverb|case|. Ниже в переменой \spverb|result| записан результат
парсинга. Функция \spverb|process-body| обрабатывает словарь тела:

\begin{english}
  \begin{clojure}
(let [{:keys [body]} result
      [tag body] body]
  (case tag
    :single
    (process-body body)
    :multi
    (doseq [body body]
      (process-body body))))
  \end{clojure}
\end{english}

\subsection{Самостоятельная работа}

\index{сообщения}

Каждый уровень спеки расширяется вглубь. Доработаем аргументы функции: разделим
их на обязательные и остаточные. Например, чтобы параметры \spverb|[x y & other]|
предстали в виде словаря:

\begin{english}
  \begin{clojure}
{:req [x y] :opt other}
  \end{clojure}
\end{english}

\noindent
По аналогии разберите словари пре- и пост- проверок.

Передайте в спеку данные с ошибками. Что делать в таком случае? Как составить
\emph{понятное} сообщение о том, где именно ошибка и что вы ожидали? Подойдет ли
словарь переводов? Получится ли у вас сделать ошибки лучше, чем в промышленных
языках?

Данные, которые вернула спека-парсер, называются
\emph{абстрактным синтаксическим деревом}\footurl{https://en.wikipedia.org/wiki/Abstract\_syntax\_tree}
(анг. abstract syntax tree, AST). Это вложенная структура, которую получают из
текста. AST~--- важный этап компиляции программы. Только построив дерево, можно
выполнить логику, которая стоит за ним.

\index{интерпретатор}

Spec работает в том числе как парсер грамматик: можно разобрать данные и
построить дерево. Вы в шаге от того, чтобы написать простой интерпретатор~---
программу, которая читает код и выполняет его. Узлы дерева это функции, а
потомки~--- аргументы или другие функции. Напишите обход дерева и его
вычисление. Даже если это курсовая работа, свой язык или компилятор улучшит ваши
навыки.

\section{Спецификация функций}

\index{spec!функции}

Проблема валидации касается и функций. Они получают данные от посредников, и
всегда есть шанс, что в них ошибка. Вспомним функцию с диапазоном дат. Если
поменять их местами (начало больше конца), проверки на интервал вернут
ложь. Здесь и пригодится спека.

Опишем параметры функции. Это \spverb|s/cat|, которая <<откусывает>> от
аргументов даты и помещает в словарь с ключами \spverb|:start| и \spverb|:end|.

\begin{english}
  \begin{clojure}
(s/def ::date-range-args
  (s/and
   (s/cat :start inst? :end inst?)
   (fn [{:keys [start end]}]
     (<= (compare start end) 0))))
  \end{clojure}
\end{english}

\index{clojure.core!compare}

Вторая функция в \spverb|s/and| принимает словарь и сравнивает даты. Для дат
используют функцию \spverb|compare|, которая верн\"{е}т -1, 0 и 1 для случаев
меньше, равно и больше. Быстрая проверка:

\begin{english}
  \begin{clojure}
(s/valid? ::date-range-args [#inst "2019" #inst "2020"]) ;; true
(s/valid? ::date-range-args [#inst "2020" #inst "2019"]) ;; false
  \end{clojure}
\end{english}

\index{декораторы}

Напрашивается декоратор, который принимает функцию и спеку. Перед тем, как
запустить функцию, он проверит аргументы и в случае ошибки бросит исключение. То
же самое проделаем с результатом.

\index{модули!clojure.spec.test.alpha}
\index{функции!instrument}

Писать декоратор не нужно, потому что его включили в Spec. Это функция
\spverb|instrument| из модуля \spverb|clojure.spec.test.alpha|
(анг. instrument~--- оснастить, оборудовать). Обратите внимание на пространство:
в него закралась частичка <<test>>. Оснащение функций вынесли в отдельный
модуль.

\spverb|Instrument| принимает символ функции, которую <<заряжают>>. Таким же
символом задают спеку для функции. \spverb|Instrument| подменяет функцию на
такую же, но с проверками. Это своего рода <<monkey patch>>, когда один модуль
изменяет другой. Функциональную спеку объявляют макросом \spverb|s/fdef|. Ему
передают символ функции и спеки входящих параметров, результата и их композиции.

\index{даты}
\index{классы!Date}

Напишем функцию и спеку к ней. Пусть функция считает разницу между датами в
секундах. Если первая дата больше второй, результат отрицательный.

\begin{english}
  \begin{clojure}
(import 'java.util.Date)

(defn date-range-sec
  "Return the difference between two dates in seconds."
  [^Date date1 ^Date date2]
  (quot (- (.getTime date2)
           (.getTime date1))
        1000))
  \end{clojure}
\end{english}

Теги \spverb|^Date| нужны, чтобы компилятор знал тип объектов \spverb|date1| и
\spverb|date2|. Если тега нет, компилятор находит тип рефлексией, что
медленней. Посчитаем разницу в сутках:

\begin{english}
  \begin{clojure}
(date-range-sec #inst "2019-01-01" #inst "2019-01-02")
86400
  \end{clojure}
\end{english}

\noindent
Если поменять даты местами, получим то же число с минусом.

Опишем функциональную спеку с символом \spverb|date-range-sec|. Под
\spverb|:args| указывают спеку входящих параметров. Это список, поэтому
пригодится \spverb|s/cat|. Он разбивает список на словарь, чтобы спеки ниже
работали с ключами.

В \spverb|:ret| указывают спеку результата. Чаще всего это проверка на число или
строку: \spverb|int?|, \spverb|string?| или их \spverb|nilable|-версии, которые
допускают \spverb|nil|: \spverb|(s/nilable int?)| и так далее.

\index{spec!fdef}

\begin{english}
  \begin{clojure}
(s/fdef date-range-sec
  :args (s/cat :start inst? :end inst?)
  :ret int?)
  \end{clojure}
\end{english}

В ключи \spverb|:args| и \spverb|:ret| можно готовые спеки, что полезно для
повторного использования. У вас может быть несколько спек для диапазона дат.

При создании функциональная спека не меняет функцию. Она только объявляет
проверки, но не запускает их. Чтобы подменить функцию на е\"{е} оснащенную версию,
вызывают \spverb|instrument|:

\begin{english}
  \begin{clojure}
(require '[clojure.spec.test.alpha :refer [instrument]])
(instrument `date-range-sec)
  \end{clojure}
\end{english}

Символ функции должен быть полным (с пространством). Чтобы подставить в символ
текущее пространство, перед ним ставят обратную кавычку \spverb|`|.

Теперь \spverb|date-range-sec| проверит аргументы и результат. Что случится,
если передать в <<заряженную>> функцию не тот аргумент? Получим исключение
\spverb|ExceptionInfo|.

\begin{english}
  \begin{clojure}
(date-range-sec nil #inst "2019")
;; Execution error - invalid arguments to date-range-sec
;; nil - failed: inst? at: [:start]
  \end{clojure}
\end{english}

\index{spec!explain}
\index{отч\"{е}ты!explain}

Сообщение и тело нам знакомы. В поле \spverb|message| текст из функции
\spverb|s/explain-str|. В поле \spverb|data| отч\"{е}т из
\spverb|s/explain-data|. Чтобы получить данные, передайте исключение в функцию
\spverb|(ex-data e)|.

\subsection{Документация}

\index{документация}
\index{модули!clojure.repl}

Функциональная спека улучшает документацию. Функция \spverb|doc| из модуля
\spverb|clojure.repl| выводит справку о запрошенной функции. С появлением Spec
е\"{е} поведение изменилось: кроме документации она выводит спеку, если е\"{е}
задали. Вот как выглядит справка для \spverb|date-range-sec| после того, как
объявили спеку:

\begin{english}
  \begin{clojure}
(clojure.repl/doc date-range-sec)
-------------------------
([date1 date2])
  Return the difference between two dates in seconds.
Spec
  args: (cat :start inst? :end inst?)
  ret: int?
  \end{clojure}
\end{english}

\index{библиотеки!Autodoc}
\index{библиотеки!Codox}

На функцию \spverb|doc| полагаются IDE и редакторы, чтобы подсказывать аргументы
в коде. Утилиты для документации вроде
Autodoc\footurl{https://github.com/tomfaulhaber/autodoc} или
Codox\footurl{https://github.com/weavejester/codox} добавляют спеки в
HTML-файлы.

\subsection{Производительность}

\index{производительность}

\spverb|Instrument| помогает в тестировании. На время тестов функции
<<заряжают>>, чтобы выявить ошибки. Это делают с помощью модуля, который
выполняет серию \spverb|(instrument ...)| при загрузке. Проект устроен так, что
модуль загружается только на время тестов. Если функция получила не те
аргументы, это станет заметно.

\index{бенчмарк}

\spverb|Instrument| не подходит для боевого режима, потому что замедляет
код. Напишем бенчмарк, который вызовет исходную функцию много раз:

\index{clojure.core!time}
\index{clojure.core!dotimes}

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
"Elapsed time: 1.783962 msecs"
  \end{clojure}
\end{english}

\noindent
То же самое после оснащения:

\begin{english}
  \begin{clojure}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
"Elapsed time: 116.984496 msecs"
  \end{clojure}
\end{english}

\index{тесты}

Разница в сто раз! Проверка \emph{существенно} замедляет приложение. Вот почему
\spverb|instrument| не претендует на запуск в бою: это слишком дорогая
цена. Однако в тестах нас не волнует скорость. На время прогона код покрывают
как можно б\'{о}льшим числом проверок, чтобы поймать все ошибки.

\section{Повторное использование спек}

\index{повторное использование}
\index{библиотеки!JDBC}

В Clojure принято снабжать библиотеки спеками, чтобы помочь другим. Если
библиотека активно работает с какой-то структурой данных, опишите е\"{е}
спекой. Хорошим примером служит JDBC\footurl{https://github.com/clojure/java.jdbc},
об\"{е}ртка для реляционных баз данных.

Подключение к базе задают словарем с ключами \spverb|:host|, \spverb|:port|,
\spverb|:user| и другими. Обычно словарь читают из конфигурации. Перед
подключением его нужно проверить, чтобы не получить \spverb|NPE| и другие
странности.

\index{NPE}

Предположим, конфигурация описана в EDN-файле. Поле \spverb|:db| зада\"{е}т
подключение к базе.

\index{форматы!EDN}

\begin{english}
  \begin{clojure}
{:db {:dbtype "mysql"
      :host "127.0.0.1"
      :port 3306
      :dbname "project"
      :user "user"
      :password "********"
      :useSSL true}}
  \end{clojure}
\end{english}

Ключи \spverb|:dbtype|, \spverb|:host| и другие уже описаны в библиотеке. Один
из модулей JDBC несет спеки подключения и основных функций. Используем их
повторно:

\begin{english}
  \begin{clojure}
(require '[clojure.java.jdbc.spec :as jdbc])
(s/def ::db ::jdbc/db-spec)
(s/def ::config (s/keys :req-un [::db]))
  \end{clojure}
\end{english}

\noindent
Прочитаем конфигурацию из файла и проверим спекой:

\begin{english}
  \begin{clojure}
(def config (read-string (slurp "config.edn")))
(s/valid? ::config config)
  \end{clojure}
\end{english}

\label{jdbc-conform-warning}

\index{spec!or}

Будьте внимательны с \spverb|::jdbc/db-spec|: это сложная спека с макросами
\spverb|s/or|, которые порождают развилки. Если передать е\"{е} в
\spverb|s/conform|, получим результат с тегами:

\begin{english}
  \begin{clojure}
(s/conform ::config config)
{:db
 [:friendly
  {:dbtype   [:name "mysql"]
   :host     "127.0.0.1"
   :port     [:port 3306]
   :dbname   "project"
   :user     "user"
   :password "********"
   :useSSL   true}]}
  \end{clojure}
\end{english}

Результат не работает с \spverb|jdbc/query| и другими функциями JDBC. Мы
ограничились \spverb|s/valid?|, чтобы оставить структуру прежней.

\index{библиотеки!Alia}

Иногда спеки выносят в отдельную библиотеку. Так поступили разработчики
Alia\footurl{https://github.com/mpenet/alia}~--- клиента для БД
Cassandra. Проект \spverb|qbits.alia| несет основные функции для работы с
базой. Спеки идут в пакете \spverb|cc.qbits/alia-spec|, который подключают
отдельно.

\section{Дополнения}

Spec входит в поставку Clojure и меняется не так часто, как хотелось бы
разработчикам. Дополнения к Spec выпускают в виде библиотек. Среди прочих
заслуживают внимания Expound и Spec.tools. Коротко опишем возможности каждой.

\index{библиотеки!Expound}

Библиотека Expound\footurl{https://github.com/bhb/expound} улучшает сообщения об
ошибках. Сигнатура функции \spverb|expound| аналогична \spverb|s/explain|: она
тоже принимает спеку и данные. Новое сообщение об ошибке выглядит так:

\index{spec!ошибки}
\index{сообщения}

\begin{english}
  \begin{clojure}
(expound/expound string? 1)
-- Spec failed --------------------
  1
should satisfy
  string?
-------------------------
Detected 1 error
  \end{clojure}
\end{english}

\index{spec!explain}

Это вс\"{е} ещ\"{е} машинный текст, который нельзя показывать пользователю. Вс\"{е} же
он лучше, чем сырой \spverb|s/explain|: его прочтут инженеры, которые не знают
Clojure. \spverb|Expound| подойдет для проверки конфигурации на старте
приложения. Конфигурацию обновляют часто, поэтому внятный отч\"{е}т об ошибке
полезен.

\index{организации!Metosin}
\index{библиотеки!Spec.tools}
\index{веб-разработка!Swagger}
\index{веб-разработка!REST}

Разработчики Metosin собрали улучшения к Spec в проекте
Spec.tools\footurl{https://github.com/metosin/spec-tools}. В сердце библиотеки
лежит объект \spverb|Spec|. Он оборачивает стандартную спеку и дополняет е\"{е}
новыми методами. С помощью Spec.tools формируют JSON-схему или описывают REST
API по стандарту Swagger. Библиотека играет роль посредника между
REST-фреймворком и спекой.

\section{Будущее спеки}

\index{библиотеки!Schema}
\index{библиотеки!Bouncer}

На сегодняшний день пакет Spec вс\"{е} ещ\"{е} не избавился от частички <<alpha>> в
названии. Авторы экспериментируют со спекой, ищут лучшие способы валидации. Это
смущает некоторых разработчиков: опасаясь, что по окончании эксперимента от Spec
избавятся, они берут альтернативы:
Schema\footurl{https://github.com/plumatic/schema},
Bouncer\footurl{https://github.com/leonardoborges/bouncer} и другие.

Отдельные группы пишут обертки над спекой, чтобы расширить е\"{е}
возможности. Например, подружить с JSON-схемой и инструментами вроде
Swagger. Это путь Spec.tools, которую мы рассмотрели.

\index{люди!Рич Хикки}
\index{видео!Maybe Not}

В докладе <<Maybe Not>>\footurl{https://youtube.com/watch?v=YR5WdGrpoug} Рич
Хикки анонсировал вторую версию спеки. В ней упростят работу со словарями (спека
\spverb|select|) и множественными типами (когда значение строка или
число). Разработка ид\"{е}т в открытом режиме, но ещ\"{е} рано говорить о
результатах. Обсуждение второй спеки выходит за рамки главы.

\section{Итог}

Spec это библиотека Clojure, которая ид\"{е}т в поставке с языком. Spec предлагает
набор функций и макросов. Ими описывают правила, которым подчиняются
данные. Правила это предикаты~--- функции, которые возвращают истину или ложь.

Предикаты гибче и мощнее типов. Если о значении известно, что оно верного типа,
это не гарантирует корректность. Значение \spverb|-1| не может быть
Unix-портом. Классы вроде \spverb|UnixPort| это не типы, а валидация в
рантайме. Она привязана к вызову класса с помощью синтаксиса.

В отличие от классов, предикаты компонуются друг с другом. Легко составить
предикат с логикой <<каждый из>>, <<любой из>> и другие.

Библиотека выводит новые данные из старых. Функция \spverb|s/conform|
оборачивает другую функцию для вывода значения. Этим пользуются для парсинга
чисел и дат.

Spec предлагает regex-спеки, похожие на регулярные выражения. От~обычных спек
они отличаются тем, что захватывают часть коллекции. На regex-спеках пишут
парсеры данных, в том числе для нужд самой Clojure. Основные макросы проверяют
тело с помощью Spec.

Библиотека полезна в тестах. Функция \spverb|instrument| изменяет другую функцию
так, что е\"{е} аргументы проверяются спекой. Это замедляет вызов, но делает тесты
надежней. Функциональная спека становится частью документации.

Spec не предлагает решения для сообщений об ошибках. Как их строить и показывать
клиенту зависит от проекта. Один из подходов основан на словаре, где ключи~---
спеки, а значения~--- текст ошибки или тег перевода. Если заменить словарь на
мультиметод, потребителям будет проще расширить его.

Мы рассмотрели основные возможности библиотеки. В обсуждение не попали,
генераторы, мульти-спеки и другие интересные вещи. Все это читатель найд\"{е}т в
официальной документации. Мы не прощаемся со спекой, в следующих главах вернемся
к ней.
