\chapter{Clojure.spec}

\begin{teaser}
В этой главе мы рассмотрим clojure.spec~--- библиотеку для проверки данных в
Clojure. Это особенная библиотека: на ней пишут валидаторы и парсеры, с ее
помощью генерируют данные для тестов. Spec фундаментальна по своей природе,
поэтому уделим ей пристальное внимание.
\end{teaser}

\emph{Spec} это сокращение от \emph{specification} (анг. спецификация,
описание). В общих словах, это набор функций и макросов, чтобы схематично
описать данные. Например, из каких ключей состоит словарь и каких типов его
значения. Такую запись называют спецификацией или сокращенно
\emph{спекой}. Далее по тексту мы будем пользоваться коротким вариантом.

Особые функции принимают спеку и данные и проверяют, подходят ли данные к
ней. Если нет, то возвращают отчет: в каком месте произошла ошибка и почему.

\spverb|Spec| входит в поставку Clojure начиная с версии 1.9. Полностью модуль
называется \spverb|clojure.spec.alpha|. Пусть вас не смущает частичка
\spverb|alpha| на конце имени. Она осталась по историческим причинам.

\spverb|Spec| стала важной вехой в развитии Clojure. Ключевое свойство
\spverb|spec| в том, что она фундаментальна. Валидация данных это малая часть ее
возможностей. \spverb|Spec| не только проверяет данные, но и преобразует
их. Например, на \spverb|spec| легко написать процессор данных или парсер.

Технически \spverb|spec| основана на абстракциях, которые предлагает
Clojure. Формально это обычная библиотека. Но абстракции \spverb|spec| оказались
настолько мощны, что Clojure переиспользует их. Начиная с 1.10, компилятор
Clojure анализирует собственный код с помощью \spverb|spec|. Так проекты
дополняют друг друга.

Мы начнем описание \spverb|spec| с валидации данных. Но прежде чем браться за
техническую часть, разберемся с теорией. Как связаны между собой классы, типы и
валидация.

\section{Типы и классы}

Принято считать, что код на языке со статической типизацией безопаснее, чем с
динамической. Компилятор не позволит сложить число и строку еще до того, как мы
запустим программу. Сторонники статической типизации забывают, что тип
переменной~--- это лишь одно из многих ограничений. Редко случается так, что тип
полностью определяет допустимые значения. Чаще всего, в дополнение к типу,
учитывают максимальные и минимальные границы, длину, попадание в интервалы и
перечисления. Бывает, по отдельности значение верно, но не может стоять в паре с
другим значением.

Рассмотрим описание сетевого порта. Это число от 0 до $2^{16}-1$. Целочисленные
типы обычно представлены степенями двойки, поэтому найдется условный
\spverb|unsigned int|, который охватывает именно этот диапазон. У нулевого порта
особая семантика, и в прикладных программах им не пользуются. Поэтому правильно
отсчитывать порт с единицы. Вероятность, что в языке предусмотрен такой тип,
крайне мала.

Легче всего увидеть проблему на диапазоне дат. Единичная дата может быть сколь
угодно разумной, но диапазон накладывает ограничение: дата начала строго меньше
даты конца. Бизнес дополняет: разница в датах не больше недели, обе даты в
рамках текущего месяца.

В мире ООП знают об этой проблеме и решают ее классами. Программисты на Java
пишут классы \spverb|UnixPort| и \spverb|DateRange|. Условный
\spverb|UnixPort|~--- это класс с одним конструктором. Он принимает целое число
и выполняет проверки на диапазон. Если число отрицательное или выходит за рамки
1~--- $2^{16}$, конструктор бросает исключение. Программист уверен, что создал
новый тип. \emph{Это неверно~--- классы и типы не тождественны}.

Конструктор такого класса это обычный валидатор, проверка во времени
исполнения. Он неявно срабатывает, когда мы пишем \spverb|new UnixPort(8080)|.
Возникает иллюзия, что это тип, но на самом деле это проверка в рантайме. Плюс
удобство синтаксиса, так называемый \emph{сахар}.

В промышленных языках невозможно объявить класс так, чтобы выражение
\spverb|new UnixPort(-42)| приводило к ошибке компиляции. Это возможно только сторонними
утилитами или плагинами к IDE.

Код в конструкторе трудно использовать повторно. Предположим, два разработчика
написали классы \spverb|UnixPort| и \spverb|MyPort|. Первый класс проверяет порт
на диапазон и бросает исключение. Выгодно пользоваться этим классом, поскольку
он совмещен с валидацией. Однако сторонняя библиотека принимает
\spverb|MyPort|. Так возникает проблема конвертации: нужно извлечь <<сырой>>
порт из \spverb|UnixPort| и передать его в \spverb|MyPort|. Это лишний код и
путаница с классами.

Определим хорошие практики валидации: независимость от данных и
компоновка. \emph{Независимость} означает, что данные не привязаны к
валидации. Нет ничего плохого в том, что порт~--- это целое число. Пусть
библиотека принимает \spverb|integer|, а разработчик сам решит, как проверить
это число. Так у него появится выбор, насколько строгой должна быть проверка.

\emph{Компоновка} означает, что хорошо иметь несколько простых проверок, из
которых легко составить сложные. Пусть заданы проверки <<это>> и <<то>>,
и теперь нужны их комбинации: <<это \emph{и} то>>, <<это \emph{или} то>>.
В идеале компоновка занимает одну-две строки и считается тривиальной задачей.

Оба тезиса ложатся на функции. Вспомним, это объект с операцией
вызова. Функция-валидатор принимает значение и возвращает истину или ложь. Это
ответ на вопрос, было ли значение правильными или нет. Функция это объект
высшего порядка; другие функции принимают валидаторы и порождают их комбинации.

\section{Основы spec}

С багажом этих рассуждений мы подходим к тому, как работает
clojure.spec. Включим модуль spec в текущее пространство:

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
\end{verbatim}

Синоним \spverb|s| нужен, чтобы избежать конфликтов имен с модулем
\spverb|clojure.core|. Модуль spec несет макросы \spverb|s/and|, \spverb|s/or|
и другие, у которых ничего общего с обычными \spverb|and| и \spverb|or|. Считается
дурным тоном, есди имена одного модуля заменяют другие. Это называется \emph{затенением},
и мы рассмотрим проблему в отдельной главе. Пока что мы будем обращаться к spec
через синоним \emph{s}.

Главная операция в spec~--- задать новую спецификацию:

\begin{verbatim}
(s/def ::string string?)
\end{verbatim}

Макрос \spverb|s/def| принимает ключ и предикат. Он создал объект спеки из функции
\spverb|string?|. Затем поместил спеку в глобальный реестр под ключом \spverb|::string|.

Важно понимать, что \spverb|::string|~--- это не спека, а только ее
псевдоним. Макросы spec устроены так, что принимают не объект спеки, а ее
ключ. Далее они сами найдут спеку. Это удобно, потому что ключи глобальны. В
любом месте можно сослаться на \spverb|::string| без лишних импортов.

Вторым аргументом следует предикат \spverb|string?|. Предикат~--- это функция,
которая возвращает истину или ложь. Функция это все еще не спека, а строительный
материал. Спека оборачивает функцию в особый объект. Технически возможно на него
сослаться. Функция \spverb|s/get-spec| по ключу спеки возвращает ее
Java-объект. Однако, на практике он не пригодится.

\begin{verbatim}
(s/get-spec ::string)
#object[clojure.spec.alpha$reify 0x3e9dde1d]
\end{verbatim}

Спеки хранятся в глобальном реестре под своими ключами. Макрос \spverb|s/def| не
проверяет, была ли уже зарегистрирована такая спека. Если под этим ключом уже
была спека, мы потеряем ее старую версию.

Spec не позволит использовать ключи без пространства, например, просто
\spverb|:error| или \spverb|:message|. Это повышает риск конфликта ключей. Чтобы
избавиться от конфликтов, укажите ключи с текущим пространством:
\spverb|::error|, \spverb|::message|.

Самое простое, что можно сделать со спекой~--- проверить, подходит ли под нее
значение. Функция \spverb|s/valid?| принимает ключ спеки, значение и возвращает
\spverb|true| или \spverb|false|.

\begin{verbatim}
(s/valid? ::string 1)      ;; false
(s/valid? ::string "test") ;; true
\end{verbatim}

Пустая строка пройдет валидацию, но чаще всего это не имеет смысла. Пустая
строка в поле <<имя>> или <<заголовок>> означает ошибку. Объявим спеку, которая
в дополнение к строке проверяет, что она не пустая. Наивный способ это
сделать~--- усложнить предикат:

\begin{verbatim}
(s/def ::ne-string
  (fn [val]
    (and (string? val)
         (not (empty? val)))))
\end{verbatim}

\noindent
Быстрая проверка:

\begin{verbatim}
(s/valid? ::ne-string "test") ;; true
(s/valid? ::ne-string "")     ;; false
\end{verbatim}

Ключ \spverb|::ne-string| это сокращение от \emph{\textbf{n}on-\textbf{e}mpty string}.
Спека встречается так часто, что логично сэкономить на ее имени.

Более изящный способ объявить эту же спеку~--- объединить предикаты через
\spverb|every-pred|. Это функция, которая принимает предикаты и возвращает
супер-предикат. Он вернет истину когда истинны все предикаты.

\begin{verbatim}
(s/def ::ne-string
  (every-pred string? not-empty))
\end{verbatim}

Мы собираем новую сущность из старых. Это удачный способ: он короче и следует
функциональному стилю. Но еще лучше комбинировать не предикаты, а спеки. Макрос
\spverb|s/and| объединяет несколько предикатов и спек в новую сущность:

\begin{verbatim}
(s/def ::ne-string
  (s/and ::string not-empty))
\end{verbatim}

Так в Clojure строят сложные спеки. Объявляют примитивы и наращивают их
комбинации.

\section{Исключения}

Во время проверки spec не перехватывает исключения; о них заботится
программист. Рассмотрим пример~--- спеку для проверки URL-адреса. Проще всего
это сделать регулярным выражением:

\begin{verbatim}
(s/def ::url
  (partial re-matches #"(?i)^http(s?)://.*"))

(s/valid? ::url "test")            ;; false
(s/valid? ::url "http://test.com") ;; true
\end{verbatim}

\noindent
Что-то отличное от строки вызовет ошибку:

\begin{verbatim}
(s/valid? ::url nil)
Execution error (NullPointerException) at java.util.regex.Matcher...
\end{verbatim}

Причина в том, что \spverb|nil| попал в функцию \spverb|re-matches|. Функция
трактует аргумент как строку, что приводит к \spverb|NPE|. Следует писать спеки
так, чтобы они не бросали исключения. В примере с \spverb|::url| сначала
убедимся, что это строка, и только потом проверим на регулярное выражение.

\begin{verbatim}
(s/def ::url
  (s/and ::ne-string
         (partial re-matches #"(?i)^http(s?)://.*")))

(s/valid? ::url nil) ;; false
\end{verbatim}

Макрос \spverb|s/and| устроен так, что на первой неудаче цепь обрывается. Все,
что следует после \spverb|::ne-string|, не сработает. Теперь \spverb|nil| не
спровоцирует исключение.

По аналогии проверим возраст пользователя. Это два предиката: на число и
диапазон.

\begin{verbatim}
(s/def ::age
  (s/and int? #(<= 0 % 150)))

(s/valid? ::age nil) ;; false
(s/valid? ::age -1)  ;; false
(s/valid? ::age 42)  ;; true
\end{verbatim}

\section{Спеки-коллекции}

Выше мы проверяли примитивные типы или \emph{скаляры}. Это удобно для примеров,
но редко встречается в практике. Чаще проверяют не скаляры, а коллекции. Spec
предлагает макросы, чтобы задать спеки-коллекции из примитивов.

Макрос \spverb|s/coll-of| принимает предикат или ключ и возвращает
спеку-коллекцию. Она проверяет, что каждый элемент проходит валидацию. Вот так
мы определим список URL-адресов:

\begin{verbatim}
(s/def ::url-list (s/coll-of ::url))
\end{verbatim}

\noindent
Быстрая проверка:

\begin{verbatim}
(s/valid? ::url-list ["http://test.com" "http://ya.ru"])
;; true

(s/valid? ::url-list ["http://test.com" "dunno.com"])
;; false
\end{verbatim}

%% TODO: ref

Макрос \spverb|s/map-of| проверяет ключи и значения словаря. Вспомним поле
запроса \spverb|:params| из главы про веб-разработку. Его ключи кейворды, а
значения строки. На языке спеки это выглядит так:

\begin{verbatim}
(s/def ::params
  (s/map-of keyword? string?))

(s/valid? ::params {:foo "test"})  ;; true
(s/valid? ::params {"foo" "test"}) ;; false
\end{verbatim}

Отдельно поговорим о словарах. Проверка \spverb|s/map-of| довольно слабая, чтобы
покрыть все варианты. Факт того, что все значения строки не несет полезной
информации. Гораздо важнее знать, что в словаре именно те ключи, что мы
ожидаем. К тому же редко бывает так, что значения словаря одного типа. Наоборот,
чаще всего в словаре поля разных типов. Например, имя, возраст и дата.

В таких случаях используют макрос \spverb|s/keys|. Он выглядит как список
спек. Ключи спек совпадают с ключами словаря. Значения ключей проверяются
одноименными спеками.

Пусть страница задана словарем с двумя полями. Это \spverb|address|, строка URL
и \spverb|description|, текстовое описание. Объявим примитивы:

\begin{verbatim}
(s/def :page/address ::url)
(s/def :page/description ::ne-string)
\end{verbatim}

Обратите внимание на пространство ключей. Адрес и описание относятся к странице,
поэтому логично задать им свое пространство. Одноименные поля могут быть у
пользователя или товара. Пространство обещает, что спеки \spverb|:page/address|
и \spverb|:user/address| не заменят друг друга.

Составим спеку страницы:

\begin{verbatim}
(s/def ::page
  (s/keys :req-un [:page/address
                   :page/description]))
\end{verbatim}

В параметре \spverb|:req-un| вектор спек. Для каждой из них \spverb|s/keys| ищет
ключ с таким же именем в словаре и проверяет значение. Рассмотрим, что именно
означает \spverb|:req-un| и какие еще параметры принимает \spverb|s/keys|.

Имя \spverb|:req-un| состоит из двух частей: \emph{req} и \emph{un}. Это
признаки наличия ключа и его типа. \emph{Req} (анг. \emph{required}) означает,
что эти ключи должны быть в словаре. Если хотя бы одного ключа нет, получим
ошибку. Противоположный по смыслу параметр называется \emph{opt}
(анг. \emph{optional}). В нем указаны ключи, которых может не быть. Валидация
таких ключей происходит, только если они оказались в словаре.

Частичка \emph{un} означает \emph{unqualified}, то есть неполный ключ. При
проверке \emph{un}-ключей отбрасывают их пространство. Например, если указать
спеку \spverb|:page/address| в списке \spverb|:req-un|, то в словаре ищется ключ
\spverb|:address|, а не \spverb|:page/address|.

Неполные ключи попадаются в коде довольно часто. Мы получаем данные из чужих API
и баз данных. Эти системы не знают о пространствах имен, и мы игнорируем их. С
точки зрения Clojure пространства нужны, чтобы разделить одноименные поля у
разных сущностей. Например, \spverb|:user/name| и \spverb|:project/name|.
Исключения бывают, когда весь стек фирмы построен на Clojure. В этом случае
клиент и сервер шлют данные с полными ключами.

Различают следующие комбинации \spverb|req|, \spverb|opt| и \spverb|un|:

\begin{itemize}

\item
  \spverb|:req|~--- необходимые полные ключи,

\item
  \spverb|:req-un|~--- необходимые краткие ключи,

\item
  \spverb|:opt|~--- опциональные полные ключи,

\item
  \spverb|:opt-un|~--- опциональные краткие ключи.

\end{itemize}

У спеки \spverb|::page| все ключи обязательны и не учитывают
пространство. Составим для нее данные \emph{с ошибками}. Это может быть
неправильный адрес, пустое описание, пропавший ключ. Если каждый из словарей
ниже подставить в выражение \spverb|(s/valid? ::params <data>)|, результат будет
ложью.

\begin{verbatim}
{:address "clojure.org" ;; not a URL
 :description "Clojure Language"}

{:address "https://clojure.org/"
 :description ""} ;; empty string

{:address "https://clojure.org/"} ;; missing key

{:page/address "https://clojure.org/" ;; fq-keys
 :page/description "Clojure Language"}
\end{verbatim}

Обратите внимание на последний случай. Значения верны, но у ключей пространство
\spverb|:page|. Валидация не сработает, потому что спека отбросит его при
поиске. Чтобы последний пример сработал, измените спеку. Исправьте тип ключей
\spverb|:req-un| на \spverb|:req| (необходимые полные).

\begin{verbatim}
(s/def ::page-fq
  (s/keys :req [:page/address
                :page/description]))

(s/valid? ::page-fq
          {:page/address "https://clojure.org/"
           :page/description "Clojure Language"})
\end{verbatim}

Комбинированный пример. Добавим странице HTTP-статус, который мы получили при
последнем обращении к ней. Поле опционально, потому что если к странице еще не
обращались, в него нечего записать. Вот как выглядит новая спека:

\begin{verbatim}
(s/def :page/status int?)

(s/def ::page-status
  (s/keys :req-un [:page/address
                   :page/description]
          :opt-un [:page/status]))
\end{verbatim}

Словари без статуса и с правильным статусом проходят валидацию:

\begin{verbatim}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"})

(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status 200})
\end{verbatim}

Заметим, что \spverb|s/keys| различает \spverb|nil| и вхождение ключа. Если
статус \spverb|nil|, то он состоит в словаре. Сработает проверка \spverb|nil| на
\spverb|int?|, что приведет к ошибке валидации.

\begin{verbatim}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status nil})
;; false
\end{verbatim}

\section{Вывод значений}

До сих пор мы проверяли данные с помощью \spverb|s/valid?|. Функция возвращает
истину или ложь, что значит данные верны или нет. Но одной проверки
недостаточно. Бывает так, что данные корректны, но требуется привести их к
нужному типу.

Например, на вход поступило число в виде строки. Мы убедились, что строка
состоит из цифр и не превышает допустимой длины. Но и после валидации значение
осталось строкой. Приходится парсить его вручную. Код растет и начинает
<<шуметь>>. Хотелось бы, чтобы типы выводил какой-то механизм.

Spec предлагает такие возможности. Это функции \spverb|s/conformer| и
\spverb|s/conform| (от анг. \emph{conform}~--- подчиняться).

\spverb|S/conformer| принимает функцию вывода и оборачивает ее в
спеку-конформер. В свою очередь, функция вывода принимает исходное значение и
возвращает либо новое, либо ключ \spverb|:clojure.spec.alpha/invalid|, что
говорит об ошибке.

Функция \spverb|S/conform| принимает ключ спеки-конформера и данные. Если вывод
прошел без ошибок, результатом будет новое значение. Если с ошибками, вернется
все тот же ключ \spverb|invalid|.

Рассмотрим пример с выводом числа из строки. Чтобы различать спеку-конформер от
валидатора, к ее имени добавляют стрелку, что означает вывод, приведение типа.

\begin{verbatim}
(s/def ::->int
  (s/conformer
   (fn [value]
     (try
       (Integer/parseInt value)
       (catch Exception e
         ::s/invalid)))))
\end{verbatim}

Эту спеку передают в \spverb|s/conform| с данными:

\begin{verbatim}
(s/conform ::->int "42") ;; 42

(s/conform ::->int "dunno")
:clojure.spec.alpha/invalid
\end{verbatim}

Как и \spverb|s/valid?|, \spverb|s/conform| не перехватывает исключения в
процессе работы. Java устроена так, что вывод данных часто выбрасывает
исключения. Будет правильно перехватывать их и возвращать \spverb|::s/invalid|,
как в примере выше.

Обе спеки~--- валидатор и конформер~--- можно объединить через
\spverb|s/and|. Например, чтобы проверить тип перед выводом. В нашем случае
убедимся, что значение~--- строка. Так мы не допустим, чтобы в \spverb|parseInt|
попал \spverb|nil| или что-то другое:

\begin{verbatim}
(s/def ::->int+
  (s/and ::ne-string ::->int))

(s/conform ::->int+ nil)
:clojure.spec.alpha/invalid
\end{verbatim}

Теперь рассмотрим, как восстанавливать даты из строк. С этой проблеме знают
веб-разработчики. Формат JSON не поддерживает даты, поэтому их передают строкой
или числом секунд.

Понадобится функция разбора такой строки и небольшая обвязка, чтобы подружить ее
со спекой. Функция \spverb|read-instant-date| из модуля \spverb|clojure.instant|
читает дату из строки. Она лояльна к формату и учитывает много
случаев. Например, датой может быть только год.

\begin{verbatim}
(require '[clojure.instant :refer [read-instant-date]])
(read-instant-date "2019")
#inst "2019-01-01T00:00:00.000-00:00"
\end{verbatim}

Обернем функцию в спеку:

\begin{verbatim}
(s/def ::->date
  (s/and
   ::ne-string
   (s/conformer
    (fn [value]
      (try
        (read-instant-date value)
        (catch Exception e
          ::s/invalid))))))
\end{verbatim}

Как и с числом, перед разбором мы делаем минимальные проверки. Убеждаемся, что
это непустая строка, чтобы отсечь \spverb|nil| и другие значения без
смысла. Строка даты:

\begin{verbatim}
(s/conform ::->date "2019-12-31")
#inst "2019-12-31T00:00:00.000-00:00"
\end{verbatim}

\noindent
Дата и время:

\begin{verbatim}
(s/conform ::->date "2019-12-31T23:59:59")
#inst "2019-12-31T23:59:59.000-00:00"
\end{verbatim}

\section{Спеки-перечисления}

Иногда мы знаем заранее, какие значения принимает поле. Например, при вызове API
клиент передает архитектуру системы~--- 32 или 64 бита. Ради двух значений нет
смысла парсить число: подойдет \emph{перебор} или \emph{словарь}.

Перебор работает через макрос \spverb|case|. Он пробегает по вариантам строки и
возвращает аналогичные числа. Если ничего не найдено, сигналим об ошибке ключом
\spverb|::s/invalid|.

\begin{verbatim}
(s/def ::->bits
  (s/conformer
   (fn [value]
     (case value
       "32" 32
       "64" 64
       ::s/invalid))))

(s/conform ::->bits "32") ;; 32
(s/conform ::->bits "42") :clojure.spec.alpha/invalid
\end{verbatim}

Вариант со словарем. По заданному словарю ищем результат формой
\spverb|get|. Если не нашли значение, вернем тег \spverb|invalid|.

\begin{verbatim}
(def bits-map {"32" 32 "64" 64})

(s/def ::->bits
  (s/conformer
   (fn [value]
     (get bits-map value ::s/invalid))))
\end{verbatim}

Этот подход хорош тем, что опорная точка~--- словарь соответствий~--- живет в
отдельной переменной. Его легко дополнить новыми значениями или вынести в
конфигурацию. При этом логика проверки не изменится.

Похожим образом читают логические значения из строк. Нет единого соглашения о
том, как передать истину и ложь в тексте. Это может быть \spverb|True|,
\spverb|TRUE|, \spverb|1|, \spverb|on|, \spverb|yes| для истины и их
противоположности: \spverb|FALSE|, \spverb|no|, \spverb|off|... При разборе
таких значений их приводят к одному регистру. В Clojure \spverb|FALSE| и
\spverb|false|~--- это разные строки, даже если отправитель имел в виду одно и
то же. Сценарий выглядит так:

\begin{itemize}

\item
  убедиться, что значение это строка;

\item
  привести ее к нижнему регистру;

\item
  вывести значение по словарю или перебором.

\end{itemize}

\noindent
Конформер из реального проекта:

\begin{verbatim}
(s/def ::->bool
  (s/and
   ::ne-string
   (s/conformer clojure.string/lower-case)
   (s/conformer
    (fn [value]
      (case value
        ("true" "1" "on" "yes") true
        ("false" "0" "off" "no") false
        ::s/invalid)))))

\end{verbatim}

\noindent
В действии:

\begin{verbatim}
(s/conform ::->bool "True") ;; true
(s/conform ::->bool "yes")  ;; true
(s/conform ::->bool "0")    ;; false
\end{verbatim}

\section{Продвинутые техники}

Мы написали достаточно кода, чтобы увидеть одинаковые участки~--- паттерны. В
этом разделе мы вынесем их в служебные функции и макросы. Заодно рассмотрим
приемы, которые ускорят вашу работу.

\subsection{Множества}

Когда значения известны, на роль спеки подходит множество. Дело в том, что
множество ведет себя как функция одного аргумента. Если аргумент есть в нем,
получим сам аргумент. Если нет, результат будет \spverb|nil|. Предположим,
статус задачи может быть \spverb|todo|, \spverb|in_progress| и
\spverb|done|. Опишем спеку множеством этих значений:

\begin{verbatim}
(s/def ::status #{"todo" "in_progres" "done"})
(s/valid? ::status "todo") ;; true
\end{verbatim}

\subsection{Перечисления}

Множество не подходит в случаях, когда \spverb|false| и \spverb|nil| считают
верными значениями. \spverb|S/valid?| трактует их как неудачу. Если \spverb|nil|
или \spverb|false| входят в множество значений, их проверяют функцией
\spverb|contains?|:

\begin{verbatim}
(contains? #{1 :a nil} nil) ;; true
\end{verbatim}

Чтобы не повторяться, напишем функцию \spverb|enum|. Она принимает значения и
возвращает функцию-предикат. Этот предикат принимает один аргумент и проверяет,
есть ли такой среди исходных значений.

\begin{verbatim}
(defn enum [& args]
  (let [arg-set (set args)]
    (fn [value]
      (contains? arg-set value))))
\end{verbatim}

Функция внутри замкнута на переменной \spverb|arg-set|. Это множество, которое
получили из списка аргументов. Мы создали его один раз, чтобы не делать это
постоянно при вызове внутренней функции. Теперь перечисления выглядят коротко и
ясно:

\begin{verbatim}
(s/def ::status
  (enum "todo" "in_progres" "done"))
\end{verbatim}

\subsection{With-conformer}

Спеки-конформеры требуют особого внимания. В них легко допустить ошибку: не
перехватить исключение или не обернуть функцию в \spverb|s/conformer|. Перенесем
рутину в макрос \spverb|with-conformer|. Он принимает символ переменной и
произвольное тело. Макрос порождает функцию одного аргумента. Она исполняет тело
в блоке \spverb|try/catch|. Если исключения не было, результатом будет последнее
выражение тела. В противном случае вернется тег \spverb|invalid|.

\begin{verbatim}
(defmacro with-conformer
  [bind & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))))
\end{verbatim}

\noindent
Ниже примеры из реального проекта. Вывод числа:

\begin{verbatim}
(s/def ::->int
  (s/and
   ::ne-string
   (with-conformer val
     (Integer/parseInt val))))
\end{verbatim}

\noindent
Вывод логического типа:

\begin{verbatim}
(s/def ::->bool
  (s/and
   ->lower
   (with-conformer val
     (case val
       ("true"  "1" "on"  "yes") true
       ("false" "0" "off" "no" ) false))))
\end{verbatim}

\noindent
Переменная \spverb|->lower| это тоже обертка для приведения регистра:

\begin{verbatim}
(def ->lower
  (s/and
    string?
    (s/conformer clojure.string/lower-case)))
\end{verbatim}

В примере с \spverb|case| необязательно указывать \spverb|invalid| на конце
макроса. Если \spverb|case| не нашел ветку и не задан вариант по умолчанию, он
бросит исключение. \spverb|With-conformer| перехватит его и вернет
\spverb|invalid|.

\section{Логические пути}

Функция \spverb|s/conform| не всегда возвращает то, что мы ожидаем. Некоторые
спеки оборачивают результат в вектор, где первый элемент~--- логический путь. Он
появляется в тех случаях, где проверка ветвится.

Выше мы объединяли спеки через \spverb|s/and|. Такая супер-спека проходит по
дочерним и проверяет данные. Иногда этого недостаточно: требуется
спека-развилка. Например, если значение число, то оставить его как есть, а если
строка, то привести к числу. Такие спеки называют условными (анг. \emph{conditional}).

Макрос \spverb|s/or| описывает условную спеку. Он принимает дочерние спеки и
теги. Макрос применяет значение к спекам до первого удачного случая. В
результате получим пару из нового значения и тега той спеки, что дала
положительный результат.

Тег становится частью логического пути, по которому шла проверка. Логический
путь помогает расследовать, в каком месте произошла ошибка. Для простых спек
обычно это не проблема. Но в реальных проектах условная спека вложена в другую
условную, та тоже и так далее. Найти ошибку без логического пути будет трудно.

Если валидация не прошла, логический путь получают из отладочной информации. Ее
возвращают функции семейства \spverb|s/explain*|, которые мы рассмотрим ниже.

Напишем спеку сетевого порта, которая принимает число или строку. Во втором
случае спека парсит ее в число. Это полезно, если значение приходит из
переменной среды или ini-файла.

\begin{verbatim}
(s/def ::smart-port
  (s/or :string ::->int :num int?))
\end{verbatim}

Теперь \spverb|s/conform| вернет не просто значение, а пару с тегом:

\begin{verbatim}
(s/conform ::smart-port 8080)
[:num 8080]

(s/conform ::smart-port "8080")
[:string 8080]
\end{verbatim}

Если в спеке был условный узел (\spverb|s/or|, \spverb|s/alt|), то структура
\spverb|s/conform| отличается от входных данных. Например, на месте скаляра
появится вектор. Покажем это на примере. Пусть порт~--- одно из полей
подключения к базе данных.

\begin{verbatim}
(s/def :conn/port ::smart-port)
(s/def ::conn
  (s/keys :req-un [:conn/port]))
\end{verbatim}

Топология результата отличается от входных данных:

\begin{verbatim}
(s/conform ::conn {:port "9090"})
{:port [:string 9090]}
\end{verbatim}

\section{Анализ ошибок}

Когда данные неверны, \spverb|s/valid?| и \spverb|s/conform| возвращают
\spverb|false| и \spverb|::s/invalid|. Этого недостаточно, чтобы понять причину
ошибки. Представьте, что у вас спека пользователя. У него несколько адресов, в
каждом адресе несколько строк (line 1, line 2),... и проверка вернула \spverb|false|.
Ручной поиск ошибки в таком дереве займет день.

Функции семейства \spverb|s/explain| принимают спеку и данные. Если ошибок не
было, результат будет пустым. Если были, мы получим отчет о проверке. Это
словарь, где указаны проблемные значения, спеки, пути к ним и другие
данные. Разница между функциями в том, как они поступают с отчетом.

\begin{itemize}

\item
  \spverb|s/explain| печатает его в стандартный поток (на экран);

\item
  \spverb|s/explain-str| возвращает отчет в виде строки;

\item
  \spverb|s/explain-data| возвращает словарь с данными. Это самый полный отчет
  об ошибке.

\end{itemize}

Попробуем \spverb|s/explain| и \spverb|s/explain-str| в действии. Их результат
одинаковый, разница в том, куда приходит текст~--- в консоль или переменную.
Подготовим простую спеку:

\begin{verbatim}
(s/def :sample/username ::ne-string)

(s/def ::sample
  (s/keys :req-un [:sample/username]))
\end{verbatim}

На корректных данных функции не проявляют себя; \spverb|s/explain| печатает
\spverb|Success!|:

\begin{verbatim}
(s/explain ::sample {:username "some user"})
Success!
nil

(s/explain-data ::sample {:username "some user"})
nil
\end{verbatim}

Теперь ошибки. Попробуем число вместо имени:

\begin{verbatim}
(s/explain ::sample {:username 42})
42 - failed: string? in: [:username]
at: [:username] spec: ::string
\end{verbatim}

Вывод читается так: значение \spverb|42| не прошло проверку предикатом
\spverb|string?|. Путь к значению внутри словаря \spverb|[:username]|.
Ключ спеки, где случилась ошибка -- \spverb|::string|.

Отчет показывает наиболее вложенные спеки и предикаты. Вспомним, что
\spverb|::ne-string| это комбинация \spverb|::string| и
\spverb|not-empty|. Ошибка случилась на этапе \spverb|::string|, о чем и было
сказано.

Для пустой строки вывод будет другим. На этот раз причиной станет
\spverb|not-empty|. Проверим это:

\begin{verbatim}
(s/explain ::sample {:username ""})
"" - failed: not-empty in: [:username]
at: [:username] spec: ::ne-string
\end{verbatim}

Со временем вы научитесь читать \spverb|explain|. Это быстрый способ сообщить о
проблеме, например, в конфигурации или JSON-файле. Но чем сложнее данные, тем
меньше понятен \spverb|explain|. Когда в коллекции больше трех уровней, отчет
заливает экран машинным выхлопом. Его трудно даже разбить на части, не говоря уж
о понимании.

Чтобы подружить \spverb|explain| с человеком, нужно промежуточное звено. Речь о
нем пойдет в следующем разделе.

\section{Понятные ошибки}

Когда проверяют данные, важен не только факт ошибки. Еще важнее объяснить
клиенту, что не так с его данными. Под клиентом не обязательно имеют в виду
человека. Даже если это другая программа, в ответ добавляют понятный
текст. Скорее всего, программа ведет журнал, который читают сотрудники.

Часто мы видим сообщения вроде <<Ошибка: DATAERROR>> без каких-либо деталей. Или
красную надписью <<проверьте данные>> над формой в два экрана. Этих глупостей
можно было избежать, умей программисты переводить язык машины в человеческий.

Фраза \spverb|"" - failed: not-empty in: [:username]| не только ничего не скажет
пользователю, но и отпугнет его машинной природой. Возникнет ощущение, что в
интерфейсе возникла брешь, и пользователь видит то, что не должен. Это резко
снижает доверие к системе.

Чтобы составить сообщение об ошибке, вернемся к функции \spverb|s/explain-data|.
Она возвращает словарь с нужной информацией. Пример такого отчета:

\begin{verbatim}
(s/explain-data ::sample {:username ""})

#:clojure.spec.alpha
{:problems
 ({:path [:username]
   :pred clojure.core/not-empty
   :val ""
   :via [::sample ::ne-string]
   :in [:username]})
 :spec ::sample
 :value {:username ""}}
\end{verbatim}

На первый взгляд непонятно, что с ним делать. К сожалению, некоторые инженеры
пасуют перед проблемой и говорят, что spec не подходит для ошибок. Это не так. В
отчете все необходимые данные, нужно только правильно их обработать.

Новички задают вопрос~--- почему бы не сделать понятные сообщения на уровне
библиотеки? Например, назначить спеке дополнительное поле с текстом <<введите
правильный адрес>>? Почему не взять пример с библиотек для Python или
JavaScript?

Ответ на вопрос не устраивает новичков. Вспомним тезис из начала главы. Spec~---
это \emph{фундаментальная библиотека}. Она не предназначена для проверки
ввода. Это набор абстракций и примитивов. То, что мы проверяем спекой
HTML-форму~--- всего лишь частный случай. Далее мы убедимся, что у спеки разные
области применения. Поэтому структура ошибки тоже фундаментальна.

Кроме того, трудно создать систему ошибок, которая устроит всех. В каждом
проекте свои правила о том, как показывать ошибки. Иногда это фиксированное
сообщение, а в других случаях шаблон. Теперь добавим локализацию. В зависимости
от языка покажем сообщения на английском, русском, французском. Это очень, очень
сложные сценарии.

Если бы разработчики spec занялись ошибками, их фокус был бы смещен с главной
цели. Вместо spec мы бы получили валидаторы по типу тех, что пишут десятками для
Python и JavaScript. Они скучны, не гибки и без концепции.

Словарь \spverb|explain-data| содержит ключи \spverb|:spec|, \spverb|:value| и
\spverb|:problems| с префиксом \spverb|clojure.spec.alpha|. Первые два это спека
и значение, которые приняли участие в проверке. Нас интересует поле
\spverb|problems|. Это список словарей; каждый словарь описывает ошибку
валидации. Перечислим его поля и семантику.


\begin{itemize}

\item
  \spverb|:path|~--- логический путь валидации. Вектор ключей, где спеки чередуются с
  тегами-развилками. Условные спеки типа \spverb|s/or| пишут сюда свои метки.

\item
  \spverb|:pred|~--- полный символ предиката, например \spverb|clojure.core/string?|.

\item
  \spverb|:val|~--- конкретное значение, которое не прошло проверку на
  предикат. Например, 42, \spverb|nil|, элемент словаря.

\item
  \spverb|:via|~--- цепочка спек, по которым прошло значение от верхнего уровня
  к нижнему.

\item
  \spverb|:in|~--- физический путь к значению. Вектор ключей и индексов, который передают
  в функцию \spverb|get-in|. Если выполнить \spverb|(get-in <исходные-данные> <путь>)|,
  получим значение, которое вызвало ошибку.

\end{itemize}

В отчете все необходимое, чтобы собрать сообщение. Из \spverb|:val| возьмем
проблемное значение. Спека, на которой прервалась валидация это последний
элемент вектора \spverb|:via|.

Составим словарь сообщений, где ключ~--- спека, а значение~--- понятный текст
или шаблон. Зная спеку, которая вызвала ошибку, получим из словаря текст. В
нашем случае последний элемент \spverb|:via| это \spverb|::ne-string|. Назначим
ей сообщение "Строка не должна быть пустой" или что-то похожее.

\begin{verbatim}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"})
\end{verbatim}

Наивная функция, которая принимает словарь ошибки (один из элементов
\spverb|::s/problems|) и возвращает понятное сообщение:

\begin{verbatim}
(defn get-message [problem]
  (let [{:keys [via]} problem
        spec (last via)]
    (get spec-errors spec)))

(get-message {:via [::sample ::ne-string]})
"Строка не должна быть пустой"
\end{verbatim}

Проверим способ на других полях. В спеку \spverb|::sample| добавим поле
электронной почты:

\begin{verbatim}
(s/def ::email
  (s/and
   ::ne-string
   (partial re-matches #"(.+?)@(.+?)\.(.+?)")))

(s/def :sample/email ::email)

(s/def ::sample
  (s/keys :req-un [:sample/username
                   :sample/email]))
\end{verbatim}

Спека \spverb|::email| убеждается, что строка не пустая и совпадает с шаблоном
адреса. Шаблон требует, чтобы в адресе был символ \spverb|@| и точка.

Если передать в \spverb|email| пустую строку, последним элементом \spverb|via|
будет \spverb|::ne-string|. Для экономии места сократим вывод
\spverb|explain-data|:

\begin{verbatim}
(s/explain-data ::sample {:username "test" :email ""})

{:path [:email]
 :pred clojure.core/not-empty
 :val ""
 :via [::sample ::email ::ne-string]
 :in [:email]}
\end{verbatim}

Теперь вызовем \spverb|get-message| с этой ошибкой. Получим сообщение о пустой
строке. Предположим теперь, почта была строкой, которая не попала под
шаблон. Тогда последним элементом \spverb|:via| будет
\spverb|:sample/email|. Полный словарь ошибки выглядит так:

\begin{verbatim}
{:path [:email]
 :pred
 (clojure.core/partial
  clojure.core/re-matches
  #"(.+?)@(.+?)\.(.+?)")
 :val "test"
 :via [::sample ::email]
 :in [:email]}
\end{verbatim}

Чтобы \spverb|get-message| вернул другое сообщение, добавим в словарь ошибок
ключ \spverb|::email|:

\begin{verbatim}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   ::email "Введите правильный почтовый адрес"})
\end{verbatim}

Остается наращивать словарь все новыми спеками и сообщениями, пока не покроем
все варианты. Это линейный подход; ниже мы рассмотрим способы улучшить его.

\subsubsection{Сообщение по умолчанию}

Что случится, если перевода нет в словаре? В этом случае вернем что-то
нейтральное, например, <<исправьте ошибку в данных>>. Заодно запишем в лог
событие с именем спеки. Лог настроен так, что сообщения из этого модуля идут в
отдельный файл. Позже локализаторы прочтут его и добавят перевод.

\begin{verbatim}
(def default-message
  "Исправьте ошибку в данных")

(defn get-better-message [problem]
  (let [{:keys [via]} problem
        spec (last via)]
    (or (get spec-errors spec)
        (do (log/debugf "missing message for spec %s" spec)
            default-message))))
\end{verbatim}

\subsubsection{Гибкий поиск}

Упростим поиск ключа в словаре. Поле \spverb|email| встречается в разных спеках:
\spverb|:account/email|, \spverb|:patient/email| и других. Согласно методу выше,
каждый из ключей должен быть в словаре. Это склоняет нас к повторам в коде.

Чтобы не засорять словарь, пойдем на хитрость. Пусть функция ищет перевод по
полному ключу, а в случае неудачи~--- по его имени. Тогда достаточно ключа
\spverb|:email|, и все емейлы сойдутся на этот перевод. Если для конкретного
\spverb|:account/email| нужен особый перевод, добавим его полную версию в словарь:

\begin{verbatim}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   :email "Введите правильный почтовый адрес"
   :account/email "Особое сообщение для адреса отправителя"})
\end{verbatim}

\noindent
Обновим поиск с учетом неполного ключа и ошибки по умолчанию:

\begin{verbatim}
(defn get-better-message
  [problem]
  (let [{:keys [via]} problem
        spec (last via)]
    (or (get spec-errors spec)
        (get spec-errors (-> spec name keyword))
        default-message)))
\end{verbatim}

Система, которую мы построили, довольно проста. Ее легко тестировать и изменять
под нужды конкретного проекта. Доработанные версии этой системы работают в
боевых проектах. В одном из них формы проверяют на клиенте до отправки на
сервер. Это возможно: мощь clojure.spec в полной мере доступна в ClojureScript.

\subsubsection{Шаблон}

Если вариант со словарем кажется сложным, попробуйте сообщение по шаблону. Такое
сообщение складывается из имени поля и значения, например: <<в поле email
неверное значение test>>.  Очевидно, его легко получить функцией
\spverb|format|. Такой ответ подойдет большинству HTTP API.

Имя поля получим как последний отличный от цифры элемент \spverb|:in|. Это
наиболее вложенное поле; цифры означают индексы вектора, поэтому их
отбрасывают. Значение поля в ключе \spverb|:val| словаря ошибки.

\begin{verbatim}
(defn get-common-message [problem]
  (let [{:keys [in val]} problem
        field (last (remove int? in))]
    (format "The field `%s` has got an incorrect value `%s`."
            (name field) val)))
\end{verbatim}

Проверим, что вернет функция. Поле и значение обернули в кавычки, чтобы выделить
их из общего текста.

\begin{verbatim}
(get-common-message {:in [::user :user/email] :val "test"})
The field `email` has got an incorrect value `test`.
\end{verbatim}

\subsection{Открытые вопросы}

За рамками остались несколько вопросов. Они слишком общие, чтобы претендовать на
одно решение. В этом разделе мы не будем писать код, а только порассуждаем.

Что делать, если требуется \emph{локализация}, то есть вывод сообщения на русском или
английском в зависимости от состояния? Переделаем словарь ошибок. Он станет
вложенным словарем, где на первом уровне код локали (\spverb|ru|, \spverb|en|),
а на втором~--- переводы спек.

На первом шаге мы получаем по локали словарь переводов. Затем переводим
сообщение как описано выше. С кодом локали тоже можно схитрить, чтобы облегчить
поиск. Для отдельных слов выделяют более точные локали, например, американский и
британский английский с кодами \spverb|en_US| и \spverb|en_GB|. Напишем поиск
так, что сперва он ищет по младшей локали (\spverb|en_US|), а затем по старшей
(\spverb|en|). Если американского текста не оказалось, получим нейтральный
английский. Этот подход работает для перевода текста в широком смысле, не только
ошибок.

Вопрос откуда читать локаль остается на ваше усмотрение. Можно хранить ее в
сессии, параметрах запроса, базе данных, словом~--- как это удобно в текущем
проекте.

Второй вопрос~--- как связать ошибки с \emph{интерфейсом}. Это тоже зависит от того,
как устроен проект. Принято отделять модель от ее представления; это касается и
форм. Удобно, когда форма~--- это структура данных, вложенный словарь.
Тогда операции над ней это чистые функции, которые легко поддерживать.

Представим форму в виде дерева. Ключи это поля, а значения виджеты. Виджет знает
тип поля, текущее значение и ошибку. На каждый лист подписан React-компонент.
При изменении виджета он рисует HTML-элемент, например, поле ввода с текущим текстом.
Если поле ошибки не \spverb|nil|, его выводят над полем.

Валидаця принимает форму и строит дерево значений. Это данные с той же
топологией, но вместо виджетов на их местах значения. С помощью спеки мы
проверяем значения (\spverb|s/valid?|) или выводим типы из строк. В случае
ошибки мы получаем отчет (\spverb|s/explain-data|). Для каждого элемента из поле
\spverb|problems| находим путь, спеку и сообщение об ошибке. Это сообщение
добавляем виджету в поле \spverb|:error|. Компонент, который подписан на виджет,
заново отрисует его с ошибкой над полем.

В последнем абзаце мы упомянули формы, React и проблемы интерфейса. Все вместе
это называется фронтенд. Это большая и сложная тема, которая заслуживает
отдельной книги. Далее мы не будем отвлекаться на фронтенд. Автор надеется, что
в будущем эта книга появится.

\section{Парсинг}

Мы знаем, как проверять данные и выводить типы. Перейдем к операции высокого
уровня~--- парсингу. Под термином понимают разбор данных на части, выделение
структуры там, где прежде ее не было.

Возможно, вам приходилось писать регулярные выражения. Это шаблоны, которые
описывают структуру текста. Специальные функции принимают текст и регулярное
выражение. Они возвращают фрагменты текста, которые совпали с шаблоном.

Пример регулярного выражения~--- IP-адрес. Это четыре группы, разделенные
точками. Каждая группа состоит из числа от 0 до 255.

\begin{verbatim}
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
\end{verbatim}

В этом шаблоне мы ставим косую черту перед точкой. В регулярных выражениях точка
это служебный символ. Мы экранируем его, чтобы указать именно на символ точки.

В регулярных выражениях применяют операторы \spverb|+|, \spverb|?|, \spverb|*| и
другие. Они указывают, сколько раз встречается то, что перед ним. Например, один
и более раз, ни одного или один, произвольное число. В зависимости от
модификатора шаблон захватывает разные части текста.

Представьте, что регулярные выражения откусывают текст частями. Та часть, что
легла на шаблон, уходит в результат. Остаток переходит к следующему шаблону, и
так далее.

Регулярные выражения подводят нас к \spverb|regex|-спекам. Это особые спеки для
разбора данных по шаблону. Разница в том, что и шаблон, и входные данные это
коллекции, а не текст.

\subsection{Простой разбор}

Предположим, из файла читают пользователей. Каждый из них это кортеж вида
<<номер, емейл, статус>>. Все значения в виде текста. Для каждого пользователя
требуется:

\begin{itemize}

\item
  убедиться, что в кортеже именно три элемента;

\item
  привести номер к числу;

\item
  проверить емейл на минимальные критерии;

\item
  привести статус к перечислению (константе).

\item
  получить словарь с верными значениями.

\end{itemize}

Мы уже знакомы с \spverb|s/conformer|. Модно написать функцию, которая принимает
кортеж и выполняет действия выше. Технически это несложно. Но такая функция
будет монолитом со слишком большим \emph{скоупом}. Это плохая практика при
работе со spec.

Спека \spverb|s/cat| служит для разбора коллекций. Она принимает набор тегов и
других спек. На вход подают коллекцию, например, список или
вектор. \spverb|S/cat| накладывает ее элементы на спеки. Если они совпали,
результатом будет словарь. Ключи этого словаря~--- теги, значения~--- вызов
дочерней спеки с элементом.

Составим спеку для разбора кортежа. Мы уже писали вывод чисел и проверку почты;
они пригодятся в задаче. Опишем статус и соберем композицию спек:

\begin{verbatim}
(s/def :user/status
  (s/and ->lower
         (with-conformer val
           (case val
             "active"  :USER_ACTIVE
             "pending" :USER_PENDING))))

(s/def ::user
  (s/cat :id ::->int
         :email ::email
         :status :user/status))
\end{verbatim}

\noindent
Проверим положительный случай:

\begin{verbatim}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1
 :email "test@test.com"
 :status :USER_ACTIVE}
\end{verbatim}

Варианты с плохим номером, почтой или не тем статусом не проходят
разбор. Примеры ниже вернут \spverb|::s/invalid|:

\begin{verbatim}
(s/conform ::user ["" "test@test.com" "active"])
(s/conform ::user ["1" "@test.com" "active"])
(s/conform ::user ["1" "test@test.com" "unknown"])
\end{verbatim}

\subsection{Условный разбор}

В примере выше поля в кортеже не меняются. На практике так бывает не
всегда. Иногда мы работаем с устаревшими форматами данных. В них бывают условия
вроде <<если перед номером стоит метка \spverb|BLOCKED|, пользователь
заблокирован>>. Например:

\begin{verbatim}
blocked;1;test@test.com;active
\end{verbatim}

Это усложняет задачу, ведь теперь кортеж состоит из трех или четырех
элементов. Сдвигается семантика полей: первый элемент не только номер, но и флаг
блокировки. Бывают и более сложные условия, особенно в старых форматах.

В императивных языках вроде Python и Java такие требования порождают каскад
\spverb|if/else|. В Clojure эту проблему решают декларативно. Объявим спеку
блокировки:

\begin{verbatim}
(s/def ::blocked
  (s/and
   ->lower
   (s/conformer
    #(= % "blocked"))))
\end{verbatim}

Добавим ее в итоговую \spverb|s/cat|, но укажем, что она встречается ни разу и
только один раз. Для этого \spverb|::blocked| оборачивают спеку в \spverb|s/?|.
В регулярных выражениях знак вопроса делает то же самое.

\begin{verbatim}
(s/def ::user
  (s/cat :blocked (s/? ::blocked)
         :id ::->int
         :email ::email
         :status :user/status))
\end{verbatim}

Теперь оба кортежа совпадают со спекой \spverb|::user|. Если пользователь
заблокирован, в словаре будет поле \spverb|:blocked|:

\begin{verbatim}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1 :email "test@test.com" :status :USER_ACTIVE}

(s/conform ::user ["Blocked" "1" "test@test.com" "active"])
{:blocked true :id 1 :email "test@test.com" :status :USER_ACTIVE}
\end{verbatim}

Усложним задачу. Представим, что на входе коллекция кортежей. Чтобы не утруждать
себя итерацией, объявим спеку-коллекцию:

\begin{verbatim}
(s/def ::users (s/coll-of ::user))

(def user-data
  [["1" "test@test.com" "active"]
   ["Blocked" "2" "joe@doe.com" "pending"]])

(s/conform ::users user-data)
[{:id 1 :email "test@test.com" :status :USER_ACTIVE}
 {:blocked true :id 2 :email "joe@doe.com" :status :USER_PENDING}]
\end{verbatim}

Отсеять заблокированных пользователей можно функцией \spverb|filter| с
предикатом \spverb|(complement :blocked)|.

\subsection{Практика}

С помощью спек парсят не только данные, но и текст. Рассмотрим, как прочитать
INI-файл в словарь данных. Напомним, INI~--- это старый формат для конфигурации
приложений. Он состоит из заголовков в квадратных скобках и пар <<поле =
значение>>. Пример условного \spverb|config.ini|:

\begin{verbatim}
[database]
host=localhost
port=5432
user=test

[server]
host=127.0.0.1
port=8080
\end{verbatim}

Хотелось бы получить словарь, где на первом уровне заголовки, а под ними~---
пары полей и значений.

\begin{verbatim}
{:database {:host "localhost"
            :port 5432}
 :server {:host "127.0.0.1"}}
\end{verbatim}

Если отбросить пустые строки и комментарии, формат сводится к грамматике
\spverb|(title, (key=value)*)*|, где звездочка означает сколько угодно раз, в
том числе ничего.

Для начала прочитаем строки из файла. Это еще не спека, а вспомогательная
функция. Спеки не должны иметь побочных эффектов; они только обрабатывают
данные.

\begin{verbatim}
(require '[clojure.java.io :as io])

(defn get-ini-lines [path]
  (with-open [src (io/reader path)]
    (doall (line-seq src))))
\end{verbatim}

Напишем парсер. Спека принимает строки из ini-файла. Выполним следующие шаги:

\begin{itemize}

\item
  удалим пустые строки и комментарии;

\item
  оставшиеся строки сгруппируем по заголовкам;

\item
  разберем пары <<поле = значение>>;

\item
  построим вложенный словарь;

\item
  выведем типы и все проверим.

\end{itemize}

Будем писать по принципу <<сверху вниз>>, как будто все компоненты уже готовы, и
осталось соединить их. Ниже~--- спека, которая покрывает нашу задачу:

\begin{verbatim}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)
   (s/conformer remap-ini-data)
   ::ini-config))
\end{verbatim}

Напишем недостающие элементы. Функция \spverb|clear-ini-lines| отбрасывает
пустые строки и комментарии. В формате ini комментарии начинаются с символа
решетки.

\begin{verbatim}
(require '[clojure.string :as str])

(defn comment? [line]
  (str/starts-with? line "#"))

(defn clear-ini-lines [lines]
  (->> lines
       (filter (complement str/blank?))
       (filter (complement comment?))))
\end{verbatim}

Спека \spverb|(s/* :ini/section)| читается как <<ноль и более секций>>. Под
секцией мы понимаем заголовок и произвольное число пар <<поле =
значение>>. Запишем ее в виде \spverb|s/cat|:

\begin{verbatim}
(s/def :ini/section
  (s/cat :title :ini/title :fields (s/* :ini/field)))
\end{verbatim} 

Объявим \spverb|:ini/title|. Она проверяет, что строка это заголовок. Согласно
формату, заголовок пишут в квадратных скобках. Если это так, вернем текст без
них:

\begin{verbatim}
(s/def :ini/title
  (s/and
   #(str/starts-with? % "[")
   #(str/ends-with? % "]")
   (with-conformer line
     (subs line 1 (dec (count line))))))
\end{verbatim}

Более короткая запись этой же спеки. Здесь мы пользуемся регулярными
выражениями, чтобы извлечь текст из скобок:

\begin{verbatim}
(s/def :ini/title
  (with-conformer line
    (or (second (re-matches #"^\[(.+)\]$" line))
        ::s/invalid)))
\end{verbatim}

Спека \spverb|:ini/field| парсит поле и значение. Мы разбиваем строку по знаку
равенства. Цифра 2 означает, что в итоговом списке должно быть не более двух
элементов: ключ и значение. Это полезно, когда значение содержит знак равенства
(например, base64-строка).

\begin{verbatim}
(s/def :ini/field
  (with-conformer line
    (let [pair (str/split line #"=" 2)]
      (if (= (count pair) 2)
        pair
        ::s/invalid))))
\end{verbatim}

Выше мы убеждаемся, что действительно получили пару. В противном случае сигналим
об ошибке. Запустим урезанную версию спеки. Обернем ее в функцию
\spverb|parse-ini|, которая читает файл.

\begin{verbatim}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* :ini/section)))

(defn parse-ini [path]
  (let [lines (get-ini-lines path)]
    (s/conform ::->ini-config lines)))
\end{verbatim}

\noindent
Черновой результат:

\begin{verbatim}
(parse-ini "config.ini")

[{:title "database"
  :fields [["host" "localhost"]
           ["port" "5432"]
           ["user" "test"]]}
 {:title "server"
  :fields [["host" "127.0.0.1"]
           ["port" "8080"]]}]
\end{verbatim}

Разбор прошел удачно. Читатель заметит, что структура отличается от той, что мы
планировали. Это неважно. Главное, мы вывели данные из текста. Не составит труда
привести словарь к нужному виду. Напишем функцию \spverb|remap-ini-data|:

\begin{verbatim}
(defn remap-ini-data [data-old]
  (reduce
   (fn [data-new entry]
     (let [{:keys [title fields]} entry]
       (assoc data-new title (into {} fields))))
   {}
   data-old))
\end{verbatim}

\noindent
Если передать в нее вектор из последнего шага, получим то, что ожидали:

\begin{verbatim}
{"database" {"host" "localhost" "port" "5432" "user" "test"}
 "server" {"host" "127.0.0.1" "port" "8080"}}
\end{verbatim}

Напишем спеку, чтобы проверить данные и вывести типы. Например, чтобы номера
портов были числами:

\begin{verbatim}
(s/def :db/host ::ne-string)
(s/def :db/port ::->int)
(s/def :db/user ::ne-string)

(s/def ::database
  (s/keys :req-un [:db/host :db/port :db/user]))

(s/def :server/host ::ne-string)
(s/def :server/port ::->int)

(s/def ::server
  (s/keys :req-un [:server/host :server/port]))

(s/def ::ini-config
  (s/keys :req-un [::database ::server]))
\end{verbatim}

Последний штрих~--- исправить тип ключей в словаре данных. Сейчас это строки, но
спека \spverb|::ini-config| ожидает ключи. Модуль \spverb|walk| предлагает
функцию \spverb|keywordize-keys| на этот случай. Она обходит словарь любой
вложенности и меняет ключи. Вот как выглядит итоговая спека:

\begin{verbatim}
(require '[clojure.walk :as walk])

(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* (s/cat :title :ini/title :fields (s/* :ini/field)))
   (s/conformer remap-ini-data)
   (s/conformer walk/keywordize-keys)
   ::ini-config))
\end{verbatim}

\noindent
Результат:

\begin{verbatim}
(parse-ini "config.ini")

{:database {:host "localhost"
            :port 5432
            :user "test"}
 :server {:host "127.0.0.1"
          :port 8080}}
\end{verbatim}

Получились красивые данные из текста. Поздравляем! Обратите внимание, что в коде
нет состояния, и в целом он выглядит как цепочка шагов. Парсер задан
декларативно; фактически, это разбор текста грамматиками.

\emph{Упражнение:} устраните мелкие недостатки в коде. Пусть пара
\spverb|"foo="| становится \spverb|{:foo nil}|, а не \spverb|{:foo ""}|.
Удалите пустые символы из имен полей и значений. Опробуйте код на больших
ini-файлах.

\section{Разбор кода (теория)}

В завершение темы поговорим о том, как парсить код. Мы уже видели, что
clojure.spec подходит для разбора коллекций. Код на Clojure состоит из
списков. Это приводит к неожиданному решению: оказывается, код можно проверить
спекой и вернуть ошибку до того, как он запущен.

В начале главы мы упоминали, что Clojure и Spec неразрывно связаны. Объясним
связь на макросах. Это особые функции, которые работают на этапе
компиляции. Макрос принимает код как список символов. В коде могут быть ошибки
синтаксиса, но макрос об этом ничего не знает: у него просто список символов.

Задача макроса в том, чтобы перестроить список в другой, понятный
Clojure. Компилятор заменяет вызов макроса на то, что он вернул, и запускает
код. Макросы это отдельная веха в изучении Clojure. Мы поговорим о них в другой
главе; пока что рассмотрим, как проверить макрос спекой.

Каждый макрос это мини-язык с соглашением о том, что подавать на вход. В простых
случаях код парсят функциями first, rest и условиями. Сложные макросы разбирают
грамматиками, как мы делали это с ini-файлом. Если код нарушает правила, мы
должны объяснить программисту, где именно ошибка.

Иногда один и тот же макрос допускает разную запись. Хорошим примером служит
\spverb|defn|, макрос определения функции. Кроме обязательных параметров он
принимает опциональные: строку документации, пре- и пост-проверки. У функции
может быть несколько тел:

\begin{verbatim}
(defn my-inc   (defn my-inc               (defn my-inc
  [x]            "Increase the number."     ([x]
  (+ x 1))       [x]                         (my-inc x 1))
                 {:pre [(int? x)]           ([x delta]
                  :post [(int? %)]}          (+ x delta)))
                 (+ x 1))
\end{verbatim}

Это одна и та же функция, записанная по-разному. Очевидно, разобрать все
варианты вручную будет трудно. До версии Clojure 1.10 каждый макрос парсил код
как придется. Это было неорганизованно. С выходом clojure.spec главные макросы
перешли на спеку. Появился общий подход, которым легко управлять.

Разберем устно, как бы мы построили спеку для разбора \spverb|defn|. Это список,
поэтому на верхнем уровне поместим \spverb|s/cat|. Первый его элемент~--- символ
\spverb|defn|. Второй~--- символ с именем функции. После имени следует строка
документации (ее может и не быть). Далее~--- тело или список тел. Пока мы не
ушли удалеко, набросаем черновик:

\begin{verbatim}
(s/def ::defn
  (s/cat :tag (partial = 'defn)
         :name symbol?
         :doc (s/? string?)
         :body :defn/body*))
\end{verbatim}

Что скрыто за спекой \spverb|:defn/body*| нам пока неизвестно. Считаем, что тело
начинается с вектора параметров. После него опциональный словарь пре- и пост-
проверок. Затем произвольные формы, из которых состоит тело функции.

\begin{verbatim}
(s/def :defn/body
  (s/cat :args vector?
         :prepost (s/? map?)
         :code (s/* any?)))
\end{verbatim}

Проблема в том, что \spverb|defn| принимает либо одно тело, либо несколько
обернутых в списки. Сравните первый и третий столбики в примере с
\spverb|my-inc|. Спеку \spverb|:defn/body| нужно обернуть так, чтобы она
учитывала оба случая. Вот как выглядит вариант со звездочкой:

\begin{verbatim}
(s/def :defn/body*
  (s/alt :single :defn/body
         :multi (s/+ (s/spec :defn/body))))
\end{verbatim}

Теперь <<заморозим>> форму \spverb|defn| с помощью апострофа; получится список
символов. Отправим его в \spverb|s/conform|:

\begin{verbatim}
(s/conform
 ::defn
 '(defn my-inc
    "Increase a number"
    [x]
    {:pre [(int? x)]
     :post [(int? %)]}
    (+ x 1)))
\end{verbatim}

\noindent
Результат:

\begin{verbatim}
{:tag defn
 :name my-inc
 :doc "Increase a number"
 :body
 [:single
  {:args [x]
   :prepost {:pre [(int? x)] :post [(int? %)]}
   :code [(+ x 1)]}]}
\end{verbatim}

Заметим, как ведет себя поле \spverb|:body|. Это вектор из метки и
результата. Для одного тела получим метку \spverb|:single| и словарь. Для
нескольких тел метка будет \spverb|:multi|, а значение~--- вектор словарей:

\begin{verbatim}
[:multi [{:args [x] :code [(println 1)]}
         {:args [x y] :code [(println 2)]}]]
\end{verbatim}

Чтобы определить ветку (одно тело или несколько), пригодится оператор
\spverb|case|. Ниже в переменой \spverb|result| записан результат
парсинга. Функция \spverb|process-body| обрабатывает словарь тела:

\begin{verbatim}
(let [{:keys [body]} result
      [tag body] body]
  (case tag
    :single
    (process-body body)
    :multi
    (doseq [body body]
      (process-body body))))
\end{verbatim}

\subsection{Самостоятельная работа}

Каждый уровень спеки можно расширить вглубь. Доработаем аргументы функции:
разделим их на обязательные и необязательные. Например, чтобы параметры
\spverb|[x y & other]| предстали в виде словаря:

\begin{verbatim}
{:req [x y] :opt other}
\end{verbatim}

\noindent
По аналогии разберите словари пре- и пост- проверок.

Передайте в спеку данные с ошибками. Что делать в таком случае? Как составить
\emph{понятное} сообщение о том, где именно ошибка и что вы ожидали? Подойдет ли
словарь переводов? Получится ли у вас сделать ошибки лучше, чем в любом
промышленном языке?

Данные, которые вернула спека-парсер, называются \emph{абстрактным синтаксическим деревом}
(анг. abstract syntax tree, AST). Это вложенная структура, которую получают из текста.
AST~--- важный этап компиляции программы. Только построив дерево, можно выполнить логику,
которая стоит за ним.

Clojure.spec работает в том числе как парсер грамматик. Вы можете разобрать
любой текст и построить дерево. Фактически, вы в шаге от того, чтобы написать
свой язык программирования. Пусть узлы дерева это функции, а потомки~--- их
аргументы. Напишите функцию, которая обходит дерево и вычисляет его в верном
порядке.  Даже если это курсовая работа, свой язык или компилятор повысит ваши
навыки.

%% ----------

\section{Спецификация функций}

В последнем разделе мы поговорим о том, как clojure.spec связана с функциями. Мы
уже упоминали проблему с проверкой входных данных. Даже если параметры нужного
типа, это не гарантирует, что значения верны. Вспомним функцию, которая
принимает диапазон дат. Случай, когда ее вызвали с параметрами
\spverb|start=2010.01.01| и \spverb|end=2009.01.01|, не имеет смысла.

Логично описать параметры этой функции спекой:

\begin{verbatim}
(s/def ::date-range-args
  (s/and
   (s/cat :start inst? :end inst?)
   (fn [{:keys [start end]}]
     (<= (compare start end) 0))))
\end{verbatim}

Вторая функция из \spverb|s/and| принимает результат первого \spverb|s/cat|, то есть словарь с
ключами \spverb|:start| и \spverb|:end|. Для сравнения дат используют специальную функцию
compare, которая возвращает -1, 0 и 1 для случаев меньше, равно и
больше. Быстрая проверка:

\begin{verbatim}
(s/valid? ::date-range-args [#inst "2019" #inst "2020"]) ;; true
(s/valid? ::date-range-args [#inst "2020" #inst "2019"]) ;; false
\end{verbatim}

Возникает идея написать декоратор, который принимает целевую функцию и спеку ее
параметров. Перед тем, как запускать функцию, он проверит параметры и в случае
ошибки выкинет исключение. То же самое можно проделать для результата функции.

Нам не придется писать декоратор, потому что его включили в поставку
clojure.spec. Речь идет о функции \spverb|clojure.spec.test.alpha/instrument|. Глагол
instrument дословно означает оснастить, оборудовать.

Функция принимает символ другой функции, которую мы хотим оснастить
проверкой. Вместе с тем она ищет особую функциональную спеку, зарегистрированную
под этим же символом. Когда обе сущности найдены, instrument подменяет функцию
на такую же, но с проверками. Это своего рода monkey patch, когда один модуль
изменяет поведение другого.

Функциональную спеку объявляют макросом \spverb|s/fdef|. Сначала передают символ
функции, которую хотели бы оснастить. Затем отдельные спеки для проверки
входящих параметров, результата и их композиции.

В качестве примера напишем функцию и спеку к ней. Пусть это будет функция,
которая возвращает разницу между двумя датами в секундах. В отличие от примера
выше, мы допускаем случай, когда первая дата болье второй. В этом случае разница
в секундах будет отрицательной.

\begin{verbatim}
(import 'java.util.Date)

(defn date-range-sec
  "Return a difference between two dates in seconds."
  [^Date date1 ^Date date2]
  (quot (- (.getTime date2)
           (.getTime date1))
        1000))
\end{verbatim}

Теги \spverb|^Date| нужны, чтобы компилятор знал тип объектов date1 и date2. В
противном случае компилятор выполнит рефлексию, чтобы узнать тип. Это съедает
машинное время. Мы поговорим о типах в отдельной главе.

Посчитаем разницу в сутках:

\begin{verbatim}
(date-range-sec
 #inst "2019-01-01" #inst "2019-01-02")
86400
\end{verbatim}

Если поменять даты местами, результат будет отрицательным.

Опишем функциональную спеку. Ее символ будет \spverb|date-range-sec|.  Под ключом
\spverb|:args| указывают спеку входящих параметров. Поскольку параметры это список, на
верхнем уровне почти всегда \spverb|s/cat|. Его задача разбить список на словарь, чтобы
спекам ниже было удобно работать с отдельными значениями.

Под \spverb|:ret| указана спека выходного значения. Чаще всего это проверка на число
или строку. Например, \spverb|int?|, \spverb|string?| или их nilable-версии: \spverb|(s/nilable int)|
и так далее.

Ключ \spverb|:fn| особый. Это спека, которая будет вызвана в контексте входных
параметров и результата. Бывает, что результат зависит от входных параметров по
определенным правилам. Например, если функция возвращает число из диапазона, то
проверка результата на \spverb|int?| недостаточна. Следует убедиться, что результат
действительно не выходит за границы аргументов.

Спеке \spverb|:fn| передают словарь с ключами \spverb|:args| и \spverb|:ret|. Значение \spverb|:args|
содержит не исходный список параметров, а результат \spverb|s/conform| от
\spverb|:args|. Задача спеки~--- проверить, удовлетворяет ли результат входным
аргументам. Если нет, вернуть \spverb|false| для предиката или \spverb|::s/invalid| для
\spverb|s/conformer|.

Напомним, что в ключи \spverb|:args|, \spverb|:ret|, \spverb|:fn| можно передавать объявленные ранее
спеки. Это хорошая практика по переиспользованию кода. Например, у вас может
быть семейство функций для работы с диапазонами чисел. Будет правильно объявить
спеку параметров отдельно и затем ссылаться на нее в каждой из \spverb|s/fdef|.

Опишем спеку для функции \spverb|date-range-sec|. Ограничимся проверкой входных
параметров и результата:

\begin{verbatim}
(s/fdef date-range-sec
  :args (s/cat :start inst? :end inst?)
  :ret int?)
\end{verbatim}

Объявление функциональной спеки еще не меняет целевую функцию. Это правильно,
потому что спека только декларирует проверки, но не запускает их. Чтобы
подменить целевую функцию на ее оснащенную версию, используют \spverb|instrument| из
модуля \spverb|clojure.spec.test.alpha|:

\begin{verbatim}
(require '[clojure.spec.test.alpha
           :refer [instrument]])

(instrument `date-range-sec)
\end{verbatim}

Важно, что символ функции должен быть полным, то есть с пространством. Чтобы
подставить в символ текущее пространство, перед ним ставят обратную кавычку \spverb|`|.

Теперь \spverb|date-range-sec| проверяет аргументы и результат. Попробуем передать
\spverb|nil| вместо одной из дат. Получим исключение класса
\spverb|clojure.lang.ExceptionInfo|.

\begin{verbatim}
(date-range-sec nil #inst "2019")
\end{verbatim}

Его текстовое сообщение и тело уже вам знакомы. Поле message содержит текст,
аналогичный \spverb|s/explain-str|:

\begin{verbatim}
Execution error - invalid arguments to date-range-sec
nil - failed: inst? at: [:start]
\end{verbatim}

В поле data структура, аналогичная результату \spverb|s/explain-data|. Чтобы получить
эти данные из пойманного сообщения, используют функцию \spverb|(ex-data exception)|.

Обратите внимание, что \spverb|instrument| расположен в отдельном модуле с доменом
"test". Это потому, что instrument предназначен для тестирования функций, но не
продакшена. Разработчики пишут спеки для наиболее важных функций в отдельном
модуле. Во время тестов проект стартует с особыми параметрами, где указаны
дополнительные модули, которые нужно загрузить. Один из таких тестовых модулей
оснащает функции их спеками. Если при прогоне тестов функция вернула неверный
результат, это сразу станет заметно.

Instrument не подходит для боевого режима, потому что значительно снижает
быстродействие функции. Замерим десять тысяч прогонов оснащенной функции:

\begin{verbatim}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
\end{verbatim}

\begin{verbatim}
"Elapsed time: 116.984496 msecs"
\end{verbatim}

Получили десятую долю секунды на 10К вызовов. Пока что трудно сказать, быстро
это или нет. Посчитаем время для исходной функции. Поскольку \spverb|date-range-sec|
уже оснащена, объявим функцию с таким же телом, но другим именем, например
\spverb|date-range-sec-orig|. Посчитаем стоимость ее вызова:

\begin{verbatim}
(time
 (dotimes [n 10000]
   (date-range-sec-orig
     #inst "2019" #inst "2020")))
\end{verbatim}

\begin{verbatim}
"Elapsed time: 1.783962 msecs"
\end{verbatim}

Разница в сто раз, или два порядка! Очевидно, что проверка в рантайме
существенно замедляет приложение. По этой причине \spverb|instrument| не претендует на
то, чтобы его использовали в продакшене. Замедление кода в десятки раз~--- слишком
дорогая цена за детальный вывод ошибок.

Наоборот, во время тестов быстродействие нас не интересует. Мы стремимся покрыть
код как можно большим числом проверок, чтобы отловить необычные сценарии.

В примере выше мы проигнорировали ключ \spverb|:fn|. Напомним, это комплексная
проверка, в которой одновременно доступны аргументы и результат. Для функции
\spverb|date-range-sec| справедливо правило: если первая дата больше второй, то
результат отрицательный. Напишите спеку \spverb|:fn|, которая проверяет это
условие. Тем самым вы предотвратите случай, когда кто-то решит, что результат
должен быть по модулю.

Наличие спеки для функции улучшает документацию у ней. Специальная функция \spverb|doc|
из модуля \spverb|clojure.repl| выводит на экран справку о запрошенной функции. С
появлением clojure.spec ее поведение изменилось. Теперь, кроме строки
документации, она выводит спеку функции.

Вот как выглядит справка для \spverb|date-range-sec|:

\begin{verbatim}
(require '[clojure.repl :refer [doc]])
\end{verbatim}

\begin{verbatim}
-------------------------
date-range-sec
([date1 date2])
  Return a difference between two dates in seconds.
Spec
  args: (cat :start inst? :end inst?)
  ret: int?
\end{verbatim}

Функцию \spverb|doc| активно используют различные IDE и редакторы, чтобы показывать
сигнатуру по мере написания кода. Даже если вы не пользуетесь \spverb|instrument| для
тестирования, спека помогает поддерживать проект.

\section{Переиспользование спек}

Писать спеки порой долго и утомительно. В Clojure-сообществе принято снабжать
библиотеки спеками, чтобы облегчить труд другим разработчикам. Если библиотека
использует какую-то структуру данных, будет правильно описать ее спекой.

Хорошим примером служит \spverb|clojure.jdbc|. Это легковесная Clojure-обертка над
реляционными базами данных. Почти каждое веб-приложение использует БД для
хранения данных. JDBC-подключение описано словарем с ключами \spverb|:host|, \spverb|:port|,
\spverb|:user| и так далее.

Считается правильным проверить конфигурацию базы перед тем, как подключаться к
ней. В противном случае вы рискуете получить странное поведение, например
\spverb|NullPointerException| при попытке соединения.

Сlojure.jdbc несет на борту семейство спек для всех своих подсистем. Достаточно
импортировать модуль \spverb|clojure.java.jdbc.spec|, чтобы описанные в нем спеки
попали в глобальный реестр.

Предположим, ключ \spverb|:db| в конфигурации описывает подключение. Пусть это будет
edn-файл:

\begin{verbatim}
{:db {:dbtype "mysql"
      :host "127.0.0.1"
      :port 3306
      :dbname "project"
      :user "user"
      :password "********"
      :useSSL true}}
\end{verbatim}

Прочитаем файл комбинацией \spverb|read-string| и \spverb|slurp|:

\begin{verbatim}
(read-string (slurp "config.edn"))
\end{verbatim}

Спека для этого файла выглядит так:

\begin{verbatim}
(require '[clojure.java.jdbc.spec :as jdbc])

(s/def ::db ::jdbc/db-spec)

(s/def ::config
  (s/keys :req-un [::db]))
\end{verbatim}

Нормально, если спеку поставляют в отдельной библиотеке как дополнение. Так
поступили разработчики alia~--- Clojure-клиента для Кассандры. Базовый пакет
\spverb|qbits.alia| несет базовую функциональность, а сторонний \spverb|cc.qbits/alia-spec|
содержит спеку кластера и основных функций.

\section{Дополнения к spec (обзор)}

Spec входит в поставку Clojure и потому не меняется так радикально, как
предлагают некоторые разработчики. Дополнения к spec выпускают отдельными
библиотеками. Среди прочих заслуживают внимания два проекта: \spverb|expound| и
\spverb|spec.tools|. В этом разделе мы коротко опишем возможности каждого.

[expound]: https://github.com/bhb/expound

Библиотека [expound][expound] улучшает сообщения об ошибках, делает их понятней
для человека. Сигнатура функции expound аналогична \spverb|s/explain|. Она тоже принимает
спеку и данные. Сообщение об ошибке выглядит примерно так:

\begin{verbatim}
(expound/expound string? 1)
\end{verbatim}

\begin{verbatim}
-- Spec failed --------------------
  1
should satisfy
  string?
-------------------------
Detected 1 error
\end{verbatim}

Такой отчет все еще выглядит машинным, и мы не можем показать его
пользователю. Все же он лучше, чем сырой \spverb|s/explain|. Например, его могут
прочитать коллеги из команды Ops, которые не знакомы с Clojure. Особенно хорошо
expound подходит для проверки конфигурации на старте приложения. Иногда код
приложения не меняется месяцами, но конфигурацию обновляют часто, поэтому отчет
о проблемах на старте важен.

[spec.tools]: https://github.com/metosin/spec-tools

Разработчики Metosin собрали ряд улучшений к clojure.spec в проекте
[spec.tools][spec.tools]. В сердце этой библиотеки особый объект Spec. Он
оборачивает стандартную спеку и дополняет ее различными методами. С помощью
spec.tools удобно формировать JSON-схему или описывать REST-проект по стандарту
Swagger. Библиотеку используют в основном как промежуточный слой между
REST-фреймворком и спекой.

Мы не будем останавливаться подробно на этих проектах. Они просты в техническом
плане и требуют больше кода, чем объяснения. Читателю не составит труда
разобраться с ними, когда на то возникнет потребность.

\section{Будущее спеки}

[schema]: https://github.com/plumatic/schema

[bouncer]: https://github.com/leonardoborges/bouncer

На сегодняшний день пакет clojure.spec все еще не избавился от частички "alpha"
в названии. Авторы все еще экспериментируют со спекой, пытаются найти лучший
способ валидировать данные. Это смущает некоторых разработчиков. Опасаясь, что
по окончании эксперимента от spec избавятся, они предпочитают альтернативные
библиотеки: [schema][schema], [bouncer][bouncer].

Отдельные группы пишут обертки над спекой, чтобы расширить ее
возможности. Например, подружить ее с JSON-схемами и популярными инструментами
вроде Swagger.

В недавнем докладе Maybe Not Рич Хикки анонсировал вторую версию
спеки. Ожидается, что разработчики упростят проверку сложных типов
данных. Например, когда значением может быть и строка, и число. Разработка
ведется в открытом режиме, но еще рано говорить о конкретных
результатах. Обсуждение новой спеки выходит за рамки этой главы.

\section{Итог}

Как мы выяснили, clojure.spec~--- это набор функций и макросов. Ими описывают
правила, которым должны удовлетворять данные. Правила это предикаты,
т.е. Функции, которые возвращают истину или ложь.

Предикаты гибче и мощнее типов. Если о значении известно, что оно верного типа,
это еще не гарантирует его корректность. Значение \spverb|-1| не может быть
Unix-портом. Пользовательские классы вроде \spverb|UnixPort| в конструкторе это не
типы, а валидация в рантайме. Она привязана к вызову класса синтаксическим
сахаром.

В отличие от классов, предикаты компонуются друг с другом. Легко написать
супер-предикат с логикой "все из", "любой из" и так далее.

Мы рассмотрели основные возможности из пакета clojure.spec. Это далеко не все, о
чем еще можно рассказать. В обсуждение не попали различные спеки-комбинаторы
вроде \spverb|s/alt|, полезные для тонких проверок. Другая обширная тема по spec~---
генераторы из модуля \spverb|clojure.spec.gen.alpha|. Мы коснемся их в отдельной главе
про тесты.
