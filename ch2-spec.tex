\chapter{Clojure.spec}

\begin{teaser}
В этой главе мы рассмотрим clojure.spec~--- библиотеку для проверки данных в
Clojure. Это особенная библиотека: на ней пишут валидаторы и парсеры, с ее
помощью генерируют данные для тестов. Spec фундаментальна по своей природе,
поэтому уделим ей пристальное внимание.
\end{teaser}

\emph{Spec} это сокращение от \emph{specification} (анг. спецификация,
описание). В общих словах, это набор функций и макросов, чтобы схематично
описать данные. Например, из каких ключей состоит словарь и каких типов его
значения. Такую запись называют спецификацией или сокращенно
\emph{спекой}. Далее по тексту мы будем пользоваться коротким вариантом.

Особые функции принимают спеку и данные и проверяют, подходят ли данные к
ней. Если нет, то возвращают отчет: в каком месте произошла ошибка и почему.

\spverb|Spec| входит в поставку Clojure начиная с версии 1.9. Полностью модуль
называется \spverb|clojure.spec.alpha|. Пусть вас не смущает частичка
\spverb|alpha| на конце имени. Она осталась по историческим причинам.

\spverb|Spec| стала важной вехой в развитии Clojure. Ключевое свойство
\spverb|spec| в том, что она фундаментальна. Валидация данных это малая часть ее
возможностей. \spverb|Spec| не только проверяет данные, но и преобразует
их. Например, на \spverb|spec| легко написать процессор данных или парсер.

Технически \spverb|spec| основана на абстракциях, которые предлагает
Clojure. Формально это обычная библиотека. Но абстракции \spverb|spec| оказались
настолько мощны, что Clojure переиспользует их. Начиная с 1.10, компилятор
Clojure анализирует собственный код с помощью \spverb|spec|. Так проекты
дополняют друг друга.

Мы начнем описание \spverb|spec| с валидации данных. Но прежде чем браться за
техническую часть, разберемся с теорией. Как связаны между собой классы, типы и
валидация.

\section{Типы и классы}

Принято считать, что код на языке со статической типизацией безопаснее, чем с
динамической. Компилятор не позволит сложить число и строку еще до того, как мы
запустим программу. Сторонники статической типизации забывают, что тип
переменной~--- это лишь одно из многих ограничений. Редко случается так, что тип
полностью определяет допустимые значения. Чаще всего, в дополнение к типу,
учитывают максимальные и минимальные границы, длину, попадание в интервалы и
перечисления. Бывает, по отдельности значение верно, но не может стоять в паре с
другим значением.

Рассмотрим описание сетевого порта. Это число от 0 до $2^{16}-1$. Целочисленные
типы обычно представлены степенями двойки, поэтому найдется условный
\spverb|unsigned int|, который охватывает именно этот диапазон. У нулевого порта
особая семантика, и в прикладных программах им не пользуются. Поэтому правильно
отсчитывать порт с единицы. Вероятность, что в языке предусмотрен такой тип,
крайне мала.

Легче всего увидеть проблему на диапазоне дат. Единичная дата может быть сколь
угодно разумной, но диапазон накладывает ограничение: дата начала строго меньше
даты конца. Бизнес дополняет: разница в датах не больше недели, обе даты в
рамках текущего месяца.

В мире ООП знают об этой проблеме и решают ее классами. Программисты на Java
пишут классы \spverb|UnixPort| и \spverb|DateRange|. Условный
\spverb|UnixPort|~--- это класс с одним конструктором. Он принимает целое число
и выполняет проверки на диапазон. Если число отрицательное или выходит за рамки
1~--- $2^{16}$, конструктор бросает исключение. Программист уверен, что создал
новый тип. \emph{Это неверно~--- классы и типы не тождественны}.

Конструктор такого класса это обычный валидатор, проверка во времени
исполнения. Он неявно срабатывает, когда мы пишем \spverb|new UnixPort(8080)|.
Возникает иллюзия, что это тип, но на самом деле это проверка в рантайме. Плюс
удобство синтаксиса, так называемый \emph{сахар}.

В промышленных языках невозможно объявить класс так, чтобы выражение
\spverb|new UnixPort(-42)| приводило к ошибке компиляции. Это возможно только сторонними
утилитами или плагинами к IDE.

Код в конструкторе трудно использовать повторно. Предположим, два разработчика
написали классы \spverb|UnixPort| и \spverb|MyPort|. Первый класс проверяет порт
на диапазон и бросает исключение. Выгодно пользоваться этим классом, поскольку
он совмещен с валидацией. Однако сторонняя библиотека принимает
\spverb|MyPort|. Так возникает проблема конвертации: нужно извлечь <<сырой>>
порт из \spverb|UnixPort| и передать его в \spverb|MyPort|. Это лишний код и
путаница с классами.

Определим хорошие практики валидации: независимость от данных и
компоновка. \emph{Независимость} означает, что данные не привязаны к
валидации. Нет ничего плохого в том, что порт~--- это целое число. Пусть
библиотека принимает \spverb|integer|, а разработчик сам решит, как проверить
это число. Так у него появится выбор, насколько строгой должна быть проверка.

\emph{Компоновка} означает, что хорошо иметь несколько простых проверок, из
которых легко составить сложные. Пусть заданы проверки <<это>> и <<то>>,
и теперь нужны их комбинации: <<это \emph{и} то>>, <<это \emph{или} то>>.
В идеале компоновка занимает одну-две строки и считается тривиальной задачей.

Оба тезиса ложатся на функции. Вспомним, это объект с операцией
вызова. Функция-валидатор принимает значение и возвращает истину или ложь. Это
ответ на вопрос, было ли значение правильными или нет. Функция это объект
высшего порядка; другие функции принимают валидаторы и порождают их комбинации.

%% -----------------

\section{Основы spec}

С багажом этих рассуждений мы подходим к тому, как работает
clojure.spec. Включим модуль spec в текущее пространство:

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
\end{verbatim}

Синоним \spverb|s| нужен, чтобы избежать конфликтов имен с модулем
\spverb|clojure.core|. Модуль spec несет макросы \spverb|s/and|, \spverb|s/or|
и другие, у которых ничего общего с обычными \spverb|and| и \spverb|or|. Считается
дурным тоном, есди имена одного модуля заменяют другие. Это называется \emph{затенением},
и мы рассмотрим проблему в отдельной главе. Пока что мы будем обращаться к spec
через синоним \emph{s}.

Главная операция в spec~--- задать новую спецификацию:

\begin{verbatim}
(s/def ::string string?)
\end{verbatim}

Макрос \spverb|s/def| принимает ключ и предикат. Он создал объект спеки из функции
\spverb|string?|. Затем поместил спеку в глобальный реестр под ключом \spverb|::string|.

Важно понимать, что \spverb|::string|~--- это не спека, а только ее
псевдоним. Макросы spec устроены так, что принимают не объект спеки, а ее
ключ. Далее они сами найдут спеку. Это удобно, потому что ключи глобальны. В
любом месте можно сослаться на \spverb|::string| без лишних импортов.

Вторым аргументом следует предикат \spverb|string?|. Предикат~--- это функция,
которая возвращает истину или ложь. Функция это все еще не спека, а строительный
материал. Спека оборачивает функцию в особый объект. Технически возможно на него
сослаться. Функция \spverb|s/get-spec| по ключу спеки возвращает ее
Java-объект. Однако, на практике он не пригодится.

\begin{verbatim}
(s/get-spec ::string)
#object[clojure.spec.alpha$reify 0x3e9dde1d]
\end{verbatim}

Спеки хранятся в глобальном реестре под своими ключами. Макрос \spverb|s/def| не
проверяет, была ли уже зарегистрирована такая спека. Если под этим ключом уже
была спека, мы потеряем ее старую версию.

Spec не позволит использовать ключи без пространства, например, просто
\spverb|:error| или \spverb|:message|. Это повышает риск конфликта ключей. Чтобы
избавиться от конфликтов, укажите ключи с текущим пространством:
\spverb|::error|, \spverb|::message|.

Самое простое, что можно сделать со спекой~--- проверить, подходит ли под нее
значение. Функция \spverb|s/valid?| принимает ключ спеки, значение и возвращает
\spverb|true| или \spverb|false|.

\begin{verbatim}
(s/valid? ::string 1)      ;; false
(s/valid? ::string "test") ;; true
\end{verbatim}

Пустая строка пройдет валидацию, но чаще всего это не имеет смысла. Пустая
строка в поле <<имя>> или <<заголовок>> означает ошибку. Объявим спеку, которая
в дополнение к строке проверяет, что она не пустая. Наивный способ это
сделать~--- усложнить предикат:

\begin{verbatim}
(s/def ::ne-string
  (fn [val]
    (and (string? val)
         (not (empty? val)))))
\end{verbatim}

\noindent
Быстрая проверка:

\begin{verbatim}
(s/valid? ::ne-string "test") ;; true
(s/valid? ::ne-string "")     ;; false
\end{verbatim}

Ключ \spverb|::ne-string| это сокращение от \emph{\textbf{n}on-\textbf{e}mpty string}.
Спека встречается так часто, что логично сэкономить на ее имени.

Более изящный способ объявить эту же спеку~--- объединить предикаты через
\spverb|every-pred|. Это функция, которая принимает предикаты и возвращает
супер-предикат. Он вернет истину когда истинны все предикаты.

\begin{verbatim}
(s/def ::ne-string
  (every-pred string? not-empty))
\end{verbatim}

Мы собираем новую сущность из старых. Это удачный способ: он короче и следует
функциональному стилю. Но еще лучше комбинировать не предикаты, а спеки. Макрос
\spverb|s/and| объединяет несколько предикатов и спек в новую сущность:

\begin{verbatim}
(s/def ::ne-string
  (s/and ::string not-empty))
\end{verbatim}

Так в Clojure строят сложные спеки. Объявляют примитивы и наращивают их
комбинации.

\section{Исключения}

Во время проверки spec не перехватывает исключения; о них заботится
программист. Рассмотрим пример~--- спеку для проверки URL-адреса. Проще всего
это сделать регулярным выражением:

\begin{verbatim}
(s/def ::url
  (partial re-matches #"(?i)^http(s?)://.*"))

(s/valid? ::url "test")            ;; false
(s/valid? ::url "http://test.com") ;; true
\end{verbatim}

\noindent
Что-то отличное от строки вызовет ошибку:

\begin{verbatim}
(s/valid? ::url nil)
Execution error (NullPointerException) at java.util.regex.Matcher...
\end{verbatim}

Причина в том, что \spverb|nil| попал в функцию \spverb|re-matches|. Функция
трактует аргумент как строку, что приводит к \spverb|NPE|. Следует писать спеки
так, чтобы они не бросали исключения. В примере с \spverb|::url| сначала
убедимся, что это строка, и только потом проверим на регулярное выражение.

\begin{verbatim}
(s/def ::url
  (s/and ::ne-string
         (partial re-matches #"(?i)^http(s?)://.*")))

(s/valid? ::url nil) ;; false
\end{verbatim}

Макрос \spverb|s/and| устроен так, что на первой неудаче цепь обрывается. Все,
что следует после \spverb|::ne-string|, не сработает. Теперь \spverb|nil| не
спровоцирует исключение.

По аналогии проверим возраст пользователя. Это два предиката: на число и
диапазон.

\begin{verbatim}
(s/def ::age
  (s/and int? #(<= 0 % 150)))

(s/valid? ::age nil) ;; false
(s/valid? ::age -1)  ;; false
(s/valid? ::age 42)  ;; true
\end{verbatim}

\section{Спеки-коллекции}

Выше мы проверяли примитивные типы или \emph{скаляры}. Это удобно для примеров,
но редко встречается в практике. Чаще проверяют не скаляры, а коллекции. Spec
предлагает макросы, чтобы задать спеки-коллекции из примитивов.

Макрос \spverb|s/coll-of| принимает предикат или ключ и возвращает
спеку-коллекцию. Она проверяет, что каждый элемент проходит валидацию. Вот так
мы определим список URL-адресов:

\begin{verbatim}
(s/def ::url-list (s/coll-of ::url))
\end{verbatim}

\noindent
Быстрая проверка:

\begin{verbatim}
(s/valid? ::url-list ["http://test.com" "http://ya.ru"])
;; true

(s/valid? ::url-list ["http://test.com" "dunno.com"])
;; false
\end{verbatim}

%% TODO: ref

Макрос \spverb|s/map-of| проверяет ключи и значения словаря. Вспомним поле
запроса \spverb|:params| из главы про веб-разработку. Его ключи кейворды, а
значения строки. На языке спеки это выглядит так:

\begin{verbatim}
(s/def ::params
  (s/map-of keyword? string?))

(s/valid? ::params {:foo "test"})  ;; true
(s/valid? ::params {"foo" "test"}) ;; false
\end{verbatim}

Отдельно поговорим о словарах. Проверка \spverb|s/map-of| довольно слабая, чтобы
покрыть все варианты. Факт того, что все значения строки не несет полезной
информации. Гораздо важнее знать, что в словаре именно те ключи, что мы
ожидаем. К тому же редко бывает так, что значения словаря одного типа. Наоборот,
чаще всего в словаре поля разных типов. Например, имя, возраст и дата.

В таких случаях используют макрос \spverb|s/keys|. Он выглядит как список
спек. Ключи спек совпадают с ключами словаря. Значения ключей проверяются
одноименными спеками.

Пусть страница задана словарем с двумя полями. Это \spverb|address|, строка URL
и \spverb|description|, текстовое описание. Объявим примитивы:

\begin{verbatim}
(s/def :page/address ::url)
(s/def :page/description ::ne-string)
\end{verbatim}

Обратите внимание на пространство ключей. Адрес и описание относятся к странице,
поэтому логично задать им свое пространство. Одноименные поля могут быть у
пользователя или товара. Пространство обещает, что спеки \spverb|:page/address|
и \spverb|:user/address| не заменят друг друга.

Составим спеку страницы:

\begin{verbatim}
(s/def ::page
  (s/keys :req-un [:page/address
                   :page/description]))
\end{verbatim}

В параметре \spverb|:req-un| вектор спек. Для каждой из них \spverb|s/keys| ищет
ключ с таким же именем в словаре и проверяет значение. Рассмотрим, что именно
означает \spverb|:req-un| и какие еще параметры принимает \spverb|s/keys|.

Имя \spverb|:req-un| состоит из двух частей: \emph{req} и \emph{un}. Это
признаки наличия ключа и его типа. \emph{Req} (анг. \emph{required}) означает,
что эти ключи должны быть в словаре. Если хотя бы одного ключа нет, получим
ошибку. Противоположный по смыслу параметр называется \emph{opt}
(анг. \emph{optional}). В нем указаны ключи, которых может не быть. Валидация
таких ключей происходит, только если они оказались в словаре.

Частичка \emph{un} означает \emph{unqualified}, то есть неполный ключ. При
проверке \emph{un}-ключей отбрасывают их пространство. Например, если указать
спеку \spverb|:page/address| в списке \spverb|:req-un|, то в словаре ищется ключ
\spverb|:address|, а не \spverb|:page/address|.

Неполные ключи попадаются в коде довольно часто. Мы получаем данные из чужих API
и баз данных. Эти системы не знают о пространствах имен, и мы игнорируем их. С
точки зрения Clojure пространства нужны, чтобы разделить одноименные поля у
разных сущностей. Например, \spverb|:user/name| и \spverb|:project/name|.
Исключения бывают, когда весь стек фирмы построен на Clojure. В этом случае
клиент и сервер шлют данные с полными ключами.

Различают следующие комбинации \spverb|req|, \spverb|opt| и \spverb|un|:

\begin{itemize}

\item
  \spverb|:req|~--- необходимые полные ключи,

\item
  \spverb|:req-un|~--- необходимые краткие ключи,

\item
  \spverb|:opt|~--- опциональные полные ключи,

\item
  \spverb|:opt-un|~--- опциональные краткие ключи.

\end{itemize}

У спеки \spverb|::page| все ключи обязательны и не учитывают
пространство. Составим для нее данные \emph{с ошибками}. Это может быть
неправильный адрес, пустое описание, пропавший ключ. Если каждый из словарей
ниже подставить в выражение \spverb|(s/valid? ::params <data>)|, результат будет
ложью.

\begin{verbatim}
{:address "clojure.org" ;; not a URL
 :description "Clojure Language"}

{:address "https://clojure.org/"
 :description ""} ;; empty string

{:address "https://clojure.org/"} ;; missing key

{:page/address "https://clojure.org/" ;; fq-keys
 :page/description "Clojure Language"}
\end{verbatim}

Обратите внимание на последний случай. Значения верны, но у ключей пространство
\spverb|:page|. Валидация не сработает, потому что спека отбросит его при
поиске. Чтобы последний пример сработал, измените спеку. Исправьте тип ключей
\spverb|:req-un| на \spverb|:req| (необходимые полные).

\begin{verbatim}
(s/def ::page-fq
  (s/keys :req [:page/address
                :page/description]))

(s/valid? ::page-fq
          {:page/address "https://clojure.org/"
           :page/description "Clojure Language"})
\end{verbatim}

Комбинированный пример. Добавим странице HTTP-статус, который мы получили при
последнем обращении к ней. Поле опционально, потому что если к странице еще не
обращались, в него нечего записать. Вот как выглядит новая спека:

\begin{verbatim}
(s/def :page/status int?)

(s/def ::page-status
  (s/keys :req-un [:page/address
                   :page/description]
          :opt-un [:page/status]))
\end{verbatim}

Словари без статуса и с правильным статусом проходят валидацию:

\begin{verbatim}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"})

(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status 200})
\end{verbatim}

Заметим, что \spverb|s/keys| различает \spverb|nil| и вхождение ключа. Если
статус \spverb|nil|, то он состоит в словаре. Сработает проверка \spverb|nil| на
\spverb|int?|, что приведет к ошибке валидации.

\begin{verbatim}
(s/valid? ::page-status
          {:address "https://clojure.org/"
           :description "Clojure Language"
           :status nil})
;; false
\end{verbatim}

\section{Вывод значений}

До сих пор мы проверяли данные с помощью \spverb|s/valid?|. Функция возвращает
истину или ложь, что значит данные верны или нет. Но одной проверки
недостаточно. Бывает так, что данные корректны, но требуется привести их к
нужному типу.

Например, на вход поступило число в виде строки. Мы убедились, что строка
состоит из цифр и не превышает допустимой длины. Но и после валидации значение
осталось строкой. Приходится парсить его вручную. Код растет и начинает
<<шуметь>>. Хотелось бы, чтобы типы выводил какой-то механизм.

Spec предлагает такие возможности. Это функции \spverb|s/conformer| и
\spverb|s/conform| (от анг. \emph{conform}~--- подчиняться).

\spverb|S/conformer| принимает функцию вывода и оборачивает ее в
спеку-конформер. В свою очередь, функция вывода принимает исходное значение и
возвращает либо новое, либо ключ \spverb|:clojure.spec.alpha/invalid|, что
говорит об ошибке.

Функция \spverb|S/conform| принимает ключ спеки-конформера и данные. Если вывод
прошел без ошибок, результатом будет новое значение. Если с ошибками, вернется
все тот же ключ \spverb|invalid|.

Рассмотрим пример с выводом числа из строки. Чтобы различать спеку-конформер от
валидатора, к ее имени добавляют стрелку, что означает вывод, приведение типа.

\begin{verbatim}
(s/def ::->int
  (s/conformer
   (fn [value]
     (try
       (Integer/parseInt value)
       (catch Exception e
         ::s/invalid)))))
\end{verbatim}

Эту спеку передают в \spverb|s/conform| с данными:

\begin{verbatim}
(s/conform ::->int "42") ;; 42

(s/conform ::->int "dunno")
:clojure.spec.alpha/invalid
\end{verbatim}

Как и \spverb|s/valid?|, \spverb|s/conform| не перехватывает исключения в
процессе работы. Java устроена так, что вывод данных часто выбрасывает
исключения. Будет правильно перехватывать их и возвращать \spverb|::s/invalid|,
как в примере выше.

Обе спеки~--- валидатор и конформер~--- можно объединить через
\spverb|s/and|. Например, чтобы проверить тип перед выводом. В нашем случае
убедимся, что значение~--- строка. Так мы не допустим, чтобы в \spverb|parseInt|
попал \spverb|nil| или что-то другое:

\begin{verbatim}
(s/def ::->int+
  (s/and ::ne-string ::->int))

(s/conform ::->int+ nil)
:clojure.spec.alpha/invalid
\end{verbatim}

Теперь рассмотрим, как восстанавливать даты из строк. С этой проблеме знают
веб-разработчики. Формат JSON не поддерживает даты, поэтому их передают строкой
или числом секунд.

Понадобится функция разбора такой строки и небольшая обвязка, чтобы подружить ее
со спекой. Функция \spverb|read-instant-date| из модуля \spverb|clojure.instant|
читает дату из строки. Она лояльна к формату и учитывает много
случаев. Например, датой может быть только год.

\begin{verbatim}
(require '[clojure.instant :refer [read-instant-date]])
(read-instant-date "2019")
#inst "2019-01-01T00:00:00.000-00:00"
\end{verbatim}

Обернем функцию в спеку:

\begin{verbatim}
(s/def ::->date
  (s/and
   ::ne-string
   (s/conformer
    (fn [value]
      (try
        (read-instant-date value)
        (catch Exception e
          ::s/invalid))))))
\end{verbatim}

Как и с числом, перед разбором мы делаем минимальные проверки. Убеждаемся, что
это непустая строка, чтобы отсечь \spverb|nil| и другие значения без
смысла. Строка даты:

\begin{verbatim}
(s/conform ::->date "2019-12-31")
#inst "2019-12-31T00:00:00.000-00:00"
\end{verbatim}

\noindent
Дата и время:

\begin{verbatim}
(s/conform ::->date "2019-12-31T23:59:59")
#inst "2019-12-31T23:59:59.000-00:00"
\end{verbatim}

\section{Спеки-перечисления}

Иногда мы знаем заранее, какие значения принимает поле. Например, при вызове API
клиент передает архитектуру системы~--- 32 или 64 бита. Ради двух значений нет
смысла парсить число: подойдет \emph{перебор} или \emph{словарь}.

Перебор работает через макрос \spverb|case|. Он пробегает по вариантам строки и
возвращает аналогичные числа. Если ничего не найдено, сигналим об ошибке ключом
\spverb|::s/invalid|.

\begin{verbatim}
(s/def ::->bits
  (s/conformer
   (fn [value]
     (case value
       "32" 32
       "64" 64
       ::s/invalid))))

(s/conform ::->bits "32") ;; 32
(s/conform ::->bits "42") :clojure.spec.alpha/invalid
\end{verbatim}

Вариант со словарем. По заданному словарю ищем результат формой
\spverb|get|. Если не нашли значение, вернем тег \spverb|invalid|.

\begin{verbatim}
(def bits-map {"32" 32 "64" 64})

(s/def ::->bits
  (s/conformer
   (fn [value]
     (get bits-map value ::s/invalid))))
\end{verbatim}

Этот подход хорош тем, что опорная точка~--- словарь соответствий~--- живет в
отдельной переменной. Его легко дополнить новыми значениями или вынести в
конфигурацию. При этом логика проверки не изменится.

Похожим образом читают логические значения из строк. Нет единого соглашения о
том, как передать истину и ложь в тексте. Это может быть \spverb|True|,
\spverb|TRUE|, \spverb|1|, \spverb|on|, \spverb|yes| для истины и их
противоположности: \spverb|FALSE|, \spverb|no|, \spverb|off|... При разборе
таких значений их приводят к одному регистру. В Clojure \spverb|FALSE| и
\spverb|false|~--- это разные строки, даже если отправитель имел в виду одно и
то же. Сценарий выглядит так:

\begin{itemize}

\item
  убедиться, что значение это строка;

\item
  привести ее к нижнему регистру;

\item
  вывести значение по словарю или перебором.

\end{itemize}

\noindent
Конформер из реального проекта:

\begin{verbatim}
(s/def ::->bool
  (s/and
   ::ne-string
   (s/conformer clojure.string/lower-case)
   (s/conformer
    (fn [value]
      (case value
        ("true" "1" "on" "yes") true
        ("false" "0" "off" "no") false
        ::s/invalid)))))

\end{verbatim}

\noindent
В действии:

\begin{verbatim}
(s/conform ::->bool "True") ;; true
(s/conform ::->bool "yes")  ;; true
(s/conform ::->bool "0")    ;; false
\end{verbatim}

\section{Продвинутые техники}

Мы написали достаточно кода, чтобы увидеть одинаковые участки~--- паттерны. В
этом разделе мы вынесем их в служебные функции и макросы. Заодно рассмотрим
приемы, которые ускорят вашу работу.

\subsection{Множества}

Когда значения известны, на роль спеки подходит множество. Дело в том, что
множество ведет себя как функция одного аргумента. Если аргумент есть в нем,
получим сам аргумент. Если нет, результат будет \spverb|nil|. Предположим,
статус задачи может быть \spverb|todo|, \spverb|in_progress| и
\spverb|done|. Опишем спеку множеством этих значений:

\begin{verbatim}
(s/def ::status #{"todo" "in_progres" "done"})
(s/valid? ::status "todo") ;; true
\end{verbatim}

\subsection{Перечисления}

Множество не подходит в случаях, когда \spverb|false| и \spverb|nil| считают
верными значениями. \spverb|S/valid?| трактует их как неудачу. Если \spverb|nil|
или \spverb|false| входят в множество значений, их проверяют функцией
\spverb|contains?|:

\begin{verbatim}
(contains? #{1 :a nil} nil) ;; true
\end{verbatim}

Чтобы не повторяться, напишем функцию \spverb|enum|. Она принимает значения и
возвращает функцию-предикат. Этот предикат принимает один аргумент и проверяет,
есть ли такой среди исходных значений.

\begin{verbatim}
(defn enum [& args]
  (let [arg-set (set args)]
    (fn [value]
      (contains? arg-set value))))
\end{verbatim}

Функция внутри замкнута на переменной \spverb|arg-set|. Это множество, которое
получили из списка аргументов. Мы создали его один раз, чтобы не делать это
постоянно при вызове внутренней функции. Теперь перечисления выглядят коротко и
ясно:

\begin{verbatim}
(s/def ::status
  (enum "todo" "in_progres" "done"))
\end{verbatim}

\subsection{With-conformer}

Спеки-конформеры требуют особого внимания. В них легко допустить ошибку: не
перехватить исключение или не обернуть функцию в \spverb|s/conformer|. Перенесем
рутину в макрос \spverb|with-conformer|. Он принимает символ переменной и
произвольное тело. Макрос порождает функцию одного аргумента. Она исполняет тело
в блоке \spverb|try/catch|. Если исключения не было, результатом будет последнее
выражение тела. В противном случае вернется тег \spverb|invalid|.

\begin{verbatim}
(defmacro with-conformer
  [bind & body]
  `(s/conformer
    (fn [~bind]
      (try
        ~@body
        (catch Exception e#
          ::s/invalid)))))
\end{verbatim}

\noindent
Ниже примеры из реального проекта. Вывод числа:

\begin{verbatim}
(s/def ::->int
  (s/and
   ::ne-string
   (with-conformer val
     (Integer/parseInt val))))
\end{verbatim}

\noindent
Вывод логического типа:

\begin{verbatim}
(s/def ::->bool
  (s/and
   ->lower
   (with-conformer val
     (case val
       ("true"  "1" "on"  "yes") true
       ("false" "0" "off" "no" ) false))))
\end{verbatim}

\noindent
Переменная \spverb|->lower| это тоже обертка для приведения регистра:

\begin{verbatim}
(def ->lower
  (s/and
    string?
    (s/conformer clojure.string/lower-case)))
\end{verbatim}

В примере с \spverb|case| необязательно указывать \spverb|invalid| для значения
по умолчанию. Если макрос не нашел ветку и не задан вариант по умолчанию, он
бросит исключение. \spverb|With-conformer| перехватит его и вернет
\spverb|invalid|.

%% ----------------

\section{Логические пути}

Результат \spverb|s/conform| не всегда то, что мы ожидаем. Некоторые спеки оборачивают
результат в вектор, где первый элемент~--- часть логического пути. Такой пусть
возникает в тех местах, где проверка ветвится.

До сих пор мы объединяли спеки через \spverb|s/and|. Такая супер-спека последовательно
проходит дочерние и выполняет проверки. Это удобно, но недостаточно. Бывает,
требуется спека-развилка, которая работает по условию. Например, если значение
число, то оставить его как есть, а если строка, то попытаться привести к
числу. Такие спеки называют условными.

Макрос \spverb|s/or|~--- одна из условных спек. Он принимает набор других спек и
тегов. Макрос применяет значение к спекам до первого положительного
случая. Результатом становится пара из нового значения и тега той спеки, что
дала положительный результат.

Этот тег становится частью т.н. логического пути, по которому шла
проверка. Логический путь помогает расследовать, в каком именно сценарии
произошла ошибка. Для простых спек типа это не проблема. Но в реальных проектах
бывает так, что условная спека вложена в другую условную, та тоже и т.д. Выявить
ошибку без логического пути в таких случаях трудно.

Если валидация не прошла, то логический путь получают из отладочной
информации. Эту информацию возвращают функции семейства \spverb|s/explain*|. Мы
рассмотрим эти функции ниже.

Вот как выглядит спека сетевого порта. Она принимает число или строку, которую
пытается преобразовать в число.

\begin{verbatim}
(s/def ::smart-port
  (s/or :string ::->int :num int?))
\end{verbatim}

Теперь \spverb|s/conform| вернет не просто выведенное значение, а пару тег-значение:

\begin{verbatim}
(s/conform ::smart-port 8080)
[:num 8080]

(s/conform ::smart-port "8080")
[:string 8080]
\end{verbatim}

Важно помнить, что если в спеке был условный узел (\spverb|s/or|, \spverb|s/alt|), то
структура \spverb|s/conform| отличается от входных данных. Например, на месте
скалярного значения появится вектор.

Покажем это на более сложном примере. Пусть порт~--- одно из полей параметров
подключения к базе данных.

\begin{verbatim}
(s/def :conn/port ::smart-port)

(s/def ::conn
  (s/keys :req-un [:conn/port]))
\end{verbatim}

Топология выходного словаря отличается от входных данных:

\begin{verbatim}
(s/conform ::conn {:port "9090"})
{:port [:string 9090]}
\end{verbatim}

\section{Анализ ошибок}

Мы уже выяснили, что в случае неудачи \spverb|s/valid?| и \spverb|s/conform| возвращают
\spverb|false| и \spverb|invalid|. Этих данных недостаточно, чтобы понять причину
ошибки. Представьте, что у вас спека пользователя системы. У пользователя набор
адресов, в каждом адресе несколько строк... и проверка вернула \spverb|false|. Поиск
ошибки вручную в таком дереве займет день.

Функции семейства \spverb|s/explain*| принимают спеку и данные. Если ошибок не было,
результат будет пустым. Если были, мы получим информацию о том, что пошло не
так. Разница между функциями в том, как они обрабатывают результат.

- \spverb|s/explain| печатает текст ошибки в стандартный поток (на экран);
- \spverb|s/explain-str| возвращает эту же информацию в виде строки;
- \spverb|s/explain-data| возвращает словарь с данными. Это самый полный отчет об
  ошибке.

Рассмотрим \spverb|s/explain| и \spverb|s/explain-str|. Результат их работы одинаковый,
разница лишь в том, куда приходит текст~--- в консоль или переменную.

Подготовим простую спеку:

\begin{verbatim}
(s/def :sample/username ::ne-string)

(s/def ::sample
  (s/keys :req-un [:sample/username]))
\end{verbatim}

На корректных данных \spverb|explain| никак не проявляет себя, разве что первый вариант
печатает \spverb|Success!|:

\begin{verbatim}
(s/explain ::sample {:username "some user"})
Success!
nil

(s/explain-data ::sample {:username "some user"})
nil
\end{verbatim}

Случай с ошибкой, вместо строки передано число:

\begin{verbatim}
(s/explain ::sample {:username 42})
\end{verbatim}

\begin{verbatim}
42 - failed: string? in: [:username] at: [:username] spec: ::string
\end{verbatim}

Отчет следует читать так: значение \spverb|42| не прошло проверку на предикате
\spverb|string?|. Путь к значению внутри структуры \spverb|[:username]|. Ключ спеки, на
которой произошла ошибка -- \spverb|::string|.

Отчет показывает самые вложенные спеки и предикаты. Вспомним, что \spverb|::ne-string|
это комбинация \spverb|::string| и \spverb|not-empty|. Ошибка случилась на этапе \spverb|::string|,
что отчет и показывает.

Для пустой строки вывод будет другим. На этот раз проверка оборвется на этапе
\spverb|not-empty|. Проверим это:

\begin{verbatim}
(s/explain ::sample {:username ""})
\end{verbatim}

\begin{verbatim}
"" - failed: not-empty in: [:username] at: [:username] spec: ::ne-string
\end{verbatim}

Сообщения такого рода допустимы для разработчиков, например, при проверке
конфигурации на старте приложения. Но чем сложнее структура данных, тем менее
понятен отчет explain. И уж точно такое сообщение нельзя показывать
пользователям, если они ошиблись в данных. В следующем разделе мы рассмотрим эти
проблемы.

\section{Понятные сообщения об ошибках}

Когда мы проверяем данные, важно не только зафиксировать факт ошибки. Еще важнее
доступно объяснить клиенту, что именно неверно в его данных. Под клиентом не
обязательно подразумевают человека. Даже если клиент это другая программа, будет
правильно снабдить ответ понятным описанием. Скорее всего, клиент запишет
результат в лог, и его прочитает человек.

Многие из нас сталкивались с сообщениями вроде "Ошибка 0x00ffff" без каких-либо
деталей. Или красной надписью "проверьте данные" над формой в два экрана. Этих
глупостей можно было избежать, умей программисты переводить системные сообщения
в человеческие.

Очевидно, фраза \spverb|"" - failed: not-empty in: [:username]| не только ничего не
скажет пользователю, но и отпугнет его машинной природой. Возникнет ощущение,
что в интерфейсе образовалась брешь, и пользователь видит то, чего не
должен. Это резко снижает доверие к системе в целом.

Чтобы сформировать понятное сообщение об ошибке, воспользуемся
\spverb|s/explain-data|. Эта функция возвращает словарь со всей необходимой
информацией. Вот как он выглядит:

\begin{verbatim}
(s/explain-data ::sample {:username ""})

#:clojure.spec.alpha
{:problems
 ({:path [:username]
   :pred clojure.core/not-empty
   :val ""
   :via [::sample ::ne-string]
   :in [:username]})
 :spec ::sample
 :value {:username ""}}
\end{verbatim}

На первый взгляд непонятно, что делать с этой структурой. К сожалению, многие
разработчики пасуют перед проблемой и говорят, что spec не подходит для
ошибок. На самом деле, это отличная структура данных, нужно только правильно ее
обработать.

Вопрос, который задают новички~--- почему бы не сделать понятные сообщения сразу
на уровне библиотеки? Например, назначить спеке дополнительное поле с текстом
"введите правильный адрес"? Почему не взять пример с многочисленных фреймворков
для Python или JavaScript?

Ответ на этот вопрос не устраивает новичков. Вспомним тезис из начала
главы. Spec~--- это фундаментальная библиотека. Она не предназначена для обработки
ввода пользователя. Это набор абстракций и примитивов. То, что мы проверяем
спекой поля HTML-формы~--- всего лишь частный случай. Ниже мы убедимся, что у
спеки самые разные области применения. Поэтому структура ошибки тоже
фундаментальна.

Во-вторых, трудно создать систему ошибок, которая устроит всех. В каждом проекте
свои правила о том, как показывать ошибки. Рассмотрим поле возраста. Где-то
пишут "укажите правильный возраст". Это фиксированное сообщение, которое не
меняется. Но в другом проекте ошибку выводят с текущим значением: "999 не
подходит под критерии возраста". Такое сообщение уже не фиксированный текст, а
шаблон. Это значит, на одном из этапов срабатывает код, который извлекает
ошибочное значение, шаблон, форматирует текст... А теперь добавим локализацию. В
зависимости от локали браузера будем формировать сообщения на английском,
русском, французском. Это очень, очень сложные сценарии.

Если бы разработчики Spec занялись выводом ошибок по принципу других
фреймворков, их фокус был бы смещен с главной цели. И тогда вместо spec мы бы
получили валидаторы по типу тех, что пишут десятками для JavaScript. Они скучны,
не гибки и без концепции.

Словарь \spverb|explain-data| содержит ключи \spverb|:spec|, \spverb|:value| и \spverb|:problems| (с
пространством \spverb|clojure.spec.alpha|). Первые два это спека и значение, которые
принимали участие в проверке. Нас интересует поле problems. Это список
словарей. Каждый словарь описывает конкретную ошибку валидации. Перечислим его
поля и семантику.

- \spverb|:path|~--- Логический путь валидации. Вектор ключей, где спеки чередуются с
  тегами-развилками. Условные спеки типа s/or записывают в этот вектор метки
  дочерних спек.

- \spverb|:pred|~--- полный символ предиката, например \spverb|clojure.core/string?|.

- \spverb|:val|~--- конкретное значение, которое не прошло проверку на
  предикат. Например, один из элементов исходного словаря.

- \spverb|:via|~--- цепочка спек, по которым успело пройти значение от верхнего уровня к
  нижнему.

- \spverb|:in|~--- физический путь к значению. Вектор ключей и индексов, который передают
  в функцию \spverb|get-in|. Если выполнить \spverb|(get-in <исходные-данные> <путь>)|, то
  получим значение, которое вызвало ошибку.

Видим, что отчет содержит все данные, чтобы собрать понятное сообщение. Из
\spverb|:val| возьмем конкретное неверное значение. Спека, на которой прервалась
валидация это последний элемента вектора \spverb|:via|.

Составим словарь сообщений, где ключ~--- спека, а значение~--- понятный текст или
шаблон. Зная спеку, в которой произошла ошибка, получим из словаря текст. Так,
последним элементом вектора \spverb|:via| была спека \spverb|::ne-string|. Логичное
сопоставить ей сообщение "Строка не должна быть пустой" или что-то похожее.

\begin{verbatim}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"})
\end{verbatim}

Напишем наивную функцию, которая принимает словарь ошибки (один из элементов
\spverb|::s/problems|) и возвращает понятное сообщение:

\begin{verbatim}
(defn get-message
  [problem]
  (let [{:keys [via]} problem
        spec (last via)]
    (get spec-errors spec)))

(get-message {:via [::sample ::ne-string]})
"Строка не должна быть пустой"
\end{verbatim}

Рассмотрим, как это работает на других полях. Добавим спеку электронной почты и
новое поле в \spverb|::sample|.

\begin{verbatim}
(s/def ::email
  (s/and
   ::ne-string
   (partial re-matches #"(.+?)@(.+?)\.(.+?)")))

(s/def :sample/email ::email)

(s/def ::sample
  (s/keys :req-un [:sample/username
                   :sample/email]))
\end{verbatim}

Спека \spverb|::email| проверяет строку по наивному шаблону электронного
адреса. Регулярное выражение из примера выше читают как
\spverb|<что-угодно>@<что-угодно>.<что-угодно>|.

Если передать в email пустую строку, последним элементом via будет
\spverb|::ne-string|. Для экономии места слегка сократим вывод \spverb|explain-data|:

\begin{verbatim}
(s/explain-data ::sample {:username "test" :email ""})

{:path [:email]
 :pred clojure.core/not-empty
 :val ""
 :via [::sample ::email ::ne-string]
 :in [:email]}
\end{verbatim}

Если передать эту ошибку в \spverb|get-message|, она вернет прежнее сообщение о пустой
строке. Но если email был непустой строкой, которая не попала под шаблон
регулярного выражения, то последним элементом \spverb|:via| будет
\spverb|:sample/email|. Полный словарь ошибки выглядит так:

\begin{verbatim}
{:path [:email]
 :pred
 (clojure.core/partial
  clojure.core/re-matches
  #"(.+?)@(.+?)\.(.+?)")
 :val "test"
 :via [::sample ::email]
 :in [:email]}
\end{verbatim}

Чтобы \spverb|get-message| вернул другое сообщение, добавим в словарь ошибок ключ
\spverb|::email|:

\begin{verbatim}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   ::email "Введите правильный почтовый адрес"})
\end{verbatim}

Остается наращивать словарь все новыми спеками и сообщениями, пока не закроем
все возможные ошибки. Но это линейный подход. Существует несколько способов
улучшить поиск сообщений.

Например, что случится, если нужного перевода не окажется в словаре? В этом
случае вернем нейтральное "исправьте ошибки в поле". Заодно зафиксируем факт
того, что перевод не был найден. Проще всего это сделать записью в лог.

Нормально, что команды разработки и локализации иногда не согласованы. Команда
локализаторов время от времени просматривает этот лог и добавляет переводы.

Рассмотрим, как упростить поиск поля в словаре. Поле \spverb|email| может встречаться в
разных спеках: \spverb|:account/email|, \spverb|:patient/email|, \spverb|:client/email|. Линейный
подход из примера выше требует, чтобы для каждого такого ключа было сообщение об
ошибке. Это склоняет нас к повторам в коде.

Чтобы не засорять словарь переводов, пойдем на хитрость. Пусть функция поиска
пытается найти сообщение по полному ключу, а в случае неудачи~--- по его
имени. Тогда достаточно ключа \spverb|:email|, и все емейлы будут сходиться на этот
перевод. Если для одного конкретного емейла нужен особый перевод, добавим его
полную версию в словарь:

\begin{verbatim}
(def spec-errors
  {::ne-string "Строка не должна быть пустой"
   :email "Введите правильный почтовый адрес"
   :account/email "Особое сообщение для адреса отправителя"})
\end{verbatim}

Объединим вышесказанное в одну функцию. Вот как выглядит поиск в словаре с
учетом неполного ключа и ошибки по умолчанию.

\begin{verbatim}
(def default-message
  "Исправьте ошибки в поле")

(defn get-better-message
  [problem]
  (let [{:keys [via]} problem
        spec (last via)]
    (or
     (get spec-errors spec)
     (get spec-errors
          (-> spec name keyword))
     default-message)))
\end{verbatim}

Система, которую мы построили, достаточно проста. Ее легко тестировать и
изменять под нужды конкретного проекта. Автор использовал доработанные версии
такой системы в реальных проектах. В одном из случаев формы полностью
проверялись на стороне клиента до их отправки на сервер. Это возможно, поскольку
код на Clojure компилируется в JavaScript. Мощь clojure.spec в полной мере
доступна на клиенте.

До сих пор мы использовали фиксированные сообщения. Но легко сделать их
шаблонами, куда подставляют текущее значение или имя поля. В этом случае
исправления в коде минимальны.

Получим имя поля как последний отличный от цифры элемент вектора \spverb|:in|. Ключ
\spverb|:val| хранит текущее ошибочное значение. В тексте сообщения расставим \spverb|%s| для
имени поля и значения. Функция \spverb|(format <шаблон> <поле> <значение>)| вернет
что-то вроде "Поле email содержит неверное значение test.com".

За рамками главы остались несколько вопросов. Первый~--- что делать, если
требуется локализация сообщения, то есть вывод на русском или английском в
зависимости от состояния? Очевидно, наша структура станет словарем словарей, где
на первом уровне будет код локали (ru, en), а на втором~--- переводы для спек.

Теперь на первом шаге мы получаем по локали словарь переводов, затем переводим
как описано выше. С кодом локали тоже можно схитрить, чтобы облегчить
поиск. Например, иногда требуется различные написания для локалей \spverb|en_US| и
\spverb|en_GB|. Реализуем функцию поиска так, что сперва она ищет по младшей локали
(\spverb|en_US|), а затем по старшей (\spverb|en|).

Вопрос откуда приходит локаль остается на усмотрение разработчика. Ее можно
хранить в сессии, параметрах адресной строки, базе данных, глобальной
переменной, словом~--- как это удобно в текущем проекте.

Второй вопрос~--- как связать вывод ошибок с интерфейсом пользователя. Это тоже
зависит от конкретного проекта. Хорошей практикой считается отделение модели от
ее представления. Это верно и для форм. Удобно, когда форма~--- это структура
данных с набором функций. Тогда все операции над ней будут чистыми функциями,
которые легко поддерживать.

Представим форму как дерево, в листьях которого структура виджета. Виджет знает
тип поля, текущее значение и ошибку. Специальный react-компонент подписан на
этот лист дерева. На каждое его изменения компонент рисует HTML-элемент,
например, поле ввода с текущим текстом. Если поле ошибки не \spverb|nil|, то оно
выводится над полем.

Функция валидации принимает дерево формы. Она строит дерево значений. Это
структура с той же топологией, но вместо листьев-виджетов на их местах
значения. С помощью спеки мы проверяем значения (\spverb|s/valid?|) или выводим
правильные типы из текста. В случае ошибки мы получаем отчет
(\spverb|s/explain-data|). Для каждого элемента из поле problems находим путь, спеку и
сообщение об ошибке. Это сообщение добавляем в соответствующий виджет в поле
\spverb|:error|. Компонент, который отрисовывает этот виджет, уведомит пользователя об
ошибке.

\section{Парсинг}

До сих пор мы обсуждали проверку данных и вывод значений. Теперь рассмотрим
операцию более высокого уровня~--- парсинг. Под парсингом понимают разбор данных
на части, выделение структуры там, где прежде ее не было.

Читателю наверняка приходилось парсить текст регулярными выражениями. Это особые
шаблоны, которые описывают структуру фрагмента. Специальные функции принимают
исходный текст и регулярное выражение. Структура результата известна
заранее. Например, это список фрагментов, которые совпали с шаблоном.

Простейший пример регулярного выражения~--- IP-адрес. Это четыре группы,
разделенные точками. Каждая группа состоит из числа от 0 до 255.

\begin{verbatim}
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
\end{verbatim}

В примере выше мы ставим косую черту перед точкой. В регулярных выражениях точка
это служебный символ. Мы экранируем его, чтобы описать именно символ точки.

В регулярных выражениях применяют операторы \spverb|+|, \spverb|?|, \spverb|*| и другие. Они
указывают, сколько раз встречается данный шаблон. Например, один и более раз, ни
одного или один, произвольное число или ни одного. В зависимости от
модификатора, шаблон захватывает разные части текста.

Можно представить, что регулярные выражения откусывают текст частями. Та часть,
что легла на шаблон, наполняет структурированный результат. Оставшийся текст
передается следующим шаблонам, и так далее.

Регулярные выражения подводят нас к regex-спекам. Это особый тип спек для
разбора данных по шаблону. Разница в том, что и шаблон, и исходные данные это
структуры, а не текст.

Предположим, мы читаем из текстового файла список пользователей. Каждый
пользователь это кортеж вида <номер, емейл, статус>. Все значения в виде
текста. Для каждого пользователя требуется:

- убедиться, что в кортеже именно три элемента;
- привести номер к числу;
- проверить емейл на минимальные критерии;
- привести статус к системному перечислению (одной из констант).

В идеале получить словарь с верными значениями.

Мы уже знакомы с \spverb|s/conformer|. Мы могли бы написать функцию, которая принимает
кортеж пользователя и выполняет описанные выше преобразования. Технически это
несложно. Но такая функция будет монолитной со слишком большим скоупом. Это
плохая практика при работе с clojure.spec.

Для разбиения коллекций подходит \spverb|s/cat|. Эта спека принимает последовательность
тегов и спек. На вход s/cat подают коллекцию значений, например список или
вектор. Спека накладывает элементы коллекции на спеки. Если они совпали,
результатом будет словарь. Ключи этого словаря~--- теги спек, значения~--- результат
применения спеки к соответствующему значению.

Составим спеку для разбора кортежа. У нас уже есть парсинг чисел и проверка
мейла. Опишем вывод статуса и соберем композицию спек:

\begin{verbatim}
(s/def :user/status
  (s/and
   ->lower
   (with-conformer val
     (case val
       "active" :USER_ACTIVE
       "pending" :USER_PENDING))))

(s/def ::user
  (s/cat :id ::->int
         :email ::email
         :status :user/status))
\end{verbatim}

Проверим положительный случай:

\begin{verbatim}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1
 :email "test@test.com"
 :status :USER_ACTIVE}
\end{verbatim}

Варианты с плохим номером, почтой или не тем статусом не проходят
преобразование. Примеры ниже вернут \spverb|::s/invalid|:

\begin{verbatim}
(s/conform ::user ["" "test@test.com" "active"])
(s/conform ::user ["1" "@test.com" "active"])
(s/conform ::user ["1" "test@test.com" "unknown"])
\end{verbatim}

В примере с пользователем число полей в кортеже фиксировано. На практике так
бывает не всегда. Мы все еще сталкиваемся с устаревшими форматами данных. В
таких форматах бывают условия вроде "если перед номером строка \spverb|BLOCKED|, то
пользователь заблокирован." Это осложняет задачу, ведь теперь в кортеж состоит
или из трех, или четырех элементов. Кроме того, сдвигается семантика
полей. Первый элемент теперь не только номер, но и флаг блокировки. Встречаются
и более сложные условия.

В императивных языка типа Python и Java такие требования порождают каскад
\spverb|if/else| с перезаписью переменных. В Clojure эту проблему решают
декларативно. Объявим спеку для флага блокировки:

\begin{verbatim}
(s/def ::blocked
  (s/and
   ->lower
   (s/conformer
    #(= % "blocked"))))
\end{verbatim}

Добавим ее в итоговую \spverb|s/cat|, но укажем, что она встречается ноль или один раз:

\begin{verbatim}
(s/def ::user
  (s/cat :blocked (s/? ::blocked)
         :id ::->int
         :email ::email
         :status :user/status))
\end{verbatim}

Теперь оба типа кортежа попадают под действие спеки. Если пользователь
заблокирован, в итоговом словаре будет поле \spverb|:blocked|:

\begin{verbatim}
(s/conform ::user ["1" "test@test.com" "active"])
{:id 1 :email "test@test.com" :status :USER_ACTIVE}

(s/conform ::user ["Blocked" "1" "test@test.com" "active"])
{:blocked true :id 1 :email "test@test.com" :status :USER_ACTIVE}
\end{verbatim}

Представим теперь, что на входе коллекция кортежей. Чтобы не утруждать себя
ручной итерацией, объявим спеку-коллекцию:

\begin{verbatim}
(s/def ::users
  (s/coll-of ::user))

(def user-data
  [["1" "test@test.com" "active"]
   ["Blocked" "2" "joe@doe.com" "pending"]])

(s/conform ::users user-data)

[{:id 1 :email "test@test.com" :status :USER_ACTIVE}
 {:blocked true :id 2 :email "joe@doe.com" :status :USER_PENDING}]
\end{verbatim}

Отсеять заблокированных пользователей можно функцией \spverb|filter| с предикатом
\spverb|(complement :blocked)|.

С помощью regex-спек можно парсить не только данные, но и текст. Рассмотрим, как
распарсить INI-файл в словарь данных. Напомним, INI~--- это старый текстовый
формат для конфигурации приложений. Он состоит из секций в квадратных скобках и
пар \spverb|поле=значение|.

\begin{verbatim}
# config.ini

[database]
host=localhost
port=5432
user=test

[server]
host=127.0.0.1
port=8080
\end{verbatim}

Хотелось бы получить из файла вложенный словарь вида:

\begin{verbatim}
{:database {:host "localhost"
            :port 5432}
 :server {:host "127.0.0.1"}}
\end{verbatim}

Если отбросить пустые и закомментированные строки, то структура файла сводится к
грамматике \spverb|(<section>, <key=value>*)*|, где звездочка означает сколько угодно
раз, в т.ч. ничего.

Сперва прочитаем строки из файла обычной функцией. Эта функция не должна быть
частью спеки. Спеки не должны иметь побочных эффектов, они только
преобразовывают данные.

\begin{verbatim}
(require '[clojure.java.io :as io])

(defn get-ini-lines
  [path]
  (with-open [src (io/reader path)]
    (doall (line-seq src))))
\end{verbatim}

Теперь составим спеку-парсер. Решим, что такая спека принимает список строк из
ini-файла. Требуется выполнить следующие шаги:

- удалить пустые строки и комментарии;
- оставшиеся строки сгруппировать по заголовкам, распарсить пары поле=значение;
- реструктурировать данные во вложенный словарь;
- вывести типы и все проверить.

Выразим это в коде:

\begin{verbatim}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* (s/cat :title :ini/title :fields (s/* :ini/field))) ;; 4
   (s/conformer remap-ini-data)
   ::ini-config))
\end{verbatim}

Убедитесь, что поняли смысл четвертой строки. Мы считаем, что INI-файл это ноль
и более блоков. Каждый блок состоит из заголовка и ноль и более пар
ключ-значение.

Реализуем недостающие элементы. Функция \spverb|clear-ini-lines| выбрасывает незначащие
строки:

\begin{verbatim}
(require '[clojure.string :as str])

(defn comment?
  [line]
  (str/starts-with? line "#"))

(defn clear-ini-lines
  [lines]
  (->> lines
       (filter (complement str/blank?))
       (filter (complement comment?))))
\end{verbatim}

Объявим спеку \spverb|:ini/title|. Она проверяет, заголовок ли текущая строка или
нет. Заголовок определяют квадратные скобки на границах строки. Если условие
выполняется, вернем текст заголовка без скобок:

\begin{verbatim}
(s/def :ini/title
  (s/and
   #(str/starts-with? % "[")
   #(str/ends-with? % "]")
   (with-conformer val
     (subs val 1 (dec (count val))))))
\end{verbatim}

Спека \spverb|:ini/field| парсит поле и значение. Просто разбиваем строку по знаку
равенства. Цифра 2 означает, что в итоговом списке должно быть не более двух
элементов: ключ и значение. Это полезно, когда значение содержит знак равенства
(например, base64 строка).

\begin{verbatim}
(s/def :ini/field
  (with-conformer val
    (let [[key val :as pair] (str/split val #"=" 2)]
      (if (and key val)
        pair
        ::s/invalid))))
\end{verbatim}

В примере выше мы убеждаемся, что действительно получили ключ и значение. Так мы
исключим строки, в которых нет знака равенства.

На текущий момент запустим черновую, урезанную версию спеки:

\begin{verbatim}
(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* (s/cat :title :ini/title :fields (s/* :ini/field)))))

(defn parse
  [path]
  (let [lines (get-ini-lines path)]
    (s/conform ::->ini-config lines)))

(parse "config.ini")
\end{verbatim}

Результат:

\begin{verbatim}
[{:title "database"
  :fields [["host" "localhost"]
           ["port" "5432"]
           ["user" "test"]]}
 {:title "server"
  :fields [["host" "127.0.0.1"]
           ["port" "8080"]]}]
\end{verbatim}

Разбор файла прошел удачно. Читатель заметит, что структура словаря отличается
от той, что мы предложили вначале. Это неважно. Главное, нам удалось привести
набор строк к определенному формату. Не составит труда обработать словарь
функцией \spverb|remap-ini-data|:

\begin{verbatim}
(defn remap-ini-data
  [data-old]
  (reduce
   (fn [data-new entry]
     (let [{:keys [title fields]} entry]
       (assoc data-new title (into {} fields))))
   {}
   data-old))
\end{verbatim}

Если передать в эту функцию вектор из предыдущего шага, результат будет тем, что
мы ожидали:

\begin{verbatim}
{"database" {"host" "localhost" "port" "5432" "user" "test"}
 "server" {"host" "127.0.0.1" "port" "8080"}}
\end{verbatim}

Напишем спеку, чтобы проверить конфигурацию и вывести типы. Например, чтобы
номера портов были числами:

\begin{verbatim}
(s/def :db/host ::ne-string)
(s/def :db/port ::->int)
(s/def :db/user ::ne-string)

(s/def ::database
  (s/keys :req-un [:db/host
                   :db/port
                   :db/user]))

(s/def :server/host ::ne-string)
(s/def :server/port ::->int)

(s/def ::server
  (s/keys :req-un [:server/host
                   :server/port]))

(s/def ::ini-config
  (s/keys :req-un [::database
                   ::server]))
\end{verbatim}

Перед тем, как применять словарь к этой спеке, следует перевести его ключи из
строк в кейворды. Вот как выглядит итоговая спека:

\begin{verbatim}
(require '[clojure.walk :as walk])

(s/def ::->ini-config
  (s/and
   (s/conformer clear-ini-lines)
   (s/* (s/cat :title :ini/title :fields (s/* :ini/field)))
   (s/conformer remap-ini-data)
   (s/conformer walk/keywordize-keys)
   ::ini-config))
\end{verbatim}

И результат:

\begin{verbatim}
(parse "config.ini")

{:database {:host "localhost"
            :port 5432
            :user "test"}
 :server {:host "127.0.0.1"
          :port 8080}}
\end{verbatim}

Упражнение: устраните мелкие недоработки в коде выше. Пусть пара \spverb|"foo="|
становится \spverb|{:foo nil}|, а не \spverb|{:foo ""}|.  Удалите пустые символы, которые
могли остаться по краям ключа и значения. Опробуйте парсинг на больших
ini-файлах.

\section{Разбор Clojure-кода (теория)}

В завершении темы немного поговорим о том, как парсить код. Мы уже видели, что
clojure.spec подходит для разбора структур данных~--- в основном
последовательностей. Вспомним, что код на Clojure состоит из списков. Это
приводит к неожиданному решению: оказывается, исходный код на Clojure можно
проверить спекой и вернуть ошибку еще до того, как он запущен.

В начале главы мы упоминали, что Clojure и Spec неразрывно связаны. Объясним эту
связь на примере макросов. Большинство форм в Clojure представлены
макросами. Это особые функции, которые срабатывают на этапе компиляции
кода. Макрос принимает код как список символов. Задача макроса, как правило, в
том, чтобы перестроить этот список в другой и вернуть его. Компилятор заменяет
макрос на список-результат и выполняет его.

Макросы это отдельная веха в изучении Clojure. Мы поговорим о них в другой
главе. Пока что заострим внимание на том, как проверить тело макроса.

Каждый макрос это по сути мини-язык с соглашением о том, что и в каком порядке
передавать. Иногда один и тот же макрос допускает разные формы записи. По
аналогии с языком, требуется разобрать грамматику кода. В случае ошибки доступно
объяснить программисту, где он ошибся.

Хорошим примером служит \spverb|defn|, макрос определения функции. Кроме обязательных
параметров он принимает несколько второстепенных: строку документации, пре- и
пост-проверки. Справедлива форма записи с несколькими телами:

\begin{verbatim}
(defn my-inc
  [x]
  (+ x 1))

(defn my-inc
  "Increase a number"
  [x]
  {:pre [(int? x)]
   :post [(int? %)]}
  (+ x 1))

(defn my-inc
  ([x]
   (my-inc x 1))
  ([x delta]
   (+ x delta)))
\end{verbatim}

Все это одна и та же функция, записанная по-разному. Очевидно, ручной разбор
всех вариантов трудоемок. До версии Clojure 1.10 каждый макрос разбирал код по
собственным правилам. Это было неорганизованно и неконсистентно. Начиная с 1.10
большинство макросов используют спеку для проверки и вывода ошибок. Так
образовался общий подход к проблеме, который легко контролировать.

Разберем устно, как бы мы построили спеку для разбора \spverb|defn|. Очевидно, это
список, поэтому на верхнем уровне спеки поместим s/cat. Первый его элемент~---
символ \spverb|defn|. Второй~--- символ с именем. После имени следует опциональный параметр
строки документации. Затем тело или список тел.

Тело начинается с вектор параметров. После него идет опциональный словарь пре- и
пост- проверок. Затем произвольное количество форм, которые составляют тело
функции.

Грубая версия:

\begin{verbatim}
(s/def ::defn
  (s/cat :tag (partial = 'defn)
         :name symbol?
         :docstring string?
         :body (s/+ :defn/body)))
\end{verbatim}

, где тело функции это

\begin{verbatim}
(s/def :defn/body
  (s/cat :args :defn/args
         :prepost (s/? map?)
         :code :defn/code))
\end{verbatim}

В свободное время напишите такую спеку. Передайте в нее замороженную версию
\spverb|defn|:

\begin{verbatim}
(s/conform
 ::defn
 '(defn my-inc
    "Increase a number"
    [x]
    {:pre [(int? x)]
     :post [(int? %)]}
    (+ x 1)))
\end{verbatim}

Результатом будет что-то отдаленно напоминающее:

\begin{verbatim}
{:name my-inc
  :docstring "Increase a number"
  :bodies
  [{:params [x]
    :declaration [(+ x 1)]
    ;; other fields}]}
\end{verbatim}

Каждый следующий уровень можно расширить вглубь. Выше мы упомянули вектор
параметров. Будет здорово разобрать их на обязательные и
необязательные. Например, чтобы параметры \spverb|[x y & other]| предстали в виде
словаря:

\begin{verbatim}
{:required [x y] :rest other}
\end{verbatim}

Усложните спеку так, чтобы она различала параметры функции. По аналогии
выполните разбор словаря пре- и пост- проверок.

\section{Спецификация функций}

В последнем разделе мы поговорим о том, как clojure.spec связана с функциями. Мы
уже упоминали проблему с проверкой входных данных. Даже если параметры нужного
типа, это не гарантирует, что значения верны. Вспомним функцию, которая
принимает диапазон дат. Случай, когда ее вызвали с параметрами
\spverb|start=2010.01.01| и \spverb|end=2009.01.01|, не имеет смысла.

Логично описать параметры этой функции спекой:

\begin{verbatim}
(s/def ::date-range-args
  (s/and
   (s/cat :start inst? :end inst?)
   (fn [{:keys [start end]}]
     (<= (compare start end) 0))))
\end{verbatim}

Вторая функция из \spverb|s/and| принимает результат первого \spverb|s/cat|, то есть словарь с
ключами \spverb|:start| и \spverb|:end|. Для сравнения дат используют специальную функцию
compare, которая возвращает -1, 0 и 1 для случаев меньше, равно и
больше. Быстрая проверка:

\begin{verbatim}
(s/valid? ::date-range-args [#inst "2019" #inst "2020"]) ;; true
(s/valid? ::date-range-args [#inst "2020" #inst "2019"]) ;; false
\end{verbatim}

Возникает идея написать декоратор, который принимает целевую функцию и спеку ее
параметров. Перед тем, как запускать функцию, он проверит параметры и в случае
ошибки выкинет исключение. То же самое можно проделать для результата функции.

Нам не придется писать декоратор, потому что его включили в поставку
clojure.spec. Речь идет о функции \spverb|clojure.spec.test.alpha/instrument|. Глагол
instrument дословно означает оснастить, оборудовать.

Функция принимает символ другой функции, которую мы хотим оснастить
проверкой. Вместе с тем она ищет особую функциональную спеку, зарегистрированную
под этим же символом. Когда обе сущности найдены, instrument подменяет функцию
на такую же, но с проверками. Это своего рода monkey patch, когда один модуль
изменяет поведение другого.

Функциональную спеку объявляют макросом \spverb|s/fdef|. Сначала передают символ
функции, которую хотели бы оснастить. Затем отдельные спеки для проверки
входящих параметров, результата и их композиции.

В качестве примера напишем функцию и спеку к ней. Пусть это будет функция,
которая возвращает разницу между двумя датами в секундах. В отличие от примера
выше, мы допускаем случай, когда первая дата болье второй. В этом случае разница
в секундах будет отрицательной.

\begin{verbatim}
(import 'java.util.Date)

(defn date-range-sec
  "Return a difference between two dates in seconds."
  [^Date date1 ^Date date2]
  (quot (- (.getTime date2)
           (.getTime date1))
        1000))
\end{verbatim}

Теги \spverb|^Date| нужны, чтобы компилятор знал тип объектов date1 и date2. В
противном случае компилятор выполнит рефлексию, чтобы узнать тип. Это съедает
машинное время. Мы поговорим о типах в отдельной главе.

Посчитаем разницу в сутках:

\begin{verbatim}
(date-range-sec
 #inst "2019-01-01" #inst "2019-01-02")
86400
\end{verbatim}

Если поменять даты местами, результат будет отрицательным.

Опишем функциональную спеку. Ее символ будет \spverb|date-range-sec|.  Под ключом
\spverb|:args| указывают спеку входящих параметров. Поскольку параметры это список, на
верхнем уровне почти всегда \spverb|s/cat|. Его задача разбить список на словарь, чтобы
спекам ниже было удобно работать с отдельными значениями.

Под \spverb|:ret| указана спека выходного значения. Чаще всего это проверка на число
или строку. Например, \spverb|int?|, \spverb|string?| или их nilable-версии: \spverb|(s/nilable int)|
и так далее.

Ключ \spverb|:fn| особый. Это спека, которая будет вызвана в контексте входных
параметров и результата. Бывает, что результат зависит от входных параметров по
определенным правилам. Например, если функция возвращает число из диапазона, то
проверка результата на \spverb|int?| недостаточна. Следует убедиться, что результат
действительно не выходит за границы аргументов.

Спеке \spverb|:fn| передают словарь с ключами \spverb|:args| и \spverb|:ret|. Значение \spverb|:args|
содержит не исходный список параметров, а результат \spverb|s/conform| от
\spverb|:args|. Задача спеки~--- проверить, удовлетворяет ли результат входным
аргументам. Если нет, вернуть \spverb|false| для предиката или \spverb|::s/invalid| для
\spverb|s/conformer|.

Напомним, что в ключи \spverb|:args|, \spverb|:ret|, \spverb|:fn| можно передавать объявленные ранее
спеки. Это хорошая практика по переиспользованию кода. Например, у вас может
быть семейство функций для работы с диапазонами чисел. Будет правильно объявить
спеку параметров отдельно и затем ссылаться на нее в каждой из \spverb|s/fdef|.

Опишем спеку для функции \spverb|date-range-sec|. Ограничимся проверкой входных
параметров и результата:

\begin{verbatim}
(s/fdef date-range-sec
  :args (s/cat :start inst? :end inst?)
  :ret int?)
\end{verbatim}

Объявление функциональной спеки еще не меняет целевую функцию. Это правильно,
потому что спека только декларирует проверки, но не запускает их. Чтобы
подменить целевую функцию на ее оснащенную версию, используют \spverb|instrument| из
модуля \spverb|clojure.spec.test.alpha|:

\begin{verbatim}
(require '[clojure.spec.test.alpha
           :refer [instrument]])

(instrument `date-range-sec)
\end{verbatim}

Важно, что символ функции должен быть полным, то есть с пространством. Чтобы
подставить в символ текущее пространство, перед ним ставят обратную кавычку \spverb|`|.

Теперь \spverb|date-range-sec| проверяет аргументы и результат. Попробуем передать
\spverb|nil| вместо одной из дат. Получим исключение класса
\spverb|clojure.lang.ExceptionInfo|.

\begin{verbatim}
(date-range-sec nil #inst "2019")
\end{verbatim}

Его текстовое сообщение и тело уже вам знакомы. Поле message содержит текст,
аналогичный \spverb|s/explain-str|:

\begin{verbatim}
Execution error - invalid arguments to date-range-sec
nil - failed: inst? at: [:start]
\end{verbatim}

В поле data структура, аналогичная результату \spverb|s/explain-data|. Чтобы получить
эти данные из пойманного сообщения, используют функцию \spverb|(ex-data exception)|.

Обратите внимание, что \spverb|instrument| расположен в отдельном модуле с доменом
"test". Это потому, что instrument предназначен для тестирования функций, но не
продакшена. Разработчики пишут спеки для наиболее важных функций в отдельном
модуле. Во время тестов проект стартует с особыми параметрами, где указаны
дополнительные модули, которые нужно загрузить. Один из таких тестовых модулей
оснащает функции их спеками. Если при прогоне тестов функция вернула неверный
результат, это сразу станет заметно.

Instrument не подходит для боевого режима, потому что значительно снижает
быстродействие функции. Замерим десять тысяч прогонов оснащенной функции:

\begin{verbatim}
(time
 (dotimes [n 10000]
   (date-range-sec #inst "2019" #inst "2020")))
\end{verbatim}

\begin{verbatim}
"Elapsed time: 116.984496 msecs"
\end{verbatim}

Получили десятую долю секунды на 10К вызовов. Пока что трудно сказать, быстро
это или нет. Посчитаем время для исходной функции. Поскольку \spverb|date-range-sec|
уже оснащена, объявим функцию с таким же телом, но другим именем, например
\spverb|date-range-sec-orig|. Посчитаем стоимость ее вызова:

\begin{verbatim}
(time
 (dotimes [n 10000]
   (date-range-sec-orig
     #inst "2019" #inst "2020")))
\end{verbatim}

\begin{verbatim}
"Elapsed time: 1.783962 msecs"
\end{verbatim}

Разница в сто раз, или два порядка! Очевидно, что проверка в рантайме
существенно замедляет приложение. По этой причине \spverb|instrument| не претендует на
то, чтобы его использовали в продакшене. Замедление кода в десятки раз~--- слишком
дорогая цена за детальный вывод ошибок.

Наоборот, во время тестов быстродействие нас не интересует. Мы стремимся покрыть
код как можно большим числом проверок, чтобы отловить необычные сценарии.

В примере выше мы проигнорировали ключ \spverb|:fn|. Напомним, это комплексная
проверка, в которой одновременно доступны аргументы и результат. Для функции
\spverb|date-range-sec| справедливо правило: если первая дата больше второй, то
результат отрицательный. Напишите спеку \spverb|:fn|, которая проверяет это
условие. Тем самым вы предотвратите случай, когда кто-то решит, что результат
должен быть по модулю.

Наличие спеки для функции улучшает документацию у ней. Специальная функция \spverb|doc|
из модуля \spverb|clojure.repl| выводит на экран справку о запрошенной функции. С
появлением clojure.spec ее поведение изменилось. Теперь, кроме строки
документации, она выводит спеку функции.

Вот как выглядит справка для \spverb|date-range-sec|:

\begin{verbatim}
(require '[clojure.repl :refer [doc]])
\end{verbatim}

\begin{verbatim}
-------------------------
date-range-sec
([date1 date2])
  Return a difference between two dates in seconds.
Spec
  args: (cat :start inst? :end inst?)
  ret: int?
\end{verbatim}

Функцию \spverb|doc| активно используют различные IDE и редакторы, чтобы показывать
сигнатуру по мере написания кода. Даже если вы не пользуетесь \spverb|instrument| для
тестирования, спека помогает поддерживать проект.

\section{Переиспользование спек}

Писать спеки порой долго и утомительно. В Clojure-сообществе принято снабжать
библиотеки спеками, чтобы облегчить труд другим разработчикам. Если библиотека
использует какую-то структуру данных, будет правильно описать ее спекой.

Хорошим примером служит \spverb|clojure.jdbc|. Это легковесная Clojure-обертка над
реляционными базами данных. Почти каждое веб-приложение использует БД для
хранения данных. JDBC-подключение описано словарем с ключами \spverb|:host|, \spverb|:port|,
\spverb|:user| и так далее.

Считается правильным проверить конфигурацию базы перед тем, как подключаться к
ней. В противном случае вы рискуете получить странное поведение, например
\spverb|NullPointerException| при попытке соединения.

Сlojure.jdbc несет на борту семейство спек для всех своих подсистем. Достаточно
импортировать модуль \spverb|clojure.java.jdbc.spec|, чтобы описанные в нем спеки
попали в глобальный реестр.

Предположим, ключ \spverb|:db| в конфигурации описывает подключение. Пусть это будет
edn-файл:

\begin{verbatim}
{:db {:dbtype "mysql"
      :host "127.0.0.1"
      :port 3306
      :dbname "project"
      :user "user"
      :password "********"
      :useSSL true}}
\end{verbatim}

Прочитаем файл комбинацией \spverb|read-string| и \spverb|slurp|:

\begin{verbatim}
(read-string (slurp "config.edn"))
\end{verbatim}

Спека для этого файла выглядит так:

\begin{verbatim}
(require '[clojure.java.jdbc.spec :as jdbc])

(s/def ::db ::jdbc/db-spec)

(s/def ::config
  (s/keys :req-un [::db]))
\end{verbatim}

Нормально, если спеку поставляют в отдельной библиотеке как дополнение. Так
поступили разработчики alia~--- Clojure-клиента для Кассандры. Базовый пакет
\spverb|qbits.alia| несет базовую функциональность, а сторонний \spverb|cc.qbits/alia-spec|
содержит спеку кластера и основных функций.

\section{Дополнения к spec (обзор)}

Spec входит в поставку Clojure и потому не меняется так радикально, как
предлагают некоторые разработчики. Дополнения к spec выпускают отдельными
библиотеками. Среди прочих заслуживают внимания два проекта: \spverb|expound| и
\spverb|spec.tools|. В этом разделе мы коротко опишем возможности каждого.

[expound]: https://github.com/bhb/expound

Библиотека [expound][expound] улучшает сообщения об ошибках, делает их понятней
для человека. Сигнатура функции expound аналогична \spverb|s/explain|. Она тоже принимает
спеку и данные. Сообщение об ошибке выглядит примерно так:

\begin{verbatim}
(expound/expound string? 1)
\end{verbatim}

\begin{verbatim}
-- Spec failed --------------------
  1
should satisfy
  string?
-------------------------
Detected 1 error
\end{verbatim}

Такой отчет все еще выглядит машинным, и мы не можем показать его
пользователю. Все же он лучше, чем сырой \spverb|s/explain|. Например, его могут
прочитать коллеги из команды Ops, которые не знакомы с Clojure. Особенно хорошо
expound подходит для проверки конфигурации на старте приложения. Иногда код
приложения не меняется месяцами, но конфигурацию обновляют часто, поэтому отчет
о проблемах на старте важен.

[spec.tools]: https://github.com/metosin/spec-tools

Разработчики Metosin собрали ряд улучшений к clojure.spec в проекте
[spec.tools][spec.tools]. В сердце этой библиотеки особый объект Spec. Он
оборачивает стандартную спеку и дополняет ее различными методами. С помощью
spec.tools удобно формировать JSON-схему или описывать REST-проект по стандарту
Swagger. Библиотеку используют в основном как промежуточный слой между
REST-фреймворком и спекой.

Мы не будем останавливаться подробно на этих проектах. Они просты в техническом
плане и требуют больше кода, чем объяснения. Читателю не составит труда
разобраться с ними, когда на то возникнет потребность.

\section{Будущее спеки}

[schema]: https://github.com/plumatic/schema

[bouncer]: https://github.com/leonardoborges/bouncer

На сегодняшний день пакет clojure.spec все еще не избавился от частички "alpha"
в названии. Авторы все еще экспериментируют со спекой, пытаются найти лучший
способ валидировать данные. Это смущает некоторых разработчиков. Опасаясь, что
по окончании эксперимента от spec избавятся, они предпочитают альтернативные
библиотеки: [schema][schema], [bouncer][bouncer].

Отдельные группы пишут обертки над спекой, чтобы расширить ее
возможности. Например, подружить ее с JSON-схемами и популярными инструментами
вроде Swagger.

В недавнем докладе Maybe Not Рич Хикки анонсировал вторую версию
спеки. Ожидается, что разработчики упростят проверку сложных типов
данных. Например, когда значением может быть и строка, и число. Разработка
ведется в открытом режиме, но еще рано говорить о конкретных
результатах. Обсуждение новой спеки выходит за рамки этой главы.

\section{Итог}

Как мы выяснили, clojure.spec~--- это набор функций и макросов. Ими описывают
правила, которым должны удовлетворять данные. Правила это предикаты,
т.е. Функции, которые возвращают истину или ложь.

Предикаты гибче и мощнее типов. Если о значении известно, что оно верного типа,
это еще не гарантирует его корректность. Значение \spverb|-1| не может быть
Unix-портом. Пользовательские классы вроде \spverb|UnixPort| в конструкторе это не
типы, а валидация в рантайме. Она привязана к вызову класса синтаксическим
сахаром.

В отличие от классов, предикаты компонуются друг с другом. Легко написать
супер-предикат с логикой "все из", "любой из" и так далее.

Мы рассмотрели основные возможности из пакета clojure.spec. Это далеко не все, о
чем еще можно рассказать. В обсуждение не попали различные спеки-комбинаторы
вроде \spverb|s/alt|, полезные для тонких проверок. Другая обширная тема по spec~---
генераторы из модуля \spverb|clojure.spec.gen.alpha|. Мы коснемся их в отдельной главе
про тесты.
