\chapter{Введение в~веб-разработку}

\begin{teaser}
В первой главе мы рассмотрим, как писать веб-приложения на Clojure. Поговорим о
том, как передают данные по протоколу HTTP. Какие абстракции строят поверх
протокола и что предлагает Clojure. Чем хорош функциональный подход и почему
разработка с~ним быстрее и~удобнее.
\end{teaser}

Каждый год компания Cognitect опрашивает\footnote{blog.cognitect.com/blog/2017/1/31/clojure-2018-results}
разработчиков на Clojure. Среди прочего в анкете вопрос о том, в какой области вы работаете? В~2010 году под
веб писали 50\% опрошенных, то есть каждый второй. К~2018 году
эта цифра выросла до 80\%. Это уже четыре человека из пяти. Похожую динамику показывают
опросы StackOverflow\footnote{insights.stackoverflow.com/survey/2018}.
Согласно им, все больше разработчиков переходит в веб из смежных областей.

Если вы найдете работу на Clojure, скорее всего это будет веб-приложение. Мы
специально не говорим <<сайт>>, чтобы подчеркнуть: термин уходит в
прошлое. Сегодня веб-приложение это не только HTML с картинками. В широком плане
это сложный обмен данными по протоколу HTTP.

Протокол разработан для передачи разметки, но удивительным образом подошел для
данных. Для этого даже не пришлось менять стандарт. Причина кроется в его
изящном дизайне, простоте и гибкости. Прежде чем перейти к Clojure, освежим в
памяти устройство протокола. Из каких частей он состоит и по каким правилам с
ним работает сервер. Это важно, потому что языки и фреймворки меняются, а
протокол нет.

\section{Основы HTTP}

HTTP это протокол, который работает поверх TCP/IP. В широком смысле протоколы~---
это соглашения о том, как читать и писать данные. Обычно они записаны в официальных
документах. Для HTTP такой документ называется RFC~2616\footnote{https://tools.ietf.org/html/rfc2616}.
Разработчики браузеров сверяются с~ним, чтобы технология работала
на разных языках и платформах.

HTTP удобен тем, что это текст. Разработчику не нужно декодировать байты, чтобы
понять, что происходит. Протокол передает и бинарные данные, но главные части
все же выражены текстом. В HTTP различают запрос и ответ. Оба состоят из трех
частей: \emph{первая строка}, \emph{заголовки} и \emph{тело}.

\emph{Первая (стартовая)} строка несет самую важную информацию. Ее формат
различается для запроса и ответа. Для запроса это метод, путь и версия, для
ответа~--- статус, сообщение и версия.

\emph{Заголовки} это пары ключ-значение. В современных фреймворках их
описывают словарем. Заголовки содержат дополнительные сведения о запросе или
ответе. Например, заголовок \spverb|Content-Type| сообщает, как трактовать тело
запроса. Был ли это XML- или JSON-документ? Программа проверяет заголовок
и~читает тело должным образом.

После заголовков следует \emph{тело}. Им может быть что угодно~--- текст, данные
в виде <<поле=значение>>, JSON-документ, картинка, фильм, электронное
письмо. Стандарт допускает смешанный тип, \spverb|multipart-encoding|. Тело
такого запроса разбито на ячейки, в каждом из которых свое содержимое. Например,
текст, картинка, снова текст, двоичный файл.

Рассмотрим примеры HTTP-трафика. Именно в таком виде он передается
по сети. Это запрос к главной странице Google, поисковой терм~--- \spverb|clojure|:

\begin{verbatim}
GET /search?q=clojure HTTP/1.1
Host: google.com
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
(blank line)
\end{verbatim}

\noindent
А это POST-запрос с JSON-документом в теле:

\begin{verbatim}
POST /api/users/ HTTP/1.1
Host: example.com
Content-Type: application/json
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)

{
  "username": "John",
  "city": "NY"
}
\end{verbatim}

\noindent
Ответ на этот запрос:

\begin{verbatim}
HTTP/1.1 200 OK
Date: Tue, 19 Mar 2019 15:57:11 GMT
Server: Nginx
Connection: close
Content-Type: application/json

{
  "code": "CREATED",
  "message": "A user has been created successfully"
}
\end{verbatim}

Видно, как изящно устроен протокол. Данные в нем расположены по убыванию важности.
Прочитав только первую строку, клиент и сервер готовы принять решение о~том,
что делать дальше.

Рассмотрим сценарий: в запросе указаны метод и путь \spverb|GET /about|, но
такой страницы не существует. Сервер проверит это заранее, например, сверив путь
с конфигурацией маршрутов. Когда маршрута нет, вернется ответ со статусом
404. Не придется читать тело запроса, что ускорит работу сервера. Получив ответ,
клиент прочитает статус 404 из первой строки, что означает ошибку. Логика
клиента может быть такова, что для негативного статуса он не читает тело.

Чтение и разбор содержимого это дорогая операция. Современные фреймворки
исключают случаи, когда чтение происходит зря. Например, по заголовку
\spverb|Content-Type| мы определяем, стоит ли читать тело. Наше приложение
работает только с JSON, поэтому для значения \spverb|text/xml| вернем
ошибку. Аналогично с заголовком \spverb|Content-Length|, где содержится длина
тела в байтах. Если значение больше заданного лимита, сервер отклонит запрос еще
до чтения.

Центральные параметры запроса это \emph{метод} и \emph{путь}. Путь указывает на
определенный ресурс на сервере. Иногда сервер трактует путь как файл
относительно заданной папки. Например, \spverb|/images/map.jpg| означает вернуть
такой файл из \spverb|/var/www/static|. Но чаще всего путь обрабатывают по
внутренним правилам. Ответом может быть не только файл, но и js-скрипт,
HTML-разметка или JSON-документ.

\emph{Метод запроса} означает действие, которые мы намерены выполнить над
ресурсом. Основные методы это \spverb|GET|, \spverb|POST|, \spverb|PUT| и
\spverb|DELETE|. Их семантика в том же порядке~--- прочитать, создать, обновить,
удалить ресурс. Так, запрос \spverb|POST /users/| означает создать пользователя,
а \spverb|GET /users/|~--- получить их список.

Главный параметр ответа это \emph{статус}~--- целое положительное число. Статусы
группируют по старшему разряду. Значения с 200 до 299 (или \spverb|2хх|) считают
положительными. Они означают, что сервер обработал запрос без ошибки.

Значения из группы \spverb|3хх| связаны с перенаправлением на другую страницу.
В заголовке \spverb|Location| приходит путь, на который нужно послать
новый запрос. Браузеры и HTTP-клиенты достаточно умны, чтобы сделать это
автоматически. Например, при запросе страницы \spverb|http://yandex.ru| вы
получите пустой документ с заголовком \spverb|Location: https://yandex.ru|.
Сервер обязывает нас перейти на безопасное соединение. Но мы даже не заметим
этого: браузер сам сменит адрес.

Статусы из группы \spverb|4хх| означают ошибку на стороне клиента. Чаще всего это 404~---
страница не найдена. На ошибочные данные сервер отвечает 400~--- \spverb|Bad request|.
Когда нет прав доступа, клиент получит код 403.

Статусы из группы \spverb|5хх| говорят об ошибке сервера или его
недоступности. Это деление на ноль, отказ базы данных, недостаток места
на диске.

Принято считать, что ответ со статусом вне диапазона \spverb|2хх| означает
ошибку. Многие HTTP-клиенты бросают исключение на ответ с негативным статусом.
Строго говоря, это верно только на высоком, абстрактном уровне. С точки
зрения протокола ответ \spverb|404 Not Found| такой же правильный, как и \spverb|200 OK|.

Когда действий с ресурсом много, используют другие, более редкие
методы. Например, \spverb|HEAD|~--- получить краткие сведения о сущности. Сервис
Amazon S3 в ответ на HEAD-запрос вернет только статус и заголовки. В них указаны
тип файла и его размер, контрольная сумма, дата последнего изменения. В данном
случае \spverb|HEAD|-запрос предпочтительней GET. Метаданные хранят в особом
хранилище отдельно от файла. Доступ к нему обычно быстрее, чем к файлу на диске.

Подход <<метод-ресурс>> со временем вырос в то, что сегодня называется
\spverb|REST|\footnote{restapitutorial.com}. Сторонники
\spverb|REST| выделяют сущности и \spverb|CRUD|-операции над ними (\textbf{C}reate,
\textbf{R}ead, \textbf{U}pdate, \textbf{D}elete). Считается хорошим подход,
когда сущность задают через путь, например \spverb|/users/1|, а операцию~---
методом. Если это создание или изменение, данные читают из тела, где обычно записан
JSON-документ. Мы не будем задерживаться на \spverb|REST|, потому что это всего лишь
свод рекомендаций, не идеальный и не единственный.

Отметим, что протокол не заставляет следовать этим правилам. Разработчик вправе
работать с HTTP так, как это удобно в данном проекте. Например, принимать только
POST-запросы с данными в теле. Или только GET с параметрами строки. Верную
стратегию определяют инструменты, бизнес и потребители сервиса.

\section{Возвращаясь к Clojure}

Современные фреймворки строят абстракции над HTTP. Разработчик не читает запрос
по байтам вручную. Эту задачу берут на себя библиотеки. Взамен разработчик
получает набор классов, чтобы с их помощью выразить логику приложения. Типичный
веб-проект на Python или Java это комбинация нескольких классов. Как правило,
это \spverb|Application|~--- главная сущность проекта. Класс \spverb|Router|
определяет, на какой обработчик переключить входящий запрос~--- \spverb|Request|.
Обработчик~--- это класс \spverb|Handler| с методами \spverb|.onGet|,
\spverb|.onPost| и тд. Ожидается, что он вернет экземпляр класса \spverb|Response|.

По такому принципу устроены промышленные веб-фреймворки: Django, Rails,
Symfony. Названия классов и их комбинация отличаются, но смысл остается
прежним. Это приложение, роутер, обработчик, запрос и ответ. Проблема в том, что
классы одного фреммворка не работаю с другим и наоборот.

Рассмотрим язык Python и фреймворки Django и Flask. Оба следуют той же
структуре. Так, запрос в Django описан в классе \spverb|django.http.HttpRequest|,
а во Flask~--- \spverb|flask.Request|. Даже беглого взгляда достаточно,
чтобы увидеть, насколько они отличаются. У классов разные методы и поля.
То, что есть в первом классе, отсутствует во втором. Использовать \spverb|flask.Request|
в проекте на Django невозможно.

Со временем проект увязает в архитектуре фреймворка. Переезд на другое решение
становится все менее возможным. Хорошие практики предлагают делить проект на
слои. Слой транспорта отвечает за ввод и вывод данных по протоколу HTTP. Слой
логики исполняет внутренний код, ничего не зная о HTTP. С таким подходом логика
не зависит от транспорта, и последний можно сменить в любой момент. Но на
практике это работает не всегда. По разным причинам слои перемешиваются. Мы
обещаем, что в следующий раз не допустим этого, и все повторяется сначала.

В Clojure другой подход.

Разработчик Джеймс Ривз (James Reeves) известен своим вкладом в экосистему
Clojure. Он разработал 60 библиотек\footnote{github.com/weavejester} для разных
задач. Нет такого проекта на Clojure, который бы не использовал его
наработки. Заслуга Джеймса в том, что он вывел стандарт веб-разработки для
Clojure на заре языка. Вместо того, чтобы писать фремворк под сиюминутные нужды,
он придумал, как сделать удобно всем.

Джеймс предложил несколько простых идей. Первая~--- если приложение принимает
запрос и возвращает ответ, то резонно \emph{выразить его функцией}. Действительно,
приложения бывают сколь угодно сложным. Они полагаются на сторонние сервисы,
машинное обучение, учитывают сотню фактов о пользователе. Но они принимают
запрос и возвращают ответ, поэтому на абстрактном уровне это \emph{функция}.

Скептики заметят, что мысль не нова. В том же Django обработчик бывает
не классом, а функцией. Разница в том, что отдельный обработчик~--- это
еще не приложение. Ему не хватает роутера, middleware и других абстракций.
Поэтому в Django или Flask выразить обработчик функцией~--- всего лишь
приятная возможность, сахар.

В Clojure приложение остается функцией на всех уровнях. Маршрутизатор~--- это
функция, которая принимает запрос, определяет обработчик и передает ему
управление. Middleware это тоже функция, которая дополняет приложение новой
логикой. Каждую тяжелую абстракцию (классы \spverb|Application|,
\spverb|Router|, \spverb|Handler|) в мире Clojure заменяют функцией. Это удобно,
потому что в отличии от классов функции стыкуются между собой.

Вторая идея Джеймса в том, чтобы зафиксировать структуру запроса и
ответа. Должны быть документы (не код, а \emph{именно документы}), где описаны
поля структур и их семантика. Это напоминает протокол HTTP. Спецификация
упрощает код и делает его переносимым. Два веб-проекта на Clojure принимают и
отдают одинаковые структуры данных. Разработчик очередного фреймворка учитывает
спецификацию. Если фреймворк следует стандарту, проще привлечь сообщество.

\subsection{Ring}

Идеи нашли применение в проекте Ring\footnote{github.com/ring-clojure/ring}.
Сегодня это стандарт веб-разработки на Clojure. Репозиторий содержит спецификацию
запроса и ответа и базовый код для работы с ними. Прилагаются основные
middleware, запуск Jetty-сервера и документация. Удивительно, как мало кода
понадобилось проекту, чтобы попасть на компьютер каждому Clojure-разработчику.

Со временем появился термин <<Ring-совместимость>>. Ему следуют все
фреймворки на Clojure. Типичное Ring-приложение запускается на многих платформах:
Jetty, Netty и других без изменений в коде.

Библиотека Ring разбита на отдельные части, чтобы можно было установить только
необходимое. Перечислим компоненты, которые понадобятся по ходу главы:


\begin{itemize}
\item
  \spverb|ring-core|~--- базовая функциональность: параметры, разбор тела, куки, сессии;

\item
  \spverb|ring-jetty-adapter|~--- запуск сервера из функции-приложения.

\end{itemize}

Первое приложение вы напишете даже без библиотеки. Вот оно:

\begin{verbatim}
(defn app [request]
  (let [{:keys [uri request-method]} request]
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body (format "You requested %s %s"
                   (name request-method) uri)}))
\end{verbatim}

Приложение извлекает путь и метод из запроса и формирует ответ. Его статус
положительный~--- 200. Мы выставили заголовок с типом документа <<простой
текст>>. Поле \spverb|:body| содержит строку, которую строим функцией \spverb|format|.

Поскольку \spverb|app| это функция, вызовем ее с различными запросами:

\begin{verbatim}
(app {:request-method :get :uri "/index.html"})
{:status 200,
 :headers {"Content-Type" "text/plain"},
 :body "You requested get /index.html"}

(app {:request-method :post :uri "/users"})
{:status 200,
 :headers {"Content-Type" "text/plain"},
 :body "You requested post /users"}
\end{verbatim}

Работает. Но пока что это структуры данных, и не ясно, что будет в
браузере. Запустим приложение в виде сервера.

Сервер это отдельная сущность. Он связывает структуры данных с сетевым
вводом-выводом. Сервер принимает приложение с параметрами и запускает в фоне
сложный процесс. Он слушает указанный порт и читает байты. Из бинарных
данных получается словарь запроса. В отдельном треде сервер вызывает проложение с
этим запросом. Результатом будет словарь ответа. Сервер переводит ответ в
байтовый поток и пишет в удаленный порт клиента. Этот цикл повторяется для
каждого запроса.

Добавим в проект зависимости:

\begin{verbatim}
[ring/ring-core "1.7.1"]
[ring/ring-jetty-adapter "1.7.1"]
\end{verbatim}

Запустим сервер:

\begin{verbatim}
(require '[ring.adapter.jetty :refer [run-jetty]])
(run-jetty app {:port 8080 :join? true})
\end{verbatim}

Происходит следующее. Мы импортировали в текущее пространство функцию
\spverb|run-jetty|. Она принимает два параметра~--- приложение и словарь
опций. Ключ \spverb|join?| определяет, будет ли заблокирован текущий тред до
конца работы сервера. Если передать \spverb|false|, сервер запустится в
фоне. Чтобы остановить его, нужно запомнить результат \spverb|run-jetty| в
переменную и вызвать у него метод \spverb|.stop|:

\begin{verbatim}
(def server
  (run-jetty app {:port 8080 :join? false}))

;; after a while
(.stop server)
\end{verbatim}

Если флаг был \spverb|true|, как в первом случае, главный поток повиснет до
конца работы сервера. Придется либо завершить программу, либо нажать
\spverb|Ctrl-C|. Пока сервер работает, откройте браузер по адресу \spverb|127.0.0.1:8080|.
Вы увидите строку из примера выше. Впишите другой путь, например \spverb|/hello| или
\spverb|/path/to/file.txt|. Ответ сервера изменится.

\section{Запросы и ответы}

Мы написали приложение, которое на все запросы печатает метод и путь. Кроме этих
полей, запрос содержит порт и адрес сервера, строку параметров, тип протокола,
заголовки и тело. Все вместе это неизменяемый словарь с ключами типа
\spverb|keyword| (кейворды или ключевые слова, в других языках~--- теги). Полное
описание запроса и ответа лежит в репозитории
на Гитхабе\footnote{github.com/ring-clojure/ring/blob/master/SPEC}.

Обратим внимание на поля \spverb|:headers| и \spverb|:body|.

Заголовки это неизменяемый словарь, но его ключи не кейворды, а строки. Такой
словарь не работает привычным с destructuring assignment. Ниже переменная \spverb|host|
окажется \spverb|nil|:

\begin{verbatim}
(defn some-handler
  [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    ...))
\end{verbatim}

Чтобы извлечь заголовки правильно, используйте \spverb|:strs|:

\begin{verbatim}
(defn some-handler
  [{:keys [headers]}]
  (let [{:strs [host user-agent]} headers]
    ...))
\end{verbatim}

\noindent
или обычный \spverb|get| со строкой:

\begin{verbatim}
(get headers "host") ;; "127.0.0.1"
\end{verbatim}

Имя заголовка всегда в нижнем регистре. С точки зрения HTTP варианты
\spverb|Content-Type| и \spverb|content-type| одинаковы. \spverb|Ring| приводит заголовки к
нижнему регистру, чтобы избежать недоразумений.

Значения заголовков тоже строки. Даже если стандарт задает типы некоторым
заголовкам, \spverb|Ring| не выводит их. Например,  \spverb|Content-Length|
передает длину тела в байтах. Современные фреймворки
приводят его к числу и помещают в отдельное поле. По умолчанию Ring не делает
ничего подобного, но это легко исправить.

С заголовками связана одна проблема. В Clojure ключи словаря почти всегда
кейворды. Легко забыть, что у заголовков они строки. Так появляется ошибка,
когда вместо правильного значения приходит \spverb|nil|:

\begin{verbatim}
(get headers :host) ;; nil
\end{verbatim}

Можно обработать заголовки, заменив тип ключей. Для одного случая это
нормально. Но если этим занят каждый обработчик, получается лишняя
работа. Приложение меняют так, чтобы в функцию приходили уже исправленные
заголовки. Эта техника называется Middleware, и мы рассмотрим ее ниже.

Поле запроса \spverb|:body| опционально. Согласно HTTP тела может и не быть. При
попытке считать \spverb|:body| проверяйте его на \spverb|nil|. Обратите внимание
на тип тела. Это не строка, а входящий поток~---
\spverb|java.io.InputStream|. Поток~--- это источник данных, который можно
прочесть только раз. По умолчанию \spverb|Ring| не читает поток. Делать это или нет
остается на ваше усмотрение.

Чтение и разбор тела это сложная операция. По заголовкам
определяют тип документа, его длину и читают нужное число байт. Из них
восстанавливают данные (JSON, XML). Результат каждого шага проверяют по разным
критериям. Когда из \spverb|Content-Length| получают число, перехватывают
исключение разбора строки. Результат \spverb|-42| неверный, потому что число байт не
может быть отрицательным. Технически возможно послать серверу JSON-документ, но
указать тип \spverb|text/xml|. Сервер должен быть готов к подобным сценариям.

Легче всего считать тело в строку функцией \spverb|slurp|:

\begin{verbatim}
(defn handler [request]
  (when-let [content (some-> request :body slurp)]
    (process-content content))
  {:status 200})
\end{verbatim}

Но в современном вебе все меньше работают с текстом: на его место приходят данные в виде
JSON. Позже мы рассмотрим, как подружить Ring с этим форматом.

\subsection{Структура ответа}

Ответ \spverb|Ring| устроен проще. Это словарь с тремя полями:
\spverb|:status|, \spverb|:headers| и \spverb|:body|.

\begin{itemize}

\item
  \spverb|:status|~--- целое положительное число, признак успеха или неудачи. Мы
  рассмотрели семантику статуса в начале главы.

\item
  \spverb|:headers|~--- заголовки ответа. В отличии от запроса, ключи и
  значения не обязательно строки. Вариант ниже работает:

\begin{verbatim}
{:status 302
 :headers {:content-length 0
           :location "/new/page.html"}}
\end{verbatim}

\item
  \spverb|:body|~--- тело ответа. Как и в запросе, его может не быть. Обычно тело
  это строка, но может быть и файлом, ресурсом или потоком.

\end{itemize}

\section{Маршруты}

Мы запустили приложение и проверили его в браузере. На любой запрос оно выдает
текст с небольшими отличиями. Это слабый подход: невозможно поддерживать
приложение, в котором все запросы сходятся в одну точку. На практике пишут
отдельные обработчики для каждой задачи. Затем распределяют по ним входящие
запросы согласно правилам. Это называется маршрутизация или роутинг.

В мире Clojure и Ring нет класса роутера. Это функция, которая принимает
обработчики (хендлеры) и возвращает новую функцию-приложение. Она принимает
запрос и по методу и пути подбирает нужный обработчик. Затем вызывает его с
запросом и возвращает ответ.

Рассмотрим тривиальный случай. Вообразим, что адресу \spverb|/| мы бы хотели видеть
название сайта, а по \spverb|/hello|~--- приветствие. Все другие адреса вернут
\spverb|404 Page not found|. Напишем обработчики:

\begin{verbatim}
(defn page-index [request]
  {:status 200
   :headers {:content-type "text/plain"}
   :body "Learning Web for Clojure"})

(defn page-hello [request]
  {:status 200
   :headers {:content-type "text/plain"}
   :body "Hi there and keep trying!"})

(defn page-404 [request]
  {:status 404
   :headers {:content-type "text/plain"}
   :body "No such a page."})
\end{verbatim}

Каждый обработчик можно запустить как сервер и проверить в браузере. Осталось
связать их в единое целое.

\subsection{Наивный подход}

Сделаем самое простое, что приходит в голову. Напишем обработчик, который
вручную определяет маршрут. Для этого проверим путь оператором \spverb|case|:

\begin{verbatim}
(defn app [request]
  (let [{:keys [uri]} request]
    (case uri
      "/"      (page-index request)
      "/hello" (page-hello request)
      (page-404 request))))
\end{verbatim}

Ответ такой функции зависит от поля запроса \spverb|:uri|. Запустите приложение
в браузере и проверьте разные адреса. Это наивный перебор, но он работает.

Недостатки функции очевидны. Мы не учитываем метод запроса. \spverb|GET /users| и
\spverb|POST /users| отличаются по смыслу. Мы сравниваем пути в лоб без
учета параметров. В правильном роутинге запросы \spverb|GET /users/1|
и \spverb|GET /users/99| приходят в один обработчик, но с разным параметром \spverb|id|.
В целом код зашумлен. Хотелось бы иметь маршруты в виде правил без перебора.

Эти и другие проблемы решены в библиотеках. Мы рассмотрим две
из них: \spverb|Compojure| и \spverb|Bidi|. Обе решают задачу роутинга по-своему, их
подходы ортогональны.

\subsection{Compojure}

Библиотека \spverb|Compojure|\footnote{github.com/weavejester/compojure}
предлагает макросы для описания маршрутов. Макросы похожи на таблицу правил.
Добавим зависимость в проект:

\begin{verbatim}
[compojure "1.6.1"]
\end{verbatim}

\noindent
Вот как выглядит приложение на Compojure:

\begin{verbatim}
(require '[compojure.core :refer [GET defroutes]])

(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
\end{verbatim}

\noindent

Эта запись чище и короче той, что мы написали вначале.

Разберемся, что получилось на выходе. Переменная \spverb|app|~--- функция, которая
принимает запрос. Мы объявили ее не через \spverb|def| или \spverb|defn|,
а особым макросом. Мы поговорим о макросах в отдельной главе. Пока что
скажем, что \spverb|defroutes| делает две вещи: строит функцию-роутер и связывает ее с
переменной \spverb|app|. Это уловка, чтобы писать меньше кода.

Макрос принимает правила. Правило это форма <<метод, путь, запрос,
выражение>>. Первые два правила заданы макросом \spverb|GET|. Они читаются так: если
метод равен \spverb|GET| и путь \spverb|"/"|, то для запроса \spverb|request|
вернуть \spverb|(page-index request)|.

Правило компилируется в функцию, которая принимает запрос. Функция проверяет,
что метод и путь запроса совпадают с заданными. Если да, функция вычислит
выражение и вернет его результат, в нашем случае \spverb|(page-index request)|.

Если совпадения не было, функция вернет \spverb|nil|. Это
значит, надо взять следующее правило и так далее. Макрос \spverb|defroutes|
работает по этой схеме. Он оборачивает правила в особый цикл. На каждом
шаге макрос берет очередное правило, применяет к нему запрос и оценивает
результат. Первое значение, отличное от \spverb|nil|, станет ответом к текущему запросу.

Что будет, если не подошло ни одно правило? Это вполне возможно. Если
приложение вернуло \spverb|nil|, это вызовет ошибку сервера. Чтобы избежать \spverb|nil|,
к правилам добавляют еще одно, которое сработает всегда. В нашем случае это функция \spverb|page-404|.
Ее результат не зависит от запроса. Этим мы гарантируем, что даже если запрос не подошел
первым двум правилам, последнее сработает обязательно.

Так работает роутинг на \spverb|Compojure|. Приложение разбивают на обработчики.
Их пишут в отдельных модулях, затем с помощью макросов \spverb|GET|, \spverb|POST|
и других оборачивают в правила. Правило возвращает функцию, которая
проверяет, что метод и путь подходят. Если да, в результате получим вызов
обработчика с запросом.

\subsection{Продвинутые возможности}

Выше мы обозначили проблему: правила \spverb|GET /users/1| и \spverb|GET /users/99|
это один обработчик с параметром. Его записывают так:

\begin{verbatim}
(GET "/users/:id" [id :as request] (page-user request))
\end{verbatim}

Обратите внимание на двоеточие перед \spverb|id| и квадратные скобки в середине.
Часть пути с двоеточием означает параметр. \spverb|Compojure| поместит его в словарь
\spverb|params|. Обработчик \spverb|page-user| обратится к нему следующим образом:

\begin{verbatim}
(defn page-user [request]
  (when-let [user-id (-> request :params :id)]
    (let [user (get-user-by-id user-id)
          {:keys [fname lname]} user]
      {:status 200
       :body (format "User %s is %s %s"
                     user-id fname lname)})))
\end{verbatim}

В данном случае мы решили, что функция \spverb|get-user-by-id| вернет словарь
пользователя по номеру. Из словаря извлекаем имя и фамилию, формируем
строку и возвращаем ответ.

\spverb|Compojure| решает проблему вложенных путей. Предположим, приложение показывает и
редактирует товары. По адресу \spverb|/content/order/1/view| открывается карточка
товара. Страница \spverb|/content/order/1/edit| показывает форму редактирования этого товара.
Чтобы сохранить товар, нужно отправить форму по тому же пути, но методом \spverb|POST|.

Очевидно, правила пересекаются. Чтобы избежать повторов, используем макрос \spverb|context|:

\begin{verbatim}
(context "/content/order/:id" [order-id]
  (GET  "/view" request (order-view request))
  (context "/edit" []
    (GET  "/" request (order-form request))
    (POST "/" request (order-save request))))
\end{verbatim}

Каждое правило под макросом \spverb|context| наследует параметры запроса. Это значит,
обработчики \spverb|order-view|, \spverb|order-form| и \spverb|order-save| получат
параметр \spverb|:order-id|.

До сих пор качестве ответа в правилах мы писали что-то вроде
\spverb|(some-handler request)|. Бывает, что ответ заранее известен,
поэтому нет смысла помещать его в отдельную функцию. Рассмотрим это на примере
\spverb|healthcheck|-обработчика.

Современные приложения запускают в контейнерах и облачных сервисах.  Чтобы
узнать, работает приложение или нет, специальная служба периодически опрашивает
его. Привычный способ сделать это~--- послать приложению \spverb|GET|-запрос по адресу
\spverb|/health| и проверить статус. Тело и заголовки ответа не играют роли.

Чтобы не создавать лишний обработчик \spverb|(page-health request)|, поместим ответ в
тело:

\begin{verbatim}
(ANY "/health" _ {:status 200 :body "ok"})
\end{verbatim}

Можно сделать еще проще. В \spverb|Compojure| предусмотрен случай, когда
выражение это строка. Для \spverb|Compojure| она становится телом положительного
ответа:

\begin{verbatim}
(ANY "/health" _ "ok")
\end{verbatim}

\subsection{Роутинг с Bidi}

Библиотека Bidi\footnote{github.com/juxt/bidi} решает проблему роутинга по-другому.
\spverb|Compojure| предлагает макросы, чтобы задать правила и сделать по ним перебор. \spverb|Bidi|
опирается на данные~--- списки и словари. Этот сценарий состоит из нескольких шагов.

На \emph{первом этапе} объявляют дерево маршрутов. Это дерево~--- комбинация
векторов и словарей по определенным правилам. В листьях дерева помещают теги~---
уникальные метки. Особая функция принимает это дерево и запрос. Функция пытается понять,
на какую ветку дерева он ложится. Если ветку нашли, результатом будет ее тег и, возможно,
параметры пути. Например, \spverb|{:route :show-user, :route-params: {:id 1}}|.

На \emph{втором этапе} пишут middleware~--- промежуточный обработчик запроса.
Он принимает запрос, добавляет в него тег и передает дальше по цепочке.

На \emph{третьем этапе} пишут обработчик запроса. Но это не функция, а мультиметод.
Его функция-диспатчер возвращает тег. Метод с тегом \spverb|:default| возвращает
ответ \spverb|404|, \spverb|:show-user|~--- страницу пользователя и так далее.

На первый взгляд схема кажется сложной. Но однажды настроив, ее легко
расширять. Чтобы сервер подхватил новый путь, в дерево добавляют ветку и
расширяют мультиметод.

Перепишем на \spverb|Bidi| все то, что сделали на \spverb|Compojure|. Добавьте в проект
зависимость:

\begin{verbatim}
[bidi "2.1.5"]                  ;; project.clj
(:require [bidi.bidi :as bidi]) ;; namespace
\end{verbatim}

Начнем с дерева маршрутов. Вариант с \spverb|page-index|, \spverb|page-hello|
и \spverb|page-404| выглядит так:

\begin{verbatim}
(def routes
  ["/" {""      :page-index
        "hello" :page-hello
        true    :not-found}])
\end{verbatim}

Проверим, как работает матчинг пути по этому дереву. Функция \spverb|match-route|
принимает маршруты, путь и возвращает словарь с тегом:

\begin{verbatim}
(bidi/match-route routes "/hello")
{:handler :page-hello}

(bidi/match-route routes "/test")
{:handler :not-found}
\end{verbatim}

Объединим тег со словарем запроса. Чтобы сделать это за один шаг, воспользуемся
функцией \spverb|match-route*|. Это альтернативная версия \spverb|match-route|, которая принимает
словарь-накопитель. Роль накопителя сыграет запрос.

\begin{verbatim}
(let [request {:request-method :get
               :uri "/test"}]
  (bidi/match-route* routes (:uri request) request))

{:request-method :get
 :uri "/test"
 :handler :not-found}
\end{verbatim}

Видим, что \spverb|match-route*| вернула запрос, но добавила в него поле
\spverb|:handler|. Перепишем этот код на middleware. Это функция, которая
принимает обработчик и возвращает его измененную версию. Получив запрос, новый
обработчик добавит к нему поле \spverb|handler| и передаст в исходный
обработчик.

\begin{verbatim}
(defn wrap-handler [handler]
  (fn [request]
    (let [{:keys [uri]} request
          request* (bidi/match-route* routes uri request)]
      (handler request*))))
\end{verbatim}

Мы еще не касались техники middleware, но вынуждены применить ее сейчас. Ниже мы
рассмотрим в деталях, как они работают и почему так важны.

Проверим \spverb|wrap-handler| на скорую руку. Для удобства обернем функцию
\spverb|identity|. Она возвращает переданный в нее аргумент:

\begin{verbatim}
((wrap-handler identity)
 {:request-method :get
  :uri "/hello?foo=42"})

{:request-method :get,
 :uri "/hello?foo=42",
 :handler :page-hello}
\end{verbatim}

Обработчик запроса будет мультиметодом. Его функция-диспатчер просто
\spverb|:handler|.

\begin{verbatim}
(defmulti multi-handler :handler)

(defmethod multi-handler :page-index
  [request]
  {:status 200
   :headers {:content-type "text/plain"}
   :body "Learning Web for Clojure"})

(defmethod multi-handler :not-found
  [request]
  {:status 404
   :headers {:content-type "text/plain"}
   :body "No such a page."})
\end{verbatim}

Обернем \spverb|multi-handler| в middleware. Это и будет финальное
приложение. Запустите веб-сервер и проверьте результат в браузере.

\begin{verbatim}
(def app (wrap-handler multi-handler))
\end{verbatim}

Это был простой роутинг на \spverb|Bidi|. Теперь рассмотрим сценарий с товарами,
их просмотром и изменением. Новое дерево выглядит так:

\begin{verbatim}
(def routes
  ["/" {["content/order/" :id]
        {"/view" {:get  :page-view}
         "/edit" {:get  :page-form
                  :post :page-save}}}])
\end{verbatim}

В этой версии листья уже не теги, а словари. Ключ каждого словаря~--- метод
HTTP-запроса, а значение~--- тег. Запрос \spverb|GET /content/order/1/edit|
разрешается в тег \spverb|:page-form|, а \spverb|POST| с таким же адресом~--- в \spverb|:page-save|.
На этапе \spverb|wrap-handler| запрос получит поле \spverb|:route-params|.
В нашем случая это словарь \spverb|{:id "1"}|.

Набросаем штрихи обработчиков. \spverb|Page-view| находит товар по номеру и
верстает HTML-страницу с ним. Если товара нет, вернем ответ 404 <<не найдено>>.

\begin{verbatim}
(defmethod multi-handler :page-view
  [request]
  (if-let [order (-> request :route-params :id get-order-by-id)]
    {:status 200
     :headers {:content-type "text/html"}
     :body (render-order-page {:order order})}
    response-404))
\end{verbatim}

Страница с формой \spverb|:page-form| отличается тем, что вместо
\spverb|render-order-page| мы бы вызвали \spverb|render-order-form|. Эта
функция верстает HTML-форму с кнопками. Обновление товара сложнее: нужно выбрать поля из
запроса и записать их а базу. Для краткости опустим валидацию:

\begin{verbatim}
(defmethod multi-handler :page-save
  [request]
  (let [{:keys [params route-params]} request
        {order-id :id} route-params
        fields (select-keys params [:title :description :price])]
    (jdbc/update! *db* :orders fields ["id = ?" order-id])
    {:status 302
     :headers {:Location (format "/content/order/%s/view" order-id)}}))
\end{verbatim}

Обратите внимание: на изменение данных мы отвечаем не HTML-страницей, а
\emph{редиректом} на нее. Если браузер получил страницу в результате
\spverb|POST|-запроса, то при попытке ее обновить браузер снова отправит
форму. Это чревато спонтанными изменениями на сервере. Вариант с редиректом решает
эту проблему. Браузер загрузит страницу через \spverb|GET|, и побочных эффектов
при обновлении не будет.

\subsection{Выбор между Compojure и Bidi}

Автор использовал оба типа роутинга. По субъективным ощущениям, легче начать с
\spverb|Compojure|. У библиотеки достойная документация с примерами. \spverb|Compojure| написал
тот же разработчик, что и \spverb|Ring|. Проекты близки и дополняют друг друга.

Дерево маршрутов \spverb|Bidi| сложно для понимания. Оно многословно и не
интуитивно. Легко допустить ошибку, перепутать вектор и словарь. С другой
стороны, логика на мультиметодах несет преимущества. Код становится линейным,
организованным, приложение легче расширять.

Если вы начинающий Clojure-разработчик и проект небольшой, выбирайте
\spverb|Compojure|. Когда проект сложный и маршрутов все больше, рассмотрите
переезд на \spverb|Bidi|.

\section{Middleware}

Выше мы упоминали про middleware и даже кинули пробный шар~--- написали
\spverb|wrap-route|. Теперь изучим их внимательней. Автор считает эту тему самой
важной в главе.

В переводе с английского <<middleware>> значит промежуточный слой, середина. В
программировании под ним понимают код между посредниками. Код приведит типы,
добавлят поля в словари, проверяет права доступа.

Паттерн <<декоратор>> это частный случай middleware. Декоратор это функция
\spverb|А|, которая принимает функцию \spverb|B| и возвращает функцию
\spverb|C|. Говорят, что \spverb|A| декорирует \spverb|B|. Результат
декорирования это \spverb|C|. В ходе исполнения функция \spverb|C| вызывает
\spverb|B|, но с изменениями. Например, изменяет входные или выходные данные
\spverb|B|.

Рассмотрим простые декораторы. \spverb|With-echo| добавляет к функции побочные
эффекты: печатает аргументы и результат.

\begin{verbatim}
(defn with-echo [func]
  (fn [& args]
    (apply println "The args are" args)
    (let [result (apply func args)]
      (println "The result is" result)
      result)))
\end{verbatim}

Вот как им пользуются:

\begin{verbatim}
(def +echo (with-echo +))
(+echo 1 2 3)
;; The args are 1 2 3
;; The result is 6
6
\end{verbatim}

\spverb|With-catch| оборачивает функцию в форму \spverb|try/catch|. Если во
время работы брошено исключение, результатом будет его объект.

\begin{verbatim}
(defn with-catch [func]
  (fn [& args]
    (try
      (apply func args)
      (catch Throwable e
        e))))
\end{verbatim}

Мы уже видели \spverb|Ring|-запрос. Возможно, читатель заметил, что в нем нет
полей, с которыми он работал в других языках. Например, классы
\spverb|django.http.HttpRequest| и \spverb|flask.Request| в Python содержат
свойства \spverb|.params| или \spverb|.values|. Это словари параметров из
адресной строки или тела запроса.

По умолчанию запрос несет только базовую информацию. Почему в стандарте
\spverb|Ring| нет столь важных вещей? Потому что не каждое приложение в них
нуждается. Словарь параметров и другие поля мы получим из исходных.

Представим, что на каждый запрос \spverb|Ring| парсит строку параметров и
тело. Это удобно разработчику, но замедляет код. Нет гарантии, что параметры
нужны в запросе. Но сервер потратит время и память на их обработку. То же самое
с разобором тела: это дорогая операция. Бывает, что в теле большой JSON-документ.
Мы считали его, но у пользователя нет прав на запись. Нужно было проверить
права до чтения!

Обработчик в \spverb|Ring| это функция, которая принимает запрос и возвращает
ответ. Middleware сочетается с таким подходом. Параметры запроса, сессии, куки,
права доступа~--- все это функция, которая возвращает функцию. Не придется
писать все middleware с нуля: \spverb|Ring| содержит основные из них. Останется
только применить их к приложению. Рассмотрим некоторые middleware и принципы их
работы.

\subsection{Параметры запроса}

Стандарт HTTP предусматривает данные в адресной строке. Это пары вида
\spverb|"name=John&city=NY"| после знака вопроса. Удобно, когда на уровне
запроса это словарь \spverb|{:name "John" :city "NY"}|.

Иногда параметры помещают в тело запроса. Так поступают из-за ограничения на
длину адресной строки и безопасности. Длина строки ограничена 2048 байтами, а на
тело запроса ограничений нет. Пароли и почтовые адреса нельзя пересылать в
адресной строке, потому что они остаются в логах и истории браузера.

Функция \spverb|wrap-params| из модуля \spverb|ring.middleware.params| меняет
обработчик следующим образом. Переданный в нее запрос дополняется тремя полями:

\begin{itemize}

\item
  \spverb|:query-params|~--- словарь параметров адресной строки;

\item
  \spverb|:form-params|~--- словарь данных из тела запроса;

\item
  \spverb|:params|~--- их комбинированная версия.

\end{itemize}

Пусть \spverb|app|~--- ваше веб-приложение. Чтобы получить его обернутую версию,
достаточно вызвать \spverb|wrap-params| c \spverb|app|. Результат будет финальным приложением. На
жаргоне разработчиков это называется <<врапнуть>> (анг. \emph{wrap}~--- обернуть).

\begin{verbatim}
(require '[ring.middleware.params :refer [wrap-params]])
(def final-app (wrap-params app))
\end{verbatim}

Чтобы не запутаться в именах, придерживайтесь правил. Исходное приложение
называйте \spverb|app-naked| или \spverb|app-raw| (голое, сырое), а финальное
просто \spverb|app|.

Доработайте приложение так, чтобы оно учитывало параметры строки. Например,
чтобы имя того, кого приветствовать, можно было задать параметром \spverb|who|:
\spverb|/hello?who=John|. Подсказка: добраться до параметра \spverb|who| можно так:

\begin{verbatim}
(defn page-hello [request]
  (let [who (get-in request [:params "who"])]
    ...))
\end{verbatim}

Обратите внимание, ключи \spverb|:params|~--- строки. Это нормально, потому что
исходные данные это строка, и алгоритм просто режет на части. Но Clojure
поощряет нас к тому, чтобы ключи были кейвордами. Исправим это. В поставке Ring
идет middleware, которое приводит \spverb|:params| к удобному виду. Это
\spverb|wrap-keyword-params| из модуля \spverb|ring.middleware.keyword-params|.
С ним ключи \spverb|:params| примут тип \spverb|Keyword|.

\begin{verbatim}
(require '[ring.middleware.keyword-params
           :refer [wrap-keyword-params]])
(def app (wrap-keyword-params (wrap-params app-naked)))
\end{verbatim}

Появилась новая проблема: когда врапперов много, от них возникает шум. Типичное
приложение включает десять-пятнадцать middleware. Получается такая лесенка:

\begin{verbatim}
(def app
  (wrap-something-else
    (wrap-current-user
      (wrap-session
        (wrap-keyword-params
          (wrap-params app-naked))))))
\end{verbatim}

Представьте, что нужно добавить новое звено где-то в середине. Это каскадно
сдвинет элементы ниже. Чтобы победить вложенность, сделаем структуру
линейной. Поможет стрелочный оператор (threading macro):

\begin{verbatim}
(def app
  (-> app-naked
      wrap-params
      wrap-keyword-params
      wrap-session
      wrap-current-user
      wrap-something-else))
\end{verbatim}

Такая форма выглядит как список, поэтому ее легко поддерживать. Ниже мы будем
называть ее \emph{стеком} middleware.

Запись в стрелочном виде имеет особенность. Не заглядывая дальше, догадайтесь, в
каком порядке будут выполнены middleware? Правильный ответ: снизу вверх для
запроса и сверху вниз для ответа. Это станет ясно при мысленном разборе.

Сперва запрос попадет в \spverb|wrap-something-else|. Код внутри него вызовет
обработчик, который получен из \spverb|wrap-current-user|. Обработчик внутри него –
результат \spverb|wrap-session| и так далее. Вершиной подъема станет
\spverb|app-naked|. Теперь ответа спускается по стеку вниз. Сначала он
пройдет через \spverb|wrap-params| и \spverb|wrap-keyword-params|. Эти два middleware не
изменяют ответ и просто вернут его. \spverb|Wrap-session| и \spverb|wrap-current-user|,
возможно, допишут новые заголовки. Последним сработает \spverb|wrap-something-else|. Цикл пройден.

Цепочку middleware рассматривваю как восхождение на гору и спуск с
нее. Другой аналогией может быть пузырек, который всплывает и опускается (не
имеет отношения к сортировке пузырьком). Похоже устроены middleware в Django, промышленном
фреймворке на Python. В Django их роль играют не функции, а классы, но обход такой же.

Порядок middleware порой критичен. Некоторые из них опираются на данные из
предыдущих middleware. Рассмотрим уже знакомые \spverb|wrap-params| и
\spverb|wrap-keyword-params|. Последний ищет в запросе поле \spverb|params| и
меняет тип ключей. Считается, что \spverb|params| уже подготовлен.
Поэтому \spverb|wrap-keyword-params| ставят строго после \spverb|wrap-params|.

Теперь посмотрим на форму \spverb|(def app...)| выше. В нее закралась \emph{ошибка}. Запрос
поднимается снизу вверх, поэтому \spverb|wrap-keyword-params| сработает раньше. Он
попытается найти поле \spverb|params| в запросе, но безуспешно. Следом сработает
\spverb|wrap-params|. Он заполнит это поле словарем из адресной строки. В результате
\spverb|params| будет словарем с ключами-строками. В следует поменять \spverb|wrap-params| и
\spverb|wrap-keyword-params| местами.

Неверный порядок middleware стоит часов отладки. Но есть трюк: если два и более
middleware идут в строгой последовательности, можно <<схлопнуть>> их в одно
целое. Функция \spverb|comp| принимает произвольные функции и
возвращает супер-функцию, которая последовательно применяет их к
аргументу. Напишем умный враппер параметров:

\begin{verbatim}
(def wrap-params+ (comp wrap-keyword-params wrap-params))
\end{verbatim}

Плюс на конце означает, что это улучшенная версия обычного \spverb|wrap-params|. Теперь
заменим в стеке \spverb|wrap-params| и \spverb|wrap-keyword-params| на \spverb|wrap-params+|. Цепь
middleware станет короче, а логика параметров теперь в отдельном месте.

Перечислим другие полезные middleware. Возьмем три самых главных: куки, сессии и
JSON.

\subsection{Cookie}

В HTTP куки~--- это маленькие кусочки информации. Между сервером и браузером
особое соглашение о том, как хранить и передавать их. Если сервер выставил куки,
браузер запомнит их для этого сайта. В следующий раз браузер отправит их на
сервер автоматически. Так продолжается до тех пор, пока сервер не удалит куки
или истечет их срок жизни.

Простейший случай, когда нужны куки~--- определить, был ли уже пользователь на
сайте. При первом запросе приложение ищет в запросе куки с именем
\spverb|visited|. Если их нет, сервер выставит заголовок:

\begin{verbatim}
Set-Cookie: visited=true;
\end{verbatim}

Во все последующие запросы браузер добавит поле \spverb|visited=true|.
Приложение проверяет: если значение истина, пользователь уже был на сайте.
Это влияет на показ рекламы, всплывающие окна и так далее.

Технически куки это длинный заголовок, где поля и значения разделены точками с
запятой. Middleware \spverb|wrap-cookie| упрощает работу с этим заголовком. В
запросе мы получим словарь \spverb|:cookies|. В нем два уровня: поля и
атрибуты. Чтобы выслать клиенту новые куки, добавьте поле \spverb|:cookies| в
ответ. В значении укажите словарь такого же вида. Ring построит из него
заголовок \spverb|Set-Cookie| и добавит в ответ.

Напишем страничку, которая определяет, видим ли мы ее в первый раз.

\begin{verbatim}
(require '[ring.middleware.cookies
           :refer [wrap-cookies]])

(defn page-seen [request]
  (let [{:keys [cookies]} request
        seen-path [:seen :value]
        seen? (get-in cookies seen-path)
        cookies* (assoc-in cookies seen-path true)]
    {:status 200
     :cookies cookies*
     :body (if seen?
             "Already seen."
             "The first time you see it!") }))

(defn app (-> page-seen
              wrap-cookies))
\end{verbatim}

\emph{Замечание:} переменная со звездочкой на конце означает новую версию
исходной переменной. Например, такой же словарь, но с новым ключом. Вместо
звездочки некоторые ставят штрих или что-то другое. В примере выше
\spverb|cookies*| читается как <<новые куки на базе старых>>.

Запустите приложение в браузере. После обновления страницы надпись изменится на
<<Already seen>>. Даже после перезагрузки сервера ответ не изменится, потому что
флаг хранится в браузере. Только очистив куки вы увидите <<The first time
you see it>>. Для полноты эксперимента откройте приватную вкладку или другой
браузер.

Куки тесно связаны с безопасностью. Убедитесь, что куки защищены от кражи и не
раскрывают секретные данные (пароли, ключи доступа). В этом разделе мы не
обсуждаем тему веб-безопасности. Она слишком обширна и заслуживает отдельной
книги.

\subsection{Сессии}

Стандарт HTTP не предполагает связи между двумя запросами. Неважно, откуда
приходят запросы~--- с соседних машин или разных континентов. Не подходит и
разница во времени, будь то пять минут или год. Без особых оговорок нельзя
утверждать, что два запроса связаны.

Но разработчики нарушили стандарт. Современные приложения запоминают
пользователя и хранят его состояние между запросами. Даже если два человека
сидят за одним столом и пользуются одной сетью, сервер различает их. Это назвали
сессией или сеансом.

Под сессией понимают любые значения, актуальные для текущего
пользователя. Например, выбранный язык, состояние виджетов, недавно
просмотренные товары. Важно, что пользователь не обязательно авторизован. Это
может быть аноним, но сервер отличает его запросы от остальных.

\spverb|Wrap-session| это довольно сложное middleware. Оно дополняет запрос
полем \spverb|:session| со словарем. Его ключи~--- поля сессии. Чтобы обновить
сессию, ее новую версию пишут в одноименное поле ответа. Middleware различает
\spverb|nil| и отсутствие сессии в ответе. Если поле \spverb|:session|
\spverb|nil|, вся сессия удаляется. Если ключа нет, ничего не происходит.

Сессия это абстрактное понятие, поэтому различают ее бэкенды. Это способы
хранить сессию физически. Например, в памяти, на диске, в базе данных, системах
Memcached и Redis или даже куках. \spverb|Ring| предлагает протокол
\spverb|SessionStore| с тремя методами для записи, чтения и удаления сессии.

При выборе бэкенда важно учитывать, может ли он работать на нескольких машинах
одновременно. Что получится, если каждый запрос случайно уходит на одну из
десяти машин? Если сессия хранится в памяти приложения, то на каждой машине
будет ее разная версия. Это чревато странным поведением и трудной
отладкой. Аналогично с файлами~--- машины не делят их между собой. А вот база
данных или Redis это общее хранилище. Оно гарантирует целостность сессии для
всех клиентов.

Интересно, что сессия в куках тоже работает на многих машинах. На каждый запрос
браузер обменивается полной сессией через заголовки. В этом случае сессию
хранит браузер. Если пользователь очистит куки или запустит другой
браузер, сессия будет утеряна.

По умолчанию \spverb|Ring| хранит сессию в памяти или куках. Тип хранилища
задают настройками \spverb|wrap-session|. Для Redis и других систем расширьте
протокол \spverb|SessionStore|.

Рассмотрим пример со счетчиком посещений. Будем считать, сколько раз
пользователь зашел на наш сайт. Для краткости храним сессию в памяти.

\begin{verbatim}
(require '[ring.middleware.session :refer [wrap-session]])

(defn page-counter [request]
  (let [{:keys [session]} request
        session* (update session :counter (fnil inc 0))]
    {:status 200
     :session session*
     :body (format "Seen %s time(s)" (:counter session*))}))

(defn app (-> page-counter
              wrap-session))
\end{verbatim}

Запустите приложение и откройте браузер. Обновите страницу, и счетчик в
сообщении возрастет с каждым просмотром. Проделайте то же самое в другом
браузере. Это будет вторая сессия, которая не зависит от первой. Поскольку
данные хранится в памяти, они будут утеряны при перезагрузке сервера.

\emph{Упражнение.} В примере выше мы считаем просмотры для всего сайта. Сделайте
так, чтобы счетчик работал в разрезе страниц. Например, главная страница
\spverb|/| просмотрена пять раз, а справка \spverb|/help|~--- три
раза. Параметры командной строки не влияют на подсчет.

\subsection{JSON}

Формат JSON предназначен для передачи данных. Среду прочих его достоинств~---
типы, коллекции и совместимость с JavaScript. JSON различает \emph{базовые типы}
данных~--- числа, строки, логический тип. Это значимый плюс по сравнению с INI
или XML, где все значения строки.

JSON предусматривает \emph{коллекции}~--- массивы и словари~--- и произвольную их
вложенность. В разное время были попытки передать коллекции строками. Например,
через запятую или квадратными скобками:

\begin{verbatim}
user_ids=1,2,3&cities=NY,LA
address[0].line[0].value=SomeStreet
\end{verbatim}

\noindent
Это оказалось неудобно, к тому же разработчики так и не договорились о едином
подходе. Каждый фреймворк предлагал свое решение, чтобы упаковать и восстановить
коллекцию. К счастью, сегодня с этим покончено. Коллекции в строках втречаются
только в старых системах.

JSON \emph{совместим с JavaScript}. Если передать его строку в функцию
\spverb|eval|, она вернет данные~--- комбинацию списков и словарей.

Эти и другие причины сделали формат столь популярным. Сегодня JSON это главный
способ передать данные в интернете.

\spverb|Ring| предлагает несколько middleware для JSON. Для удобства их вынесли
в отдельную библиотеку. Добавьте в проект зависимость:

\begin{verbatim}
[ring/ring-json "0.4.0"]
\end{verbatim}

\spverb|Wrap-json-response| упрощает возврат JSON-данных. Middleware проверяет
поле ответа \spverb|:body|. Если это коллекция (вектор, словарь), то middleware
заменит его на кодированную строку и добавит заголовок
\spverb|Content-Type: application/json|.

Рассмотрим API для чтения пользователя. Если мы нашли его по номеру, вернем
словарь полей. Если нет, в ответе будет структура ошибки. В обоих случаях не
нужно кодировать данные вручную~--- это делает \spverb|wrap-json-response|.

\begin{verbatim}
(require '[ring.middleware.json
           :refer [wrap-json-response]])

(defn page-data [request]
  (let [user-id (-> request :params :id)]
    (if-let [user (get-user-by-id user-id)]
      {:status 200 :body user}
      {:status 404
       :body {:error_code "MISSING_USER"
              :error_message "No such a user"
              :error_data {:id user-id}}})))

(def app (-> page-data wrap-json-response))
\end{verbatim}

Для входящего JSON в библиотеке два middleware. Это \spverb|wrap-json-body| и
\spverb|wrap-json-params|. Оба проверяют, что заголовок \spverb|Content-Type|
равен \spverb|application/json|. Если да, они парсят тело с учетом возможных
исключений. При ошибке разбора ответ будет \spverb|400 JSON body malformed|.

Разница между \spverb|wrap-json-body| и \spverb|wrap-json-params| в том, куда
они складывают данные. \spverb|Wrap-json-body| заменяет поле \spverb|:body|
запроса на новую структуру данных. Ниже обработчик \spverb|page-body| извлекает
имя и город из \spverb|:body|. Тело запроса уже не входящий поток, а структура
данных. Обратите внимание, middleware принимает опциональные параметры. Флаг
\spverb|:keywords? true| означает, что ключи словарей станут кейвордами.

\begin{verbatim}
(require '[ring.middleware.json :refer [wrap-json-body]])

(defn page-body [request]
  (let [{:keys [body]} request
        {:keys [username city]} body]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-body
             (wrap-json-body {:keywords? true})))
\end{verbatim}

Чтобы отправить JSON серверу, понадобится специальная программа. Это
может быть утилита \spverb|cURL| или графическое приложение Postman. Пример с \spverb|cURL|:

\begin{verbatim}
curl --request POST \
     --header "Content-Type: application/json" \
     --data '{"username":"John","city":"NY"}' \
     http://localhost:8080/
\end{verbatim}

\subsection{Проблемы слияния}

Вариант с \spverb|wrap-json-params| работает с небольшим отличием. Оно пишет
данные в поле \spverb|:json-params|. Если из JSON пришел словарь, он дополняет
\spverb|:params|. Объясним, в чем разница.

Поле \spverb|:params| это общий аккумулятор параметров. В него пишут данные и
другие врапперы, например, \spverb|wrap-params|. Иногда нам неважно, откуда
пришли параметры: из адресной строки, тела или JSON. Внутри обработчика мы
просто черпаем данные из \spverb|:params|. С точки зрения API это мог быть
GET-запрос или POST-запрос с телом \spverb|multipart/form-data| или JSON.

В других случаях важно, чтобы параметры не смешивались в один словарь и не
заменяли друг друга. Чтобы прочесть только те данные, что пришли в JSON-теле,
обратимся к полю \spverb|:json-params| или \spverb|:body|. Каким враппером
пользоваться, зависит от конкретного API.

Вспомним, что \spverb|:params| это словарь с ключам-строками. Чтобы слияние
прошло правильно \spverb|wrap-json-params| сохраняет строки в ключах. Исправьте
ключи уже знакомым нам \spverb|wrap-keyword-params|. Оно должно быть ниже
\spverb|wrap-json-params| по

Разработчики не случайно выделяют поле \spverb|:json-params|. Тело
JSON-документа не обязательно словарь; это может быть и массив. Его невозможно
объединить с \spverb|:params|. На этот случай JSON-данные хранят отдельным
полем.

Представим, что клиент передает данные гибридно: \spverb|username| в теле
JSON-документа и \spverb|city| в параметрах строки. Обратите внимание на стек
middleware. Сперва мы парсим параметры строки, затем тело. Оба словаря
накапливаются в \spverb|:params|. Затем, уже после их накопления, исправляем тип
ключей.

\begin{verbatim}
(defn page-params [request]
  (let [{:keys [params]} request
        {:keys [username city]} params]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-params
             wrap-keyword-params
             wrap-json-params
             wrap-params))
\end{verbatim}

\noindent
Пример такого запроса:

\begin{verbatim}
curl --request POST \
     --header "Content-Type: application/json" \
     --data '{"username":"John"}' \
     http://localhost:8080/?city=NY
\end{verbatim}

Из-за того, что поля приходят из разных источников, может возникнуть
путаница. Избегайте случаев, когда в \spverb|:params| валится все подряд. Пример
выше не призывает строить API именно так. Мы лишь показываем, как работает
\spverb|Ring|.

\subsection{Свои middleware}

До сих пор мы использовали сторонние врапперы. Это те, что идут в поставке
\spverb|Ring| и в смежных библиотеках. Рано или поздно вам потребуются
собственные middleware. Рассмотрим несколько примеров из реальных проектов.

\subsubsection*{Ключи заголовков, wrap-headers-kw}

Этот простой враппер обновляет заголовки запроса. Их ключи меняют тип со строк
на кейворды. Полезно, когда приложение часто обращается к заголовкам. Основную
работу выполняет функция \spverb|keywordize-keys| из пакета
\spverb|clojure.walk|:

\begin{verbatim}
(require '[clojure.walk :refer [keywordize-keys]])

(defn wrap-headers-kw [handler]
  (fn [request]
    (-> request
        (update :headers keywordize-keys)
        handler)))
\end{verbatim}

\subsubsection*{Идентификатор запроса, wrap-request-id}

В протоколе HTTP запрос и ответ не связаны друг с другом. Порой трудно понять, к
какому запросу относится данный ответ и наоборот. Важно, чтобы система
могла их сопоставить. Например, была серия ответов с кодом 500, но какие именно
запросы вызвали ошибку?

Для этого ввели заголовок \spverb|X-Request-Id|. Это случайный идентификатор,
чаще всего \spverb|UUID|, строка из 36 символов. Для краткости его называют айди
(анг. id). Если клиент не передал айди в запросе, ему назначат случайный. Тот же
айди возвращается в ответе. Записи в лог включают идентификатор, чтобы по
запросу вернуть цепочку событий.

В примере ниже мы работаем с заголовками как с кейвордами. Ожидается, что
\spverb|wrap-headers-kw| был выше по стеку.

\begin{verbatim}
(import 'java.util.UUID)

(defn wrap-request-id [handler]
  (fn [request]
    (let [uuid (or (get-in request [:headers :x-request-id])
                   (str (UUID/randomUUID)))]
      (-> request
          (assoc-in [:headers :x-request-id] uuid)
          (assoc :request-id uuid)
          handler
          (assoc-in [:headers :x-request-id] uuid)))))
\end{verbatim}

Идентификатор хранят не только в заголовках, но и на уровне запроса в поле
\spverb|:request-id|. Для записи в лог к нему часто обращаются. Удобно вынести
это поле в переменную в начале функции:

\begin{verbatim}
(defn some-handler [request]
  (let [{:keys [params request-id]} request]
    (log/info "Request id: %s" request-id)))
\end{verbatim}

\subsubsection*{Текущий пользователь, wrap-current-user}

Этот враппер подставляет в запрос текущего пользователя. В данном случае мы ищем
его номер в сессии. Если номер найден, читаем пользователя из базы и добавляем к
запросу. Функция \spverb|get-user-by-id| вернет словарь или \spverb|nil|. Чтобы
не вызывать ее с \spverb|nil|, форму оборачивают в условие
\spverb|(when user-id...)|.

\begin{verbatim}
(defn wrap-current-user [handler]
  (fn [request]
    (let [user-id (-> request :session :user-id)
          user (when user-id
                 (get-user-by-id user-id))]
      (-> request
          (assoc :user user)
          handler))))
\end{verbatim}

К вопросу о безопасности: в общем случае \emph{можно} хранить \spverb|user-id| в
сессии. Как правило, сессия подписана секретным ключом, поэтому только сервер
может ее изменить. Но не допускайте, чтобы айди текущего пользователя шел в
адресной строке.

\subsection{Прерывание стека}

До сих пор мы работали с цепочкой middleware, где каждое звено передает
управление следующему. Но логика middleware не всегда линейна; бывает, цепочку
нужно прервать. Например, в каком-то middleware мы поняли, что у пользователя
нет прав к странице. Продолжать не имеет смысла: наоборот, мы должны как можно
скорее вывалиться из стека.

Некоторые врапперы из примеров выше работают на условиях. Например,
\spverb|wrap-json-params| читает тело только если заголовок
\spverb|Content-Type| равен \spverb|application/json|. Если тип другой, враппер
не читает тело. При разборе JSON ловится возможное исключение. Бывает, кто-то
составил документ с ошибками или он повредился из-за сбоя в сети. В этом случае
\spverb|wrap-json-params| не продолжает цепочку. Он вернет ответ <<400 JSON body
malformed>>, при этом ни одно middleware ниже по стеку не сработает.

Разберем проверку доступа. Пусть приложение доступно только по
авторизации. Текущего пользователя получим с помощью
\spverb|wrap-current-user|. Это middleware только находит пользователя (или
\spverb|nil|), но не ограничивает доступ. Ниже по стеку добавим другое:

\begin{verbatim}
(defn wrap-auth-user-only [handler]
  (fn [request]
    (if (:user request)
      (handler request)
      {:status 403
       :headers {:content-type "text/plain"}
       :body "Please sign in to see that page."})))
\end{verbatim}

Переход к следующему middleware теперь под условием. Если пользователь не
авторизован, middleware ниже \spverb|wrap-auth-user-only| не сработают.

Цепочку middleware можно представить как восхождение и спуск с горы. Если одно
из них терпит неудачу, мы как будто срезаем верхушку. Словно добрались до
середины, столкнулись с проблемой и повернули обратно. \emph{Общее правило:} чем
раньше мы обнаружим проблему, тем меньше потратим ресурсов. Поэтому более общие
проверки ставят выше по стеку.

Еще один вариант с развилкой~--- перехват ошибок. Это очень важный
обработчик. Вы не найдете его в стандартных библиотеках, потому что реакция на
ошибки меняется от проекта к проекту. Такой враппер просто копируют с небольшими
изменениями.

Итак, что случится, если при обработке запроса возникнет исключение? На этот
счет не бывает четких правил. Каждый фреймворк делает это по-разному. Один
покажет стек-трейс в браузере. Другой вернет HTML-страницу с информацией о
сервере. Разработчики третьего посчитали, что показывать машинные данные
небезопасно. Исключение пишут в лог, а в ответе нейтральная фраза об ошибке.

Хорошо, когда мы сами определяем, что делать с исключениями. Ниже простое
middleware, которое перехватывает ошибку, пишет ее в лог и возвращает
ответ-заглушку:

\begin{verbatim}
(defn wrap-exception [handler]
  (fn [request]
    (try
      (handler request)
      (catch Throwable e
        (let [{:keys [uri
                      request-method]} request]
          (log/errorf e "Error, method %s, path %s"
                      request-method uri)
          {:status 500
           :headers {:content-type "text/plain"}
           :body "Sorry, please try later."})))))
\end{verbatim}

В примере выше \spverb|log/errorf| это макрос для записи ошибки. Он принимает
исключение, шаблон и параметры. Мы хотим знать, какие были метод и путь запроса,
поэтому записываем их тоже. Это облегчит анализ логов в будущем.

Чем выше \spverb|wrap-exception| расположено в стеке, тем меньше шансов
возникнуть непойманному исключению. В идеале оно стоит на вершине цепочки,
чтобы ловать все исключения.

Порой даже используют стратегию двойного перехвата. Дело в том, что ошибки в
разных частях системы заслуживают разного подхода. Например, нам важно знать все
об ошибках в бизнес-логике. Если пользователь не смог что-то купить, мы запишем
его номер и данные, которые вызвали ошибку. Но если нам прислали поврежденный
JSON, это техническая проблема, не связанная с бизнесом. В таком случае
исключение это норма, потому его не пишут в лог.

Чтобы разделить бизнес- и технические проблемы, на границах стека расставляют
разные \spverb|wrap-exception|. Самое нижнее оборачивает \spverb|app-naked|. Оно
ловит исключения в бизнес-логике. Такую ошибку пишут в журналы максимально
подробно. На вершине стека другая, облегченная версия \spverb|wrap-exception|.
Оно подавляет технические ошибки на предварительных этапах запроса. Основная его
задача~--- вернуть адекватный ответ пользователю.

\subsection{Middleware вне стека}

Интересен сценарий, когда middleware оказывает эффект только на запросы по
определенному пути. Вернемся к \spverb|wrap-auth-user-only|. В чем его
недостаток? Если включить его в стек, анонимный пользователь не увидит вообще
ничего. Каждый запрос будет отклонен со статусом 403. Главная страница,
контактные данные, форма входа~--- все будет недоступно. В этом нет никакого
смысла.

Очевидно, \spverb|wrap-auth-user-only| должен перекрывать только подмножество
запросов. Например, тех, что начинаются с \spverb|/account|:
\spverb|/account/cart|, \spverb|/account/orders| и т.д. Место
\spverb|wrap-auth-user-only| не в общем стеке, а ниже~--- на уровне маршрута.

Реализация зависит от того, как мы строим маршруты. В \spverb|Compojure| есть
особое middleware под названием \spverb|wrap-routes|. Оно принимает правило и
другое middleware. Оно сработает только в том случае, если правило подходит к
запросу. Столь сложная логика нужна, чтобы не вызвать middleware, пока запрос не
совпадет с правилом.

\noindent
Вынесем маршруты для аккаунта в отдельную ветку:

\begin{verbatim}
(defroutes account-routes
  (with-context "/account" []
    (GET "/profile" request (account-profile request))
    (GET "/orders" request (account-orders request))
    (GET "/cart" request (account-cart request))))
\end{verbatim}

\noindent
Обернем всю ветку в проверку доступа:

\begin{verbatim}
(defroutes app
  (GET "/" request (page-index request))
  (GET "/help" request (page-help request))
  (wrap-routes account-routes wrap-auth-user-only))
\end{verbatim}

Теперь \spverb|wrap-auth-user-only| сработает только для путей, которые
начинаются с \spverb|/account/|. Для главной страницы и справки оно не будет
вызвано.

Middleware, которое принимает middleware~--- довольно крутая абстракция. Если вы
действительно поняли, как это работает, примите поздравления. Это серьезный
рубеж.

\section{Другие библиотеки}

Для Clojure написаны и другие веб-фреймворки. Если возможностей \spverb|Ring| не
хватает, обратите внимание на эти проекты.

\begin{itemize}

\item
  \emph{Compojure API}\footnote{github.com/metosin/compojure-api}~---
  убер-надстройка над обычным \spverb|Compojure|. Это набор макросов, чтобы
  описывать REST API. Библиотека тесно связана с JSON-схемой и Swagger.

\item
  \emph{Luminus}\footnote{luminusweb.net}~--- шаблон веб-приложения. Включает
  \spverb|Compojure API| для маршрутов, модуль базы данных, миграции и другие
  предустановленные возможности. У проекта достойная документация и сообщество,
  куда можно обратиться за помощью.

\item
  \emph{Pedestal}\footnote{github.com/pedestal/pedestal}~--- альтернативный
  фреймворк компании Cognitect. Отличается гибкой системой \emph{перехватчиков}
  (анг. interceptors), с помощью которых строят большие системы.

\item
  \emph{Vase}\footnote{github.com/cognitect-labs/vase}~--- экспериментальная
  надстройка над \spverb|Pedestal|. Задает обработчики в виде
  \spverb|edn|-файла. Отличается тесной интеграцией с Datomic, базой данных от
  Cognitect.

\item
  \emph{Duct}\footnote{github.com/duct-framework/duct}~--- новый фреймворк от
  создателя \spverb|Ring|. Пока что проект на ранней стадии, документации
  мало. Сделан упор на модульность и систему. О системах мы поговорим ближе к
  концу книги.

\item
  \emph{Liberator}\footnote{clojure-liberator.github.io}~--- аналог проекта
  \emph{Webmachine} для Erlang. Запрос и ответ проходят множество стадий, каждую
  из которых можно перехватить. Позволяет задать сложные правила, расширяя
  мультиметод.

\end{itemize}

\section{Все вместе}

Вспомним, что мы узнали в этой главе.

Современный веб работает по HTTP. Это текстовый сетевой протокол на базе
TCP/IP. Взаимодействие по HTTP проходит в две фазы: запрос и ответ. Оба они
состоят из первой строки, заголовков и тела, которого может и не быть.

Для запроса наиболее важны его метод и путь, а для ответа~--- статус. С
развитием веба появились соглашения о том, как строить HTTP API. Самое
популярное из них называется REST. Согласно ему, сущность определяет путь, а
действие над ней~--- метод. Данные о сущности передают в формате JSON.

Чтобы писать веб на Clojure, установите \spverb|Ring|. Это семейство библиотек,
в которых самое нужное: базовые абстракции, middleware и веб-сервер. Запрос и
ответ представлены словарями. Обработчик запроса это функция, которая принимает
запрос и возвращает ответ.

Роутинг не входит в поставку Ring; потребуются сторонние библиотеки. Проект
Compojure предлагает макросы, чтобы задать маршруты правилами. Библиотека Bidi
строит дерево с тегами. Чаще всего оно работает в паре с мультиметодами.

Middleware это функция, которая оборачивает другую функцию. Их цепочка
называется стеком. Легче всего описать стек с помощью стрелочного оператора. Это
экономит скобки и делает запись наглядней. Middleware нужны для предварительной
обработки запроса, например, прочитать JSON-тело или проверить права
доступа. Отдельные middleware прерывают стек, если возникло исключение или
запрос нельзя обработать.

%% TODO sections
