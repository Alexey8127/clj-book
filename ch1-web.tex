\chapter{Веб-разработка}

\begin{teaser}
В первой главе мы рассмотрим, как писать веб-приложения на Clojure. Поговорим о
передаче данных по протоколу HTTP. Какие абстракции строят над протоколом и что
предлагает Clojure. Чем хорош функциональный подход и почему разработка на~нем
удобнее.
\end{teaser}

Каждый год компания Cognitect
опрашивает\footurl{https://blog.cognitect.com/blog/2017/1/31/clojure-2018-results}
разработчиков на~Clojure. Среди прочего анкета спрашивает, в какой области вы
работаете. В~2010 году веб писали половина опрошенных. К~2018 году эта цифра
выросла до 80\%, что уже четыре человека из пяти. Похожую динамику показывают
опросы StackOverflow\footurl{https://insights.stackoverflow.com/survey/2018}. Согласно
им, все больше инженеров переходят в веб из смежных областей.

Если вы найдете работу на Clojure, скорее всего это будет веб-приложение. Мы
специально не говорим <<сайт>>, потому что термин уходит в прошлое. Сегодня
веб-приложение это не только текст с картинками. В широком плане это сложный
обмен данными по HTTP.

Протокол служит для передачи разметки, но со временем подошел и для данных. Для
этого даже не пришлось менять стандарт. Причина кроется в изящном дизайне и
простоте. Прежде чем перейти к Clojure, освежим в памяти устройство
протокола: из каких частей он состоит и как с ним работает сервер. Это важно,
потому что языки и фреймворки меняются, а протокол нет.

\section{Основы HTTP}

Протокол HTTP работает поверх TCP/IP. В широком смысле протокол~--- это
соглашение о том, как обмениваться данными. Обычно они записаны в официальных
документах. Для HTTP документ называется
RFC~2616\footurl{https://https://tools.ietf.org/html/rfc2616}. Программисты
сверяются с~ним, чтобы код работал на разных языках и платформах.

HTTP удобен тем, что это текст. Не нужно парсить байты, чтобы понять, что
происходит. Протокол работает и с бинарными данными, но~главные его части
остаются текстом. В HTTP различают запрос и ответ. Они состоят из трех частей:
первая строка, заголовки и тело.

Первая (стартовая) строка несет самую важную информацию. Ее формат отличается
для запроса и ответа. Для запроса это метод, путь и версия, для ответа~---
статус, сообщение и версия.

Заголовки это пары ключей и значений. В коде их описывают словарем. Заголовки
несут дополнительные сведения о~запросе или ответе. Например, заголовок
\spverb|Content-Type| сообщает, как читать тело запроса. Был ли это XML- или
JSON-документ? Программа сверяет заголовок и~читает тело должным образом.

После заголовков следует тело. Им может быть что угодно~--- текст, пары полей и
значений, JSON, картинка. Стандарт допускает смешанный тип,
\spverb|multipart-encoding|. Тело такого запроса состоит из ячеек, в каждой из
которых свое содержимое. Например, текст, картинка, снова текст, двоичный файл.

Рассмотрим примеры HTTP-трафика. Именно в таком виде его передают по сети. Ниже
запрос к главной странице Google по слову <<clojure>>:

\begin{english}
  \begin{http}
GET /search?q=clojure HTTP/1.1
Host: google.com
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
  \end{http}
\end{english}

\noindent
А это POST-запрос с JSON:

\begin{english}
  \begin{http}
POST /api/users/ HTTP/1.1
Host: example.com
Content-Type: application/json
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)

{
  "username": "John",
  "city": "NY"
}
  \end{http}
\end{english}

\noindent
Ответ на него:

\begin{english}
  \begin{http}
HTTP/1.1 200 OK
Date: Tue, 19 Mar 2019 15:57:11 GMT
Server: Nginx
Connection: close
Content-Type: application/json

{
  "code": "CREATED",
  "message": "A user has been created successfully"
}
  \end{http}
\end{english}

Видно, как изящно устроен протокол: данные в идут по убыванию важности.
Прочитав только первую строку, клиент и~сервер готовы принять решение о~том, что
делать дальше.

Рассмотрим сценарий: в запросе указаны метод и путь \spverb|GET /about|, но
такой страницы не существует. Сервер проверит путь по таблице маршрутов. Если
его нет, получим ответ со статусом 404. Не придется читать тело запроса, что
ускорит работу сервера. Клиент получит статус 404 из первой строки. Логика
клиента может быть такова, что для негативного статуса он не читает тело.

Чтение и разбор содержимого это долгая операция. Современные фреймворки не
делают этого зря. По заголовку \spverb|Content-Type| они определяют, стоит ли
читать тело. Если приложение работает только с~JSON, для \spverb|text/xml|
вернется ошибка. Аналогично поступают с заголовком \spverb|Content-Length|, где
указана длина тела в байтах. Если значение больше лимита, сервер отклонит запрос
до чтения.

Главные части запроса это \emph{метод} и \emph{путь}. Путь указывает на
определенный ресурс на сервере. Иногда путь означает файл относительно папки на
сервере. Например, \spverb|/images/map.jpg| ведет к файлу из
\spverb|/var/www/static|. Чаще всего путь обрабатывают внутри приложения.
Ответом может быть не только файл, но и HTML, скрипт, JSON.

Метод запроса означает действие, которые мы намерены выполнить над
ресурсом. Основные методы это \spverb|GET|, \spverb|POST|, \spverb|PUT| и
\spverb|DELETE|~--- прочитать, создать, обновить и удалить ресурс. Запрос
\spverb|POST /users/| означает создать пользователя, а \spverb|GET /users/|~---
получить их список.

Главный параметр ответа это статус~--- целое положительное число. Статусы
группируют по старшей цифре. Значения с 200 до 299 (или \spverb|2хх|) считают
положительными. Они означают, что сервер обработал запрос без ошибки.

Значения из группы \spverb|3хх| связаны с направлением на другую страницу. В
заголовке \spverb|Location| указан адрес, по которому отправляют новый
запрос. Современные браузеры и клиенты делают это автоматически. По адресу
\spverb|http://yandex.ru| получим пустой документ с заголовком
\spverb|Location: https://yandex.ru|. Разница в схеме протокола: сервер обязывает
перейти на безопасное соединение. Мы даже не заметим этого: браузер сам сменит адрес.

Статусы \spverb|4хх| означают ошибку на стороне клиента. Чаще всего это 404~---
страница не найдена. Если прислать ошибочные данные, сервер ответит
\spverb|400 Bad request|. Когда нет прав доступа, получим код 403.

Значения из группы \spverb|5хх| говорят о проблеме на стороне сервера. Чаще всего
это исключение в коде: деление на ноль, отказ базы данных, нехватка места
на~диске. Реже сервер на техобслуживании или вообще недоступен.

Принято считать, что ответ со статусом вне группы \spverb|2хх| означает
ошибку. Многие HTTP-клиенты бросают исключение на ответ с негативным статусом.
Это верно только на высоком, абстрактном уровне. С точки зрения протокола ответ
\spverb|404 Not Found| такой же правильный, как и \spverb|200 OK|.

Когда действий с ресурсом много, применяют другие, более редкие
методы. Например, HEAD~--- получить краткие сведения о сущности. Сервис Amazon
S3 в ответ на HEAD вернет только статус и заголовки. В них указаны тип файла и
его размер, контрольная сумма, дата изменения. HEAD-запрос предпочитают
GET. Метаданные хранят отдельно от файла, поэтому доступ к нему быстрее, чем к
диску.

Подход <<метод и ресурс>> вырос в то, что сегодня называется
REST\footurl{https://restapitutorial.com}. Сторонники REST выделяют сущности и
CRUD-операции над ними (\textbf{C}reate, \textbf{R}ead, \textbf{U}pdate,
\textbf{D}elete). Считается верным подход, когда сущность задают через путь,
например \spverb|/users/1|, а операцию~--- методом. Если это запрос на
изменение, данные читают из тела с JSON. Мы не будем задерживаться на REST,
потому что это лишь свод рекомендаций, не идеальный и не единственный.

Протокол не заставляет следовать REST и другим правилам. Работайте с HTTP как
это удобно проекту. Идеальная архитектура не обещает успех, и~наоборот: успех не
значит, что под капотом все блестит.

\subsection{Фреймворк}

Фреймворк это абстракция над HTTP. Разработчик не читает запрос по байтам
вручную~--- задачу берет на себя чужой код. Взамен мы получаем классы, чтобы
описать логику приложения. Типичный проект на Python или Java состоит из
следующих классов.

\spverb|Application| это главная сущность проекта: она группирует классы рангом
ниже. \spverb|Router| определяет, на какой обработчик подать входящий запрос~---
\spverb|Request|. Обработчик~--- это класс \spverb|Handler| с методами
\spverb|.onGet|, \spverb|.onPost| и другими. Ожидается, что он вернет экземпляр
класса \spverb|Response|. Так устроены промышленные фреймворки: Django, Rails,
Symfony. Имена и комбинация классов отличается, но смысл прежний. Это
приложение, роутер, обработчик, запрос и ответ.

Большие проекты делят на слои. Слой транспорта отвечает за обмен данными, слой
логики исполняет код, ничего не зная о транспорте. Одни и те же данные получают
по HTTP или из очереди задач. С таким подходом логика не зависит от транспорта,
и последний можно сменить в любой момент. На практике это работает не всегда: по
разным причинам, в том числе из-за спешки, слои перемешиваются.

Проекты на Clojure опираются на фреймворки. Принципы, о которых мы говорили
выше, справедливы и для этого языка.

\section{HTTP в Clojure}

Разработчик Джеймс Ривз (James Reeves)\footurl{https://www.booleanknot.com/}
известен вкладом в экосистему Clojure. Нет проекта, который бы не использовал
его библиотеки. Джеймс ввел стандарт веб-разработки для Clojure на заре
языка. Стандарт опирается на несколько простых идей.

Приложения бывают сколь угодно сложными: они полагаются на сторонние сервисы,
машинное обучение, учитывают сотню фактов о клиенте. Но даже самое сложное
приложение принимает запрос и возвращает ответ, поэтому это функция. Скептики
заметят, что мысль не нова. В Django обработчик тоже бывает не классом, а
функцией. Разница в том, что обработчик~--- это еще не приложение. Ему не
хватает роутера, middleware и других абстракций. Функция-обработчик в других
языках это локальная возможность.

В Clojure приложение остается функцией на всех уровнях. Маршрут это функция,
которая принимает запрос, ищет обработчик и передает ему управление. Middleware
это тоже функция, которая дополняет приложение логикой. Каждую тяжелую
абстракцию (классы \spverb|Application|, \spverb|Router|, \spverb|Handler|) в
Clojure заменяют функцией. Это удобно, потому что в отличии от классов функции
компонуются между собой.

Другая идея в том, чтобы зафиксировать структуру запроса и ответа. Должны быть
документы (не код, а именно документы), где описаны поля и семантика. Это
напоминает протокол HTTP: спецификация упрощает код и делает его
переносимым. Два проекта на Clojure работают с одними структурами. Разработчик
учитывает спецификацию: если фреймворк следует стандарту, легче привлечь
сообщество.

\subsection{Ring}

\label{ring-jetty}

Идеи воплотились в проекте Ring\footurl{https://github.com/ring-clojure/ring}.
Сегодня это стандарт веб-разработки на Clojure. Репозиторий содержит описание
запроса и ответа и базовый код для работы с ними. Прилагаются основные middleware,
обертка для сервера Jetty и документация.

Со временем появился термин <<Ring-совместимость>>. Ему следуют все фреймворки
на Clojure. Ring-приложение работает на платформах Jetty, Immutant и других без
изменений в коде.

Библиотека Ring разбита на отдельные части, чтобы можно было установить только
нужное. Перечислим компоненты, которые понадобятся по ходу главы:

\begin{itemize}

\item
  \spverb|ring-core|~--- базовый набор: параметры, куки, сессии;

\item
  \spverb|ring-jetty-adapter|~--- запуск сервера из функции;

\item
  \spverb|ring/ring-json|~--- поддержка JSON.

\end{itemize}

Первое приложение мы напишем даже без библиотеки. Вот оно:

\label{first-handler}

\begin{english}
  \begin{clojure}
(defn app [request]
  (let [{:keys [uri request-method]} request]
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body (format "You requested %s %s"
                   (-> request-method name .toUpperCase)
                   uri)}))
  \end{clojure}
\end{english}

Приложение читает путь и метод запроса и формирует ответ. Его статус
положительный~--- 200. Мы выставили заголовок с типом <<простой текст>>. Поле
\spverb|:body| содержит строку, которую строим функцией \spverb|format|.

Поскольку \spverb|app| это функция, вызовем ее с запросами:

\begin{english}
  \begin{clojure}
(app {:request-method :get :uri "/index.html"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested GET /index.html"}

(app {:request-method :post :uri "/users"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested POST /users"}
  \end{clojure}
\end{english}

Пока что это словари, и не ясно, что будет в браузере. Запустим приложение в
виде сервера. Он принимает приложение, параметры и~запускает сложный
процесс. Сервер слушает указанный порт и читает байты. Из бинарных данных
получается словарь запроса. В отдельном потоке сервер вызывает с ним
приложение. Получим словарь ответа. Сервер переводит словарь в байты и~пишет в
удаленный порт клиента. Цикл повторяется для каждого запроса.

Добавим в проект зависимости:

\begin{english}
  \begin{clojure}
[ring/ring-core "1.7.1"]
[ring/ring-jetty-adapter "1.7.1"]
  \end{clojure}
\end{english}

Запустим сервер:

\begin{english}
  \begin{clojure}
(require '[ring.adapter.jetty :refer [run-jetty]])
(run-jetty app {:port 8080 :join? true})
  \end{clojure}
\end{english}

Происходит следующее. Мы добавили в текущий модуль функцию
\spverb|run-jetty|. Она принимает приложение и словарь опций. Ключ
\spverb|join?| определяет, будет ли заблокирован текущий поток до конца работы
сервера. Если передать \spverb|false|, сервер запустится в~фоне. Чтобы
остановить его, нужно поместить результат \spverb|run-jetty| в~переменную
и~вызвать метод \spverb|.stop|:

\begin{english}
  \begin{clojure}
(def server
  (run-jetty app {:port 8080 :join? false}))

;; after a while
(.stop server)
  \end{clojure}
\end{english}

Если флаг истина как в первом случае, главный поток повиснет до тех пор, пока
сервер не выключат. Придется либо завершить программу, либо нажать
\spverb|Ctrl-C|. Пока сервер работает, откройте браузер по адресу
\spverb|localhost:8080|. Вы увидите строку из примера выше. Измените путь на
\spverb|/hello| или \spverb|/path/to/file.txt|. Ответ сервера изменится.

\section{Запросы и ответы}

Мы написали приложение, которое на все запросы печатает метод и путь. Кроме этих
полей, запрос содержит порт и адрес сервера, строку параметров, тип протокола,
заголовки и тело. Все вместе это неизменяемый словарь с ключами типа
\spverb|keyword|. Полное описание запроса и~ответа смотрите в репозитории на
GitHub\footurl{https://github.com/ring-clojure/ring/blob/master/SPEC}.

Здесь и далее будем писать слово \spverb|keyword| по-русски: <<кейворд>>. В
других языках тип называют токенами или тегами.

Обратим внимание на поля \spverb|:headers| и \spverb|:body|. Заголовки это
неизменяемый словарь, но его ключи не кейворды, а строки. Такой словарь не
работает с разбиением по \spverb|:keys|. Переменная \spverb|host| окажется равна
\spverb|nil|:

\begin{english}
  \begin{clojure}
(defn some-handler
  [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    ...))
  \end{clojure}
\end{english}

Чтобы извлечь заголовки правильно, используйте \spverb|:strs|:

\begin{english}
  \begin{clojure}
(defn some-handler
  [{:keys [headers]}]
  (let [{:strs [host user-agent]} headers]
    ...))
  \end{clojure}
\end{english}

\noindent
или обычный \spverb|get| со строкой:

\begin{english}
  \begin{clojure}
(get headers "host") ;; "127.0.0.1"
  \end{clojure}
\end{english}

Имя заголовка всегда в нижнем регистре. В протоколе HTTP варианты
\spverb|Content-Type| и \spverb|content-type| одинаковы. Ring приводит
заголовки к нижнему регистру, чтобы избежать недоразумений.

Значения заголовков тоже строки. Даже если стандарт задает типы некоторым
заголовкам, Ring не выводит их. Например, \spverb|Content-Length|
передает длину тела в байтах. Современные фреймворки приводят его к числу и
помещают в отдельное поле. По умолчанию Ring не делает ничего подобного, но это
легко исправить.

Легко забыть, что ключи заголовков это строки. Так появляется ошибка, когда
вместо правильного значения приходит \spverb|nil|:

\begin{english}
  \begin{clojure}
(get headers :host) ;; nil
  \end{clojure}
\end{english}

Можно обработать заголовки, сменив тип ключей. Для одного случая это
нормально, но если это делает каждый обработчик, получается лишняя
работа. Приложение меняют так, чтобы в функцию приходили уже исправленные
заголовки. Техника называется middleware, и мы рассмотрим ее ниже.

Поле запроса \spverb|:body| опционально. Согласно HTTP тела может и не
быть. Обратите внимание на его тип: это не строка, а входящий поток~---
\spverb|java.io.InputStream|. Поток это источник данных, который читают только
раз. По умолчанию Ring не читает поток. Делать это или нет остается на ваше
усмотрение.

Чтение и разбор тела это сложная операция. По заголовкам определяют тип
документа, его длину и читают нужное число байт. Из них восстанавливают данные
(JSON, XML). Результат каждого шага проверяют по разным критериям. Когда из
\spverb|Content-Length| получают число, учитывают ошибку в разборе
строки. Результат \spverb|-42| неверный, потому что число байт не может быть
отрицательным. Технически возможно послать JSON-документ, но указать тип
\spverb|text/xml|. Сервер должен быть готов к подобным сценариям.

Легче всего прочитать тело в строку функцией \spverb|slurp|:

\begin{english}
  \begin{clojure}
(defn handler [request]
  (when-let [content (some-> request :body slurp)]
    (process-content content))
  {:status 200})
  \end{clojure}
\end{english}

В современном вебе все меньше работают с текстом: на его место приходят данные в
виде JSON. Позже мы рассмотрим, как подружить Ring с этим форматом.

Ответ Ring это словарь с полями \spverb|:status|, \spverb|:headers| и
\spverb|:body|.

\begin{itemize}

\item
  \spverb|:status|~--- целое число, признак успеха или неудачи. Мы рассмотрели
  семантику статуса в начале главы.

\item
  \spverb|:headers|~--- заголовки ответа с ключами-строками:

\begin{english}
  \begin{clojure}
{:status 302
 :headers {"content-length" 0
           "location" "/new/page.html"}}
  \end{clojure}
\end{english}

\item
  \spverb|:body|~--- тело ответа. Как и в запросе, тела может не быть. Обычно
  это строка, но может быть и файл, ресурс или поток.

\end{itemize}

\section{Маршруты}

Мы запустили приложение и проверили в браузере. На любой запрос оно выдает текст
с небольшими отличиями. На практике приложение строят из обработчиков, каждый из
которых решает узкую задачу. Входящие запросы распределяют по ним согласно
правилам. Это называется маршрутизация или роутинг.

В Clojure и Ring нет класса роутера. Его роль играет функция, которая принимает
обработчики и возвращает приложение. Оно принимает запрос и по методу и пути
подбирает нужный обработчик. Затем вызывает его с запросом и возвращает ответ.

Вообразим, что адресу \spverb|/| мы бы хотели видеть название сайта, а по
\spverb|/hello|~--- приветствие. Другие адреса вернут \spverb|404 Page not found|.
Напишем обработчики:

\begin{english}
  \begin{clojure}
(defn page-index [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defn page-hello [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Hi there! Keep trying!"})

(defn page-404 [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
  \end{clojure}
\end{english}

Каждый обработчик можно запустить в виде сервера и открыть в браузере. Осталось
связать их в единое целое.

\subsection{Наивный подход}

Сделаем самое простое, что приходит в голову. Напишем обработчик, который
находит маршрут вручную. Для этого проверим путь оператором \spverb|case|:

\begin{english}
  \begin{clojure}
(defn app [request]
  (let [{:keys [uri]} request]
    (case uri
      "/"      (page-index request)
      "/hello" (page-hello request)
      (page-404 request))))
  \end{clojure}
\end{english}

Ответ функции зависит от поля запроса \spverb|:uri|. Запустите приложение в
браузере и проверьте разные адреса. Это наивный перебор, но он работает.

Недостатки функции очевидны. Мы не учитываем метод запроса: \spverb|GET /users|
и \spverb|POST /users| отличаются по смыслу. Мы сравниваем пути в лоб без учета
параметров. В правильном роутинге пути \spverb|/users/1| и \spverb|/users/99|
приходят в один обработчик, но с разным параметром \spverb|id|. Код получился
шумный. Хотелось бы задать маршруты правилами, декларативно.

Эти и другие проблемы решают библиотеки. Мы рассмотрим Compojure и Bidi. Обе
строят маршруты, но их подходы ортогональны.

\subsection{Compojure}

\label{compojure}

Библиотека Compojure\footurl{https://github.com/weavejester/compojure}
предлагает макросы для описания маршрутов. Макросы похожи на таблицу правил.
Добавим зависимость в проект:

\begin{english}
  \begin{clojure}
[compojure "1.6.1"]
  \end{clojure}
\end{english}

Так выглядит приложение на Compojure. Оно чище и короче того, что мы написали
вначале.

\begin{english}
  \begin{clojure}
(require '[compojure.core :refer [GET defroutes]])

(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
  \end{clojure}
\end{english}

Разберемся, что получилось на выходе. Переменная \spverb|app|~--- функция,
которая принимает запрос. Мы задали ее не через \spverb|def| или \spverb|defn|,
а макросом \spverb|defroutes|. Он строит функцию-роутер и связывает ее с
переменной \spverb|app|. С макросом получается меньше кода.

После имени следуют правила. Правило это форма \tuple{метод, путь, запрос, выражение}.
Первые два правила заданы макросом \spverb|GET|. Они читаются так:
если метод равен \spverb|GET| и путь равен \spverb|"/"|, то для запроса
\spverb|request| вернуть \spverb|(page-index request)|.

Правило собирается в функцию, которая принимает запрос. Функция проверяет, что
метод и путь запроса совпадают с заданными. Если да, функция вычислит выражение
и вернет его результат, в нашем случае \spverb|(page-index request)|.

Макрос \spverb|defroutes| оборачивает правила в перебор. На каждом шаге он берет
очередное правило, применяет к нему запрос и оценивает результат. Первое
значение, отличное от \spverb|nil|, станет ответом к текущему запросу.

Что будет, если не подошло ни одно правило? Результат \spverb|nil| вызовет
ошибку сервера. Чтобы избежать \spverb|nil|, к правилам добавляют еще одно,
которое сработает всегда. Это функция \spverb|page-404|: ее результат не
зависит от запроса. Так мы гарантируем, что даже если запрос не подошел первым
двум правилам, последнее сработает всегда.

Так устроен роутинг на Compojure. Приложение разбивают на обработчики.  Их пишут
в отдельных модулях, затем с помощью макросов \spverb|GET|, \spverb|POST| и
других оборачивают в правила. Правило вернет функцию, которая проверяет, что
метод и путь подходят. Если да, получим вызов обработчика с запросом.

\subsection{Продвинутые возможности}

Выше мы обозначили проблему: правила \spverb|GET /users/1|
и \spverb|GET /users/99| это один обработчик с параметром. Его записывают так:

\begin{english}
  \begin{clojure}
(GET "/users/:id" [id :as request] (page-user request))
  \end{clojure}
\end{english}

Обратите внимание на двоеточие перед \spverb|id| и квадратные скобки в середине.
Часть пути с двоеточием означает параметр. Compojure поместит его в словарь
\spverb|params|. Страница \spverb|page-user| обратится к нему следующим образом:

\begin{english}
  \begin{clojure}
(defn page-user [request]
  (when-let [user-id (-> request :params :id)]
    (let [user (get-user-by-id user-id)
          {:keys [fname lname]} user]
      {:status 200
       :body (format "User %s is %s %s"
                     user-id fname lname)})))
  \end{clojure}
\end{english}

Условная функция \spverb|get-user-by-id| вернет словарь пользователя по
номеру. Находим из словаря имя и фамилию и возвращаем строку.

Compojure решает проблему вложенных путей. Рассмотрим приложение для учета
товаров. По адресу \spverb|/content/order/1/view| открывается карточка
товара. Страница \spverb|/content/order/1/edit| показывает форму редактирования
этого товара. Чтобы обновить товар, нужно отправить форму по тому же пути, но
методом POST.

Очевидно, правила пересекаются. Чтобы избежать повторов, используем макрос
\spverb|context|:

\begin{english}
  \begin{clojure}
(context "/content/order/:id" [order-id]
  (GET  "/view" request (order-view request))
  (context "/edit" []
    (GET  "/" request (order-form request))
    (POST "/" request (order-save request))))
  \end{clojure}
\end{english}

Каждое правило в \spverb|context| наследует параметры из уровня выше. Это
значит, обработчики \spverb|order-view|, \spverb|order-form| и
\spverb|order-save| получат параметр \spverb|:order-id|.

До сих пор в качестве ответа в правилах мы писали что-то вроде
\spverb|(some-handler request)|. Иногда ответ знают заранее, поэтому нет смысла
выносить его в функцию. Рассмотрим это на примере
\spverb|healthcheck|-обработчика.

Современные приложения запускают в контейнерах и облачных сервисах. Чтобы
узнать, работает приложение или нет, специальная служба опрашивает его. Простой
способ сделать это~--- послать приложению \spverb|GET|-запрос по адресу
\spverb|/health| и проверить статус. Тело и~заголовки ответа не играют роли.

Чтобы не создавать лишний обработчик \spverb|(page-health request)|, поместим
ответ в правило:

\begin{english}
  \begin{clojure}
(ANY "/health" _ {:status 200 :body "ok"})
  \end{clojure}
\end{english}

Можно сделать еще проще. В Compojure предусмотрен случай, когда выражение это
строка. Она становится телом положительного ответа:

\begin{english}
  \begin{clojure}
(ANY "/health" _ "ok")
  \end{clojure}
\end{english}

\subsection{Роутинг с Bidi}

Библиотека Bidi\footurl{https://github.com/juxt/bidi} строит роутинг
по-другому. Она опирается на данные~--- списки и словари. Метод состоит из
нескольких шагов.

На первом этапе объявляют дерево маршрутов. Это комбинация векторов и словарей
по особым правилам. В листьях дерева помещают теги~--- уникальные
метки. Специальная функция принимает дерево и запрос. Функция ищет ветку дерева,
которой он подходит. Если ветка нашлась, результатом будет ее тег и параметры
пути. Например, \spverb|{:route :show-user, :route-params: {:id 1}}|.

На втором этапе пишут middleware~--- промежуточный обработчик запроса. Он
принимает запрос, добавляет в него тег и передает дальше по цепочке.

На третьем этапе добавляют обработчик запроса. Это не функция, а мультиметод.
Его функция-диспатчер возвращает тег. Метод с тегом \spverb|:default| вернет
ответ \spverb|404|, \spverb|:show-user|~--- страницу пользователя и так далее.

На первый взгляд схема кажется сложной. Но однажды настроив, ее легко
масштабировать. Чтобы сервер подхватил новый путь, в дерево добавляют ветку и
расширяют мультиметод.

Перепишем на Bidi пример из начала главы. Добавьте зависимость:

\begin{english}
  \begin{clojure}
[bidi "2.1.5"]                  ;; project.clj
(:require [bidi.bidi :as bidi]) ;; namespace
  \end{clojure}
\end{english}

Начнем с дерева маршрутов. Вариант с \spverb|page-index|, \spverb|page-hello| и
\spverb|page-404| выглядит так:

\begin{english}
  \begin{clojure}
(def routes
  ["/" {""      :page-index
        "hello" :page-hello
        true    :not-found}])
  \end{clojure}
\end{english}

Проверим поиск пути по этому дереву. Функция \spverb|match-route| принимает
маршруты, путь и возвращает словарь с тегом:

\begin{english}
  \begin{clojure}
(bidi/match-route routes "/hello")
{:handler :page-hello}

(bidi/match-route routes "/test")
{:handler :not-found}
  \end{clojure}
\end{english}

Объединим тег с запросом. Сделаем это за один шаг функцией
\spverb|match-route*|. Это альтернативная версия \spverb|match-route|, которая
принимает словарь-накопитель. Накопителем станет запрос.

\begin{english}
  \begin{clojure}
(let [request {:request-method :get
               :uri "/test"}]
  (bidi/match-route* routes (:uri request) request))

{:request-method :get
 :uri "/test"
 :handler :not-found}
  \end{clojure}
\end{english}

Видим, что \spverb|match-route*| вернула запрос, но добавила в него поле
\spverb|:handler|. Обернем этот код в middleware. Получив запрос, новый
обработчик добавит к запросу поле \spverb|handler| и вызовет исходный
обработчик.

\begin{english}
  \begin{clojure}
(defn wrap-handler [handler]
  (fn [request]
    (let [{:keys [uri]} request
          request* (bidi/match-route* routes uri request)]
      (handler request*))))
  \end{clojure}
\end{english}

Мы еще не касались техники middleware, но вынуждены применить ее сейчас. Ниже мы
рассмотрим в деталях, как они работают и почему так важны.

Проверим \spverb|wrap-handler| на скорую руку. Для удобства обернем функцию
\spverb|identity|, которая вернет переданный в нее аргумент:

\begin{english}
  \begin{clojure}
(def wrapped (wrap-handler identity))
(wrapped {:request-method :get
          :uri "/hello?foo=42"})

{:request-method :get
 :uri "/hello?foo=42"
 :handler :page-hello}
  \end{clojure}
\end{english}

Обработчик запроса это мультиметод. Его функция-диспатчер просто ключ
\spverb|:handler|.

\begin{english}
  \begin{clojure}
(defmulti multi-handler :handler)

(defmethod multi-handler :page-index
  [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defmethod multi-handler :not-found
  [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
  \end{clojure}
\end{english}

Обернем \spverb|multi-handler| в middleware и получим финальное
приложение. Запустите веб-сервер и проверьте результат в браузере.

\begin{english}
  \begin{clojure}
(def app (wrap-handler multi-handler))
  \end{clojure}
\end{english}

Это был простой роутинг на Bidi. Теперь рассмотрим товары, их
просмотр и изменение. Новое дерево выглядит так:

\begin{english}
  \begin{clojure}
(def routes
  ["/" {["content/order/" :id]
        {"/view" {:get  :page-view}
         "/edit" {:get  :page-form
                  :post :page-save}}}])
  \end{clojure}
\end{english}

В этой версии листья уже не теги, а словари. Ключ каждого словаря это метод, а
значение~--- тег. Запрос \spverb|GET /content/order/1/edit| разрешается в тег
\spverb|:page-form|, а POST с таким же адресом~--- в \spverb|:page-save|.  На
этапе \spverb|wrap-handler| запрос получит поле \spverb|:route-params|.  В нашем
случая это словарь \spverb|{:id "1"}|.

Расширим мультиметод страницами. \spverb|Page-view| находит товар по номеру и
верстает его HTML-страницу. Если товара нет, вернем ответ 404 <<не найдено>>.

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-view
  [request]
  (if-let [order (some-> request :route-params
                         :id get-order-by-id)]
    {:status 200
     :headers {"content-type" "text/html"}
     :body (render-order-page {:order order})}
    response-404))
  \end{clojure}
\end{english}

%% ---------------

Страница с формой \spverb|:page-form| отличается тем, что вместо
\spverb|render-order-page| мы бы вызвали \spverb|render-order-form|. Эта функция
строит HTML-форму с кнопками. Обновление товара сложнее: нужно выбрать поля из
запроса и записать их в базу. Для краткости опустим валидацию:

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-save
  [request]
  (let [{:keys [params route-params]} request
        {order-id :id} route-params
        fields (select-keys params [:title :description :price])]
    (jdbc/update! *db* :orders fields ["id = ?" order-id])
    {:status 302
     :headers {"Location" (format "/content/order/%s/view" order-id)}}))
  \end{clojure}
\end{english}

Обратите внимание: на изменение данных мы отвечаем не HTML-страницей, а
\emph{редиректом} на нее. Если страница пришла в ответ на POST-запрос, то при ее
обновлении браузер снова отправит форму. Это чревато странным поведением на
сервере. Вариант с редиректом решает эту проблему. Браузер загрузит страницу
через GET, и побочных эффектов при обновлении не будет.

\subsection{Выбор между Compojure и Bidi}

Новичку в Clojure будет легче начать с Compojure. У библиотеки достойная
документация с примерами. Compojure написал тот же разработчик, что и
Ring. Проекты близки и дополняют друг друга.

Дерево маршрутов Bidi сложно для понимания. Оно многословно и не
интуитивно. Легко допустить ошибку, например перепутать вектор и словарь. С
другой стороны, логика на мультиметодах несет преимущества. Код становится
линейным, организованным, приложение легче расширять.

Если проект небольшой, выбирайте Compojure. Когда проект сложный и маршрутов все
больше, рассмотрите переезд на Bidi.

\section{Middleware}

Выше мы упоминали про middleware и даже кинули пробный шар~--- написали
\spverb|wrap-route|. Теперь изучим их внимательней. Это самый важный раздел в
главе.

В переводе с английского <<middleware>> означает промежуточный слой, середина. В
программировании так называют код-посредник. Он приведит типы, дополняет
словари, проверяет права доступа.

\label{decorator}

Паттерн <<декоратор>>~--- частный случай middleware. Декоратор это функция
\spverb|А|, которая принимает функцию \spverb|B| и возвращает функцию
\spverb|C|. Говорят, что \spverb|A| декорирует \spverb|B|. Результат
декорирования это \spverb|C|. В ходе исполнения \spverb|C| вызывает \spverb|B|,
но с изменениями. Например, дополняет входные или выходные данные \spverb|B|.

Рассмотрим простые декораторы. \spverb|With-echo| добавляет к функции побочный
эффект: печатает аргументы и результат.

\begin{english}
  \begin{clojure}
(defn with-echo [func]
  (fn [& args]
    (apply println "The args are" args)
    (let [result (apply func args)]
      (println "The result is" result)
      result)))
  \end{clojure}
\end{english}

Вот как им пользуются:

\begin{english}
  \begin{clojure}
(def +echo (with-echo +))
(+echo 1 2 3)
;; The args are 1 2 3
;; The result is 6
6
  \end{clojure}
\end{english}

\spverb|With-catch| оборачивает функцию в форму \spverb|try/catch|. Если во
время работы брошено исключение, результатом будет его объект.

\begin{english}
  \begin{clojure}
(defn with-catch [func]
  (fn [& args]
    (try
      (apply func args)
      (catch Throwable e
        e))))
  \end{clojure}
\end{english}

Мы уже видели запрос в Ring. Читатель заметил, что в нем нет полей, с которыми
он работал в других языках. Например, классы \spverb|django.http.HttpRequest| и
\spverb|flask.Request| в Python содержат свойства \spverb|.params| или
\spverb|.values|. Это словари параметров из адресной строки или тела запроса.

По умолчанию запрос несет только базовую информацию. Почему в Ring нет столь
важных вещей? Потому что не каждое приложение в них нуждается. Представим, что
на каждый запрос Ring парсит адресную строку и тело. Это удобно разработчику, но
замедляет код. Нет гарантии, что параметры нужны в запросе, но сервер потратит
время и память на их обработку.

То же самое с разобором тела: это дорогая операция. Бывает, что в теле большой
JSON-документ. Мы считали его, но у пользователя нет прав на запись. Нужно было
проверить права до чтения!

Обработчик в Ring это функция, которая принимает запрос и возвращает
ответ. Middleware сочетается с таким подходом. Параметры запроса, сессии, куки,
права доступа~--- вс\"{е} это функция, которая возвращает функцию. Не придется
писать все middleware с нуля. Ring содержит самые основные, нужно только
подключить их. Рассмотрим некоторые middleware и принципы их работы.

\subsection{Параметры запроса}

\label{ring-params}

Стандарт HTTP предусматривает данные в адресной строке. Это пары вида
\spverb|"name=John&city=NY"| после знака вопроса. Удобно, когда на уровне
запроса это словарь \spverb|{:name "John" :city "NY"}|.

Иногда параметры помещают в тело запроса. Так поступают из-за ограничения на
длину адресной строки и безопасности. Длина строки ограничена 2048 байтами, а на
тело запроса ограничений нет. Пароли и почтовые адреса нельзя пересылать в
адресной строке, потому что они остаются в логах и истории браузера.

Функция \spverb|wrap-params| из модуля \spverb|ring.middleware.params| меняет
обработчик следующим образом. Переданный в него запрос дополняется полями:

\begin{itemize}

\item
  \spverb|:query-params|~--- словарь параметров адресной строки;

\item
  \spverb|:form-params|~--- словарь данных из тела запроса;

\item
  \spverb|:params|~--- их комбинированная версия.

\end{itemize}

Пусть \spverb|app|~--- ваше веб-приложение. Чтобы получить его обернутую версию,
достаточно вызвать \spverb|wrap-params| c \spverb|app|. Результат будет
финальным приложением. На жаргоне разработчиков это называется <<врапнуть>>
(анг. \emph{wrap}~--- обернуть).

\begin{english}
  \begin{clojure}
(require '[ring.middleware.params :refer [wrap-params]])
(def final-app (wrap-params app))
  \end{clojure}
\end{english}

Чтобы не запутаться в именах, придерживайтесь правил. Исходное приложение
называйте \spverb|app-naked| или \spverb|app-raw| (голое, сырое), а финальное
просто \spverb|app|.

Доработайте приложение так, чтобы оно учитывало параметры строки. Например,
чтобы имя того, кого приветствовать, можно задать параметром \spverb|who|:
\spverb|/hello?who=John|. Подсказка: добраться до параметра \spverb|who| можно
так:

\begin{english}
  \begin{clojure}
(defn page-hello [request]
  (let [who (get-in request [:params "who"])]
    ...))
  \end{clojure}
\end{english}

Обратите внимание, ключи \spverb|:params|~--- строки. Исходные данные это
строка, и алгоритм режет ее на части. Но Clojure поощряет нас к тому, чтобы
ключи были кейвордами. Исправим это. В поставке Ring идет middleware, которое
приводит \spverb|:params| к удобному виду. Это \spverb|wrap-keyword-params| из
модуля \spverb|ring.middleware.keyword-params|. С ним ключи \spverb|:params|
примут тип \spverb|Keyword|.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.keyword-params
           :refer [wrap-keyword-params]])
(def app (wrap-keyword-params (wrap-params app-naked)))
  \end{clojure}
\end{english}

Теперь до \spverb|:who| можно добраться так:

\begin{english}
  \begin{clojure}
(get-in request [:params :who])
(-> request :params :who)
  \end{clojure}
\end{english}

\subsection{Стек middleware}

Появилась новая проблема: когда врапперов много, от них возникает шум. Типичное
приложение включает около десяти middleware. Получается лесенка:

\begin{english}
  \begin{clojure}
(def app
  (wrap-something-else
    (wrap-current-user
      (wrap-session
        (wrap-keyword-params
          (wrap-params app-naked))))))
  \end{clojure}
\end{english}

Представьте, что нужно добавить новое звено посередине. Это каскадно сдвинет
элементы ниже. Чтобы победить вложенность, сделаем структуру линейной. Поможет
стрелочный оператор (threading macro):

\begin{english}
  \begin{clojure}
(def app
  (-> app-naked
      wrap-params
      wrap-keyword-params
      wrap-session
      wrap-current-user
      wrap-something-else))
  \end{clojure}
\end{english}

Такая запись выглядит как список, поэтому ее легко поддерживать. Ниже мы будем
называть ее \emph{стеком} middleware.

Запись в стрелочном виде имеет особенность. Не заглядывая дальше, догадайтесь, в
каком порядке будут выполнены middleware? Правильный ответ: снизу вверх для
запроса и сверху вниз для ответа. Это станет ясно при мысленном разборе.

Сперва запрос попадет в \spverb|wrap-something-else|. Код внутри него вызовет
обработчик, который получен из \spverb|wrap-current-user|. Обработчик внутри
него~--- результат \spverb|wrap-session| и так далее. Вершиной подъема станет
\spverb|app-naked|. В нем сработает основная логика приложения.

Теперь ответ спускается в обратном порядке. Сначала он пройдет через
\spverb|wrap-params| и \spverb|wrap-keyword-params|. Эти два middleware не
изменяют ответ и просто вернут его. \spverb|Wrap-session| и
\spverb|wrap-current-user|, возможно, допишут новые заголовки. Последним
сработает \spverb|wrap-something-else|. Цикл пройден.

Представьте стек middleware как восхождение в гору и спуск с нее. Другой
аналогией может быть пузырек, который всплывает и опускается (не имеет отношения
к сортировке пузырьком). Похоже устроены middleware в Django, промышленном
фреймворке на Python. В Django их роль играют не функции, а классы, но порядок
обхода такой же.

Порядок middleware порой критичен. Некоторые из них опираются на данные из
предыдущих middleware. Рассмотрим уже знакомые \spverb|wrap-params| и
\spverb|wrap-keyword-params|. Последний ищет в запросе поле \spverb|params| и
меняет тип ключей. Получается разделение труда: одно middleware готовит поле,
второе улучшает его. Поэтому \spverb|wrap-keyword-params| ставят строго после
\spverb|wrap-params|.

Теперь посмотрим на форму \spverb|(def app...)| выше. В нее закралась
\emph{ошибка}. Запрос поднимается снизу вверх, поэтому
\spverb|wrap-keyword-params| сработает раньше. Он попытается найти
\spverb|:params| в запросе, но безуспешно. Далее сработает
\spverb|wrap-params|. Он заполнит это поле словарем из адресной строки. В
результате у \spverb|:params| ключи будут строками. Поменяйте
\spverb|wrap-params| и \spverb|wrap-keyword-params| местами.

Неверный порядок middleware стоит часов отладки. Но есть трюк: если два и более
middleware зависят друг от друга, можно <<схлопнуть>> их в одно целое. Функция
\spverb|comp| принимает произвольные функции и возвращает супер-функцию, которая
применяет их к аргументу. Напишем умный враппер параметров:

\begin{english}
  \begin{clojure}
(def wrap-params+ (comp wrap-params wrap-keyword-params))
  \end{clojure}
\end{english}

Разберемся, почему аргументы \spverb|comp| следуют в таком порядке. Обозначим их
для краткости \spverb|foo| и \spverb|bar| и перепишем выражение несколько раз:

\noindent
\begin{tabular}{ @{}p{3cm} @{}p{3.5cm} @{}p{3.5cm} }

\begin{english}
  \begin{clojure}
(comp foo bar)
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(fn [x]
  (foo (bar x)))
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(fn [x] (-> x
            bar
            foo))
  \end{clojure}
\end{english}

\end{tabular}

Если представить, что \spverb|x| в третьем выражении это приложение, а
\spverb|foo| и \spverb|bar| различные middleware, то вс\"{е} станет ясно. Во время
запроса они работают в обратном порядке, поэтому \spverb|foo| запустится раньше
\spverb|bar|. Значит, на месте \spverb|foo| должно быть \spverb|wrap-params|, а
вместо \spverb|bar|~--- \spverb|wrap-keyword-params|. Если подставить их в
первое выражение, получим то, что записали вначале.

Плюс на конце означает, что это улучшенная версия обычного
\spverb|wrap-params|. Заменим в стеке \spverb|wrap-params| и
\spverb|wrap-keyword-params| на версию с плюсом. Цепочка станет короче, а логика
параметров теперь в отдельном месте.

Перечислим другие полезные middleware: куки, сессии и JSON.

\subsection{Cookie}

В HTTP куки~--- это маленькие кусочки информации. Между сервером и браузером
особое соглашение о том, как хранить и передавать их. Если сервер выставил куки,
браузер запомнит их для этого сайта. В следующий раз браузер отправит их на
сервер автоматически. Так продолжается до тех пор, пока сервер не удалит куки
или истечет их срок жизни.

Простейший случай, когда нужны куки~--- определить, был ли уже пользователь на
сайте. При первом запросе приложение ищет в запросе куки с именем
\spverb|visited|. Если их нет, сервер выставит заголовок:

\begin{english}
  \begin{http}
Set-Cookie: visited=true;
  \end{http}
\end{english}

В последующие запросы браузер добавит поле \spverb|visited=true|. Приложение
проверяет: если значение истина, пользователь уже был на сайте.  Это влияет на
показ рекламы, всплывающие окна и так далее.

Технически куки это длинный заголовок, где поля и значения разделены точками с
запятой. Middleware \spverb|wrap-cookie| упрощает работу с этим заголовком. В
запросе мы получим словарь \spverb|:cookies|. В нем два уровня: поля и
атрибуты. Чтобы выслать клиенту новые куки, добавьте поле \spverb|:cookies| в
ответ. В значении укажите словарь такого же вида. Ring построит из него
заголовок \spverb|Set-Cookie| и добавит в ответ.

Страница \spverb|page-seen| проверяет, видим ли мы ее в первый раз.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.cookies
           :refer [wrap-cookies]])

(defn page-seen [request]
  (let [{:keys [cookies]} request
        seen-path ["seen" :value]
        seen? (get-in cookies seen-path)
        cookies* (assoc-in cookies seen-path true)]
    {:status 200
     :cookies cookies*
     :body (if seen?
             "Already seen."
             "The first time you see it!") }))

(def app (-> page-seen
             wrap-cookies))
  \end{clojure}
\end{english}

Замечание: переменная со звездочкой на конце означает новую версию
исходной переменной. Например, такой же словарь, но с новым ключом. Вместо
звездочки некоторые ставят штрих или что-то другое. В примере выше
\spverb|cookies*| читается как <<новые куки на базе старых>>.

По аналогии с \spverb|:params| ключи куки это строки. Если поменять
\spverb|"seen"| на \spverb|:seen|, вы промахнетесь мимо значения. Ring не
предлагает \spverb|wrap-keyword-cookie|; такую обертку легко написать
самому. Ниже мы покажем способ для заголовков.

Запустите приложение в браузере. После обновления страницы надпись изменится на
<<Already seen>>. Она останется такой даже после перезагрузки сервера, потому
что флаг хранится в браузере. Только очистив куки вы увидите <<The first time
you see it>>. Для полноты эксперимента откройте приватную вкладку или другой
браузер.

Куки тесно связаны с безопасностью. Убедитесь, что куки защищены от кражи и не
раскрывают секретные данные (пароли, ключи доступа). В этом разделе мы не
обсуждаем веб-безопасность: тема слишком обширна и заслуживает отдельной книги.

\subsection{Сессии}

Стандарт HTTP не предполагает связи между двумя запросами. Неважно, откуда
приходят запросы~--- с соседних машин или разных континентов. Промежуток времени
тоже не решающий фактор. Кто-то читает страницу час, а кто-то обновляет каждую
минуту. Без особых оговорок нельзя утверждать, что два запроса связаны.

Разработчики пошли на уловку. Приложение запоминает пользователя и хранит его
состояние между запросами. Даже если два человека сидят за одним столом и
пользуются одной сетью, сервер различает их. Это назвали \emph{сессией} или
\emph{сеансом}.

Под сессией понимают любые значения, связанные с текущим
пользователем. Например, выбранный язык, состояние виджетов, просмотренные
товары. Важно учесть, что пользователь не обязательно авторизован. Это может
быть аноним, но сервер отличает его запросы от остальных.

\spverb|Wrap-session| это довольно сложное middleware. Оно дополняет запрос
словарем \spverb|:session|. Его ключи~--- поля сессии. Чтобы обновить сессию, ее
новую версию пишут в одноименное поле ответа. Middleware различает \spverb|nil|
и отсутствие сессии в ответе. Если поле \spverb|nil|, вся сессия удаляется. Если
ключа нет, ничего не происходит.

Сессия это абстрактное понятие, поэтому различают ее бэкенды. Это способы
хранить сессию физически. Например, в памяти, на диске, в базе данных, системах
Memcached и Redis или даже куках. Ring предлагает протокол \spverb|SessionStore|
с методами записи, чтения и удаления сессии.

При выборе бэкенда важно учитывать, может ли он работать на нескольких машинах
одновременно. Что получится, если каждый запрос случайно уходит на одну из
десяти машин? Если сессия хранится в памяти приложения, то на каждой машине
будет разная сессия. Это чревато странным поведением и трудной
отладкой. Аналогично с файлами~--- машины не делят их между собой. База данных
или Redis это центральное хранилище. Оно гарантирует целостность сессии для всех
клиентов.

Интересно, что сессия в куках тоже работает на многих машинах. На каждый запрос
браузер передает полную сессию в заголовках. В этом случае сессию хранит
браузер. Если пользователь очистит куки или запустит другой браузер, сессия
будет утеряна.

По умолчанию Ring хранит сессию в памяти или куках. Тип хранилища задают
настройками \spverb|wrap-session|. Чтобы подружить сессию с Redis или другой
системой, расширьте протокол \spverb|SessionStore|.

Рассмотрим пример со счетчиком посещений. Будем считать, сколько раз
пользователь зашел на сайт. Для краткости храним сессию в памяти.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.session :refer [wrap-session]])

(defn page-counter [request]
  (let [{:keys [session]} request
        session* (update session :counter (fnil inc 0))]
    {:status 200
     :session session*
     :body (format "Seen %s time(s)" (:counter session*))}))

(def app (-> page-counter
             wrap-session))
  \end{clojure}
\end{english}

Запустите приложение и откройте браузер. Обновите страницу, и счетчик в
сообщении возрастет с каждым просмотром. Проделайте то же самое в другом
браузере. Это будет вторая сессия, которая не зависит от первой. Поскольку
данные хранится в памяти, они потеряются при новом запуске сервера.

\emph{Упражнение.} Выше мы считаем просмотры для всего сайта. Сделайте так,
чтобы счетчик работал в разрезе страниц. Например, главная страница \spverb|/|
просмотрена пять раз, а справка \spverb|/help|~--- три раза. Параметры строки не
влияют на подсчет.

\subsection{JSON}

Формат JSON предназначен для передачи данных. Среду прочих его достоинств~---
типы, коллекции и совместимость с JavaScript. JSON различает базовые типы
данных~--- числа, строки, логический тип. Это значимый плюс по сравнению с INI
или XML, где все значения строки.

JSON выделяет коллекции~--- массивы и словари~--- и произвольную их
вложенность. В разное время были попытки передать коллекции строками. Например,
через запятую или квадратными скобками:

\begin{english}
  \begin{text}
user_ids=1,2,3&cities=NY,LA
address[0].line[0].value=SomeStreet
  \end{text}
\end{english}

\noindent
Это оказалось неудобно, к тому же разработчики так и не договорились о едином
подходе. Каждый фреймворк предлагал свое решение, чтобы упаковать и восстановить
коллекцию. К счастью, сегодня с этим покончено. Коллекции в строках втречаются
только в старых системах.

JSON совместим с JavaScript. Если передать его строку в функцию \spverb|eval|,
она вернет данные~--- комбинацию списков и словарей. Эти и другие причины
сделали формат столь популярным. Сегодня JSON это главный способ передать данные
в вебе.

Ring предлагает несколько middleware для JSON. Для удобства их вынесли в
отдельную библиотеку. Добавьте зависимость:

\begin{english}
  \begin{clojure}
[ring/ring-json "0.4.0"]
  \end{clojure}
\end{english}

\spverb|Wrap-json-response| упрощает возврат JSON-данных. Middleware проверяет
поле ответа \spverb|:body|. Если это коллекция (вектор или словарь), то
middleware заменит его на кодированную строку и добавит заголовок
\spverb|Content-Type: application/json|.

Рассмотрим API для чтения пользователя. Если мы нашли его по номеру, вернем
словарь полей. Если нет, в ответе будет структура ошибки. В обоих случаях не
нужно кодировать данные вручную~--- это делает \spverb|wrap-json-response|.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.json
           :refer [wrap-json-response]])

(defn page-data [request]
  (let [user-id (-> request :params :id)]
    (if-let [user (get-user-by-id user-id)]
      {:status 200 :body user}
      {:status 404
       :body {:error_code "MISSING_USER"
              :error_message "No such user"
              :error_data {:id user-id}}})))

(def app (-> page-data
             wrap-params+
             wrap-json-response))
  \end{clojure}
\end{english}

Для входящего JSON служат два middleware: \spverb|wrap-json-body| и
\spverb|wrap-json-params|. Оба проверяют, что заголовок \spverb|Content-Type|
равен \spverb|application/json|. Если да, они парсят тело с учетом возможных
исключений. При ошибке разбора получим статус 400 и текст <<JSON body
malformed>>.

Разница между middleware в том, куда они складывают
данные. \spverb|Wrap-json-body| заменяет поле \spverb|:body| запроса на
структуру данных. Ниже обработчик \spverb|page-body| извлекает имя и город из
\spverb|:body|. Тело запроса уже не входящий поток, а словарь. Обратите
внимание, middleware принимает дополнительные параметры. Флаг \spverb|:keywords? true|
означает, что ключи словаря станут кейвордами.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.json :refer [wrap-json-body]])

(defn page-body [request]
  (let [{:keys [body]} request
        {:keys [username city]} body]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-body
             (wrap-json-body {:keywords? true})))
  \end{clojure}
\end{english}

Чтобы отправить JSON серверу, понадобится специальная программа. Это может быть
утилита \spverb|cURL| или графическое приложение Postman. Пример с
\spverb|cURL|:

\begin{english}
  \begin{bash}
curl --request POST \
     --header "Content-Type: application/json" \
     --data '{"username":"John","city":"NY"}' \
     http://localhost:8080/
  \end{bash}
\end{english}

\subsection{Проблемы слияния}

Вариант с \spverb|wrap-json-params| работает с небольшим отличием. Оно пишет
данные в поле \spverb|:json-params|. Если в JSON пришел словарь, он дополняет
\spverb|:params|. Объясним, в чем разница.

Поле \spverb|:params| это общий аккумулятор параметров. В него пишут данные и
другие врапперы, например, \spverb|wrap-params|. Иногда нам неважно, откуда
пришли параметры: из адресной строки, тела или JSON. В обработчике мы просто
черпаем данные из \spverb|:params|.

В других случаях важно, чтобы параметры не смешивались и не заменяли друг
друга. Чтобы прочесть только те данные, что пришли в JSON-теле, обратимся к полю
\spverb|:json-params| или \spverb|:body|. Каким враппером пользоваться, зависит
от конкретного случая.

Вспомним, что \spverb|:params| это словарь с ключам-строками. Чтобы слияние
прошло правильно, \spverb|wrap-json-params| оставляет ключи строками. Исправьте
ключи с помощью \spverb|wrap-keyword-params|. Оно должно идти после разбора
JSON.

Разработчики не случайно выделяют поле \spverb|:json-params|. JSON-документ не
обязательно словарь. Это может быть и массив, который невозможно объединить с
\spverb|:params|. На этот случай JSON-данные хранят в отдельном поле.

Пример, когда клиент передает данные гибридно: \spverb|username| в JSON и
\spverb|city| в параметрах строки. Обратите внимание на стек middleware. Сначала
парсят параметры адреса, затем тело. Оба словаря оседают в
\spverb|:params|. После их накопления исправляют тип ключей.

\begin{english}
  \begin{clojure}
(defn page-params [request]
  (let [{:keys [params]} request
        {:keys [username city]} params]
    (create-user username city)
    {:status 201
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-params
             wrap-keyword-params
             wrap-json-params
             wrap-params
             wrap-json-response))
  \end{clojure}
\end{english}

\noindent
Пример такого запроса:

\begin{english}
  \begin{bash}
curl --request POST \
     --header "Content-Type: application/json" \
     --data '{"username":"John"}' \
     http://localhost:8080/?city=NY
  \end{bash}
\end{english}

Из-за того, что поля приходят из разных источников, может возникнуть
путаница. Избегайте случаев, когда в \spverb|:params| валится все подряд. При
работе над API читайте один источник: \spverb|:query-params| для GET,
\spverb|:form|- или \spverb|:json-params| для POST.

\subsection{Свои middleware}

До сих пор мы использовали врапперы из Ring или смежных библиотек. Рано или
поздно вам потребуются свои middleware. Рассмотрим несколько примеров из
реальных проектов.

\subsubsection*{Ключи заголовков}

Этот враппер обновляет заголовки запроса~--- меняет тип ключей со строк на
кейворды. Для этого служит функция \spverb|keywordize-keys| из пакета
\spverb|clojure.walk|. Заголовкам меняют тип когда приложение часто к ним
обращается.

Если в заголовки ответа добавить кейворд, сервер бросит исключение. Адаптер
Jetty ожидает строки, и произойдет ошибка типов. Добавьте обратное действие:
измените ключи с кейвордов на строки. Эту задачу решает функция
\spverb|stringify-keys|.

\begin{english}
  \begin{clojure}
(require '[clojure.walk :refer
           [keywordize-keys stringify-keys]])

(defn wrap-headers-kw [handler]
  (fn [request]
    (-> request
        (update :headers keywordize-keys)
        handler
        (update :headers stringify-keys))))
  \end{clojure}
\end{english}

Внутри \spverb|handler| приложение работает с заголовками как с кейвордами. По
аналогии можно сменить тип ключей для куки.

\subsubsection*{Идентификатор запроса}

В протоколе HTTP запрос и ответ не связаны друг с другом. Порой трудно понять, к
какому запросу относится данный ответ и наоборот. Важно, чтобы система могла их
сопоставить. Мы увидели в логах ответ с кодом 500, но какой именно запрос вызвал
ошибку?

Для этого ввели заголовок \spverb|X-Request-Id|. Это случайный идентификатор,
чаще всего UUID, строка из 36 символов. Для краткости его называют <<айди>>
(анг. id). Если клиент не передал айди в запросе, ему назначат случайный. Тот же
айди возвращают в ответе. Его пишут в лог, чтобы по запросу вернуть цепочку
событий.

Напишем обертку для айди. Внутри мы работаем с заголовками как с
кейвордами. Ожидается, что \spverb|wrap-headers-kw| был выше по стеку.

\begin{english}
  \begin{clojure}
(import 'java.util.UUID)

(defn wrap-request-id [handler]
  (fn [request]
    (let [uuid (or (get-in request [:headers :x-request-id])
                   (str (UUID/randomUUID)))]
      (-> request
          (assoc-in [:headers :x-request-id] uuid)
          (assoc :request-id uuid)
          handler
          (assoc :request-id uuid)
          (assoc-in [:headers :x-request-id] uuid)))))
  \end{clojure}
\end{english}

Айди хранят в заголовках, но дублируют на уровне запроса и ответа в поле
\spverb|:request-id|. Для записи в лог к нему часто обращаются. Удобно вынести
поле в переменную в начале функции:

\begin{english}
  \begin{clojure}
(defn some-handler [request]
  (let [{:keys [params request-id]} request]
    (log/info "Request id: %s" request-id)))
  \end{clojure}
\end{english}

\subsubsection*{Текущий пользователь}

Этот враппер добавляет в запрос текущего пользователя. В данном случае мы ищем
его номер в сессии. Если номер найден, читаем пользователя из базы и добавляем к
запросу. Функция \spverb|get-user-by-id| вернет словарь или \spverb|nil|. Чтобы
не вызывать ее с \spverb|nil|, форму оборачивают в условие \spverb|(when user-id)|.

\begin{english}
  \begin{clojure}
(defn wrap-current-user [handler]
  (fn [request]
    (let [user-id (-> request :session :user-id)
          user (when user-id
                 (get-user-by-id user-id))]
      (-> request
          (assoc :user user)
          handler))))
  \end{clojure}
\end{english}

К вопросу о безопасности: номер пользователя \emph{можно} хранить в сессии. Она
подписана секретным ключом, поэтому только сервер может изменить сессию. Номер
пользователя не раскрывает приватные данные. Но не храните в сессии пароли и
ключи доступа.

\subsection{Прерывание стека}

До сих пор мы работали с цепочкой middleware, где каждое звено передает
управление следующему. Логика middleware не всегда линейна: бывает, цепочку
нужно прервать. В одном из middleware мы поняли, что у пользователя нет прав к
странице. Продолжать не имеет смысла: наоборот, мы как можно скорее обрываем
стек.

Некоторые врапперы из тех, что мы рассмотрели работают на условиях. Например,
\spverb|wrap-json-params| читает тело только если заголовок
\spverb|Content-Type| равен \spverb|application/json|. Если тип другой, враппер
ничего не делает. При разборе JSON ловится исключение. Бывает, что документ
составили с ошибками или он повредился из-за сбоя в сети. В этом случае
\spverb|wrap-json-params| не продолжает цепочку. Он вернет ответ <<400 JSON body
malformed>>, при этом ни одно middleware ниже по стеку не сработает.

Разберем проверку доступа. Пусть приложение доступно только по
авторизации. С~помощью \spverb|wrap-current-user| получим текущего
пользователя. Это middleware только находит пользователя, но не ограничивает
доступ. Добавим еще одно:

\begin{english}
  \begin{clojure}
(defn wrap-auth-user-only [handler]
  (fn [request]
    (if (:user request)
      (handler request)
      {:status 403
       :headers {"content-type" "text/plain"}
       :body "Please sign in to see that page."})))
  \end{clojure}
\end{english}

Переход к следующему middleware теперь под условием. Если пользователь не
авторизован, звенья ниже \spverb|wrap-auth-user-only| будут отброшены.

Мы уже говорили, что цепочка middleware это восхождение и спуск с горы. Если
одно звено терпит неудачу, мы как будто срезаем верхушку. Словно добрались до
середины, столкнулись с проблемой и повернули обратно. \emph{Общее правило:} чем
раньше мы обнаружим проблему, тем меньше потратим ресурсов. Поэтому более общие
проверки ставят выше по стеку (или ниже в операторе \arr).

Еще один вариант с развилкой~--- перехват ошибок. Это очень важный
обработчик. Вы не найдете его в стандартной библиотеке, потому что реакция на
ошибки зависит от проекта. Такой враппер просто копируют с небольшими
изменениями.

Что случится, если при обработке запроса возникнет исключение? На этот счет нет
четких правил. Каждый фреймворк ведет себя по-разному. Один покажет стек-трейс в
браузере. Другой вернет HTML-страницу с информацией о сервере. Разработчики
третьего посчитали, что показывать машинные данные небезопасно. Исключение пишут
в лог, а в ответе нейтральная фраза об ошибке.

Хорошо, когда мы сами определяем, что делать с исключениями. Ниже простое
middleware, которое перехватывает ошибку, пишет ее в лог и возвращает
ответ-заглушку:

\begin{english}
  \begin{clojure}
(defn wrap-exception [handler]
  (fn [request]
    (try
      (handler request)
      (catch Throwable e
        (let [{:keys [uri
                      request-method]} request]
          (log/errorf e "Error, method %s, path %s"
                      request-method uri)
          {:status 500
           :headers {"content-type" "text/plain"}
           :body "Sorry, please try later."})))))
  \end{clojure}
\end{english}

Выражение \spverb|log/errorf| это макрос для записи ошибки. Он принимает
исключение, шаблон и параметры. Мы хотим знать, какие были метод и путь запроса,
поэтому записываем их тоже. Это облегчит анализ логов в будущем.

Чем выше \spverb|wrap-exception| расположено в стеке, тем меньше шансов у
исключения просочиться. В идеале middleware стоит на вершине цепочки, чтобы
ловить все исключения.

Иногда используют двойной перехват. Ошибки в разных частях системы заслуживают
разного подхода. Важно знать все об ошибках в бизнес-логике. Если пользователь
не смог что-то купить, мы запишем его номер и данные, которые вызвали ошибку. Но
если нам прислали поврежденный JSON, это техническая проблема, не связанная с
бизнесом. В этом случае исключение это норма, потому его не пишут в лог.

Чтобы разделить бизнес- и технические проблемы, на границах стека расставляют
разные \spverb|wrap-exception|. Самое нижнее оборачивает \spverb|app-naked|: оно
ловит исключения в бизнес-логике. Такую ошибку пишут в журналы максимально
подробно. На вершине стека другая, облегченная версия \spverb|wrap-exception|.
Оно подавляет технические ошибки на предварительных этапах запроса. Его задача
вернуть адекватный ответ пользователю и не засорять журнал.

\subsection{Middleware вне стека}

Интересен сценарий, когда middleware влияет только на запросы по определенному
пути. Вернемся к \spverb|wrap-auth-user-only|. В чем его недостаток? Если
добавить его в стек, анонимный пользователь не увидит ничего. Каждый запрос
будет отклонен со статусом 403. Главная страница, контактные данные, форма
входа~--- все будет недоступно. В этом нет никакого смысла.

Очевидно, \spverb|wrap-auth-user-only| должен перекрывать только некоторые
запрос. Например те, что начинаются с \spverb|/account|: \spverb|/account/cart|,
\spverb|/account/orders| и другие. Поэтому место \spverb|wrap-auth-user-only| не
в общем стеке, а ниже~--- на уровне маршрута.

Реализация зависит от того, как мы строим маршруты. В Compojure есть особое
middleware под названием \spverb|wrap-routes|. Оно принимает правило и другое
middleware. Последнее сработает только в том случае, если правило подходит к
запросу. Столь сложная логика нужна, чтобы не вызвать middleware, пока запрос не
совпадет с правилом.

Вынесем пути для аккаунта в отдельную ветку:

\begin{english}
  \begin{clojure}
(defroutes account-routes
  (with-context "/account" []
    (GET "/cart" request (account-cart request))
    (GET "/orders" request (account-orders request))
    (GET "/profile" request (account-profile request))))
  \end{clojure}
\end{english}

\noindent
Обернем ветку в проверку доступа:

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/" request (page-index request))
  (GET "/help" request (page-help request))
  (wrap-routes account-routes wrap-auth-user-only))
  \end{clojure}
\end{english}

Теперь \spverb|wrap-auth-user-only| сработает только для путей, которые
начинаются с \spverb|/account/|. На главной и справочной страницах проверки
доступа не будет.

Middleware, которое принимает middleware~--- довольно крутая абстракция. Если вы
действительно поняли, как оно работает, примите поздравления. Это серьезный
рубеж.

\section{Другие библиотеки}

Для Clojure написаны и другие фреймворки и библиотеки. Если возможностей Ring не
хватает, обратитесь к проектам ниже.

\begin{itemize}

\item
  \emph{Compojure API}\footurl{https://github.com/metosin/compojure-api}~---
  убер-надстройка над обычным Compojure. Набор макросов, чтобы описывать REST
  API. Библиотека тесно связана с JSON-схемой и Swagger.

\item
  \emph{Luminus}\footurl{https://luminusweb.net}~--- шаблон
  веб-приложения. Включает \spverb|Compojure API| для маршрутов, модуль базы
  данных, миграции и многое другое из коробки. У проекта достойная документация
  и сообщество, куда можно обратиться за помощью.

\item
  \emph{Pedestal}\footurl{https://github.com/pedestal/pedestal}~---
  альтернативный фреймворк компании Cognitect. Отличается гибкой системой
  перехватчиков (анг. \emph{interceptors}), с помощью которых строят большие
  системы.

\item
  \emph{Vase}\footurl{https://github.com/cognitect-labs/vase}~---
  экспериментальная надстройка над Pedestal. Задает обработчики в виде
  \spverb|edn|-файла. Отличается тесной интеграцией с Datomic, базой данных
  Cognitect.

\item
  \emph{Duct}\footurl{https://github.com/duct-framework/duct}~--- новый
  фреймворк от создателя Ring. Пока что проект на ранней стадии, и документации
  мало. Сделан упор на модульность и систему. О системах мы поговорим ближе к
  концу книги.

\item
  \emph{Liberator}\footurl{https://clojure-liberator.github.io/liberator/}~---
  аналог проекта Webmachine для Erlang. Запрос и ответ проходят множество
  стадий, каждую из которых можно перехватить. Предлагает сложные правила на
  базе мультиметодов.

\end{itemize}

\section{Заключение}

Перечислим, что мы узнали в этой главе.

Современный веб работает по HTTP. Это текстовый сетевой протокол на базе
TCP/IP. Обмен по HTTP проходит в две фазы: запрос и ответ. Оба они состоят из
первой строки, заголовков и тела, которого может и не быть.

Для запроса важны его метод и путь, а для ответа~--- статус. С развитием веба
появились соглашения о том, как строить HTTP API. Самое популярное из них
называется REST. Согласно ему, путь определяет сущность, а действие над ней~---
метод. Данные о сущности передают в формате JSON.

Чтобы писать веб на Clojure, установите Ring. Это набор библиотек, в которых
самое нужное: базовые абстракции, middleware и веб-сервер. Запрос и ответ
описаны словарями. Обработчик запроса это функция, которая принимает запрос и
возвращает ответ.

Роутинг не входит в поставку Ring; потребуются сторонние библиотеки. Проект
Compojure предлагает макросы, чтобы задать маршруты правилами. Библиотека Bidi
строит дерево с тегами. Чаще всего оно работает в паре с мультиметодами.

Middleware это функция, которая оборачивает другую функцию. Их цепочка
называется стеком. Проще всего задать стек стрелочным оператором. Это экономит
скобки и делает запись наглядней. Middleware нужны для предварительной обработки
запроса, например прочитать JSON-тело или проверить права доступа. Отдельные
middleware прерывают стек, если возникло исключение или запрос нельзя
обработать.

Кроме Ring, для Clojure написаны другие фреймворки. Некоторые из них повторяют
аналоги в других языках. Задача фреймворка~--- упростить труд человека и
сократить код. С опытом читатель найдет инструмент, который подходит под эти
критерии.
