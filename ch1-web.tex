\chapter{Веб-разработка}

\begin{teaser}
В первой главе мы рассмотрим, как писать веб-приложения на Clojure. Поговорим о
передаче данных по протоколу HTTP. Какие абстракции строят над протоколом и что
предлагает Clojure. Чем хорош функциональный подход и почему разработка на~нем
удобнее.
\end{teaser}

\index{организации!Cognitect}
\index{организации!StackOverflow}

Каждый год компания Cognitect
опрашивает\footurl{https://blog.cognitect.com/blog/2017/1/31/clojure-2018-results}
разработчиков на~Clojure. Среди прочего анкета спрашивает, в какой области вы
работаете. В~2010 году веб писали половина опрошенных. К~2018 году эта цифра
выросла до 80\%, что уже четыре человека из пяти. Похожую динамику показывают
опросы StackOverflow\footurl{https://insights.stackoverflow.com/survey/2018}. Согласно
им, все больше инженеров переходят в веб из смежных областей.

Если вы найд\"{е}те работу на Clojure, скорее всего это будет веб-приложение. Мы
специально не говорим <<сайт>>, потому что термин уходит в прошлое. Сегодня
веб-приложение это не только текст с картинками. В широком плане это сложный
обмен данными по HTTP.

Протокол служит для передачи разметки, но со временем подошел и для данных. Для
этого даже не пришлось менять стандарт. Причина кроется в изящном дизайне и
простоте. Прежде чем перейти к Clojure, освежим в памяти устройство
протокола: из каких частей он состоит и как с ним работает сервер. Это важно,
потому что языки и фреймворки меняются, а протокол нет.

\section{Основы HTTP}

\index{HTTP}
\index{стандарты!HTTP}

Протокол HTTP работает поверх TCP/IP. В широком смысле протокол~--- это
соглашение о том, как обмениваться данными. Обычно они записаны в официальных
документах. Для HTTP документ называется
RFC~2616\footurl{https://https://tools.ietf.org/html/rfc2616}. Программисты
сверяются с~ним, чтобы код работал на разных языках и платформах.

HTTP удобен тем, что это текст. Не нужно парсить байты, чтобы понять, что
происходит. Протокол работает и с бинарными данными, но~главные его части
остаются текстом. В HTTP различают запрос и ответ. Они состоят из трех частей:
первая строка, заголовки и тело.

Первая (стартовая) строка несет самую важную информацию. Е\"{е} формат отличается
для запроса и ответа. Для запроса это метод, путь и версия, для ответа~---
статус, сообщение и версия.

\index{HTTP!заголовки}

Заголовки это пары ключей и значений. В коде их описывают словарем. Заголовки
несут дополнительные сведения о~запросе или ответе. Например, заголовок
\spverb|Content-Type| сообщает, как читать тело запроса. Был ли это XML- или
JSON-документ? Программа сверяет заголовок и~читает тело должным образом.

\index{HTTP!тело}

После заголовков следует тело. Им может быть что угодно~--- текст, пары полей и
значений, JSON, картинка. Стандарт допускает смешанный тип,
\spverb|multipart-encoding|. Тело такого запроса состоит из ячеек, в каждой из
которых свое содержимое. Например, текст, картинка, снова текст, двоичный файл.

Рассмотрим примеры HTTP-трафика. Именно в таком виде его передают по сети. Ниже
запрос к главной странице Google по слову <<clojure>>:

\begin{english}
  \begin{http}
GET /search?q=clojure HTTP/1.1
Host: google.com
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
  \end{http}
\end{english}

\noindent
А это POST-запрос с JSON:

\begin{english}
  \begin{http}
POST /api/users/ HTTP/1.1
Host: example.com
Content-Type: application/json
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)

{
  "username": "John",
  "city": "NY"
}
  \end{http}
\end{english}

\noindent
Ответ на него:

\begin{english}
  \begin{http}
HTTP/1.1 200 OK
Date: Tue, 19 Mar 2019 15:57:11 GMT
Server: Nginx
Connection: close
Content-Type: application/json

{
  "code": "CREATED",
  "message": "A user has been created successfully"
}
  \end{http}
\end{english}

Видно, как изящно устроен протокол: данные в идут по убыванию важности.
Прочитав только первую строку, клиент и~сервер готовы принять решение о~том, что
делать дальше.

\index{HTTP!404}

Рассмотрим сценарий: в запросе указаны метод и путь \spverb|GET /about|, но
такой страницы не существует. Сервер проверит путь по таблице маршрутов. Если
его нет, получим ответ со статусом 404. Не прид\"{е}тся читать тело запроса, что
ускорит работу сервера. Клиент получит статус 404 из первой строки. Логика
клиента может быть такова, что для негативного статуса он не читает тело.

Чтение и разбор содержимого это долгая операция. Современные фреймворки не
делают этого зря. По заголовку \spverb|Content-Type| они определяют, стоит ли
читать тело. Если приложение работает только с~JSON, для \spverb|text/xml|
верн\"{е}тся ошибка. Аналогично поступают с заголовком \spverb|Content-Length|, где
указана длина тела в байтах. Если значение больше лимита, сервер отклонит запрос
до чтения.

\index{HTTP!путь}
\index{HTTP!метод}

Главные части запроса это \emph{метод} и \emph{путь}. Путь указывает на
определенный ресурс на сервере. Иногда путь означает файл относительно папки на
сервере. Например, \spverb|/images/map.jpg| ведет к файлу из
\spverb|/var/www/static|. Чаще всего путь обрабатывают внутри приложения.
Ответом может быть не только файл, но и HTML, скрипт, JSON.

Метод запроса означает действие, которые мы намерены выполнить над
ресурсом. Основные методы это \spverb|GET|, \spverb|POST|, \spverb|PUT| и
\spverb|DELETE|~--- прочитать, создать, обновить и удалить ресурс. Запрос
\spverb|POST /users/| означает создать пользователя, а \spverb|GET /users/|~---
получить их список.

Главный параметр ответа это статус~--- целое положительное число. Статусы
группируют по старшей цифре. Значения с 200 до 299 (или \spverb|2хх|) считают
положительными. Они означают, что сервер обработал запрос без ошибки.

Значения из группы \spverb|3хх| связаны с направлением на другую страницу. В
заголовке \spverb|Location| указан адрес, по которому отправляют новый
запрос. Современные браузеры и клиенты делают это автоматически. По адресу
\spverb|http://yandex.ru| получим пустой документ с заголовком
\spverb|Location: https://yandex.ru|. Разница в схеме протокола: сервер обязывает
перейти на безопасное соединение. Мы даже не заметим этого: браузер сам сменит адрес.

Статусы \spverb|4хх| означают ошибку на стороне клиента. Чаще всего это 404~---
страница не найдена. Если прислать ошибочные данные, сервер ответит
\spverb|400 Bad request|. Когда нет прав доступа, получим код 403.

Значения из группы \spverb|5хх| говорят о проблеме на стороне сервера. Чаще всего
это исключение в коде: деление на ноль, отказ базы данных, нехватка места
на~диске. Реже сервер на техобслуживании или вообще недоступен.

Принято считать, что ответ со статусом вне группы \spverb|2хх| означает
ошибку. Многие HTTP-клиенты бросают исключение на ответ с негативным статусом.
Это верно только на высоком, абстрактном уровне. С точки зрения протокола ответ
\spverb|404 Not Found| такой же правильный, как и \spverb|200 OK|.

\index{HTTP!HEAD}

Когда действий с ресурсом много, применяют другие, более редкие
методы. Например, HEAD~--- получить краткие сведения о сущности. Сервис Amazon
S3 в ответ на HEAD верн\"{е}т только статус и заголовки. В них указаны тип файла и
его размер, контрольная сумма, дата изменения. HEAD-запрос предпочитают
GET. Метаданные хранят отдельно от файла, поэтому доступ к нему быстрее, чем к
диску.

\index{веб-разработка!REST}

Подход <<метод и ресурс>> вырос в то, что сегодня называется
REST\footurl{https://restapitutorial.com}. Сторонники REST выделяют сущности и
CRUD-операции над ними (\textbf{C}reate, \textbf{R}ead, \textbf{U}pdate,
\textbf{D}elete). Считается верным подход, когда сущность задают через путь,
например \spverb|/users/1|, а операцию~--- методом. Если это запрос на
изменение, данные читают из тела с JSON. Мы не будем задерживаться на REST,
потому что это лишь свод рекомендаций, не идеальный и не единственный.

\index{веб-разработка!CRUD}

Протокол не заставляет следовать REST и другим правилам. Работайте с HTTP как
это удобно проекту. Идеальная архитектура не обещает успех, и~наоборот: успех не
значит, что под капотом все блестит.

\subsection{Фреймворк}

\index{термины!фреймворк}

Фреймворк это абстракция над HTTP. Разработчик не читает запрос по байтам
вручную~--- задачу берет на себя чужой код. Взамен мы получаем классы, чтобы
описать логику приложения. Типичный проект на Python или Java состоит из
следующих классов.

\spverb|Application| это главная сущность проекта: она группирует классы рангом
ниже. \spverb|Router| определяет, на какой обработчик подать входящий запрос~---
\spverb|Request|. Обработчик~--- это класс \spverb|Handler| с методами
\spverb|.onGet|, \spverb|.onPost| и другими. Ожидается, что он верн\"{е}т экземпляр
класса \spverb|Response|. Так устроены промышленные фреймворки: Django, Rails,
Symfony. Имена и комбинация классов отличается, но смысл прежний. Это
приложение, роутер, обработчик, запрос и ответ.

\index{фреймворки!Django}

Большие проекты делят на слои. Слой транспорта отвечает за обмен данными, слой
логики исполняет код, ничего не зная о транспорте. Одни и те же данные получают
по HTTP или из очереди задач. С таким подходом логика не зависит от транспорта,
и последний можно сменить в любой момент. На практике это работает не всегда: по
разным причинам, в том числе из-за спешки, слои перемешиваются.

Проекты на Clojure опираются на фреймворки. Принципы, о которых мы говорили
выше, справедливы и для этого языка.

\section{HTTP в Clojure}

\index{люди!James Reeves}
\index{сайты!booleanknot.com}

Разработчик Джеймс Ривз (James Reeves)\footurl{https://www.booleanknot.com/}
известен вкладом в экосистему Clojure. Нет проекта, который бы не использовал
его библиотеки. Джеймс ввел стандарт веб-разработки для Clojure на заре
языка. Стандарт опирается на несколько простых идей.

Приложения бывают сколь угодно сложными: они полагаются на сторонние сервисы,
машинное обучение, учитывают сотню фактов о клиенте. Но даже самое сложное
приложение принимает запрос и возвращает ответ, поэтому это функция. Скептики
заметят, что мысль не нова. В Django обработчик тоже бывает не классом, а
функцией. Разница в том, что обработчик~--- это ещ\"{е} не приложение. Ему не
хватает роутера, middleware и других абстракций. Функция-обработчик в других
языках это локальная возможность.

\label{http-all-function}

В Clojure приложение остается функцией на всех уровнях. Маршрут это функция,
которая принимает запрос, ищет обработчик и передает ему управление. Middleware
это тоже функция, которая дополняет приложение логикой. Каждую тяжелую
абстракцию (классы \spverb|Application|, \spverb|Router|, \spverb|Handler|) в
Clojure заменяют функцией. Это удобно, потому что в отличии от классов функции
компонуются между собой.

Другая идея в том, чтобы зафиксировать структуру запроса и ответа. Должны быть
документы (не код, а именно документы), где описаны поля и семантика. Это
напоминает протокол HTTP: спецификация упрощает код и делает его
переносимым. Два проекта на Clojure работают с одними структурами. Разработчик
учитывает спецификацию: если фреймворк следует стандарту, легче привлечь
сообщество.

\subsection{Ring}

\index{библиотеки!Ring}
\index{стандарты!Ring}

\label{ring-jetty}

Идеи воплотились в проекте Ring\footurl{https://github.com/ring-clojure/ring}.
Сегодня это стандарт веб-разработки на Clojure. Репозиторий содержит описание
запроса и ответа и базовый код для работы с ними. Прилагаются основные middleware,
об\"{е}ртка для сервера Jetty и документация.

\index{Ring!совместимость}

Со временем появился термин <<Ring-совместимость>>. Ему следуют все фреймворки
на Clojure. Ring-приложение работает на платформах Jetty, Immutant и других без
изменений в коде.

Библиотека Ring разбита на отдельные части, чтобы можно было установить только
нужное. Перечислим компоненты, которые понадобятся по ходу главы:

\begin{itemize}

\item
  \spverb|ring-core|~--- базовый набор: параметры, куки, сессии;

\item
  \spverb|ring-jetty-adapter|~--- запуск сервера из функции;

\item
  \spverb|ring/ring-json|~--- поддержка JSON.

\end{itemize}

Первое приложение мы напишем даже без библиотеки. Вот оно:

\index{Ring!приложение}

\label{first-handler}

\begin{english}
  \begin{clojure}
(defn app [request]
  (let [{:keys [uri request-method]} request]
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body (format "You requested %s %s"
                   (-> request-method name .toUpperCase)
                   uri)}))
  \end{clojure}
\end{english}

Приложение читает путь и метод запроса и формирует ответ. Его статус
положительный~--- 200. Мы выставили заголовок с типом <<простой текст>>. Поле
\spverb|:body| содержит строку, которую строим функцией \spverb|format|.

Поскольку \spverb|app| это функция, вызовем е\"{е} с запросами:

\begin{english}
  \begin{clojure}
(app {:request-method :get :uri "/index.html"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested GET /index.html"}

(app {:request-method :post :uri "/users"})
{:status 200
 :headers {"Content-Type" "text/plain"}
 :body "You requested POST /users"}
  \end{clojure}
\end{english}

Пока что это словари, и не ясно, что будет в браузере. Запустим приложение в
виде сервера. Он принимает приложение, параметры и~запускает сложный
процесс. Сервер слушает указанный порт и читает байты. Из бинарных данных
получается словарь запроса. В отдельном потоке сервер вызывает с ним
приложение. Получим словарь ответа. Сервер переводит словарь в байты и~пишет в
удаленный порт клиента. Цикл повторяется для каждого запроса.

\index{Ring!Jetty}
\index{библиотеки!Jetty}

Добавим в проект зависимости:

\begin{english}
  \begin{clojure}
[ring/ring-core "1.7.1"]
[ring/ring-jetty-adapter "1.7.1"]
  \end{clojure}
\end{english}

Запустим сервер:

\begin{english}
  \begin{clojure}
(require '[ring.adapter.jetty :refer [run-jetty]])
(run-jetty app {:port 8080 :join? true})
  \end{clojure}
\end{english}

Происходит следующее. Мы добавили в текущий модуль функцию
\spverb|run-jetty|. Она принимает приложение и словарь опций. Ключ
\spverb|join?| определяет, будет ли заблокирован текущий поток до конца работы
сервера. Если передать \spverb|false|, сервер запустится в~фоне. Чтобы
остановить его, нужно поместить результат \spverb|run-jetty| в~переменную
и~вызвать метод \spverb|.stop|:

\begin{english}
  \begin{clojure}
(def server
  (run-jetty app {:port 8080 :join? false}))

;; after a while
(.stop server)
  \end{clojure}
\end{english}

Если флаг истина как в первом случае, главный поток повиснет до тех пор, пока
сервер не выключат. прид\"{е}тся либо завершить программу, либо нажать
\spverb|Ctrl-C|. Пока сервер работает, откройте браузер по адресу
\spverb|localhost:8080|. Вы увидите строку из примера выше. Измените путь на
\spverb|/hello| или \spverb|/path/to/file.txt|. Ответ сервера изменится.

\section{Запросы и ответы}

Мы написали приложение, которое на все запросы печатает метод и путь. Кроме этих
полей, запрос содержит порт и адрес сервера, строку параметров, тип протокола,
заголовки и тело. Все вместе это неизменяемый словарь с ключами типа
\spverb|keyword|. Полное описание запроса и~ответа смотрите в репозитории на
GitHub\footurl{https://github.com/ring-clojure/ring/blob/master/SPEC}.

\index{clojure!keyword}

Здесь и далее будем писать слово \spverb|keyword| по-русски: <<кейворд>>. В
других языках тип называют токенами или тегами.

\index{HTTP!заголовки}

Обратим внимание на поля \spverb|:headers| и \spverb|:body|. Заголовки это
неизменяемый словарь, но его ключи не кейворды, а строки. Такой словарь не
работает с разбиением по \spverb|:keys|. Переменная \spverb|host| окажется равна
\spverb|nil|:

\begin{english}
  \begin{clojure}
(defn some-handler
  [request]
  (let [{:keys [headers]} request
        {:keys [host]} headers]
    ...))
  \end{clojure}
\end{english}

Чтобы извлечь заголовки правильно, используйте \spverb|:strs|:

\begin{english}
  \begin{clojure}
(defn some-handler
  [{:keys [headers]}]
  (let [{:strs [host user-agent]} headers]
    ...))
  \end{clojure}
\end{english}

\index{clojure.core!get}

\noindent
или обычный \spverb|get| со строкой:

\begin{english}
  \begin{clojure}
(get headers "host") ;; "127.0.0.1"
  \end{clojure}
\end{english}

\index{заголовки!Content-Type}

Имя заголовка всегда в нижнем регистре. В протоколе HTTP варианты
\spverb|Content-Type| и \spverb|content-type| одинаковы. Ring приводит
заголовки к нижнему регистру, чтобы избежать недоразумений.

Значения заголовков тоже строки. Даже если стандарт зада\"{е}т типы некоторым
заголовкам, Ring не выводит их. Например, \spverb|Content-Length|
передает длину тела в байтах. Современные фреймворки приводят его к числу и
помещают в отдельное поле. По умолчанию Ring не делает ничего подобного, но это
легко исправить.

Легко забыть, что ключи заголовков это строки. Так появляется ошибка, когда
вместо правильного значения приходит \spverb|nil|:

\begin{english}
  \begin{clojure}
(get headers :host) ;; nil
  \end{clojure}
\end{english}

Можно обработать заголовки, сменив тип ключей. Для одного случая это
нормально, но если это делает каждый обработчик, получается лишняя
работа. Приложение меняют так, чтобы в функцию приходили уже исправленные
заголовки. Техника называется middleware, и мы рассмотрим е\"{е} ниже.

\index{классы!InputStream}

Поле запроса \spverb|:body| опционально. Согласно HTTP тела может и не
быть. Обратите внимание на его тип: это не строка, а входящий поток~---
\spverb|java.io.InputStream|. Поток это источник данных, который читают только
раз. По умолчанию Ring не читает поток. Делать это или нет остается на ваше
усмотрение.

\index{заголовки!Content-Length}

Чтение и разбор тела это сложная операция. По заголовкам определяют тип
документа, его длину и читают нужное число байт. Из них восстанавливают данные
(JSON, XML). Результат каждого шага проверяют по разным критериям. Когда из
\spverb|Content-Length| получают число, учитывают ошибку в разборе
строки. Результат \spverb|-42| неверный, потому что число байт не может быть
отрицательным. Технически возможно послать JSON-документ, но указать тип
\spverb|text/xml|. Сервер должен быть готов к подобным сценариям.

Легче всего прочитать тело в строку функцией \spverb|slurp|:

\begin{english}
  \begin{clojure}
(defn handler [request]
  (when-let [content (some-> request :body slurp)]
    (process-content content))
  {:status 200})
  \end{clojure}
\end{english}

В современном вебе вс\"{е} меньше работают с текстом: на его место приходят данные в
виде JSON. Позже мы рассмотрим, как подружить Ring с этим форматом.

\index{Ring!тело запроса}

Ответ Ring это словарь с полями \spverb|:status|, \spverb|:headers| и
\spverb|:body|.

\begin{itemize}

\item
  \spverb|:status|~--- целое число, признак успеха или неудачи. Мы рассмотрели
  семантику статуса в начале главы.

\item
  \spverb|:headers|~--- заголовки ответа с ключами-строками:

\index{заголовки!Location}

\begin{english}
  \begin{clojure}
{:status 302
 :headers {"content-length" 0
           "location" "/new/page.html"}}
  \end{clojure}
\end{english}

\item
  \spverb|:body|~--- тело ответа. Как и в запросе, тела может не быть. Обычно
  это строка, но может быть и файл, ресурс или поток.

\end{itemize}

\section{Маршруты}

\index{Ring!маршруты}

Мы запустили приложение и проверили в браузере. На любой запрос оно выдает текст
с небольшими отличиями. На практике приложение строят из обработчиков, каждый из
которых решает узкую задачу. Входящие запросы распределяют по ним согласно
правилам. Это называется маршрутизация или роутинг.

В Clojure и Ring нет класса роутера. Его роль играет функция, которая принимает
обработчики и возвращает приложение. Оно принимает запрос и по методу и пути
подбирает нужный обработчик. Затем вызывает его с запросом и возвращает ответ.

\index{HTTP!404}

Вообразим, что адресу \spverb|/| мы бы хотели видеть название сайта, а по
\spverb|/hello|~--- приветствие. Другие адреса вернут \spverb|404 Page not found|.
Напишем обработчики:

\begin{english}
  \begin{clojure}
(defn page-index [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defn page-hello [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Hi there! Keep trying!"})

(defn page-404 [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
  \end{clojure}
\end{english}

Каждый обработчик можно запустить в виде сервера и открыть в браузере. Осталось
связать их в единое целое.

\subsection{Наивный подход}

Сделаем самое простое, что приходит в голову. Напишем обработчик, который
находит маршрут вручную. Для этого проверим путь оператором \spverb|case|:

\begin{english}
  \begin{clojure}
(defn app [request]
  (let [{:keys [uri]} request]
    (case uri
      "/"      (page-index request)
      "/hello" (page-hello request)
      (page-404 request))))
  \end{clojure}
\end{english}

Ответ функции зависит от поля запроса \spverb|:uri|. Запустите приложение в
браузере и проверьте разные адреса. Это наивный перебор, но он работает.

Недостатки функции очевидны. Мы не учитываем метод запроса: \spverb|GET /users|
и \spverb|POST /users| отличаются по смыслу. Мы сравниваем пути в лоб без учета
параметров. В правильном роутинге пути \spverb|/users/1| и \spverb|/users/99|
приходят в один обработчик, но с разным параметром \spverb|id|. Код получился
шумный. Хотелось бы задать маршруты правилами, декларативно.

Эти и другие проблемы решают библиотеки. Мы рассмотрим Compojure и Bidi. Обе
строят маршруты, но их подходы ортогональны.

\subsection{Compojure}

\label{compojure}

\index{библиотеки!Compojure}

Библиотека Compojure\footurl{https://github.com/weavejester/compojure}
предлагает макросы для описания маршрутов. Макросы похожи на таблицу правил.
Добавим зависимость в проект:

\begin{english}
  \begin{clojure}
[compojure "1.6.1"]
  \end{clojure}
\end{english}

Так выглядит приложение на Compojure. Оно чище и короче того, что мы написали
вначале.

\index{модули!compojure.core}

\begin{english}
  \begin{clojure}
(require '[compojure.core :refer [GET defroutes]])

(defroutes app
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)
  \end{clojure}
\end{english}

Разбер\"{е}мся, что получилось на выходе. Переменная \spverb|app|~--- функция,
которая принимает запрос. Мы задали е\"{е} не через \spverb|def| или \spverb|defn|,
а макросом \spverb|defroutes|. Он строит функцию-роутер и связывает е\"{е} с
переменной \spverb|app|. С макросом получается меньше кода.

После имени следуют правила. Правило это форма \tuple{метод, путь, запрос, выражение}.
Первые два правила заданы макросом \spverb|GET|. Они читаются так:
если метод равен \spverb|GET| и путь равен \spverb|"/"|, то для запроса
\spverb|request| вернуть \spverb|(page-index request)|.

Правило собирается в функцию, которая принимает запрос. Функция проверяет, что
метод и путь запроса совпадают с заданными. Если да, функция вычислит выражение
и верн\"{е}т его результат, в нашем случае \spverb|(page-index request)|.

\index{макросы!defroutes}

Макрос \spverb|defroutes| оборачивает правила в перебор. На каждом шаге он берет
очередное правило, применяет к нему запрос и оценивает результат. Первое
значение, отличное от \spverb|nil|, станет ответом к текущему запросу.

Что будет, если не подошло ни одно правило? Результат \spverb|nil| вызовет
ошибку сервера. Чтобы избежать \spverb|nil|, к правилам добавляют ещ\"{е} одно,
которое сработает всегда. Это функция \spverb|page-404|: е\"{е} результат не
зависит от запроса. Так мы гарантируем, что даже если запрос не подошел первым
двум правилам, последнее сработает всегда.

Так устроен роутинг на Compojure. Приложение разбивают на обработчики.  Их пишут
в отдельных модулях, затем с помощью макросов \spverb|GET|, \spverb|POST| и
других оборачивают в правила. Правило верн\"{е}т функцию, которая проверяет, что
метод и путь подходят. Если да, получим вызов обработчика с запросом.

\subsection{Продвинутые возможности}

Выше мы обозначили проблему: правила \spverb|GET /users/1|
и \spverb|GET /users/99| это один обработчик с параметром. Его записывают так:

\index{макросы!GET}

\begin{english}
  \begin{clojure}
(GET "/users/:id" [id :as request] (page-user request))
  \end{clojure}
\end{english}

Обратите внимание на двоеточие перед \spverb|id| и квадратные скобки в середине.
Часть пути с двоеточием означает параметр. Compojure поместит его в словарь
\spverb|params|. Страница \spverb|page-user| обратится к нему следующим образом:

\begin{english}
  \begin{clojure}
(defn page-user [request]
  (when-let [user-id (-> request :params :id)]
    (let [user (get-user-by-id user-id)
          {:keys [fname lname]} user]
      {:status 200
       :body (format "User %s is %s %s"
                     user-id fname lname)})))
  \end{clojure}
\end{english}

Условная функция \spverb|get-user-by-id| верн\"{е}т словарь пользователя по
номеру. Находим из словаря имя и фамилию и возвращаем строку.

Compojure решает проблему вложенных путей. Рассмотрим приложение для учета
товаров. По адресу \spverb|/content/order/1/view| открывается карточка
товара. Страница \spverb|/content/order/1/edit| показывает форму редактирования
этого товара. Чтобы обновить товар, нужно отправить форму по тому же пути, но
методом POST.

Очевидно, правила пересекаются. Чтобы избежать повторов, используем макрос
\spverb|context|:

\index{макросы!context}

\begin{english}
  \begin{clojure}
(context "/content/order/:id" [order-id]
  (GET  "/view" request (order-view request))
  (context "/edit" []
    (GET  "/" request (order-form request))
    (POST "/" request (order-save request))))
  \end{clojure}
\end{english}

Каждое правило в \spverb|context| наследует параметры из уровня выше. Это
значит, обработчики \spverb|order-view|, \spverb|order-form| и
\spverb|order-save| получат параметр \spverb|:order-id|.

До сих пор в качестве ответа в правилах мы писали что-то вроде
\spverb|(some-handler request)|. Иногда ответ знают заранее, поэтому нет смысла
выносить его в функцию. Рассмотрим это на примере
\spverb|healthcheck|-обработчика.

Современные приложения запускают в контейнерах и облачных сервисах. Чтобы
узнать, работает приложение или нет, специальная служба опрашивает его. Простой
способ сделать это~--- послать приложению \spverb|GET|-запрос по адресу
\spverb|/health| и проверить статус. Тело и~заголовки ответа не играют роли.

Чтобы не создавать лишний обработчик \spverb|(page-health request)|, поместим
ответ в правило:

\index{макросы!ANY}

\begin{english}
  \begin{clojure}
(ANY "/health" _ {:status 200 :body "ok"})
  \end{clojure}
\end{english}

Можно сделать ещ\"{е} проще. В Compojure предусмотрен случай, когда выражение это
строка. Она становится телом положительного ответа:

\begin{english}
  \begin{clojure}
(ANY "/health" _ "ok")
  \end{clojure}
\end{english}

\subsection{Роутинг с Bidi}

\index{организации!JUXT}
\index{библиотеки!Bidi}

Библиотека Bidi\footurl{https://github.com/juxt/bidi} строит роутинг
по-другому. Она опирается на данные~--- списки и словари. Метод состоит из
нескольких шагов.

На первом этапе объявляют дерево маршрутов. Это комбинация векторов и словарей
по особым правилам. В листьях дерева помещают теги~--- уникальные
метки. Специальная функция принимает дерево и запрос. Функция ищет ветку дерева,
которой он подходит. Если ветка нашлась, результатом будет е\"{е} тег и параметры
пути. Например, \spverb|{:route :show-user, :route-params: {:id 1}}|.

\index{middleware}

На втором этапе пишут middleware~--- промежуточный обработчик запроса. Он
принимает запрос, добавляет в него тег и передает дальше по цепочке.

На третьем этапе добавляют обработчик запроса. Это не функция, а мультиметод.
Его функция-диспатчер возвращает тег. Метод с тегом \spverb|:default| верн\"{е}т
ответ \spverb|404|, \spverb|:show-user|~--- страницу пользователя и так далее.

На первый взгляд схема кажется сложной. Но однажды настроив, е\"{е} легко
масштабировать. Чтобы сервер подхватил новый путь, в дерево добавляют ветку и
расширяют мультиметод.

\index{библиотеки!Bidi}
\index{модули!bidi.bidi}

Перепишем на Bidi пример из начала главы. Добавьте зависимость:

\begin{english}
  \begin{clojure}
[bidi "2.1.5"]                  ;; project.clj
(:require [bidi.bidi :as bidi]) ;; namespace
  \end{clojure}
\end{english}

Начнем с дерева маршрутов. Вариант с \spverb|page-index|, \spverb|page-hello| и
\spverb|page-404| выглядит так:

\begin{english}
  \begin{clojure}
(def routes
  ["/" {""      :page-index
        "hello" :page-hello
        true    :not-found}])
  \end{clojure}
\end{english}

\index{функции!match-route}

Проверим поиск пути по этому дереву. Функция \spverb|match-route| принимает
маршруты, путь и возвращает словарь с тегом:

\begin{english}
  \begin{clojure}
(bidi/match-route routes "/hello")
{:handler :page-hello}

(bidi/match-route routes "/test")
{:handler :not-found}
  \end{clojure}
\end{english}

\index{функции!match-route}

Объединим тег с запросом. Сделаем это за один шаг функцией
\spverb|match-route*|. Это альтернативная версия \spverb|match-route|, которая
принимает словарь-накопитель. Накопителем станет запрос.

\begin{english}
  \begin{clojure}
(let [request {:request-method :get
               :uri "/test"}]
  (bidi/match-route* routes (:uri request) request))

{:request-method :get
 :uri "/test"
 :handler :not-found}
  \end{clojure}
\end{english}

Видим, что \spverb|match-route*| вернула запрос, но добавила в него поле
\spverb|:handler|. Обернем этот код в middleware. Получив запрос, новый
обработчик добавит к запросу поле \spverb|handler| и вызовет исходный
обработчик.

\begin{english}
  \begin{clojure}
(defn wrap-handler [handler]
  (fn [request]
    (let [{:keys [uri]} request
          request* (bidi/match-route* routes uri request)]
      (handler request*))))
  \end{clojure}
\end{english}

Мы ещ\"{е} не касались техники middleware, но вынуждены применить е\"{е} сейчас. Ниже мы
рассмотрим в деталях, как они работают и почему так важны.

Проверим \spverb|wrap-handler| на скорую руку. Для удобства обернем функцию
\spverb|identity|, которая верн\"{е}т переданный в не\"{е} аргумент:

\begin{english}
  \begin{clojure}
(def wrapped (wrap-handler identity))
(wrapped {:request-method :get
          :uri "/hello?foo=42"})

{:request-method :get
 :uri "/hello?foo=42"
 :handler :page-hello}
  \end{clojure}
\end{english}

\index{мультиметоды!multi-handler}

Обработчик запроса это мультиметод. Его функция-диспатчер просто ключ
\spverb|:handler|.

\begin{english}
  \begin{clojure}
(defmulti multi-handler :handler)

(defmethod multi-handler :page-index
  [request]
  {:status 200
   :headers {"content-type" "text/plain"}
   :body "Learning Clojure"})

(defmethod multi-handler :not-found
  [request]
  {:status 404
   :headers {"content-type" "text/plain"}
   :body "Page not found."})
  \end{clojure}
\end{english}

Обернем \spverb|multi-handler| в middleware и получим финальное
приложение. Запустите веб-сервер и проверьте результат в браузере.

\begin{english}
  \begin{clojure}
(def app (wrap-handler multi-handler))
  \end{clojure}
\end{english}

Это был простой роутинг на Bidi. Теперь рассмотрим товары, их
просмотр и изменение. Новое дерево выглядит так:

\begin{english}
  \begin{clojure}
(def routes
  ["/" {["content/order/" :id]
        {"/view" {:get  :page-view}
         "/edit" {:get  :page-form
                  :post :page-save}}}])
  \end{clojure}
\end{english}

В этой версии листья уже не теги, а словари. Ключ каждого словаря это метод, а
значение~--- тег. Запрос \spverb|GET /content/order/1/edit| разрешается в тег
\spverb|:page-form|, а POST с таким же адресом~--- в \spverb|:page-save|.  На
этапе \spverb|wrap-handler| запрос получит поле \spverb|:route-params|.  В нашем
случая это словарь \spverb|{:id "1"}|.

\index{HTML}

Расширим мультиметод страницами. \spverb|Page-view| находит товар по номеру и
верстает его HTML-страницу. Если товара нет, вернем ответ 404 <<не найдено>>.

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-view
  [request]
  (if-let [order (some-> request :route-params
                         :id get-order-by-id)]
    {:status 200
     :headers {"content-type" "text/html"}
     :body (render-order-page {:order order})}
    response-404))
  \end{clojure}
\end{english}

Страница \spverb|:page-form| рисует форму редактирования. От \spverb|:page-view|
она отличается HTML-шаблоном. Обновление товара сложнее: нужно выбрать поля
запроса и записать их в базу. Для краткости опустим валидацию:

\begin{english}
  \begin{clojure}
(defmethod multi-handler :page-save
  [request]
  (let [{:keys [params route-params]} request
        {order-id :id} route-params
        fields [:title :description :price]
        params (select-keys params fields)
        path (format "/content/order/%s/view" order-id)]
    (jdbc/update! *db* :orders params ["id = ?" order-id])
    {:status 302
     :headers {"Location" path}}))
  \end{clojure}
\end{english}

\index{HTTP!перенаправление}

Обратите внимание: на изменение данных мы отвечаем не HTML-страницей, а
\emph{редиректом} на не\"{е}. Если страница пришла в ответ на~POST-запрос, то при
обновлении браузер снова отправит форму. Это чревато странным поведением на
сервере. Вариант с редиректом решает проблему: браузер загрузит страницу через
GET, и побочных эффектов при обновлении не будет.

\subsection{Выбор между Compojure и Bidi}

Новичку в Clojure легче начать с Compojure. У библиотеки достойная документация
с примерами. Compojure написал тот же разработчик, что и Ring. Проекты близки и
дополняют друг друга.

Маршруты Bidi сложны для понимания: они многословны и не интуитивны. В них легко
перепутать вектор и словарь. С другой стороны, логика на мультиметодах несет
преимущества. Код становится линейным, и приложение легче расширять.

Если проект небольшой, выбирайте Compojure. Когда проект сложный и маршрутов вс\"{е}
больше, рассмотрите переезд на Bidi.

\section{Middleware}

\index{middleware}

Выше мы упоминали про middleware и даже кинули пробный шар~--- написали
\spverb|wrap-route|. Теперь изучим их внимательней. Это самый важный раздел в
главе.

В переводе с английского <<middleware>> означает промежуточный слой, середина. В
программировании так называют код в роли посредника. Он приведит типы, дополняет
словари, проверяет права доступа.

\label{decorator}

\index{паттерны!декоратор}

Паттерн <<декоратор>>~--- частный случай middleware. Декоратор это функция
\spverb|А|, которая принимает функцию \spverb|B| и возвращает функцию
\spverb|C|. Говорят, что \spverb|A| декорирует \spverb|B|. В ходе работы
\spverb|C| вызывает \spverb|B|, но с изменениями. Например, дополняет входные
или выходные данные \spverb|B|.

Рассмотрим простые декораторы. \spverb|With-echo| добавляет к функции побочный
эффект: печатает аргументы и результат.

\begin{english}
  \begin{clojure}
(defn with-echo [func]
  (fn [& args]
    (apply println "The args are" args)
    (let [result (apply func args)]
      (println "The result is" result)
      result)))
  \end{clojure}
\end{english}

Вот как им пользоваться:

\begin{english}
  \begin{clojure}
(def +echo (with-echo +))
(+echo 1 2 3)
;; The args are 1 2 3
;; The result is 6
6
  \end{clojure}
\end{english}

\index{исключения}
\index{try/catch}
\index{макросы!with-catch}

\spverb|With-catch| оборачивает функцию в \spverb|try/catch|. Если произошло
исключение, результатом будет его объект.

\begin{english}
  \begin{clojure}
(defn with-catch [func]
  (fn [& args]
    (try
      (apply func args)
      (catch Throwable e
        e))))
  \end{clojure}
\end{english}

\index{языки!Python}
\index{фреймворки!Django}

Мы уже видели запрос в Ring. У него нет полей, с которыми читатель работал в
других языках. Например, классы \spverb|HttpRequest| и \spverb|flask.Request| в
Django содержит свойство \spverb|.params|. Это словарь параметров из адресной
строки или тела запроса.

По умолчанию запрос несет только базовую информацию. Почему в Ring нет столь
важных вещей? Потому что не каждое приложение в~них нуждается. Представим, что
на каждый запрос Ring парсит адресную строку и тело. Это удобно разработчику, но
замедляет код. Нет гарантии, что параметры нужны в запросе, но сервер потратит
время на их обработку.

То же самое с разобором тела: это дорогая операция. Представим, пришел большой
JSON-документ. Мы считали его, но у пользователя нет прав на запись. Нужно было
проверить права до чтения!

Middleware играет большую роль в Ring. Параметры запроса, сессии, куки, права
доступа~--- вс\"{е} это функция, которая возвращает функцию. Не прид\"{е}тся писать
все middleware с нуля: Ring содержит наиболее важные, нужно только подключить
их. Рассмотрим основные middleware и принципы их работы.

\subsection{Параметры запроса}

\label{ring-params}

\index{HTTP!параметры}

HTTP предусматривает данные в адресе. Это пары вида \spverb|"name=John&city=NY"|
после знака вопроса. Удобно, когда в коде это словарь
\spverb|{:name "John" :city "NY"}|.

Иногда параметры помещают в тело запроса. Так поступают из-за ограничения на
длину адреса и безопасности. Длина адреса не превышает 2048 байт, а на тело
запроса ограничений нет. Пароли и почтовые адреса нельзя пересылать в адресной
строке, потому что они остаются в логах и истории браузера.

\index{модули!ring.middleware.params}
\index{HTTP!параметры!строки}
\index{HTTP!параметры!тела}

Функция \spverb|wrap-params| из модуля \spverb|ring.middleware.params| меняет
обработчик следующим образом. Переданный в него запрос обретает поля:

\begin{itemize}

\item
  \spverb|:query-params|~--- словарь параметров адресной строки;

\item
  \spverb|:form-params|~--- словарь данных из тела запроса;

\item
  \spverb|:params|~--- их комбинированная версия.

\end{itemize}

Пусть \spverb|app|~--- ваше веб-приложение. Чтобы получить обернутую версию,
передайте его в \spverb|wrap-params|. Результат будет финальным приложением. На
жаргоне разработчиков это называется <<врапнуть>> (анг. \emph{wrap}~---
обернуть).

\index{middleware!wrap-params}

\begin{english}
  \begin{clojure}
(require '[ring.middleware.params :refer [wrap-params]])
(def final-app (wrap-params app))
  \end{clojure}
\end{english}

Чтобы не запутаться в именах, придерживайтесь правил. Исходное приложение
называйте \spverb|app-naked| или \spverb|app-raw| (голое, сырое), а~финальное
просто \spverb|app|.

Доработайте приложение так, чтобы оно учитывало параметры адреса. Например,
чтобы параметр who определял имя, кого приветствовать:
\spverb|/hello?who=John|. Добраться до него можно так:

\begin{english}
  \begin{clojure}
(defn page-hello [request]
  (let [who (get-in request [:params "who"])]
    ...))
  \end{clojure}
\end{english}

\index{классы!Keyword}

Обратите внимание, ключи \spverb|:params|~--- строки. Адрес это строка, и
алгоритм режет е\"{е} на части. Clojure поощряет нас к тому, чтобы ключи были
кейвордами. Исправим это. В поставке Ring ид\"{е}т middleware, которое приводит
\spverb|:params| к удобному виду. С ним ключи \spverb|:params| примут тип
\spverb|Keyword|.

\index{middleware!wrap-keyword-params}

\begin{english}
  \begin{clojure}
(require '[ring.middleware.keyword-params
           :refer [wrap-keyword-params]])
(def app (wrap-keyword-params (wrap-params app-naked)))
  \end{clojure}
\end{english}

\index{макросы!стрелочный оператор}

Теперь до \spverb|:who| можно добраться в том числе и стрелочным оператором
(threading macro):

\begin{english}
  \begin{clojure}
(get-in request [:params :who])
(-> request :params :who)
  \end{clojure}
\end{english}

\subsection{Стек middleware}

Обычное приложение включает до десяти middleware. Если обернуть их все,
получится лесенка:

\begin{english}
  \begin{clojure}
(def app
  (wrap-something-else
    (wrap-current-user
      (wrap-session
        (wrap-keyword-params
          (wrap-params app-naked))))))
  \end{clojure}
\end{english}

\index{вложенность}

Если добавить звено посередине, оно каскадом сдвинет элементы ниже. Чтобы
победить вложенность, сделаем структуру линейной. Поможет стрелочный оператор:

\index{clojure.core!->}

\begin{english}
  \begin{clojure/lines}
(def app
  (-> app-naked
      wrap-params
      wrap-keyword-params
      wrap-session
      wrap-current-user
      wrap-something-else))
  \end{clojure/lines}
\end{english}

\index{middleware!стек}

Новая запись напоминает список, поэтому е\"{е} легко поддерживать. Назывем е\"{е}
\emph{стеком} middleware.

Запись в стрелочном виде имеет особенность. Не заглядывая дальше, догадайтесь, в
каком порядке будут выполнены middleware? Правильный ответ: снизу вверх для
запроса и сверху вниз для ответа. Это станет ясно при мысленном разборе.

\index{middleware!порядок}

Сперва запрос попад\"{е}т в \spverb|wrap-something-else|. Код внутри него вызовет
обработчик, который получен из \spverb|wrap-current-user|. Обработчик внутри
него~--- результат \spverb|wrap-session| и так далее. Вершиной подъема станет
\spverb|app-naked|. В нем сработает основная логика приложения.

Теперь ответ спускается в обратном порядке. Сначала он пройдет через
\spverb|wrap-params| и \spverb|wrap-keyword-params|. Эти два middleware не
меняют ответ и просто вернут его. \spverb|Wrap-session| и
\spverb|wrap-current-user|, возможно, допишут новые заголовки.
\spverb|Wrap-something-else| сработает последним. Цикл пройден.

\index{языки!Python}

Представьте стек как восхождение в гору и спуск с не\"{е}. Похоже устроены
middleware в Django, промышленном фреймворке на Python. Их роль играют классы, а
не функции, но порядок обхода такой же.

Порядок middleware порой критичен. Некоторые из них опираются на данные из
предыдущих middleware. Рассмотрим уже знакомые \spverb|wrap-params| и
\spverb|wrap-keyword-params|. Последний ищет в запросе поле \spverb|params| и
меняет тип ключей. Разделение труда: одно middleware готовит поле, второе
улучшает его. Поэтому \spverb|wrap-keyword-params| ставят строго после
\spverb|wrap-params|.

\index{middleware!ошибки порядка}

Теперь посмотрим на форму \spverb|(def app...)| выше. В не\"{е} закралась
\emph{ошибка}. Запрос поднимается снизу вверх, поэтому
\spverb|wrap-keyword-params| на сработает раньше \coderef{4}. Он попытается
найти \spverb|:params| в запросе, но безуспешно. Далее сработает
\spverb|wrap-params| \coderef{3}. Он заполнит поле словарем из~адресной
строки. В~результате у \spverb|:params| ключи будут строками. Поменяйте
\spverb|wrap-params| и \spverb|wrap-keyword-params| местами.

Неверный порядок middleware стоит часов отладки. Но есть трюк: если два и более
middleware зависят друг от друга, можно <<схлопнуть>> их в одно целое. Функция
\spverb|comp| принимает функции и возвращает супер-функцию, которая
применяет их к аргументу. Напишем умный враппер параметров:

\index{clojure.core!comp}
\index{функции!композиция}

\begin{english}
  \begin{clojure}
(def wrap-params+ (comp wrap-params wrap-keyword-params))
  \end{clojure}
\end{english}

Разбер\"{е}мся, почему аргументы \spverb|comp| идут в таком порядке. Обозначим их
\spverb|foo| и \spverb|bar| и перепишем выражение несколько раз:

\noindent
\begin{tabular}{ @{}p{3.2cm} @{}p{3.5cm} @{}p{3.5cm} }

\begin{english}
  \begin{clojure}
(comp foo bar)
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(fn [x]
  (foo (bar x)))
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
(fn [x] (-> x
            bar
            foo))
  \end{clojure}
\end{english}

\end{tabular}

Если \spverb|x| в третьем столбике это приложение, а~ \spverb|foo| и
\spverb|bar| middleware, то вс\"{е} станет ясно. Во время запроса они работают в
обратном порядке, поэтому \spverb|foo| запустится раньше \spverb|bar|. Значит,
на месте \spverb|foo| должно быть \spverb|wrap-params|, а вместо
\spverb|bar|~--- \spverb|wrap-keyword-params|. Если подставить их в~первый
столбик, получим то, что записали вначале.

Плюс на конце означает, что это улучшенная версия \spverb|wrap-params|. Заменим
в стеке \spverb|wrap-params| и \spverb|wrap-keyword-params| на~версию с~
плюсом. Цепочка станет короче, а логика параметров поселилась в~отдельном месте.

Перечислим другие полезные middleware: куки, сессии и JSON.

\subsection{Cookie}

\index{HTTP!куки}

В HTTP куки это маленькие кусочки информации. Между сервером и браузером
соглашение о том, как хранить и передавать их. Если сервер выставил куки,
браузер запомнит их для этого сайта. В~следующий раз браузер отправит их на
сервер автоматически. Так продолжается до тех пор, пока сервер не удалит куки
или истечет их~срок жизни.

Простейший случай, когда нужны куки~--- определить, был ли уже пользователь на
сайте. В первый раз приложение ищет в запросе куки с именем
\spverb|visited|. Если их нет, сервер добавит заголовок:

\begin{english}
  \begin{http}
Set-Cookie: visited=true;
  \end{http}
\end{english}

В следующие запросы браузер добавит поле \spverb|visited=true|. Приложение
проверяет: если значение истина, клиент уже был на сайте.  Это влияет на
показ рекламы, всплывающие окна и так далее.

Технически куки это длинный заголовок, где поля и значения разделены точками с
запятой. Middleware \spverb|wrap-cookie| упрощает работу с этим заголовком. В
запросе мы получим словарь \spverb|:cookies|. В нем два уровня с именами и
атрибутами. Чтобы выслать клиенту новые куки, добавьте измененную копию словаря
в ответ. Ring построит из него заголовок \spverb|Set-Cookie|

Страница \spverb|page-seen| проверяет, видим ли мы е\"{е} в первый раз.

\index{модули!ring.middleware.cookies}

\begin{english}
  \begin{clojure}
(require '[ring.middleware.cookies
           :refer [wrap-cookies]])

(defn page-seen [request]
  (let [{:keys [cookies]} request
        seen-path ["seen" :value]
        seen? (get-in cookies seen-path)
        cookies* (assoc-in cookies seen-path true)]
    {:status 200
     :cookies cookies*
     :body (if seen?
             "Already seen."
             "The first time you see it!") }))

(def app (-> page-seen
             wrap-cookies))
  \end{clojure}
\end{english}

Замечание: переменная со звездочкой на конце означает новую версию исходной
переменной. Например, такой же словарь, но с новым ключом. Вместо звездочки
иногда ставят штрих. Переменная \spverb|cookies*| означает <<новые куки на базе
старых>>.

\index{middleware!wrap-keyword-cookie}

По аналогии с \spverb|:params| ключи куки это строки. Если поменять
\spverb|"seen"| на \spverb|:seen|, вы промахнетесь и получите \spverb|nil|. В
Ring нет аналога \spverb|wrap-keyword-cookie|; такую обертку легко написать
самому. Ниже мы покажем способ для заголовков.

Запустите приложение в браузере. После обновления страницы надпись изменится на
<<Already seen>>. Она останется даже после перезагрузки сервера, потому что флаг
хранит в браузер. Только очистив куки вы увидите <<The first time you see
it>>. Для полноты эксперимента откройте приватную вкладку или другой браузер.

\index{безопасность!HTTP}
\index{HTTP!безопасность}

Куки тесно связаны с безопасностью. Убедитесь, что они защищены от кражи и не
раскрывают секретные данные (пароли, ключи доступа). В этой главе мы не
обсуждаем веб-безопасность: тема слишком обширна и заслуживает отдельной книги.

\subsection{Сессии}

\index{HTTP!сессии}

HTTP не предполагает связи между двумя запросами. Серверу неважно, откуда они
приходят~--- с соседних машин или разных континентов. Нельзя отталкиваться от
промежутка времени: кто-то читает страницу час, а другие обновляют каждую
минуту.

Разработчики пошли на уловку. Даже если клиенты сидят в одной сети, приложение
выдаст им куки с длинной случайной строкой. Браузеры добавляют куки к запросам,
и сервер отличает клиентов. Технику назвали \emph{сессией} или \emph{сеансом}.

Под сессией понимают значения, связанные с пользователем. Например, выбранный
язык, состояние виджетов, просмотренные товары. Важно, что пользователь не
обязательно авторизован. Это может быть аноним, но сервер отличит его запросы
от~остальных.

\index{middleware!wrap-session}

\spverb|Wrap-session| это сложное middleware, которое дополняет запрос словарем
\spverb|:session|. Его ключи~--- поля сессии. Чтобы обновить сессию, е\"{е} новую
версию пишут в ответ по аналогии с куки. Middleware различает \spverb|nil| и
отсутствие сессии в ответе. Если поле \spverb|nil|, вся сессия удаляется. Если
ключа нет, ничего не происходит.

\index{базы данных!Redis}
\index{базы данных!Memcached}

Различают бэкенды сессии, способы хранить е\"{е} физически. Например, в памяти, на
диске, в базе данных, системах Memcached и Redis или даже куках. При выборе
бэкенда учитывайте, может ли он работать на~нескольких машинах одновременно. Что
получится, если каждый запрос случайно уходит на одну из десяти машин? Если
сессию хранят памяти, на каждой машине будет разная е\"{е} копия. Это чревато
странным поведением и отладкой. Аналогично с файлами~--- машины не делят их
между собой. База данных или Redis это центральное хранилище. Оно гарантирует
целостность сессии для всех клиентов.

Интересно, что сессия в куках тоже работает на многих машинах. На каждый запрос
браузер передает полную сессию в заголовках. В~этом случае е\"{е} хранит
браузер. Если пользователь очистит куки или запустит другой браузер, сессия
будет утеряна.

Ring хранит сессию в памяти или куках. Тип хранилища задают настройками
\spverb|wrap-session|. Чтобы подружить сессию с Redis или другой системой,
расширьте протокол \spverb|SessionStore|.

Рассмотрим пример со сч\"{е}тчиком посещений. Будем считать, сколько раз
пользователь зашел на сайт. Сессию храним в~памяти.

\index{модули!ring.middleware.session}

\begin{english}
  \begin{clojure}
(require '[ring.middleware.session :refer [wrap-session]])

(defn page-counter [request]
  (let [{:keys [session]} request
        session* (update session :counter (fnil inc 0))]
    {:status 200
     :session session*
     :body (format "Seen %s time(s)" (:counter session*))}))

(def app (-> page-counter
             wrap-session))
  \end{clojure}
\end{english}

Запустите приложение и откройте браузер. Обновите страницу, и~сч\"{е}тчик в
сообщении возрастет с каждым просмотром. Проделайте то же самое в другом
браузере. Это будет вторая сессия, которая не зависит от первой. Данные лежат в
памяти, поэтому они потеряются при новом запуске сервера.

\emph{Упражнение.} Выше мы считаем просмотры для всего сайта. Сделайте так,
чтобы сч\"{е}тчик работал в разрезе страниц. Например, главную страницу \spverb|/|
смотрели пять раз, а справку \spverb|/help|~--- три раза. Параметры запроса не
влияют на подсчет.

\subsection{JSON}

\index{форматы!JSON}
\index{clojure.core!eval}

Формат JSON служит для передачи данных. Он различает базовые типы: числа,
строки, логический тип и коллекции любой вложенности. Это значимый плюс по
сравнению с INI или XML, где все значения строки. JSON совместим с
JavaScript. Если передать строку в функцию \spverb|eval|, она верн\"{е}т данные~---
комбинацию списков и словарей. Эти и~другие причины сделали формат
популярным. Сегодня JSON это главный способ передать данные в вебе.

Ring предлагает несколько middleware для JSON. Для удобства их~поместили
в~отдельную библиотеку. Добавьте зависимость:

\begin{english}
  \begin{clojure}
[ring/ring-json "0.4.0"]
  \end{clojure}
\end{english}

\index{middleware!wrap-json-response}
\index{HTTP!JSON}

Middleware \spverb|wrap-json-response| упрощает возврат JSON-данных. Оно
проверяет поле ответа \spverb|:body|: Если это коллекция, его заменяют на
кодированную строку и добавляют заголовок \spverb|Content-Type: application/json|.

Рассмотрим API для чтения пользователя. Если нашли его по номеру, вернем словарь
полей. Если нет, в ответе будет структура ошибки. В обоих случаях не нужно
кодировать данные вручную~--- это делает \spverb|wrap-json-response|.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.json
           :refer [wrap-json-response]])

(defn page-data [request]
  (let [user-id (-> request :params :id)]
    (if-let [user (get-user-by-id user-id)]
      {:status 200 :body user}
      {:status 404
       :body {:error_code "MISSING_USER"
              :error_message "No such user"
              :error_data {:id user-id}}})))

(def app (-> page-data
             wrap-params+
             wrap-json-response))
  \end{clojure}
\end{english}

Для входящего JSON служат два middleware: \spverb|wrap-json-body|
и~\spverb|wrap-json-params|. Оба проверяют, что заголовок \spverb|Content-Type|
равен \spverb|application/json|. Если заголовок верный, они парсят тело с учетом
возможных исключений. При ошибке разбора получим статус 400 и текст <<JSON body
malformed>>.

Разница между middleware в том, куда они складывают
данные. \spverb|Wrap-json-body| заменяет поле \spverb|:body| запроса на
структуру данных. Ниже обработчик \spverb|page-body| извлекает имя и город из
\spverb|:body|. Тело запроса уже не входящий поток, а словарь. Обратите
внимание, middleware принимает дополнительные параметры. Флаг \spverb|:keywords? true|
означает, что ключи словаря станут кейвордами.

\begin{english}
  \begin{clojure}
(require '[ring.middleware.json :refer [wrap-json-body]])

(defn page-body [request]
  (let [{:keys [body]} request
        {:keys [username city]} body]
    (create-user username city)
    {:status 200
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-body
             (wrap-json-body {:keywords? true})))
  \end{clojure}
\end{english}

\index{утилиты!cURL}
\index{HTTP!POST}

Чтобы отправить JSON серверу, понадобится специальная программа. Это может быть
утилита \spverb|cURL| или графическое приложение
Postman\footurl{https://www.postman.com/}. Пример с \spverb|cURL|:

\begin{english}
  \begin{bash}
curl --request POST \
     --header "Content-Type: application/json" \
     --data '{"username":"John","city":"NY"}' \
     http://localhost:8080/
  \end{bash}
\end{english}

\subsection{Проблемы слияния}

\spverb|Wrap-json-params| работает с небольшим отличием. Оно пишет данные в поле
\spverb|:json-params|. Если пришел словарь, он дополняет
\spverb|:params|. Объясним, в чем разница.

Поле \spverb|:params| это общий аккумулятор параметров. Его наполняют и другие
врапперы, например \spverb|wrap-params|. Чаще всего нам неважно, откуда пришли
параметры: из адресной строки, тела или JSON. В код мы просто черпаем данные из
\spverb|:params|.

В других случаях важно, чтобы параметры не смешивались и не заменяли друг
друга. Чтобы прочесть только те данные, что пришли в JSON, обратимся к полю
\spverb|:json-params| или \spverb|:body|. Каким враппером пользоваться, зависит
от конкретного случая.

\index{middleware!wrap-json-params}

Вспомним, что \spverb|:params| это словарь с ключам-строками. Чтобы слияние
прошло правильно, \spverb|wrap-json-params| оставляет ключи строками. Исправьте
ключи с помощью \spverb|wrap-keyword-params| после разбора JSON.

Разработчики не случайно выделяют поле \spverb|:json-params|. Данные в JSON не
обязательно словарь: это может быть массив, который нельзя объединить со
словарем. На этот случай данные хранят в отдельном поле.

Пример, когда клиент передает данные гибридно: \spverb|username| в JSON и
\spverb|city| в параметрах строки. Обратите внимание на стек middleware. Сначала
парсят параметры адреса \coderef{12}, затем тело \coderef{11}. Оба словаря
оседают в \spverb|:params|. После накопления исправляют тип ключей \coderef{10}.

\begin{english}
  \begin{clojure/lines}
(defn page-params [request]
  (let [{:keys [params]} request
        {:keys [username city]} params]
    (create-user username city)
    {:status 201
     :body {:code "CREATED"
            :message "User created"}}))

(def app (-> page-params
             wrap-keyword-params
             wrap-json-params
             wrap-params
             wrap-json-response))
  \end{clojure/lines}
\end{english}

\noindent
Пример такого запроса:

\begin{english}
  \begin{bash}
curl --request POST \
     --header "Content-Type: application/json" \
     --data '{"username":"John"}' \
     http://localhost:8080/?city=NY
  \end{bash}
\end{english}

Из-за того, что поля приходят из разных источников, может возникнуть
путаница. Избегайте случаев, когда в \spverb|:params| валится вс\"{е} подряд. При
работе над API читайте один источник: \spverb|:query-params| для GET,
\spverb|:form|- или \spverb|:json-params| для POST.

\subsection{Свои middleware}

\index{middleware!пользовательские}

До сих пор мы использовали наработки из Ring и смежных библиотек. Рано или
поздно вам потребуются свои middleware. Рассмотрим примеры из реальных проектов.

\subsubsection*{Ключи заголовков}

\index{HTTP!заголовки}

Враппер обновляет заголовки запроса~--- меняет тип ключей со строк на
кейворды. Для этого служит функция \spverb|keywordize-keys| из пакета
\spverb|clojure.walk|. Заголовкам меняют тип когда приложение часто к ним
обращается.

\index{модули!clojure.walk}
\index{функции!keywordize-keys}

Если в заголовки ответа добавить кейворд, сервер бросит исключение. Адаптер
Jetty ожидает строки, и произойдет ошибка типов. Для ответа добавьте обратное
действие: измените ключи с кейвордов на строки. Задачу решает функция
\spverb|stringify-keys|.

\index{функции!stringify-keys}

\begin{english}
  \begin{clojure}
(require '[clojure.walk :refer
           [keywordize-keys stringify-keys]])

(defn wrap-headers-kw [handler]
  (fn [request]
    (-> request
        (update :headers keywordize-keys)
        handler
        (update :headers stringify-keys))))
  \end{clojure}
\end{english}

Внутри \spverb|handler| приложение работает с заголовками как с кейвордами. По
аналогии можно сменить тип ключей для куки.

\subsubsection*{Идентификатор запроса}

\index{классы!UUID}
\index{идентификатор!HTTP}
\index{идентификатор!UUID}
\index{HTTP!идентификатор}
\index{заголовки!X-Request-Id}

По умолчанию запрос и ответ не связаны друг с другом. Порой трудно понять, к
какому запросу относится данный ответ и наоборот. Мы увидели в логах ответ с
кодом 500, но какой именно запрос вызвал ошибку? Важно, чтобы система могла их
сопоставить.

Для этого ввели заголовок \spverb|X-Request-Id|. Чаще всего это случайный
идентификатор (UUID), строка из 36 символов. Для краткости его называют <<айди>>
(анг. id). Если клиент не передал id в запросе, ему назначат случайный. Тот же
id вернут в ответе. Его пишут в лог, чтобы построить цепочку событий.

\index{middleware!wrap-request-id}

Напишем обертку для id. Заголовки это кейворды, потому что выше по стеку
\spverb|wrap-headers-kw|.

\begin{english}
  \begin{clojure}
(import 'java.util.UUID)

(defn wrap-request-id [handler]
  (fn [request]
    (let [uuid (or (get-in request [:headers :x-request-id])
                   (str (UUID/randomUUID)))]
      (-> request
          (assoc-in [:headers :x-request-id] uuid)
          (assoc :request-id uuid)
          handler
          (assoc :request-id uuid)
          (assoc-in [:headers :x-request-id] uuid)))))
  \end{clojure}
\end{english}

\index{clojure.core!get-in}
\index{clojure.core!assoc}
\index{clojure.core!dissoc}

Id хранят в заголовках, но дублируют в запросе и ответе в поле
\spverb|:request-id|. К нему часто обращаются в логах, поэтому удобно вынести в
переменную в начале функции:

\index{логирование!HTTP}

\begin{english}
  \begin{clojure}
(defn some-handler [request]
  (let [{:keys [params request-id]} request]
    (log/info "Request id: %s" request-id)))
  \end{clojure}
\end{english}

\subsubsection*{Текущий пользователь}

\index{HTTP!пользователь}
\index{пользователь!HTTP}

Этот враппер добавляет в запрос текущего пользователя. В данном случае мы ищем
его номер в сессии. Если номер найден, читаем пользователя из базы и добавляем к
запросу. Функция \spverb|get-user-by-id| верн\"{е}т словарь или \spverb|nil|. Чтобы
не передать \spverb|nil|, вызов оборачивают в условие \spverb|(when user-id)|.

\index{middleware!wrap-current-user}

\begin{english}
  \begin{clojure}
(defn wrap-current-user [handler]
  (fn [request]
    (let [user-id (-> request :session :user-id)
          user (when user-id
                 (get-user-by-id user-id))]
      (-> request
          (assoc :user user)
          handler))))
  \end{clojure}
\end{english}

\index{безопасность!сессия}
\index{HTTP!безопасность}

К вопросу о безопасности: номер пользователя \emph{можно} хранить в сессии. Она
подписана секретным ключом, поэтому только сервер знает, как е\"{е} изменить. Номер
пользователя не раскрывает приватные данные. Но не храните в сессии пароли и
ключи доступа.

\subsection{Прерывание стека}

\index{middleware!прерывание}

До сих пор мы работали с цепочкой middleware, где каждое звено передает
управление следующему. Цепь не всегда линейна: иногда е\"{е} нужно прервать. В одном
из middleware мы поняли, что у пользователя нет прав. Продолжать не имеет
смысла: наоборот, как можно скорее оборвем стек.

\index{HTTP!400}

Middleware часто содержат условия. Например, \spverb|wrap-json-params| читает
тело только если заголовок \spverb|Content-Type| равен
\spverb|application/json|. Когда тип другой, враппер ничего не делает. Разбор
JSON бросит исключение, документ составили неправильно или он повредился из-за
сбоя в сети. В этом случае \spverb|wrap-json-params| не продолжает цепочку. Он
верн\"{е}т ответ <<400 JSON body malformed>>, и ни одно middleware ниже по стеку не
сработает.

Пусть приложение доступно только по авторизации. С~помощью
\spverb|wrap-current-user| получим текущего пользователя. Это middleware только
находит пользователя, но не ограничивает доступ. Добавим ещ\"{е} одно:

\index{middleware!wrap-current-user}
\index{middleware!wrap-auth-user-only}
\index{HTTP!авторизация}

\begin{english}
  \begin{clojure}
(defn wrap-auth-user-only [handler]
  (fn [request]
    (if (:user request)
      (handler request)
      {:status 403
       :headers {"content-type" "text/plain"}
       :body "Please sign in to access this page."})))
  \end{clojure}
\end{english}

Переход к следующему middleware под условием. Если пользователь не
авторизован, звенья ниже \spverb|wrap-auth-user-only| будут отброшены.

Мы уже говорили, что цепочка middleware это восхождение и спуск с горы. Если
звено терпит неудачу, мы как будто срезаем верхушку. Словно добрались до
середины, столкнулись с проблемой и повернули обратно. \emph{Общее правило:} чем
раньше мы обнаружим проблему, тем меньше потратим ресурсов. Поэтому более общие
проверки ставят выше по стеку (или ниже в операторе \arr).

\index{ошибки!HTTP}

Ещ\"{е} один вариант с развилкой~--- перехват ошибок. Это важный обработчик, но его
нет в поставке Ring, потому что реакция на ошибки зависит от многих
факторов. Враппер копируют из проекта в проект с небольшими изменениями.

Что случится, если при обработке запроса возникнет исключение? На этот счет нет
четких правил: каждый фреймворк ведет себя по-разному. Один покажет стек-трейс в
браузере, другой верн\"{е}т HTML с информацией для отладки. Разработчики третьего
посчитали, что показывать эти данные небезопасно. Исключение пишут в~лог, а
клиенту вернут нейтральную фразу об ошибке.

Полезно, когда мы сами определяем, что делать с исключением. Ниже middleware,
которое ловит ошибку, пишет е\"{е} в лог и возвращает ответ-заглушку:

\index{middleware!wrap-exception}

\begin{english}
  \begin{clojure}
(defn wrap-exception [handler]
  (fn [request]
    (try
      (handler request)
      (catch Throwable e
        (let [{:keys [uri
                      request-method]} request]
          (log/errorf e "Error, method %s, path %s"
                      request-method uri)
          {:status 500
           :headers {"content-type" "text/plain"}
           :body "Sorry, please try later."})))))
  \end{clojure}
\end{english}

\index{логирование!HTTP}

Выражение \spverb|log/errorf| это макрос для записи ошибки. Он принимает
исключение, шаблон и параметры. Важно знать, какие были метод и путь запроса,
поэтому запишем их тоже. Это облегчит анализ логов в будущем.

Чем выше \spverb|wrap-exception| в стеке, тем меньше у исключения шансов
просочиться. В идеале оно стоит на вершине цепочки, чтобы ловить все
исключения.

Иногда используют двойной перехват. Ошибки в разных частях системы заслуживают
разного подхода. Об ошибках в бизнес-логике важно знать вс\"{е}. Если пользователь
не смог купить товар, мы запишем его номер и данные, которые вызвали ошибку. Но
если пришел поврежденный JSON, это техническая проблема, не связанная с
бизнесом. Исключение здесь это норма, потому его не пишут в лог.

Чтобы разделить бизнес- и технические проблемы, на границах стека расставляют
разные \spverb|wrap-exception|. Самое нижнее оборачивает \spverb|app-naked|: оно
ловит исключения в бизнес-логике. Такую ошибку пишут в журнал максимально
подробно. На вершине стека другая, облегченная версия \spverb|wrap-exception|.
Оно подавляет технические проблемы на предварительных этапах. Его задача вернуть
адекватный ответ и не засорять журнал.

\subsection{Middleware вне стека}

\index{middleware!вне стека}

Интересен сценарий, когда middleware влияет на запросы по определенному пути. В
чем недостаток \spverb|wrap-auth-user-only|? Если добавить его в стек, анонимный
пользователь не увидит ничего: каждый запрос завершится с кодом 403. Главная
страница, контактные данные, форма входа~--- вс\"{е} будет недоступно.

Очевидно, проверка должна касаться части запросов. Например тех, что начинаются
с \spverb|/account|: \spverb|/account/cart|, \spverb|/account/orders| и
других. Место \spverb|wrap-auth-user-only| не в общем стеке, а ниже~--- на
уровне маршрута.

Реализация зависит от того, как мы строим маршруты. В Compojure предлагает
middleware под названием \spverb|wrap-routes|. Оно принимает правило и другое
middleware. Последнее сработает только в том случае, если правило подходит к
запросу. Столь сложная логика нужна, чтобы не вызвать middleware, пока запрос не
совпадет с правилом.

Вынесем пути для аккаунта в отдельную ветку:

\begin{english}
  \begin{clojure}
(defroutes account-routes
  (with-context "/account" []
    (GET "/cart" request (account-cart request))
    (GET "/orders" request (account-orders request))
    (GET "/profile" request (account-profile request))))
  \end{clojure}
\end{english}

\noindent
Обернем е\"{е} в проверку доступа:

\begin{english}
  \begin{clojure}
(defroutes app
  (GET "/" request (page-index request))
  (GET "/help" request (page-help request))
  (wrap-routes account-routes wrap-auth-user-only))
  \end{clojure}
\end{english}

\index{функции!wrap-routes}

Теперь \spverb|wrap-auth-user-only| сработает только для путей, которые
начинаются с \spverb|/account/|. На главной и справочной страницах проверки
доступа не будет.

Middleware, которое принимает middleware~--- довольно крутая абстракция. Если вы
поняли, как оно работает, примите поздравления. Это серьезный рубеж.

\section{Другие библиотеки}

Для Clojure написаны и другие фреймворки и библиотеки. Если возможностей Ring не
хватает, обратитесь к проектам ниже.

\begin{itemize}

\index{библиотеки!Compojure API}
\index{организации!Metosin}
\index{JSON}
\index{стандарты!Swagger}
\index{веб-разработка!Swagger}

\item
  \emph{Compojure API}\footurl{https://github.com/metosin/compojure-api}~---
  убер-надстройка над обычным Compojure. Набор макросов, чтобы описать REST
  API. Библиотека тесно связана с JSON-схемой и Swagger.

\index{библиотеки!Luminus}
\index{сайты!luminusweb.net}

\item
  \emph{Luminus}\footurl{https://luminusweb.net}~--- шаблон
  веб-приложения. Включает \spverb|Compojure API| для маршрутов, модуль базы
  данных, миграции и многое другое из коробки. У проекта достойная документация
  и сообщество, куда можно обратиться за помощью.

\index{библиотеки!Pedestal}
\index{организации!Cognitect}

\item
  \emph{Pedestal}\footurl{https://github.com/pedestal/pedestal}~--- фреймворк
  компании Cognitect. Отличается гибкой системой перехватчиков
  (анг. \emph{interceptors}), с помощью которых вложенную логику задают линейно.

\index{библиотеки!Vase}
\index{организации!Cognitect}
\index{базы данных!Datomic}
\index{форматы!EDN}

\item
  \emph{Vase}\footurl{https://github.com/cognitect-labs/vase}~---
  экспериментальная об\"{е}ртка над Pedestal. Задает логику в файле EDN. Тесно
  связан с Datomic, базой данных Cognitect.

\index{библиотеки!Duct}

\item
  \emph{Duct}\footurl{https://github.com/duct-framework/duct}~--- новый
  фреймворк от создателя Ring. Проект на ранней стадии, и документации
  мало. Делает упор на модульность и систему компонентов \page{chapter-systems}.

\index{библиотеки!Liberator}
\index{языки!Erlang}
\index{мультиметоды}

\item
  \emph{Liberator}\footurl{https://clojure-liberator.github.io/liberator/}~---
  аналог проекта Webmachine для Erlang. Запрос и~ответ проходят множество
  стадий, на каждую из которых можно задать реакцию. Предлагает систему правил
  на базе мультиметодов.

\end{itemize}

\section{Заключение}

Перечислим, что мы узнали в этой главе.

Современный веб работает по HTTP. Это текстовый протокол на базе TCP/IP. Обмен
по HTTP проходит в две фазы: запрос и~ответ. Оба состоят из первой строки,
заголовков и тела, которого может и не быть.

Для запроса важны его метод и путь, а для ответа~--- статус. С развитием веба
появились соглашения о том, как строить HTTP API. Самое популярное называется
REST. Согласно ему, путь определяет сущность, а действие над ней~---
метод. Данные передают в~формате JSON.

Чтобы писать веб на Clojure, установите Ring. Это набор библиотек, в которых
самое нужное: базовые абстракции, middleware и веб-сервер. Обработчик запроса
это функция, которая принимает запрос и возвращает ответ. Обе сущности~---
словари.

В поставке Ring нет маршрутов; потребуются сторонние библиотеки. Compojure
предлагает макросы, чтобы задать маршруты правилами. Bidi строит дерево с
тегами. С ним работают в паре с мультиметодом.

Middleware это функция, которая оборачивает другую функцию. Их цепочка
называется стеком. Удобно задать стек стрелочным оператором: это экономит скобки
и делает запись наглядней. Middleware нужны для предварительной обработки
запроса: прочитать JSON из тела или проверить права доступа. Отдельные middleware
прерывают стек, если возникло исключение или запрос нельзя обработать.

Кроме Ring, для Clojure написаны другие фреймворки. Некоторые из них повторяют
аналоги в других языках. Фреймворк диктует структуру проекта и упрощает труд
человека.
