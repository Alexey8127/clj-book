\chapter{Тесты в Clojure}

\label{chapter-tests}

\begin{teaser}
В последней главе мы поговорим о тестировании приложений. Читатель узнает, что
такое тесты и каких видов они бывают. Избежим лишней сложности: опустим термины
вроде <<TDD>> и <<BDT>>. Покажем, что в~Clojure легко писать и поддерживать
тесты.
\end{teaser}

\section{Основные понятия}

На тему тестов написали много книг и статей, придумали методологии. Их
сторонники отстаивают позиции в вечных спорах. Начинающих сбивает с толку
множество терминов и мнений. Поможем читателю погрузиться в тему: расскажем о
тестах простыми словами.

Тест~--- это код, который проверяет другой код. Напишем функцию для перевода
температуры из Цельсия в Фаренгейты:

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.8) 32))
  \end{clojure}
\end{english}

Мы вызвали ее несколько раз убедились, что результаты такие же, как в
справочнике. Зафиксируем расчеты в функции проверки. Она сравнивает вызов
\spverb|->fahr| с каноничными значениями. Их посчитали заранее и расценивают как
эталон.

\begin{english}
  \begin{clojure}
(defn test-fahr []
  (assert (= (int (->fahr 20)) 68))
  (assert (= (int (->fahr 100)) 212)))
  \end{clojure}
\end{english}

Примечание: в тесте мы сравниваем результат \spverb|->fahr| с целым числом. Без
обертки в \spverb|(int ...)| функция вернет число с плавающей запятой, которое
трудно сравнить с другим таким же числом. Поэтому значение приводят к целому.

Макрос \spverb|assert| бросит исключение, если тело вычисляется в ложь. Пока что
\spverb|(test-fahr)| вернет \spverb|nil| без ошибок. Если изменить расчеты,
получим ошибку:

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (+ (* cel 1.9) 32))

(test-fahr)
;; Assert failed: (= (int (->fahr 20)) 68)
  \end{clojure}
\end{english}

Функция \spverb|test-fahr| и есть тест. Она проверяет, что код \spverb|->fahr|
не изменили так, что получится другой результат. В наших интересах вызвать
\spverb|(test-fahr)| перед сборкой программы. Так мы не допустим, чтобы код с
ошибкой попал в производство.

Тест не знает устройство функции, которую проверяет. Мы вправе менять алгоритм
до тех пор, пока тест выполняется без ошибок. Предположим, мы тестируем функцию
факториала. В первой версии мы линейно умножаем числа, что неэффективно. Но уже
на этой стадии добавим тест, что $5! = 120$. Если заменить линейный алгоритм на
дерево или таблицу значений, тест пройдет без ошибок. В противном случае новый
алгоритм содержит ошибку.

\subsection{Кейсы и покрытие}

Близкие по семантике тесты объединяются в \emph{кейсы}. Вспомним школьную задачу
с квадратным уравнением: найти корни по заданным коэффициентам $a$, $b$,
$c$. Особенность в том, что логика задачи ветвится. В зависимости от параметров
может быть два корня, один или ни одного.

\begin{english}
  \begin{clojure}
(defn square-roots [a b c]
  (let [D (- (* b b) (* 4 a c))]
    (cond
      (pos? D) [(/ (+ (- b) (Math/sqrt D)) (* 2 a))
                (/ (- (- b) (Math/sqrt D)) (* 2 a))]
      (zero? D) (/ (- b) (* 2 a))
      (neg? D) nil)))
  \end{clojure}
\end{english}

Чтобы проверить алгоритм, тест вызывает функцию \spverb|square-roots| минимум
три раза. Подберем параметры так, чтобы сработала каждая ветка. Еще лучше, если
на каждую ветку приходится отдельный тест, чтобы расширить их в будущем. Тесты
ниже образуют кейс, который проверяет алгоритм целиком.

\begin{english}
  \begin{clojure}
(defn test-square-roots-two-roots []
  (let [[x1 x2] (square-roots 1 -5 6)]
    (assert (= [3 2] [(int x1) (int x2)]))))

(defn test-square-roots-one-root []
  (let [x (square-roots 1 6 9)]
    (assert (= -3 (int x)))))

(defn test-square-roots-no-roots []
  (assert (nil? (square-roots 2 4 7))))
  \end{clojure}
\end{english}

В объектно-ориентированных языках кейсы это классы, а тесты~--- их методы. В
Clojure тест это функция, а роль кейса играет пространство.

В тестах часто упоминают \emph{покрытие}. Под этим словом имеют в виду долю
кода, которая сработала в тесте. Предположим, мы написали тест только для двух
корней. В этом случае ветки \spverb|(zero? D)| и \spverb|(neg? D)| не
сработают. Фреймворк считает общее число строк и сколько из них
выполнились. Покрытие это отношение второй величины к первой, число от нуля до
единицы. Некоторые библиотеки строят отчет, где выполненные строки отмечены
зеленым (плюсом), а пропущенные красным (минусом). Подсчет покрытия это трудная
задача, поэтому ее выносят в расширение фреймворка.

\begin{english}
  \begin{diff}
+(defn square-roots [a b c]
+  (let [D (- (* b b) (* 4 a c))]
+    (cond
+      (pos? D) [(/ (+ (- b) (Math/sqrt D)) (* 2 a))
+                (/ (- (- b) (Math/sqrt D)) (* 2 a))]
-      (zero? D) (/ (- b) (* 2 a))
-      (neg? D) nil)))
  \end{diff}
\end{english}

В функции \spverb|square-roots| всего семь строк. При запуске теста сработали
пять из них. Покрытие составит 5/7, что приблизительно 71\%. Принято считать,
что покрытия 80\% достаточно для того, чтобы код работал надежно. Значения ниже
говорят о малом покрытии. Это значит, в проекте встречается код, который не
защищен от спонтанных изменений. При попытке приблизиться к 100\% тесты
становятся затратными в поддержке. В каждом проекте придерживаются той величины,
которая удобна процессу.

Величина в процентах не должна затмевать здравый смысл. В примере выше цифра
71\% кажется большой только на первый взгляд. Из покрытия видно, что мы
проверяем только одну ветку алгоритма из трех. Если в двух других ошибки, мы не
узнаем о них. При оценке покрытия смотрят не на проценты, а на развилки
алгоритма. Надежный тест гарантирует, что сработала каждая ветка.

\subsection{Не только числа}

У начинающих складывается мнение, что тесты пишут только для математических
расчетов. Это не так: тесты подходят для всех действий, которые хотят
зафиксировать. Это может быть обход коллекции, криптография, поиск в тексте.

Рассмотрим подпись HTTP-запроса. Функция \spverb|sign-params| принимает словарь
параметров и секретный ключ. Алгоритм подписи следующий:

\begin{itemize}

\item
  отсортировать параметры по ключам;

\item
  составить строку \spverb|param1=value1&param2=value2...|;

\item
  экранировать некоторые символы: пробел, плюс, процент и другие;

\item
  получить сигнатуру строки по алгоритму HMAC-SHA256 и секретному ключу;

\item
  вернуть словарь параметров с полем \spverb|:signature|.

\end{itemize}

Так работает авторизация в популярных сервисах. Напишем тест для функции
подписи. Проверим, что входные параметры дополнены сигнатурой, которую посчитали
заранее.

\begin{english}
  \begin{clojure}
(defn test-sign-params []
  (let [api-key "2Ag48&@%776^634Tsdf23"
        params {:action :postComment
                :user_id 42
                :post_id 1999
                :comment "This is a great article!"}
        signature "e36b331823b..."]
    (assert (= (assoc params :signature signature)
               (sign-params params api-key)))))
  \end{clojure}
\end{english}

Заметим, что \spverb|sign-params| работает не с числами, а коллекциями и
криптографией. Это не помешало написать для нее тест. Чтобы улучшить нашу
работу, добавьте проверку на пустой ключ, экранирование символов, кириллицу,
эмодзи и так далее.

\subsection{Что тестировать}

Иногда разработчики не понимают, какие функции нужно проверить, и тестов не
хватает. Бывает и другая крайность: тесты пишут строго для каждой функции. Это
приводит к их избыточности и замедляет разработку. Верное решение, как всегда,
посередине.

Тестируйте действия, которые атомарны с точки зрения логики. Подпись запроса
состоит из мелких функций: сортировки, экранирования и других. Если проверять
каждую из них, получится слишком много кода. Позже алгоритм поменяют, а тесты
станут не нужны. И наоборот, когда тестируют огромный пласт кода, трудно понять,
почему возникла ошибка. Тест становится хрупким: малейшее изменение рушит
его. Крупные тесты разбивают на несколько поменьше.

Подробнее на вопрос отвечает пирамида
тестов\footurl{https://martinfowler.com/bliki/TestPyramid.html}. Это модель, где
тесты разделены на слои. Чем выше слой, тем б\'{о}льшую часть логики он
покрывает. Говорить о пирамиде преждевременно; мы вернемся к ней ближе к концу
главы.

\subsection{О чистоте функций}

Функцию удобно тестировать, если у нее нет побочных эффектов. Это значит,
функция не обращается к диску, сети и глобальным переменным. Результат зависит
только от входных параметров.

Представим, функция читает файл. Перед запуском теста мы пишем файл в нужное
место, а потом удаляем его. Тест усложняется, ведь теперь он зависит от
окружения. Чтобы облегчить тестирование, функцию разделяют на две: первая читает
содержимое файла и передает во вторую. До исправления:

\begin{english}
  \begin{clojure}
(defn process-csv [path]
  (let [content (slurp path)]
    (for [line (clojure.string/split content #"\n")]
      (remap-line line))))
  \end{clojure}
\end{english}

\noindent
и после:

\begin{english}
  \begin{clojure}
(defn process-csv-content [content]
  (for [line (clojure.string/split content #"\n")]
    (remap-line line)))

(defn process-csv [path]
  (process-csv-content (slurp path)))
  \end{clojure}
\end{english}

Напишем тест для \spverb|process-csv-content|. Не придется писать файл на диск:
функция принимает строку, которую объявим тут же.

\begin{english}
  \begin{clojure}
(def CONTENT
  (str "Ivan;ivan@test.ru;http://example.ru"
       \newline
       "John;john@test.com;http://example.com"))

(assert (= [{:name "Ivan" :email ...}
            {:name "John" :email ...}]
           (process-csv-content CONTENT)))
  \end{clojure}
\end{english}

Другой способ в том, чтобы заменить функцию на мультиметод. Его реализация
зависит от первого аргумента. Если это файл, читаем его и вызываем мультиметод
со строкой. Для строки запускаем ее разбор.

Чистая функция это идеальный случай тестирования. Промышленный код трудно
изолировать от побочных эффектов, а иногда это невозможно. Чтобы тестировать код
с эффектами, прибегают к расширенным практикам: используют заглушки (стабы),
меняют объекты в рантайме (моки). Мы рассмотрим эти и другие приемы ниже.

Подмена среды это вынужденная мера, и к ней прибегают в последнюю
очередь. Сначала проверьте, можно ли выделить в коде чистую часть. Если да,
создайте отдельную функцию и тестируйте ее.

\subsection{Производство}

Тесты не только проверяют логику, но и помогают на разных стадиях
производства. Ветку с изменениями нельзя слить в мастер до тех пор, пока не
пройдут тесты. Так вы обезопасите код от случайных изменений.

Если разработчик добавил код без тестов, это снизит долю покрытия. Можно задать
правило, что при покрытии ниже порога слияние запрещено. Сервисы GitHub,
CircleCI и другие гибко реагируют на ошибки в тестах. Они шлют письма, пишут
сообщения в Slack, всячески сигналят о проблеме.

Иногда тесты заменяют документацию. В открытых проектах ее компенсируют тестами,
потому что на качественный текст уходит столько же времени, сколько на
разработку. Если вы не уверены, как работает функция, возможно, ее поведение
прояснится в тесте.

\subsection{Устройство тестов}

Функции с макросом \spverb|assert| это лишь приближение. Они пригодятся на
раннем этапе, когда автор только обозначил контуры программы. Для полноценных
тестов понадобится фремворк~--- библиотека, которая определяет, где и как писать
тесты.

Если выполнить команду \spverb|lein test| в папке проекта, запустится тестовый
фреймворк. Это сложный цикл из нескольких шагов. Мы рассмотрим основные из них,
чтобы читатель понял устройство.

На первом этапе фреймворк ищет тесты в коде проекта. По-другому фаза называется
\emph{test discovery}. Каждый найденный тест попадает в глобальный регистр.

Тест должен носить признак, которым он отличается от обычной функции. В примере
выше \spverb|test-sign-params| это именно функция, а не тест (префикс
\spverb|test-| ни на что не влияет). Далее мы рассмотрим, как превратить ее в
тест.

Когда тесты найдены, система определяет, какие из них вызвать. Если не заданы
фильтры, сработают все тесты. Иногда нужно выполнить их подмножество по имени
или тегу. В этом случае происходит отбор тестов.

На этапе прогона фреймворк выполняет тесты один за другим как функции. Система
фиксирует их количество и имена. Тест обернут в \spverb|try/catch|, чтобы
исключение не оборвало процесс. Каждая проверка попадает в накопитель. Эти
сведения необходимы, чтобы построить отчет.

На этапе отчета система выводит данные в консоль. Отчет должен быть понятен
человеку. Проблемные тесты обозначены красным цветом. Для неудачных сравнений
ожидают полные формы, а не финальные значения. Например,
\spverb|(= (int (->fahr 20)) 68)| вместо \spverb|(= 69 68)|.

Фреймворки выводят отчет в разных форматах. Кроме консоли это может быть файл
HTML. Систему настраивают так, что отчет публикуется на внутреннем сервере по
адресу \spverb|/<project>/<artifact>/tests.html|. Часть \spverb|<artifact>| это
имя ветки или хэш коммита.

Стандарт XUnit определяет, как записать отчет в XML-файл. Системы вроде TeamCity
и CircleCI понимают, как показать его в удобном виде. У вас могут быть тесты на
Python, JavaScript или Clojure, но если прогон запущен с флагом \spverb|--xunit|
(или подобным), отчеты будут похожи.

Это был поверхностный обзор того, как работает тестовый фреймворк. Далее мы
рассмотрим, как управлять им на каждом этапе.

\subsection{Типы тестов}

Прежде чем писать тесты, разберемся каких видов они бывают. Возможно, читатель
слышал термины <<юнит>>, <<интеграционные>> и другие. На первый взгляд это
излишняя классификация. На практике тесты из разных категорий отличаются стилем,
окружением и запуском.

Понятие <<юнит-тест>> происходит от английского <<unit>>, модуль. Термин пришел
из мира Java и фреймворка JUnit. Согласно ему, тесты группируют по модулям. На
каждый модуль приходится одноименный тестовый, который проверяет первый.

\textbf{Юнит-тесты} фиксируют логику приложения. Это базовые, самые необходимые
тесты. Юнит-тестирование поощряет чистые функции. Чем меньше требований к их
окружению, тем они удобней в поддержке. Юнит-тесты проверяют приложение по
частям (но не разом). Примеры выше были юнит-тестами.

\textbf{Интеграционные тесты} решают проблему, с которой не справляются
юнит-тесты. Даже если отдельные части проверены, это не значит, что они
согласованы друг с другом. Рассмотрим регистрацию на сайте. Это сложный процесс
из нескольких шагов:

\begin{itemize}

\item
  проверить, что почта еще не занята;

\item
  создать временную учетную запись;

\item
  сгенерировать ссылку для подтверждения записи;

\item
  отправить письмо с ссылкой;

\item
  по клику на ссылку проверить, что она не подделана и не устарела;

\item
  активировать учетную запись.

\end{itemize}

Интеграционные выполняют в среде, максимально приближенной к реальности. Это
главное отличие от юнит-тестов: в одном случае окружение сужают, во втором
расширяют. Их труднее организовать из-за обширного состояния. Если выполнить
тест повторно, пользователь уже будет в базе данных, и сценарий не пройдет.

Ошибки в интеграционных тестах требуют расследования. Юнит-тесты выводят отчет,
где четко указано, какое выражение не равно чему. В интеграционных тестах
причина чаще всего не ясна. После отправки формы мы ожидаем текст с просьбой
проверить почту, но он не появился. Была ли это ошибка на сервере? Пользователь
уже существует? Не заполнили обязательное поле? Может, текст изменился, и
селектор его не находит? Ответ требует внимания человека.

Чтобы проверить проект под нагрузкой, прибегают к \textbf{нагрузочному тестированию}.
Приложению посылают запросы и фиксируют метрики: время ответа,
число запросов, сколько из них параллельны, потребление процессора и
памяти. По этим данным строят отчеты и графики.

Нагрузочное тестирование находит медленные части в проекте. С помощью него
проверяют, насколько <<фича>> готова к запуску. Если боевой сервер
выдвет сто запросов в секунду, а новый раздел только двадцать, его
отправят на доработку.

К другим категориям относятся Smoke-, Sanity-, регрессионные тесты и другие. Мы
не ставим цель рассмотреть их все. В этой главе изучим юнит- и интеграционные
тесты. К концу книги читателю хватит знаний, чтобы разобрать другие методы
самостоятельно.

\section{Тесты в Clojure}

Познакомимся с тестовым фреймворком Clojure. Напишем тесты, которые отвечают его
требованиям. За основу возьмем функции Фаренгейта и квадратного уравнения,
которые написали выше.

Пусть функция \spverb|->fahr| находится в модуле \spverb|src/book/util.clj|.
Создайте файл \spverb|test/book/util_test.clj| с кодом:

\begin{english}
  \begin{clojure}
(ns book.util-test
  (:require [book.util :refer [->fahr]]
            [clojure.test :refer [deftest testing is]]))

(deftest test-fahr
  (is (= (int (->fahr 20)) 68))
  (is (= (int (->fahr 100)) 212)))
  \end{clojure}
\end{english}

Получился тестовый модуль. Он импортирует \spverb|->fahr| и объявляет тест
\spverb|test-fahr|. Макросы \spverb|is| и \spverb|deftest| приходят из пакета
\spverb|clojure.test|. Это тестовый фреймворк из поставки Clojure.

Эти шесть строк несут новую информацию. У читателя появятся резонные
вопросы. Почему тесты лежат в папке \spverb|test|, а не \spverb|src|? Разве не
логично хранить тесты рядом с тем, что они проверяют? Как система найдет их?
Почему тест объявляют макросом \spverb|deftest|? Автор утверждал, что тест это
функция, или это не так? Зачем было менять \spverb|assert| на \spverb|is|?

Это правильные вопросы, ответим на них по порядку.

В Clojure разделяют код приложения и тестов. Приложение находится в папке
\spverb|src|, а тесты в \spverb|test|. У подхода несколько
преимуществ. Во-первых, код делится на смысловые части. Чтобы найти неисправный
тест, мы сужаем область поиска до папки \spverb|test|, а не ищем по всему
проекту. Во-вторых, когда тесты отделены, снижается риск, что они попадут в
скомпилированный файл. В этом нет смысла, потому что тесты запускают только в
разработке. Мы напрасно увеличим время сборки и объем файла.

Во время тестов проект запускается с особым параметром. Он определяет, где еще
кроме \spverb|src| искать код. Это список, в котором по умолчанию
\spverb|"src"|. В режиме тестов система добавляет к нему путь
\spverb|"test"|. Когда компилятор ищет файлы, он по очереди обходит пути из
списка. Позже мы рассмотрим, как настроить пути под нужды проекта.

Фреймворку нужен признак, чтобы отличить тест от обычной функции. Макрос
\spverb|deftest| объявляет функцию и сообщает ей метаданные с полем
\spverb|:test|. Чтобы найти тесты, фреймворк сканирует модули и читает
метаданные каждой переменной. Если среди полей есть \spverb|:test|, переменная
считается тестом.

Заметим, что \spverb|deftest| не позволит задать аргументы теста. Это сделано
нарочно: в Clojure тест не зависит от внешних данных. Если тесту нужно особое
окружение, его задают фикстурами. Мы рассмотрим в фикстуры в отдельном разделе.

Макрос \spverb|is| отличается от \spverb|assert| побочными
эффектами. \spverb|Assert| это чистое сравнение: получим либо \spverb|nil|, либо
исключение. Макрос \spverb|is| ведет учет, сколько раз и с какими аргументами
его вызвали. Позже из этих данных фреймворк строит отчет. Например, покажет все
выражения, которые не прошли проверку.

Мы только написали тест, но не запустили его. Clojure предлагает несколько
способов сделать это.

\subsection{Командная строка}

Самый простой вариант~--- поручить прогон тестов утилите. Если проект основан на
Leiningen\footurl{https://leiningen.org}, запустите команду \spverb|lein test|.
Потребуется время, чтобы считать код из папок \spverb|src| и \spverb|test|,
найти тесты и выполнить их. Вы увидите следующий отчет:

\begin{english}
  \begin{text}
lein test book.util-test
Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
  \end{text}
\end{english}

Clojure группирует тесты по пространствам имен. Под каждым пространством
информация о том, сколько выполнено тестов (объявлений \spverb|deftest|) и
проверок (вызовов \spverb|is|). У нас один тест \spverb|test-fahr| с двумя
\spverb|is|.

Выражение \spverb|lein test book.util-test| напечатано для того, чтобы его можно
было скопировать и запустить в терминале. Тогда сработают тесты только из модуля
\spverb|book.util-test|.

Фреймворк различает \emph{failures} и \emph{errors}. Failure (анг. <<неудача>>)
это ложное утверждение. Если сравнение в \spverb|is| вернуло ложь, счетчик
\spverb|failures| увеличится на единицу. Каждая неудача помнит о том, с какими
параметрами ее запустили. Если была хотя бы одна неудача, получим отчет об
ошибке.

Откройте функцию \spverb|->fahr| и измените коэффициент 1.8 на 1.9. Сохраните
файл и выполните \spverb|lein test|:

\begin{english}
  \begin{text}
$ lein test
lein test :only book.util-test/test-fahr

FAIL in (test-fahr) (util_test.clj:6)
expected: (= (int (->fahr 20)) 68)
  actual: (not (= 70 68))

lein test :only book.util-test/test-fahr

FAIL in (test-fahr) (util_test.clj:7)
expected: (= (int (->fahr 100)) 212)
  actual: (not (= 222 212))

Ran 1 tests containing 2 assertions.
2 failures, 0 errors.
Tests failed.
  \end{text}
\end{english}

Отчет показывает два \spverb|failures|, что верно: макрос \spverb|is|
встречается дважды. Обе проверки неверны, потому что опираются на неисправный
\spverb|->fahr|. Для каждого случая показаны исходное выражение и результат.

Выражение с \spverb|:only| выполнит только указанный тест. Это полезно, когда вы
работаете над участком кода и запускаете тест много раз.

\begin{english}
  \begin{bash}
lein test :only book.util-test/test-fahr
  \end{bash}
\end{english}

Errors это не пойманные исключения, которые случились во время работы
теста. Чаще всего ошибки возникают, когда в функцию подают неверные
данные. Представим, мы решили проверить \spverb|->fahr| с \spverb|nil|. Добавим
второй тест:

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (is (nil? (->fahr nil))))
  \end{clojure}
\end{english}

Отчет будет другим:

\begin{english}
  \begin{clojure}
$ lein test
lein test :only book.util-test/test-fahr-nil

ERROR in (test-fahr-nil) (Numbers.java:3849)
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException: null
 at clojure.lang.Numbers.multiply (Numbers.java:3849)
    ... ;; truncated

Ran 2 tests containing 3 assertions.
0 failures, 1 errors.
Tests failed.
  \end{clojure}
\end{english}

Вызов \spverb|(->fahr nil)| приводит к \spverb|NullPointerException|. Фреймворк
оборачивает тест в \spverb|try/catch| и запоминает исключение. Для ошибок отчет
выводит их стек-трейс. Выше мы сократили его для экономии места.

Иногда мы ожидаем, что функция бросит исключение при определенных
параметрах. Макрос \spverb|is|, записанный в особой форме, выражает это
утверждением. Мы рассмотрим пример с исключениями позже.

\subsection{REPL}

Код на Clojure работает быстро, но его загрузка занимает от трех до десяти
секунд. Точное время зависит от библиотек, объема кода и оборудования. Даже если
вы запускаете один тест, проект включается с нуля, что неэффективно.

Когда вы работаете с проектом, скорее всего, вы подключены к REPL. Удобно
выполнить тест прямо в REPL, не запуская новый проект. Издержки на загрузку
станут равны нулю.

Наивный способ выполнить тест~--- запустить его как функцию. Выражение
\spverb|(test-fahr)| вернет \spverb|nil|, что означает, что утверждения
сработали верно. Теперь добавим в тест ошибку:

\begin{english}
  \begin{clojure}
(is (= (int (->fahr 20)) 999))
  \end{clojure}
\end{english}

Если сохранить файл и вызвать \spverb|(test-fahr)|, \emph{по-прежнему} получим
результат без ошибок. Так происходит, потому что мы только сохранили файл, но не
загрузили изменения в память. То, как изменения в файле перетекают в REPL,
зависит от окружения.

Если это Emacs и CIDER, выполните одно из действий. Переместите курсор за
последнюю скобку формы \spverb|(deftest test-fahr...)| и нажмите \spverb|C-c C-e|.
Сработает команда \spverb|cider-eval-last-sexp|, которая выполнит последнее S-выражение.

Другой способ в том, чтобы выполнить на сервере весь буфер. Независимо от того,
где сейчас курсор, нажмите \spverb|C-c C-k| (или \spverb|M-x cider-eval-buffer <RET>|).
Команда равносильна тому, чтобы скопировать буфер, вставить в REPL и нажать ввод.

После обновления вызов \spverb|(test-fahr)| вернет \spverb|nil|, но в консоли
появятся строки:

\begin{english}
  \begin{clojure}
FAIL in (test-fahr) (util_test.clj:14)
expected: 68
  actual: (999)
  \end{clojure}
\end{english}

Если вызвать тест \spverb|(test-fahr-nil)|, который все еще не исправен, увидим
исключение:

\begin{english}
  \begin{clojure}
ERROR in (test-fahr-nil) (Numbers.java:3849)
expected: (nil? (->fahr nil))
  actual: java.lang.NullPointerException: null
 at clojure.lang.Numbers.multiply (Numbers.java:3849)
    book.util$__GT_fahr.invokeStatic (form-init3606582116051051694.clj:5)
    ... ;; truncated
  \end{clojure}
\end{english}

Это только вывод в консоль, а не брошенное исключение. Макрос \spverb|deftest|
оборачивает тело в \spverb|try/catch|.

Когда тест запускают как функцию, не работают фикстуры. Это обработчики, которые
готовят среду для теста. О фикстурах мы поговорим позже; пока что отметим, что
функция \spverb|test-vars| выполняет тесты с учетом фикстур. Она принимает
вектор объектов \spverb|Var|:

\begin{english}
  \begin{clojure}
(require '[clojure.test :refer [test-vars]])
(test-vars [#'test-fahr #'test-fahr-nil])
  \end{clojure}
\end{english}

Функция \spverb|run-test| запускает все тесты пространства (текущего или
указанного). Технически она сводится к \spverb|test-vars| со всеми переменными
пространства:

\begin{english}
  \begin{clojure}
(require '[clojure.test :refer [run-tests]])
(run-tests)
  \end{clojure}
\end{english}

Еще одна функция \spverb|run-all-tests| из выполняет тесты для всех загруженных
пространств:

\begin{english}
  \begin{clojure}
(require '[clojure.test :refer [run-all-tests]])
(run-all-tests)
  \end{clojure}
\end{english}

Запустив это выражение, вы увидете, как фреймворк перебирает загруженные модули:

\begin{english}
  \begin{text}
Testing clojure.test
Testing clojure.core.server
Testing clojure.core.specs.alpha
Testing book.util
...
  \end{text}
\end{english}

Чтобы отбросить лишнее, в \spverb|run-all-tests| передают регулярное выражение.
Чтобы выполнить только наши тесты, укажем, что имя модуля начинается с book:

\begin{english}
  \begin{clojure}
(run-all-tests #"$book")
  \end{clojure}
\end{english}

\subsection{Emacs и CIDER}

Модуль CIDER\footurl{https://github.com/clojure-emacs/cider} для Emacs упрощает
работу с тестами. CIDER предлагает команды и комбинации клавиш, чтобы выполнить
один или несколько тестов. Он показывает отчет об ошибках в отдельном
буфере. Вызвать тест клавишей удобнее, чем печатать команду в REPL.

Чтобы запустить один тест, поместите на него курсор и нажмите \spverb|C-c C-t t|
(или \spverb|M-x cider-test-run-test|). Курсор может быть в любом месте
\spverb|(deftest ...)|. Если тест прошел без ошибок, внизу появится зеленый
текст, иначе откроется буфер \spverb|*cider-test-report*|.

Буфер выводит отчет в удобной форме. Ошибки в утверждениях подсвечены красным
цветом, а непойманные исключения желтым. Буфер интерактивен: если подвести
курсор к блоку с ошибкой и нажать Enter, соседний буфер покажет исходный код. То
же самое для исключений: чтобы не засорять отчет, CIDER показывает только класс
и сообщение. По Enter открывается отдельный буфер со стек-трейсом.

Перечислим другие полезные команды:

\begin{itemize}

\item
  \spverb|cider-test-rerun-failed-tests| (\spverb|C-c C-t f|) выполнит только
  неудачные тесты из прошлого запуска. Полезно, чтобы не ждать весь прогон
  снова.

\item
  \spverb|cider-test-run-ns-tests| (\spverb|C-c C-t n|) выполнит тесты для
  заданного пространства. Чтобы сопоставить пространство и тесты, CIDER
  добавляет к имени \spverb|-test|. Например, для \spverb|book.util| тестовый
  модуль получится \spverb|book.util-test|.

\end{itemize}

Запуск тестов это рутина. Чтобы не терять время, изучите, как это сделать из
редактора или IDE.

\section{Полезные практики}

Тесты это тоже код, и ему нужна поддержка. Небрежность в тестах несет столько же
проблем, сколько и в приложении. Приемы ниже сделают тесты удобней в чтении и
поддержке.

\subsection{Testing}

Макрос \spverb|testing| оборачивает тело строкой. Это сообщение о том, что мы
собираемся делать:

\begin{english}
  \begin{clojure}
(deftest test-square-roots
  (testing "Two roots"
    (let [result (square-roots 1 -5 6)]
      (is (= (mapv int result) [3 2]))))
  (testing "One root"
    (is (= (square-roots 1 6 9) -3)))
  (testing "No roots"
    (is (nil? (square-roots 2 4 7)))))
  \end{clojure}
\end{english}

Сообщение важно по двум причинам: визуальной и технической. Оно разбивает код на
логические блоки, заменяет комментарии, делает тест понятнее. Если утверждение
не сработало, в отчете будет сообщение, в которое оно обернуто.

Макросы \spverb|testing| могут быть вложенными. Каждое сообщение наращивает
последнее через пробел. Тест ниже проверяет, что API \spverb|createUser| вносит
пользователя в базу. Дополнительно мы убеждаемся, что пароль в базе
зашифрован. Если отбросить основной код, получим скелет из форм
\spverb|testing|:

\begin{english}
  \begin{clojure}
(deftest test-some-api
  (testing "API call" ...
    (testing "HTTP response" ...))
  (testing "DB checks:" ...
    (testing "common user fields" ...)
    (testing "password is hashed" ...)))
  \end{clojure}
\end{english}

\subsection{Исключения}

Мы все еще не разобрались, как тестировать код с исключениями. Хотелось бы
убедиться, что вызов \spverb|(->fahr nil)| бросит ошибку, а не вернет
\spverb|nil|. Если проверки нет, код не защищен от таких изменений:

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (when cel
    (+ (* cel 1.8) 32)))
  \end{clojure}
\end{english}

В этом случае \spverb|nil| провалится ниже по стеку вызовов, что усложнит поиск
причины.

Пример с \spverb|try/catch| решает проблему лишь отчасти. В таком виде
\spverb|(is true)| действительно сработает. Если заменить \spverb|(->fahr nil)|
на \spverb|(->fahr 1)|, то исключения не произойдет, и тело \spverb|(catch...)|
будет отброшено. Если исключение ожидают, но его нет, это тоже ошибка.

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (try
    (->fahr nil)
    (catch NullPointerException e
      (is true))))
  \end{clojure}
\end{english}

Макрос \spverb|(is (thrown?...))| решает эту проблему. Форма \spverb|thrown?|
принимает класс исключения и произвольное тело. Если брошено исключение этого
класса (с учетом наследования), внешний \spverb|is| сработает
положительно.

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (is (thrown? NullPointerException
               (->fahr nil))))
  \end{clojure}
\end{english}

Когда исключения не было, получим ошибку в утверждении. Исправьте \spverb|nil|
на любое число и убедитесь, что тест не проходит.

Иногда проверки на класс недостаточно. В больших участках кода \spverb|NPE|
возникает на разных уровнях. Если кто-то изменит \spverb|->fahr| так, что она
вернет \spverb|nil|, ошибка переедет в другое место. Это приводит к ложному
тестированию: на самом деле происходит не то, что ожидают.

\begin{english}
  \begin{clojure}
(let [temp-cel nil]
  (+ 1 (->fahr temp-cel)))
  \end{clojure}
\end{english}

Проблему решают двумя шагами. Первый~--- исправить функцию так, чтобы она
бросила что-то более осмысленное, чем \spverb|NPE|. Подойдет специальное
исключение \spverb|IllegalArgumentException|. Его дополняют сообщением о том,
что именно не так:

\begin{english}
  \begin{clojure}
(defn ->fahr [cel]
  (if cel
    (+ (* cel 1.8) 32)
    (throw (new IllegalArgumentException
            "Fahrenheit temperature should be a real number"))))
  \end{clojure}
\end{english}

Второй шаг~--- убедиться, что исключение пришло именно из \spverb|->fahr|. Форма
\spverb|(is (thrown-with-msg?...))| проверяет, что текст исключения совпадает с
регулярным выражением. Тест ниже покрывает эти требования:

\begin{english}
  \begin{clojure}
(deftest test-fahr-nil
  (is (thrown-with-msg?
       IllegalArgumentException #"Fahrenheit temperature"
       (->fahr nil))))
  \end{clojure}
\end{english}

\subsection{Пакетная проверка}

Вспомним, как выглядит \spverb|test-fahr|:

\begin{english}
  \begin{clojure}
(deftest test-fahr
  (is (= (int (->fahr 20)) 68))
  (is (= (int (->fahr 100)) 212)))
  \end{clojure}
\end{english}

Оба \spverb|is| отличается только числами. Чтобы добавить новую проверку,
придется копировать одну из форм. Подход с копированием раздувает код и в целом
выходит боком. Очевидно, из похожих \spverb|(is...)| можно выделить постоянную
часть и переписать тест.

Макрос \spverb|are| (анг. множественная форма <<is>>) выполняет несколько
\spverb|is| по шаблону. Он принимает форму связывания, шаблон и аргументы. Число
аргументов должно быть кратно переменным из формы связывания. На каждом шаге
макрос связывает часть аргументов с переменными и выполняет шаблон:

\begin{english}
  \begin{clojure}
(deftest test-fahr
  (are [f c] (= (int (->fahr f)) c)
    20 68
    100 212))
  \end{clojure}
\end{english}

Аргументы записывают столбиком по принципу одна строка~--- один
\spverb|is|. Выше \spverb|f| и \spverb|c| означают цифры по Фаренгейту и
Цельсию, то есть исходное и ожидаемое значения. Выражение \spverb|(int (->fahr f))|
переехало в шаблон, поэтому нет смысла копировать его.

Макрос \spverb|are| удобен для небольших выражений. Со временем он становится
трудным в поддержке. В этом случае тест переписывают на \spverb|doseq|, который
пробегает по данным.

Предположим, мы тестируем API для создания пользователя. Один из тестов
проверяет входные параметры. Мы ожидаем негативный ответ для случаев, когда нет
обязательного поля или оно в неверном формате. В переменную \spverb|params-ok|
запишем правильные параметры:

\begin{english}
  \begin{clojure}
(def params-ok {:name "John Smith" :email "john@test.com"})
  \end{clojure}
\end{english}

Для негативных случаев объявим вектор \spverb|params-variations|. Он состоит из
пар \tuple{словарь, текст}. Словарь это измененные параметры, которые
мы добавим к \spverb|params-ok| функцией \spverb|merge|. Текст это сообщение с
описанием проблемы: неверная почта, слишком длинное имя и так далее.

\begin{english}
  \begin{clojure}
(def params-variations
  [[{:name nil} "Empty name"]
   [{:name (apply str (repeat 999 "A"))} "Name is too long"]
   [{:email "dunno"} "Wrong email"]
   [{:email nil} "No email"]
   [{:extra 42} "Extra field"]])
  \end{clojure}
\end{english}

Тест пробегает по \spverb|params-variations|. На каждом шаге он вызывает
\spverb|api-create-user| с испорченными параметрами. Обратите внимание, что
вызов обернут в \spverb|testing| с сообщением. Если на одном из шагов
утверждение не сработает, мы узнаем причину из отчета.

\begin{english}
  \begin{clojure}
(deftest test-api-create-user-bad-params
  (testing "Sending bad parameters"
    (doseq [[params* description] params-variations]
      (testing description
        (let [params (merge params-ok params*)
              response (api-create-user params)
              {:keys [status]} response]
          (is (= 400 status)))))))
  \end{clojure}
\end{english}

Когда тест разделяет данные и проверку, его легко поддерживать. Если в API
появятся новые поля, расширим \spverb|params-variations|, не меняя тест.

\subsection{Именование}

Начинайте имя теста с префикса \spverb|test-|. С точки зрения Clojure это
необязательно: фреймворк ищет тесты по метаданным, а не имени. Выражения
останутся функцией и тестом даже если их назвали наоборот.

\begin{english}
  \begin{clojure}
(defn test-if-suspended [user]) ;; func
(deftest is-suspended)          ;; test
  \end{clojure}
\end{english}

Префикс необходим для навигации по коду. В модуле может быть больше тестов, чем
умещается на экран. Вперемешку с тестами идут переменные и функции. С ростом
модуля станет трудно понять, где функция, а где тест. С префиксом ошибки быть не
может.

Emacs навигация работает командой \spverb|imenu| и ее улучшенной версией
\spverb|helm-imenu|. При вызове команды открывается буфер со списком
определений. С вводом текста в буфере останутся только те элементы, которые его
содержат. Называйте определения так, чтобы по команде \spverb|M-x helm-imenu <RET> test|
в списке остались только тесты.

В общем случае имя тест называют по правилу \spverb|test-<what>-<case>|, где
\spverb|<what>| означает что мы тестируем, а \spverb|<case>|~---
сценарий. Например, \spverb|test-create-user-ok| означает, что создают
пользователя и ожидают успех. Имя \spverb|test-create-user-bad-params| говорит о
попытке создать пользователя с неверными параметрами. От теста
\spverb|test-user-login-signature-expired| ожидают, что пользователь не смог
войти в систему, потому что подпись устарела.

\subsection{Порядок аргументов}

Необычный вопрос: как писать правильно, \spverb|(is (= 200 status))| или
\spverb|(is (= status 200))|? На первый взгляд это абсурд: неужели равенство
зависит от порядка? Значения либо равны, либо нет. Но макрос \spverb|is|
сложнее, чем мы думаем. Он разбивает форму \spverb|(= 200 status)| на ожидаемую
и фактическую части. По-английски они называются <<expected>> и <<actual>>.

Ожидаемое это число или коллекция, которую посчитали заранее. Фактическое значение~---
то, на которое тест вышел самостоятельно, вызвав функцию. Число 68 это ожидаемое,
а \spverb|(int (->fahr 20))|~--- действительное. Статус 200 это ожидаемое,
а \spverb|(:status response)|~--- действительное.

Разделение нужно для отчетов. Когда значения не равны, хотелось бы видеть, где
мы ошиблись. Предположим, что в отчете написано: \spverb|failed (= 200 403)|.
Как это понимать? Ожидали успешный ответ, но не хватило прав? Или это брешь в
безопасности~--- ожидали, что прав на страницу нет, но пользовать ее увидел?
Если же написано <<expected 200, got 403>>, то все ясно~--- это первый случай,
когда не хватило прав.

Правило: ожидаемое стоит на первом месте, а действительное на втором. Пишите
\spverb|(is (= 200 status))| вместо \spverb|(is (= status 200))|. Это непривычно
и противоречит здравому смыслу. Как правило, фактическое это число, а
действительное~--- выражение, поэтому хочется записать их как слева. Увы,
придется побороть себя и писать как справа:

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{clojure}
;; wrong
(= (int (->fahr 20)) 68)
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
;; correct
(= 68 (int (->fahr 20)))
  \end{clojure}
\end{english}

\end{tabular}

Правило уходит корнями в прошлое. Фреймворк JUnit утвердил именно такой порядок
в методах сравнения\footurl{https://junit.org/junit5/docs/current/user-guide/}.
Хорошо это или плохо, судить поздно~--- принцип <<expected слева>> стал
стандартом. Аналогично работают тесты в Python, Ruby и других языках. Отдельные
фреймворки предлагают модули, чтобы <<перестать говорить как Йодо>>, что значит
поменять семантику аргументов. Это возможно и в Clojure, но сейчас мы не будем
углубляться в детали.

Особенность expected и actual видна при запуске тестов в CIDER. Один и тот же
тест проверяет статус ответа на 200. Пока все хорошо, нет разницы, в каком
порядке идут аргументы. В случе ошибки вариант слева вносит путаницу. Согласно
ему, нормальным считается статус 404, а не 200. Вариант справа выводит статусы
правильно.

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{clojure}
;; wrong
(is (= status 200))

Fail in test-...
expected: 404
  actual: 200
    diff: - 404
          + 200
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
;; correct
(is (= 200 status))

Fail in test-...
expected: 200
  actual: 404
    diff: - 200
          + 404
  \end{clojure}
\end{english}

\end{tabular}

\section{Фикстуры}

До сих пор мы работали с простыми тестами. Они запускаются в любой момент,
потому что не зависят от ресурсов. Так бывает не всегда: чем сложнее код, тем
больше у него требований к базе данных, файлам и сети. Все вместе это называется
окружением теста.

Рассмотрим, как сообщить тесту его окружение. Для этого служат фикстуры. Термин
означает стенд, на котором испытывают изделие. В программировании фикстура это
объект или функция, которая работает до или после теста. Фикстура готовит
окружение и очищает его.

Перечислим случаи, когда фикстуры полезны.

\textbf{Файлы на диске.} Код, который мы тестируем, ищет в заданной папке файл с
данными. Фикстура пишет в нее файл и удаляет после теста. Подход гарантирует,
что на диске не останется следов после работы.

\textbf{Данные в базе.} Чтобы проверить авторизацию, в базу вносят пользователя
с известным паролем. Пригодятся и другие данные: профиль, друзья, история
заказов. Фикстура пишет данные в базу и после очищает таблицы, чтобы не повлиять
на следующий тест.

\textbf{Запуск и остановка системы.} Иногда фикстура управляет глобальным
состоянием программы. Например, для интеграционного теста нужны все компоненты
системы (сервер, база, почта). Запуск и остановку системы логично поместить в
фикстуру.

Мы рассмотрим и другие сценарии, когда прибегают к фикстурам. Пока что
разберемся, как они устроены технически.

Фикстура это функция, которая принимает тест. Функция выполняет любые действия,
в том числе вызывает тест. Вопрос в какой момент его вызывать остается на ваше
усмотрение.

\begin{english}
  \begin{clojure}
(def db {:dbtype "postgres" :dbname "book"
         ;; other JDBC fields
         })

(defn fix-db-data [t]
  ;; purge tables
  (jdbc/execute! db "truncate users cascade;")
  (jdbc/execute! db "truncate orders cascade;")
  ;; add data
  (jdbc/insert! db :users user-data)
  (jdbc/insert! db :profile profile-data)
  ;; execute the test
  (t))
  \end{clojure}
\end{english}

В этом примере мы сначала готовим окружение, а затем вызываем тест. Бывает и
наоборот: тест нуждается в финальных действиях. Предположим, мы пишем
промежуточные файлы на диск. Чтобы очистить папку при выходе из теста, напишем
фикстуру:

\begin{english}
  \begin{clojure}
(import 'java.io.File
        'org.apache.commons.io.FileUtils)

(defn clean-dir [path]
  (FileUtils/cleanDirectory (new File path)))

(defn fix-clear-files [t]
  (t)
  (clean-dir "/tmp/tests/data"))
  \end{clojure}
\end{english}

Иногда фикстура сообщает и предварительные, и финальные шаги. В этом случае
\spverb|(t)| располагается где-то посередине.

Надеемся, читатель заметил, что имена фикстур начинаются с префикса
\spverb|fix-|. Для фикстур действует то же правило именования, что и для
тестов. Это особые сущности, поэтому их выделяют префиксом.

\subsection{Регистрация}

Если запустить тест сейчас, фикстура не сработает. Мы только объявили фикстуру,
но не сказали фреймворку взять ее в работу. Это делают регистрацией фикстуры.
Резонный вопрос: если фреймворк находит тесты, почему бы ему не искать фикстуры
и применять их?

Причина в том, что фикстура может работать на разных этапах теста. Фреймворк
Clojure выделяет стадии \spverb|:each| и \spverb|:once|. Зарегистрировать
фикстуру означает связать ее с одним из этих ключей. Значение \spverb|:each|
означает, что фикстура работает для каждого теста из модуля. С ключом
\spverb|:once| фикстура выполняется однажды в рамках модуля.

Одна и та же фикстура может быть \spverb|:each| или \spverb|:once|. Вспомним
фикстуру \spverb|fix-clear-files|, которая очищает папку. Если у файлов
случайные имена, логично очистить папку один раз в конце, и фикстуре указывают
\spverb|:once|. Если имена одинаковы, возрастает риск их коллизии (чтение из
другого теста). Тогда фикстуру связывают с ключом \spverb|:each|.

Другой пример~--- фикстура базы данных. На время теста она добавляет в таблицы
данные и очищает их. Если тесты только читают данные, укажем
\spverb|:once|. Получим выигрыш в скорости: для тридцати тестов фикстура
сработает один раз. Для тестов на запись важно, чтобы ни один из них не влиял на
другой. Поэтому фикстуру регистрируют с \spverb|:each|. Иногда тесты на чтение и
запись разносят по разным модулям.

Функция \spverb|use-fixtures| из \spverb|clojure.test| принимает ключ и любое
число фикстур:

\begin{english}
  \begin{clojure}
(use-fixtures :once fix-db-server fix-clear-files)
(use-fixtures :each fix-db-data)
  \end{clojure}
\end{english}

Эти выражения ставят в верхней части файла до тестов. Они могут быть и в конце,
но чем раньше программист увидит фикстуры, тем лучше.

\subsection{Пример}

Чтобы увидеть порядок фикстур, добавим побочный эффект. Функция
\spverb|fix-factory| принимает тип фикстуры, ее номер и возвращает
фикстуру. Внутри она обрамляет тест выводом в консоль.

\begin{english}
  \begin{clojure}
(defn fix-factory [type number]
  (fn [t]
    (println (format "%s %s starts" type number))
    (t)
    (println (format "%s %s ends" type number))))
  \end{clojure}
\end{english}

Добавим по две фикстуры каждого типа:

\begin{english}
  \begin{clojure}
(use-fixtures :once
  (fix-factory :once 1)
  (fix-factory :once 2))

(use-fixtures :each
  (fix-factory :each 3)
  (fix-factory :each 4))
  \end{clojure}
\end{english}

Если запустить тесты, увидим следующее. Фикстуры 1 и 2 типа \spverb|:once|
сработали однажды на границах. Обратите внимание, что в конце их порядок
противоположный: сначала завершается фикстура 2 и только потом 1. Фикстуры 3 и 4
оборачивают каждый тест. Чтобы выразить процесс нагляднее, добавим отступы. С
ними видна иерархия фикстур.

\begin{english}
  \begin{clojure}
:once 1 starts
  :once 2 starts
    :each 3 starts
      :each 4 starts
      :each 4 ends
    :each 3 ends
    :each 3 starts
      :each 4 starts
      :each 4 ends
    :each 3 ends
  :once 2 ends
:once 1 ends
  \end{clojure}
\end{english}

\subsection{На нижнем уровне}

Пытливому читателю будет интересно узнать, где лежит информация о
фикстурах. Очевидно, вызов \spverb|use-fixtures| меняет глобальное
состояние. Это не атом и не переменная, а нечто другое, с чем мы еще не
работали~--- метаданные пространства. После регистрации фикстур проверьте его
ключи:

\begin{english}
  \begin{clojure}
(keys (meta *ns*))
(:clojure.test/each-fixtures :clojure.test/once-fixtures)
  \end{clojure}
\end{english}

В них находится список функций, который передали в \spverb|use-fixtures| с
\spverb|:each| или \spverb|:once|. Вызов \spverb|use-fixtures| заменяет в
метаданных все фикстуры этого типа. Важно, что это полная замена, а не запись в
конец. Чтобы отказаться от всех фикстур \spverb|:each|, выполните:

\begin{english}
  \begin{clojure}
(use-fixtures :each nil)
  \end{clojure}
\end{english}

Другой способ очистить фикстуры~--- удалить \spverb|use-fixtures| и выполнить
буфер в REPL. Тогда шапка \spverb|(ns...)| сработает еще раз с новыми
метаданными.

Другие языки и фреймворки выделяют еще одну стадию фикстур~---
\spverb|:session|. Такая фикстура запускается в разрезе \emph{всего прогона}
тестов. Можно сказать, это фикстура-синглтон: даже для нескольких модулей она
сработает один раз. В Clojure нет такой стадии. С ней пространства были бы
связаны друг с другом, что идеологически неверно. Начинающим не хватает
session-фикстур, но мы научимся обходиться без них.

\subsection{Связанные переменные}

Фикстуры особенно удобны в паре с динамическими переменными. Напомним,
динамические переменные это формы \spverb|def| с тегом \spverb|^:dynamic| и
\spverb|*|ушками\spverb|*|. Макрос \spverb|binding| выполняет код с новым
значением переменной. Мы рассматривали их в главе про
изменяемость \page{dynamic-vars}.

Форма \spverb|deftest| порождает функцию без аргументов. Нельзя сообщить тесту
его параметры как обычной функции. А ведь тесту нужны файлы, база данных и
многое другое. Окружение передают в два шага. Первый~--- тест ссылается на
глобальную переменную. Второй~--- пишут фикстуру, которая оборачивает тест в
\spverb|binding| с этой переменной и нужным значением.

Предположим, мы тестируем функцию, которая принимает путь к файлу и пишет в него
картинку. Объявим фикстуру, которая на время теста свяжет переменную
\spverb|*file*| со временным файлом. На время теста \spverb|*file*| будет
экземпляром \spverb|java.util.File|. При выходе из теста удалим файл, а
переменная станет \spverb|nil|.

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *file* nil)

(defn with-fix-tmp-file [t]
  (let [^File tmp-file (TmpFile/createFile "....")]
    (binding [*file* tmp-file]
      (t))
    (.delete tmp-file)))

(use-fixture :each with-fix-tmp-file)
  \end{clojure}
\end{english}

Внутри теста мы вызываем \spverb|plot-chart| с текущим временным
файлом. Убедимся, что функция действительно записала в него картинку. Класс
\spverb|PngImage| предлагает простейший парсер PNG. Прочитаем разрешение файла и
сверим с образцом.

\begin{english}
  \begin{clojure}
(import 'some.path.PngImage)

(deftest test-plot-chart-png
  (let [dataset [[...] [...] [...]]
        filepath (.getAbsPath *file*)]
    (plot-chart dataset filepath)
    (let [png (new PngImage *file*)
          width (.getWidth png)
          height (.getHeight png)])
    (is (= [640 480] [width height]))))
  \end{clojure}
\end{english}

Для полноты картины рассмотрим случай с базой данных. Пусть это будет Cassandra,
а не JDBC-драйвер. Фикстура \spverb|with-fix-db| связывает \spverb|*db*| с
текущей сессией. Установка сессии это дорогая операция, поэтому вынесем ее в
разовую фикстуру.

\begin{english}
  \begin{clojure}
(defonce ^:dynamic ^Session *db* nil)

(defn with-fix-db [t]
  (let [cluster ...
        session ...]
    (binding [*db* session]
      (t))
    (.close session)
    (.close cluster)))

(use-fixture :once with-fix-db)
  \end{clojure}
\end{english}

Вторая фикстура готовит данные для каждого теста. Фикстуры \spverb|:once|
запускаются раньше, чем \spverb|:each|. Подготовка данных сработает внутри
\spverb|(binding [*db* ...])| из первой фикстуры. Это значит, внутри второй мы
свободно обращаемся к \spverb|*db*| как к сессии:

\begin{english}
  \begin{clojure}
(defn fix-db-prepare-data [t]
  (alia/execute! *db* "truncate project.users;")
  (alia/execute! *db* "truncate project.orders;")
  (alia/execute! *db* "insert into project.users...")
  (t))

(use-fixture :each fix-db-prepare-data)
  \end{clojure}
\end{english}

\section{Мульти-фикстуры}

Любопытный вопрос: что произойдет, фикстура вызовет тест несколько раз? Напишем
такую фикстуру:

\begin{english}
  \begin{clojure}
(defn fix-multi [t]
  (t) (t) (t))

(use-fixtures :each fix-multi)
  \end{clojure}
\end{english}

\noindent
и запустим один тест. С точки зрения фреймворка прошло три теста, о чем скажет
отчет:

\begin{english}
  \begin{text}
book.util-test: Ran 6 assertions, in 3 test functions.
0 failures, 0 errors.
  \end{text}
\end{english}

На первый взгляд в этом нет смысла. Многократный прогон не несет пользы, а
только потребляет ресурсы и время. Но с динамическими переменными такая фикстура
полезна. Один и тот же тест можно запустить в разных окружениях.

Предположим, программа работает с базой данных. В требованиях сказано, что это
может быть PostgreSQL или MySQL. Убедимся, что программа поддерживает обе
СУБД. Чтобы не дублировать тесты под каждый тип базы, логику выносят в
фикстуру. Объявим подключения к базам данных:

\begin{english}
  \begin{clojure}
(def db-pg {:dbtype "postgresql" :host "..."})
(def db-mysql {:dbtype "mysql" :host "..."})
  \end{clojure}
\end{english}

Добавим динамическую переменную \spverb|*db*|. Новая фикстура перебирает список
подключений и связывает их с \spverb|*db*| на каждом шаге. Когда переменная
связана, запускается тест. Он зависит от текущего подключения и тем самым
обращается либо в PostgreSQL, либо в MySQL.

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *db* nil)

(defn fix-multi-db-backend [t]
  (doseq [db [db-pg db-mysql]]
    (binding [*db* db]
      (testing (format "Testing with DB %s" (:dbtype *db*))
        (t)))))
  \end{clojure}
\end{english}

Вызов \spverb|(t)| обернут в форму \spverb|testing|. В ней мы сообщаем тип
базы. Если произошла ошибка, мы узнаем, с какой базой работали в тот
момент. Пример теста на чтение пользователя:

\begin{english}
  \begin{clojure}
(defn test-get-user-by-id
  (let [user (project.orm/get-user *db* 1)]
    (is (= {:name "Ivan"} user))))
  \end{clojure}
\end{english}

Перечислим другие сценарии для мульти-фикстур. Это может быть запуск
интеграционных тестов в нескольких браузерах (Chrome, Firefox). Иногда нужно
проверить, что логика не зависит от формата передачи данных (JSON,
Msgpack). Если программа работает с изображениями, тесты прогоняют на разных
типах файлов (PNG, JPEG) и разрешениях.

\subsection{Минутка неадекватности}

Перейдем в другую крайность: что случится, если фикстура не вызовет тест?

\begin{english}
  \begin{clojure}
(defn fix-mute [t])
(use-fixtures :each fix-mute)
  \end{clojure}
\end{english}

Это приведет к тому, что ни один тест не сработает. Фикстура не отменяет тесты:
фреймворк по-прежнему находит и выполняет их. В отчете увидим список тестов, но
для каждого будет указано <<0~assertions>>. Если запустить тест из Emacs, увидим
предупреждение:

\begin{english}
  \begin{clojure}
No assertions (or no tests) were run.
Did you forget to use ‘is’ in your tests?
  \end{clojure}
\end{english}

CIDER считает подозрительным, что не было ни одного \spverb|is|. Чтобы обмануть
CIDER, улучшим фикстуру. Добавим в нее \spverb|is|, который всегда истинен. Даже
если тест с ошибками, его тело не выполнится, а в отчете будет один
assertion. Назовем такую фикстуру \spverb|fix-this-is-fine|%
\footurl{https://knowyourmeme.com/memes/this-is-fine}:

\begin{english}
  \begin{clojure}
(defn fix-this-is-fine [t]
  (is true))

(use-fixtures :each fix-this-is-fine)
  \end{clojure}
\end{english}

С ее помощью мы пройдем тест Оруэлла:

\begin{english}
  \begin{clojure}
(deftest test-1984
  (is (= (* 2 2) 5)))
;; OK, ran 1 assertions
  \end{clojure}
\end{english}

По аналогии напишите фикстуру, которая портит любой тест. Добейтесь, чтобы все
тесты завершились с ошибкой. Теперь вернемся к серьезному повествованию.

\subsection{Фикстуры с условиями}

Фикстура не только вызывает тест, но и несет дополнительную логику. Тест может
быть обернут в цикл, условие или другую форму. Разберемся с условием. В каких
случаях тест ставят под \spverb|if| и какой в этом смысл?

К условной фикстуре прибегают, когда мы не знаем заранее, сможем ли выполнить
тест. Например, часть программы не работает на Windows или Mac. Фикстура
проверяет тип системы и не вызывает тест, если он заведомо не работает.

\begin{english}
  \begin{clojure}
(defn fix-mac-only [t]
  (when (= (System/getProperty "os.name") "Mac OS X")
    (t)))
  \end{clojure}
\end{english}

Фикстура выполнит тест только на платформе Mac семейства \spverb|X|. Недостаток
в том, что мы сравниваем значения в лоб. Чтобы определить платформу правильно,
\spverb|os.name| проверяют на вхождение строки или регулярным выражением.

Сделаем фикстуру подробнее. Обернем тест в форму \spverb|testing|, чтобы видеть,
в рамках какой системы сработал тест. Если мы не поддерживаем систему, добавим
ложное утверждение:

\begin{english}
  \begin{clojure}
(defn fix-mac-only [t]
  (let [os (System/getProperty "os.name")]
    (if (= os "Mac OS X")
      (testing (format "OS: %s" os)
        (t))
      (testing (format "Unsupported OS: %s" os)
        (is false)))))
  \end{clojure}
\end{english}

Каким способом зарегистрировать фикстуру~--- \spverb|:once| или \spverb|:each|?
Это зависит от семантики условия. В нашем примере система не меняется от теста к
тесту, поэтому условие может быть выполнено однажды. Если фикстура проверяет
файл на диске, условие выполняют для каждого теста.

Рассмотрим другие сценарии, когда фикстурам нужны условия. Это версия базы
данных: если она ниже порога, мы не можем выполнить тест. Иногда приложение
зависит от системной утилиты, которую вызывает в отдельном процессе. Фикстура
проверяет, что утилита установлена. Когда тест работает с большими файлами,
может не хватить места на сервере CI. Фикстура убеждается, что места достаточно.

\section{Метки и селекторы}

Фикстуры с условиями похожи на фильтры. С их помощью запускают не все тесты, а
часть, которая подходит окружению. Избегайте ситуаций, когда в фикстурах слишком
много условий. Clojure предлагает более удобный способ для выборочного
прогона. Это метки и селекторы тестов.

Метки устроены проще, чем фикстуры с условием. Это метаданные, которые сообщают
тесту при его создании. Тесту ниже:

\begin{english}
  \begin{clojure}
(deftest ^:special test-special-case
  (is true))
  \end{clojure}
\end{english}

\noindent
назначили флаг \spverb|:special| со значением \spverb|true|. Напомним, что
выражение \spverb|^:field| это сокращенная форма \spverb|^{:field true}|.
<<Крышка>> полезна, чтобы задать несколько флагов за один раз:

\begin{english}
  \begin{clojure}
(deftest ^:special ^:backend ^:no-db
  test-special-case
  (let [...]
    (is ...)))
  \end{clojure}
\end{english}

Когда тегов два и больше, имя теста переносят на следующую строку, чтобы
визуально отделить их.

По тегам легко догадаться, что это тест на серверную логику (backend); ему не
нужна база данных (no-db); это особый тест (special). Семантика тегов зависит от
соглашений в команде. Проверим флаги: прочитаем метаданные переменной
\spverb|test-special-case|. Среди прочих полей вы найдете \spverb|:special| и
остальные:

\begin{english}
  \begin{clojure}
(meta #'test-special-case)
{:special true :backend true :no-db true ...}
  \end{clojure}
\end{english}

По тегам можно выбрать часть тестов, например, только особые (special) или на
серверную логику (backend). Выборка называется селектором тестов. Селекторы
полезны по нескольким причинам.

Часть тестов отработает быстрее, чем полный набор. Если мы правим участкок кода
и точно знаем, какие тесты он задевает, нет смысла запускать вс\"{е}
подряд. Назначим тег и будем работать с подмножеством.

Иногда окружение не настроено должным образом, и выполнить все тесты
невозможно. Например, интеграционный тест длится на порядок дольше модульного и
требует инфраструктуру. Их выносят в отдельный шаг сборочной линии. В общих
чертах схема выглядит так:

\begin{itemize}

\item
  запускается минимальное окружение (база данных);

\item
  выполняются модульные тесты;

\item
  если не было ошибок, запускается дополнительное окружение (очередь задач, заглушки);

\item
  выполняются интеграционные тесты.

\end{itemize}

Чем сложнее проект, тем больше в нем тестов и шагов по их запуску.

В тестовом фреймворке Clojure нет селекторов. Он запускает один тест,
пространство или все целиком. Селекторы доступны в сторонних библиотеках и
утилитах. Рассмотрим, как задать их в Leiningen.

Откройте файл \spverb|project.clj|. Внутри \spverb|defproject| добавьте ключ
\spverb|:test-selectors|. Это словарь, где ключ это метка селектора, а
значение~--- функция одного аргумента. В функцию приходят метаданные теста. Если
функция вернула ложь или \spverb|nil|, тест пропускают.

Поскольку кейворд в Clojure это функция, селектором может быть сам тег. Пример
ниже читается как <<набор тестов \spverb|:special|, у которых тег \spverb|:special|>>:

\begin{english}
  \begin{clojure}
:test-selectors {:special :special
                 :backend :backend}
  \end{clojure}
\end{english}

Чтобы запустить тесты по селектору, передайте метку в команду \spverb|test|:

\begin{english}
  \begin{clojure}
lein test :special
  \end{clojure}
\end{english}

Если метка не задана, фреймворк назначит ей \spverb|:default|. Под этот селектор
подходит любой тест. Хитрость в том, что ему можно задать свой селектор. Ниже
пример из реального проекта. Для \spverb|:default| задали селектор, который
вернет все \emph{не} интеграционные тесты. Команда \spverb|lein test| запустит
только модульные тесты. На случай, когда нужно прогнать весь проект, мы завели
метку \spverb|:all|, которая всегда вернет истину.

\begin{english}
  \begin{clojure}
:test-selectors {:default (complement :integration)
                 :integration :integration
                 :all (constantly true)}
  \end{clojure}
\end{english}

Селектор может быть не только ключом, но и функцией. Предположим, программа
работает с разными версиями базы для совместимости. Для каждого теста укажем
минимальную версию базы. Это поле \spverb|:pg/version| с числом. Тест считают
экспериментальным, если версия базы выше 11:

\begin{english}
  \begin{clojure}
(deftest ^{:pg/version 11}
  test-db-experimental-feature
  (is true))
  \end{clojure}
\end{english}

\noindent
Селектор, который вернет подобные тесты:

\begin{english}
  \begin{clojure}
:test-selectors
{:db-experimental
 (fn [test-meta]
   (some-> test-meta :pg/version (>= 11)))}
  \end{clojure}
\end{english}

\noindent
Запустите их командой \spverb|lein test :db-experimental|.

Когда тестов много, расставлять теги утомительно. Повышается риск забыть тег, и
тест выпадет из набора. Если все тесты модуля связаны по смыслу, тег назначают
не тесту, а пространству. С точки зрения \spverb|lein| тест наследует теги
пространства, в котором объявлен:

\begin{english}
  \begin{clojure}
(ns ^:integration
  book.integration-test
  (:require [clojure.test :refer :all]))

(deftest test-user-login-ok
  ...)
  \end{clojure}
\end{english}

Нет смысла указывать \spverb|^:integration| каждому тесту, поскольку мы сделали
это на уровне модуля. Селектор интеграционных тестов не изменится: его метка и
функция равны \spverb|:integration|. Тесты запускаются как обычно:

\begin{english}
  \begin{clojure}
lein test :integration
  \end{clojure}
\end{english}

\subsection{Тесты в deps.edn}

Не все проекты на Clojure используют Lein; некоторые перешли на
Deps.edn\footurl{https://clojure.org/guides/deps\_and\_cli}. Это утилита для
управления зависимостями. С версии 1.9 Deps.edn идет в поставке Clojure.

Если проект работает на Deps, мы теряем возможности Lein, в том числе прогон
тестов. Чтобы компенсировать потери, в Deps подключают сторонние
библиотеки. Проект Test-runner\footurl{https://github.com/cognitect-labs/test-runner}
делает то же, что и \spverb|lein test|: находит тесты, запускает их и выводит
отчет.

Добавьте в файл \spverb|deps.edn| новую сущность:

\begin{english}
  \begin{clojure}
:aliases
{:test
 {:extra-paths ["test"]
  :extra-deps
  {com.cognitect/test-runner
   {:git/url "https://github.com/cognitect-labs/test-runner.git"
    :sha "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
  :main-opts ["-m" "cognitect.test-runner"]}}
  \end{clojure}
\end{english}

Ключ \spverb|:aliases| это то же самое, что профили в \spverb|lein|: опции,
которые включаются, если указан профиль. Ключ \spverb|:extra-paths| это список
путей для поиска файлов с кодом. Поле \spverb|:extra-deps| указывает зависимости
в дополнение к основным. Test-runner нужен только для тестов, поэтому не нужно
вносить его в глобальные зависимости.

Библиотека загружается с GitHub; поле \spverb|:sha| означает номер коммита. Это
коренное отличие Deps от Lein: репозиторием может быть GitHub. Ключ
\spverb|:main-opts| задает входную точку программы. Это функция \spverb|-main|
из модуля \spverb|cognitect.test-runner|.

Библиотека предлагает ключи для выборки тестов с логикой <<только с этим тегом>>
(\spverb|-i|, include, включить) или <<без этого тега>> (\spverb|-e|, exclude,
исключить). Команда ниже выполнит все тесты кроме интеграционных:

\begin{english}
  \begin{bash}
clj -Atest -e :integration
  \end{bash}
\end{english}

Селекторы в \spverb|test-runner| могут быть только ключами. Сложные функции
вроде версии базы не поддерживаются. Test-runner умеет искать пространства по
регулярному выражению (ключ \spverb|-r|, namespace-regex). С ним можно выбрать
тесты по доменной структуре, например, все дочерние модули \spverb|project.api|.

\section{Проблема окружения}

До сих пор мы писали примитивные тесты, которые проверяют числа. На практике вы
столкнетесь с проблемой: в коде преобладают не вычисления, а ввод-вывод
данных. Это обращение к сторонним ресурсам: базе данных, очереди задач, HTTP
API. Такой код трудно тестировать по двум причинам.

Во-первых, настроить локальное окружение стоит усилий, а иногда это
невозможно. У вас может не быть ключей доступа или сертификатов. Во-вторых,
тесты плохо работают с данными, которые не контролируют. Если однажды ответ
сервиса изменятся, получим сломанный билд.

Чтобы тест не зависел от окружения, применяют \emph{моки} и
\emph{стабы}. Разберемся, что это такое и в чем плюсы и минусы каждого.

\subsection{Моки}

Мок (анг. \emph{mock}~--- ложный, фиктивный)~--- это объект, который временно
заменяет другой объект. При обращении к объекту сработает не исходный код, а
указанный. Чаще всего моки накладывают на функции с доступом в сеть. С их
помощью проверяют, как поведет себя код в разных ситуациях: данные получены,
статус 403, соединение не удалось.

Представим мобильное приложение для развлечения и отдыха. На главном экране
карта, на которую нанесены кафе, рестораны и ближайшие события: фильмы,
выставки, фестивали. Данные приходят с сервера по протоколу HTTP в JSON. Функция
\spverb|view-main-page| принимает запрос с координатами устройства, собирает
сведения о местах и событиях и отсылает обратно:

\begin{english}
  \begin{clojure}
(ns book.views
  (:require [clj-http.client :as client]))

(defn view-main-page [request]
  (let [location (-> request :params (select-keys [:lat :lon]))
        sites (get-sites-by-location location)
        events (get-events-by-location location)]
    {:status 200
     :body {:sites sites :events events}}))
  \end{clojure}
\end{english}

Данные о местах и событиях приходят из сторонних сервисов, условных Яндекс.Карт
и Афиши. Функции \spverb|get-sites...| и \spverb|get-events...| общаются с ними
по HTTP. Так выглядит функция \spverb|get-sites-by-location| для поиска кафе и
ресторанов в радиусе 300 метров:

\begin{english}
  \begin{clojure}
(defn get-sites-by-location
  [{:keys [lat lon]}]
  (-> {:method :get
       :url "https://maps.yandex.ru/search/v1/"
       :as :json
       :query-params {:apikey "....."
                      :lat lat :lon lon :distance 300
                      :type "cafe,restaurant"}}
      client/request
      :body))
  \end{clojure}
\end{english}

Функция \spverb|get-events-by-location| для событий аналогична первой. Разница в
адресе (не \spverb|maps.yandex.ru|, a \spverb|events.yandex.ru|) и параметрах
запроса.

Очевидно, \spverb|view-main-page| обращается к сети дважды, что затрудняет
тестирование. Понадобится два API-ключа; если запускать тесты часто, мы
исчерпаем квоты на число запросов. Настоящие данные меняются и поэтому не
подходят для тестов (завтра откроется новое кафе или закроется старое). Решим
проблему моками.

В главе про изменяемость мы работали с \spverb|with-redefs| \page{with-redefs}.
Макрос заменяет переменную по ее пути на что-то другое. Простейший мок~--- это
подмена функции с обращением в сеть на функцию, которая вернет известный
результат.

Напишем тест главного экрана с двумя моками. Данные моков вынесем в переменные в
\spverb|let|. Функцию \spverb|view-main-page| вызывают внутри
\spverb|with-redefs|, иначе эффект моков теряется.

\begin{english}
  \begin{clojure}
(deftest test-main-page
  (let [sites [{:name "Cafe1"} {:name "Cafe2"}]
        events [{:name "Event1"} {:name "Event2"}]]
    (with-redefs
      [book.views/get-sites-by-location (constantly sites)
       book.views/get-events-by-location (constantly events)]
      (let [request {:params {:lat 55.751244
                              :lon 37.618423}}
            result (view-main-page request)]
        (is (= (:body result)
               {:sites sites :events events}))))))
  \end{clojure}
\end{english}

Мы избежали похода в сеть: тест не зависит от ключей, прав доступа и новых
заведений. Запустите его в любое время, и результат не изменится. Теперь
рассмотрим, как улучшить этот тест.

\subsection{Вынести данные в файл}

Переменные \spverb|sites| и \spverb|events|, которые якобы пришли из сторонних
сервисов, крайне скудны. Сообщите им данные из реального источника, например,
десять ресторанов и семь мероприятий. Чтобы не засорять код огромными словарями,
поместите ответы в .json-файлы в папку с ресурсами. Считайте их в переменную
модуля:

\begin{english}
  \begin{clojure}
(def data-events
  (-> "data/events.json"
      clojure.java.io/resource
      slurp
      (json/parse-string true)))
  \end{clojure}
\end{english}

На практике функция \spverb|get-sites-by-location| сложнее, чем в
примере. Заведения фильтруют согласно внутренней логике. Например, исключают
кафе с низкой оценкой и те, что сейчас закрыты. Это порождает отдельный тест:
добавьте кафе с низкой оценкой и убедитесь, что его нет в ответе.

\subsection{Мок в фикстуре}

Если тестов на главный экран несколько, оборачивать каждый в
\spverb|with-redefs| утомительно. Поместим мок в фикстуру. Так мы снизим повторы
в коде, и ей смогут пользоваться другие тесты.

\begin{english}
  \begin{clojure}
(defn fix-mock-sites-events [t]
  (with-redefs [...]
    (t)))

(use-fixtures :each fix-mock-sites-events)
  \end{clojure}
\end{english}

Недостаток фикстуры в том, всем тестам она задает позитивный сценарий (оба
вызова сработали без ошибок). Для полноты картины нужно проверить ошибки.

\subsection{Негативные сценарии}

Недоступность сервиса не должна влиять на приложение в целом. Если возникли
проблемы с кафе, пользователь увидит мероприятия и наоборот. Возможно, он даже
не заметит проблемы: если локации не пришли, приложение покажет старые данные.

Чтобы проверить главный экран на устойчивость, необходимы сценарии:

\begin{itemize}

\item
  получили кафе, но не события;

\item
  наоборот: с кафе все в порядке, ошибка с событиями;

\item
  не работают оба сервиса.

\end{itemize}

Под общими словами <<не работают>> имеют в виду:

\begin{itemize}

\item
  проблемы доступа или квот: статусы 403 и 429;

\item
  недоступность сервиса: статусы 500 и 503;

\item
  проблемы связи: таймаут соединения или поиск хоста.

\end{itemize}

Напишем макрос \spverb|with-mock|, который принимает путь к функции, результат
мока и блок, который он оборачивает.

\begin{english}
  \begin{clojure}
(defmacro with-mock
  [path result & body]
  `(with-redefs
     [~path (fn [& ~'_] ~result)]
     ~@body))
  \end{clojure}
\end{english}

Важно: для замены \spverb|path| мы создаем функцию с помощью \spverb|fn|, а не
\spverb|constantly|. Дело в том, что \spverb|result| может быть не только
выражением, но и произвольным кодом. \spverb|Constantly| это функция, поэтому ее
аргументы вычисляются до того, как она сработает. Не получится передать в нее
код, который бросит исключение. Строка:

\begin{english}
  \begin{clojure}
(constantly (throw (new Exception "error")))
  \end{clojure}
\end{english}

\noindent
бросит исключение до входа в \spverb|with-redefs|.

С помощью \spverb|with-mock| мы собирают комбинации успехов и неудач. Тест ниже
проверяет сценарий, когда сервис кафе сработал без ошибок, а с событиями что-то
не так. Если запустить тест, окажется, что главный экран не ловит исключения, и
пользователь не получит ничего.

\begin{english}
  \begin{clojure}
(deftest test-sites-ok-events-err
  (with-mock book.views/get-sites-by-location [...]
    (with-mock book.views/get-events-by-location
      (throw (new java.net.UnknownHostException "DNS error"))
      (let [request {...}
            response (view-main-page request)
            {:keys [status body]} response]
        (is (= 200 status))
        (is (= {...} body))))))
  \end{clojure}
\end{english}

Доработайте \spverb|view-main-page| так, чтобы тест получил ответ со статусом
200 и полем \spverb|:sites|. Добавьте тесты с другими комбинациями: ошибка
соединения в \spverb|get-sites|, статусы 403 и 500, недоступность сразу двух
сервисов.

Подумайте, как улучшить \spverb|with-mock|. Сейчас макросы вложены друг в друга,
что дает отступы и лишний код. Сделайте так, чтобы \spverb|with-mock| был похож
на \spverb|let|~--- принимал форму связывания, где четный элемент это путь к
функции, а нечетный~--- результат. Тогда каскад макросов можно заменить на один.

\subsection{Сбор данных}

Не заглядывая в конец главы, подумайте, как сделать мок промышленного уровня. Он
не только возвращает результат, но и:

\begin{itemize}

\item
  считает, сколько раз его вызвали;

\item
  запоминает аргументы на каждый вызов;

\item
  принимает список результатов и возвращает их поочередно, например, первый и
  второй раз словари, а на третий исключение;

\item
  предлагает удобный доступ к собранным данным.

\end{itemize}

Такие моки следят за особой логикой. Например, поиск ресторанов вернет только
базовые сведения о них. Чтобы получить подробные сведения о месте, нужно слать
отдельный запрос. Чтобы трафик не рос линейно, данные извлекают только для трех
лучших ресторанов. Мок проверяет, что функцию \spverb|get-site-details| вызвали
не больше трех раз. В конце главы мы рассмотрим продвинутые решения для мокинга
в Clojure.

%% -----------------

\subsection{Недостатки}

На первый взгляд кажется, что моки решили проблему окружения. Теперь тесты
автономны и не зависят от сторонних сервисов. Есть у моков и недостатки;
перечислим основные из них.

Мок нарушает принцип \emph{закрытости} (черного ящика). При написании теста мы
подглядываем в код, чтобы узнать, какие функции подменить. Чем меньше тест знает
о коде, который тестирует, тем он надежней.

Мок исключает сетевое взаимодействие, что иногда выходит боком. Передача данных
по HTTP это сложный процесс. Подмена запроса на чистую функцию это грубое
приближение. С его помощью нельзя предугадать все возможные ошибки.

Наконец, мок повышает связанность тестов с логикой. Если переименовать функцию
\spverb|get-sites...|, форма \spverb|(with-redefs...)| перестанет
работать. Косметические правки в коде повлияют на тесты, что неудобно и неверно
идеологически.

Эти проблемы решают стабы, о которых речь в следующем разделе.

\subsection{Стабы}

Стаб (анг. \emph{stub}, заглушка)~--- это сущность, которая заменяет объект или
часть системы на время тестов. От моков она отличается тем, что тест не может ей
управлять. Если моку указывают, что и чем заменить, то стаб это черный ящик с
точки зрения теста.

Удачный пример стаба это локальный сервер, имитирующий сторонний сервис.
Например, поиск мест на карте. Сервер запущен на порту 8808 и по адресу
\spverb|/search/v1/| вернет данные, которые мы взяли из настоящего источника. Не
будем мокать функцию \spverb|get-sites-by-location|. Изменим ее так, чтобы поле
\spverb|:url| запроса указывало не на \spverb|https://maps.yandex.ru/|, а на
\spverb|http://127.0.0.1:8808/|. Если запустить тест, функция выполнит запрос к
локальному серверу.

Подход со стабами несет преимущество: он сводит к нулю зависимость теста от
логики. Теперь тест ничего не знает о функциях приложения. От нас требуется
только перенацелить запросы на другой адрес. Это вопрос конфигурации, а в логике
программы ничего не меняется.

Другое достоинство в том, что во время теста происходит \emph{настоящий} обмен
данными по сети. Да, это локальный сервер без зашифрованного соединения и
проверки сертификатов. Но основная часть HTTP протекает так же, как и в
промышленном запуске. Это разбор заголовков, чтение и парсинг JSON-данных,
проверка статуса.

Сервера-заглушки еще называют фейки (анг. \emph{fake}, подделка). С помощью
фейка программист моделирует нештатное поведение сервера. Например, сервер
принимает соединение, но не отвечает. Или полную недоступность сервера, когда
его выключают перед тестом.

Достичь таких эффектов моком невозможно. С его помощью можно только кидать
исключения, которые, согласно документации, бросит настоящий HTTP-клиент. Тесты
на исключениях хрупки и далеки от реального положения дел.

С технической стороны стаб это фикстура. До запуска теста она включает сервер, а
после выключает его. Сервер это \spverb|Jetty| или другой адаптер для
Ring-обработчика запроса. Мы подробно рассмотрели Ring и Jetty в главе по
веб-разработку \page{ring-jetty}.

Напишем фикстуру для сервера карт. Обработчик это функция, которая принимает
запрос. Для пути \spverb|/search/v1| она возвращает JSON-данные, для всего
остального ответ 404:

\begin{english}
  \begin{clojure}
(defn sites-handler* [{:keys [uri]}]
  (case uri
    "/search/v1/"
    {:status 200
     :body [{:name "Cafe1" :address "..."}
            {:name "Cafe2" :address "..."}]}
    {:status 404
     :body "page not found"}))
  \end{clojure}
\end{english}

Обернем функцию в middleware. Мы хотим, чтобы коллекция из ответа приводилась к
JSON автоматически. Кроме того, пригодятся параметры запроса:

\begin{english}
  \begin{clojure}
(def sites-handler
  (-> sites-handler*
      wrap-keyword-params
      wrap-params
      wrap-json-response))
  \end{clojure}
\end{english}

Напишем и подключим фикстуру. Сервер не меняет состояние от теста к тесту (мы
только читаем данные), поэтому фикстура сработает один раз (ключ
\spverb|:once|):

\begin{english}
  \begin{clojure}
(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}
        server (run-jetty sites-handler opt)]
    (t)
    (.stop server)))

(use-fixtures :once fix-fake-sites-server)
  \end{clojure}
\end{english}

Исправим функцию \spverb|get-sites-by-location| так, чтобы клиент обращался к
локальному хосту. Очевидно, базовый URL должен быть в конфигурации. Вы уже
знаете, как устроена конфигурация, поэтому не будем приводить весь код. Для
краткости представим, что переменная \spverb|config| это словарь
параметров. Тогда полный URL для карт формируется так:

\begin{english}
  \begin{clojure}
:url (str (:maps-base-url config ) "/search/v1/")
  \end{clojure}
\end{english}

Вернемся к тесту главного экрана. Нам не нужны моки, поэтому тест сводится к
вызову \spverb|view-main-page|. Прямо сейчас тест не пройдет, потому что мы
решили проблему только с поиском заведений. Поиск событий по-прежнему обращается
к чужому серверу. Чтобы убедиться, стаб работает нормально, на время
закомментируем вызов \spverb|get-events-by-location|, а поле \spverb|:events|
сделаем \spverb|nil|. Тест сработает без ошибок: в поле \spverb|:sites| ответа
окажутся данные, что вернул стаб.

\begin{english}
  \begin{clojure}
(deftest test-main-page
  (let [request {:params {:lat 55.751244
                          :lon 37.618423}}
        result (view-main-page request)]
    (is (= (:body result) {:sites [...] :events nil}))))
  \end{clojure}
\end{english}

Верните все как было и напишите заглушку для поиска событий. Оформите ее в
фикстуру и убедитесь, что тест проходит.

Рассмотрим, что еще интересного предлагают стабы. Как и в случае с моками,
удобно, когда ответы лежат в файлах. Чтобы фейковый сервер читал файл, измените
ответ следующим образом:

\begin{english}
  \begin{clojure}
{:status 200
 :body (-> "data/events.json"
           clojure.java.io/resource
           clojure.java.io/file)}
  \end{clojure}
\end{english}

В файл \spverb|resources/data/events.json| запишите ответ реального сервера.

Пока что стаб всегда возвращает успешный ответ. Сделаем так, чтобы при особых
условиях мы получили негативный ответ. Проще всего это сделать в зависимости от
параметров. Договоримся, что некоторые координаты, которые передает
пользователь, \emph{особые}. Например, для пары \tuple{0,0} сервер вернет пустой
результат; при \tuple{66,66} получим ошибку доступа. С координатами
\tuple{42,42} сервер отвечает с задержкой в 35 секунд, что больше ожидания по
умолчанию в 30 секунд. Перепишем \spverb|sites-handler*|:

\begin{english}
  \begin{clojure}
(defn sites-handler* [request]
  (let [{:keys [uri params]} request
        {:keys [lat lon]} params]
    (case uri
      "/search/v1/"
      (case [lat lon]
        ["0" "0"]   {:status 200 :body []}
        ["66" "66"] {:status 403 :body {:error "ACCESS_ERROR"}}
        ["42" "42"] (do (Thread/sleep (* 1000 35))
                        {:status 200 :body []})
        {:status 200
         :body [{:name "Cafe1" :address "..."}
                {:name "Cafe2" :address "..."}]})
      {:status 404 :body "page not found"})))
  \end{clojure}
\end{english}

Теперь напишите тесты для этих координат. Особенно интересен случай с долгим
ответом, пара \tuple{42,42}. Убедимся, что если сервис карт не
отвечает, мы ждем разумное время, а не стандартные 30 секунд. Передайте в
параметры \spverb|(client/get)| поля \spverb|:socket-timeout| и
\spverb|:connection-timeout| со значением 5000, пять секунд. Этого хватит для
боевого запуска. Замерьте выполнение \spverb|view-main-page|. Добавьте в тест
приверку \spverb|is|, что ожидание не превышает 5 секунд с небольшой
погрешностью.

Добавим тест на экстремальный случай: что произойдет, если сервер выключен?
Чтобы смоделировать ситуацию, фикстура должна предоставить доступ к
серверу. Проще всего это сделать динамической переменной:

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *server* nil)

(defn fix-fake-sites-server [t]
  (let [opt {:port 8808 :join? false}]
    (binding [*server* (run-jetty sites-handler opt)]
      (t)
      (.stop *server*))))
  \end{clojure}
\end{english}

Напишем тест, в котором временно отключим сервер. В конце его нужно включить,
иначе мы испортим все следующие тесты.

\begin{english}
  \begin{clojure}
(deftest test-the-website-is-down
  (.stop *server*)
  (let [request {:params {:lat 1 :lon 2}}
        result (view-main-page request)]
    (is (= (:body result) {...})))
  (.start *server*))
  \end{clojure}
\end{english}

Тест не сработает из-за ошибки <<Connection refused>>. Доработайте логику так,
чтобы пользователю ушел пустой результат.

\subsection{Ресурсы и пути}

Мы упомянули, что данные для моков или стабов хранят в файлах. Так мы не
засоряем код объемными усписками и словарями. Файлы в папке \spverb|resources|
называются \emph{ресурсами приложения}. Они играют особую роль: при сборке
jar-файла ресурсы становятся его частью. Код из jar читает ресурсы, словно это
файлы рядом на диске.

Мы поместили файл \spverb|events.json| в папку \spverb|resources/data| и читали
его как ресурс. Проблема в том, что файл нужен только для тестов. Если собрать
проект, \spverb|events.json| станет частью выходного uberjar. Это напрасно
увеличит его объем.

Чтобы отбросить лишние ресурсы при сборке, в проекте настраивают
\spverb|:resource-paths|. Это вектор, в котором перечислены пути для поиска
ресурсов. По умолчанию он равен \spverb|["resources"]|. При слиянии профилей
векторы соединяются в один. Если другой профиль задал ресурсы иначе:

\begin{english}
  \begin{clojure}
:resource-paths ["resources_test"]
  \end{clojure}
\end{english}

\noindent
, то в итоге программа будет искать в папках \spverb|resources| и
\spverb|resources_test|. Для боевой сборки оставим только \spverb|resources|,
чтобы не вбирать в jar ресурсы для тестов.

Путь \spverb|resources_test| выбран неудачно. Более удобный способ связать файлы
и окружение~--- \emph{env-директория}. На ее первом уровне находятся папки с
именами профилей, а внутри \spverb|src| и \spverb|resources| с кодом и
ресурсами. Эти пути задают профилям в описании проекта.

Создайте нужные пути и переместите ресурсы для теста:

\begin{english}
  \begin{bash}
mkdir -p env/test/resources/data
mv resources/data/events.json env/test/resources/data/
rm -rf resources/data
  \end{bash}
\end{english}

Задайте профили в проекте:

\begin{english}
  \begin{clojure}
:profiles {:test {:resource-paths ["env/test/resources"]}
           :dev  {:resource-paths ["env/test/resources"]}}
  \end{clojure}
\end{english}

На первый взгляд странно, что для \spverb|:dev| и \spverb|:test| мы указали один
и тот же путь. По умолчанию REPL запускается с профилем \spverb|dev|, но не
\spverb|test|. В режиме разработки у нас не будет доступа к ресурсам из
\spverb|env/test|. Это влечет неудобства: например, мы исправили код и тут же
вызвали тест, но он не проходит из-за путей.

Если вам не нравятся повторы в конфигурации, запустите REPL с ключом
\spverb|with-profile +test|. Плюс перед профилем означает \emph{добавить} его к
стандартному. Без плюса профиль \emph{заменит} его.

Считайте ресурс как в примере ниже. Обратите внимание: вы переместили файл между
папками, но для JVM это один и тот же ресурс.

\begin{english}
  \begin{clojure}
(def data-events
  (-> "data/events.json"
      clojure.java.io/resource
      slurp
      (json/parse-string true)))
  \end{clojure}
\end{english}

Любознательным читателям предлагаем эксперимент. Скомпилируйте \spverb|uberjar|
с разными ресурсами: в первый раз как обычно, а во второй с опцией
\spverb|:resource-paths|:

\begin{english}
  \begin{clojure}
:profiles {:uberjar {:resource-paths ["env/test/resources"]}
  \end{clojure}
\end{english}

Сохраните первый файл \spverb|target/uberjar/<project>.jar| в другую папку,
чтобы второй не затер его. Распакуйте оба архива командой \spverb|jar|:

\begin{english}
  \begin{bash}
jar xf <project>.jar
  \end{bash}
\end{english}

Среди файлов из второго архива вы найдете \spverb|data/events.json|. Убедитесь,
что его нет в первом архиве. Очевидно, если ваша программа это jar-архив, любой
желающий может распаковать его. Поэтому в ресурсах не должно быть приватных
данных, например конфигурации с паролями и ключами. Это относится и к данным для
тестирования~--- включать их в jar будет ошибкой.

Пользуясь случаем, исследуйте другие файлы, которые вы получили из jar, их
структуру и содержимое.

\subsection{База данных}

При написании тестов вы столкнетесь с проблемой: почти каждое действие требует,
чтобы в базе были особые данные. Например, для создания пользователя нужна
учетка администратора. Чтобы добавить участника в группу, нужна эта
группа. Чтобы оформить заказ, нужны товары, история покупок для расчета скидки и
многое другое. Чем шире логика приложения, тем больше понадобится данных для
теста.

Если каждый тест вручную готовит данные, у вас будут проблемы с поддержкой таких
тестов. Нужна единая точка входа, чтобы каждый тест имел доступ к одинаковым
данным. В идеале данные декларативны и лежат в файле. Чтобы добавить записи, мы
исправляем только данные, но не код. Когда тесты закончились, содержимое базы
исчезает. Недопустимо, чтобы тест зависел от изменений, выполненных в другом
тесте.

В этом разделе мы рассмотрим, как работать с базой во время тестов. Начнем с
первого шага~--- подготовки новой базы. Под этим понимают создание таблиц,
индексов и других сущностей \emph{без вставки} данных.

Физически базу создают еще до того, как запустились тесты. Способ зависит от
того, как работает база: локально или в Докере. Если локально, достаточно
нескольких утилит. Ниже мы вызываем утилиты \spverb|createuser| и
\spverb|createdb|, которые входят входят в поставку PostgreSQL.

\begin{english}
  \begin{bash}
createuser book_test -S -W
createdb -O book_test book_test
  \end{bash}
\end{english}

Первая команда готовит нового пользователя БД с именем \spverb|book_test|. Ключ
\spverb|-S| означает, что это \emph{супер}пользователь, обладатель высших
привилегий. Они нужны, чтобы подключить расширения: триграммный поиск, прогрев
индексов и другие. В боевом запуске, наоборот, приложению выделяют минимальные
права, но для тестов это неважно. Вторая команда создает одноименную пустую
базу. Ключ \spverb|-O| (owner) задает владельца базы. Владелец имеет полный
доступ ко всем ее сущностям.

Если база работает в Докере, обратитесь к главе про системы. Там мы узнали, как
задать параметры базы в .yaml-файле и переменными среды.

Пустую базу наполняют таблицами. Если приложение ведет миграции, их запускают до
тестов из командной строки:

\begin{english}
  \begin{clojure}
lein migratus migrate
lein test
  \end{clojure}
\end{english}

Шага с миграциями можно избежать, если скопировать их в папку образа
\spverb|/docker-entrypoint-initdb.d|. Специальный скрипт выполнит все sql-файлы
из этой папки на старте образа. Убедитесь, что скопировали только
\spverb|up|-миграции, иначе их \spverb|down|-версии сведут пользу на нет.

Таблицы и индексы готовы, но нет данных. Переходим к основной задаче: перечислим
способы их вставки и очистки на время тестов.

\subsubsection*{Ручная вставка}

В простом случае данные для тестов хранят в виде коллекции. Специальная функция
пробегает по списку словарей; каждый словарь это запись в базе. Функцию
оборачивают в фикстуру, которая запускает тест после вставки всех записей.

\begin{english}
  \begin{clojure}
(def db-data
  [[:users {:name "Ivan" :email "ivan@test.com"}]
   [:users {:name "Juan" :email "Juan@test.com"}]
   [:groups {:name "Dog fans" :topics 6}]
   [:groups {:name "Cat fans" :topics 7}]])
  \end{clojure}
\end{english}

Здесь и ниже мы полагаем, что переменная \spverb|*db*| указывает на
JDBC-спеку. Не будем задаваться вопросом, откуда пришла эта переменная. Читатель
уже знаком с системами и конфигурацией и вправе задать \spverb|*db*| на свое
усмотрение.

\begin{english}
  \begin{clojure}
(defn load-data []
  (doseq [[table row] db-data]
    (jdbc/insert! *db* table row)))

(defn with-db-data [t]
  (load-data) (t))
  \end{clojure}
\end{english}

Заметим, что для каждой записи нужно знать ее таблицу. Это может быть первый
элемент пары \tuple{таблица, запись} или поле метаданных. Когда
записей одного типа много, имя таблицы становится избыточным. Логично
сгруппировать записи по таблицам и вставлять их не по одной, а разом, что
быстрее.

\begin{english}
  \begin{clojure}
(def db-data
  [[:users [{:name "Ivan" :email "ivan@test.com"}
            {:name "Juan" :email "Juan@test.com"}]]
   [:groups [{:name "Dog fans" :topics 6}
             {:name "Cat fans" :topics 7}]]])

(defn load-data []
  (doseq [[table rows] db-data]
    (jdbc/insert-multi! *db* table rows)))
  \end{clojure}
\end{english}

\subsubsection*{Вставка из CSV}

Когда записей много, хранить их в словарях неудобно. Ключи словаря занимают в
среднем половину его описания. Для тысячи записей мы столько же раз укажем
ключи. Если структура данных одинакова, их хранят в виде массива, а ключи
указывают один раз.

Именно так устроен формат
CSV\footurl{https://en.wikipedia.org/wiki/Comma-separated\_values}. Это текст,
где каждая строка означает запись, а поля разделены запятой. В первой строке
обычно идет заголовок~--- имена полей с тем же разделителем.

У CSV несколько преимуществ. Записи это массивы, а не словари, поэтому имена
полей не дублируются. CSV компактней JSON и аналогов. С ним работают табличные
редакторы, например Excel и OpenOffice. Можно открыть CSV как электронную
таблицу, добавить или удалить столбец, пересчитать ячейки формулой и сохранить
результат.

Отдельные базы данных читают и пишут CSV напрямую. На больших объемах вставка из
CSV работает быстрее, чем обычный \spverb|INSERT|.

Предположим, нам скинули данные о пользователях боевого сервера в CSV. Поместим
файл в ресурс \spverb|data/users.csv|. Вот несколько его первых строк:

\begin{english}
  \begin{text}
name,email
ivan,ivan@test.me
juan,juan@example.com
ioan,ioan@dunno.org
  \end{text}
\end{english}

Составим SQL-запрос с командой \spverb|COPY|. Это особый оператор, который
работает в PostgreSQL. Укажем таблицу, путь к CSV-файлу и его свойства. Под
свойствами понимают тип разделителя, формат файла и признак
заголовка. Разделителем может быть не только запятая, но и точка с запятой или
табуляция. Если заголовка нет, считается, что поля идут в том же порядке, что и
в таблице.

\begin{english}
  \begin{clojure}
(jdbc/execute! *db*
 "COPY users(name, email)
  FROM '/Users/ivan/work/book/env/test/resources/data/users.csv'
  DELIMITER ',' CSV HEADER")
  \end{clojure}
\end{english}

Заметим, что запрос ожидает полный путь к файлу, что мешает командной
работе. Вероятность того, что коллеги держат проект в папке
\spverb|/Users/ivan/work/book| равна нулю. Вам придется вычислить полный путь к
файлу из относительного.

Если в запросе нет ошибок, и файл на месте, и пользователя достаточно прав, в
таблице users окажутся данные из файла. Аналогично работает <<дамп>> таблицы в
файл: оператор \spverb|FROM| заменяют на \spverb|TO|.

Выполним загрузку из CSV силами Clojure. Усложним задачу тем, что в файле очень
много записей, и потому он сжат архиватором \spverb|gzip|. Это полезная
практика: все большие файлы в репозитории должны быть сжаты. Чтобы читать такой
файл на лету (без выгрузки во временную папку), понадобятся классы:

\begin{english}
  \begin{clojure}
(:import java.io.FileInputStream
         java.util.zip.GZIPInputStream
         org.postgresql.copy.CopyManager)
  \end{clojure}
\end{english}

\spverb|CopyManager| делает то же, что и команда COPY. Чтобы создать его
экземпляр, требуется соединение с базой (именно TCP-соединение, а не словарь
спеки). Получим его функцией \spverb|jdbc/get-connection|. Метод \spverb|copyIn|
принимает SQL-запрос и поток данных CSV. Стрим мы получим из ресурса
\spverb|data/users.csv.gz|, пропустив его через серию функций и
классов. Последний \spverb|GZIPInputStream| занимается тем, что по мере чтения
приводит сжатые данные к нормальному виду. В конце работы закрываем соединение с
базой.

\begin{english}
  \begin{clojure}
(defn load-data-gz []
  (let [conn (jdbc/get-connection *db*)
        copy (CopyManager. conn)
        stream (-> "data/users.csv.gz"
                   clojure.java.io/resource
                   clojure.java.io/file
                   FileInputStream.
                   GZIPInputStream.)]
    (.copyIn copy "COPY users(name, email)
                   FROM STDIN (FORMAT CSV, HEADER true)"
             stream)
    (.close conn)))
  \end{clojure}
\end{english}

Нельзя загрузить один файл сразу в несколько таблиц. Соблюдайте правило один
файл~--- одна таблица. Если файлов несколько, перепишите функцию так, чтобы она
принимала путь к файлу и имя таблицы. Импорт \emph{очень больших} данных
(миллион и больше) можно вести параллельно при помощи футур и \spverb|pmap|.

\subsubsection*{Проблема ключей}

Таблицы редко существуют сами по себе. Чаще всего они логически связаны:
пользователь ссылается на профиль, заказ на пользователя и так далее. Для этого
служат \emph{первичный} и \emph{внешний} ключи. Первичный ключ (PK, Primary key)
это поле, которое однозначно определяет запись в таблице. Внешний ключ (FK,
Foreign key) это поле, которое ссылается на первичный ключ другой таблицы. Все
вместе это называют \emph{отношением} таблиц.

Как правило, первичные ключи это целые числа с автоматической нумерацией. Чтобы
добавить запись в таблицу, не нужно подбирать новый PK. Если ключ с
автонумерацией, база данных ведет для него уникальный счетчик. Для очередной
записи счетчик вырастет на единицу. Имя счетчика в PostgreSQL строится по
шаблону \spverb|<table>_<pk>_seq|, например \spverb|users_id_seq|.

При вставке связанных данных их PK и FK должны быть равны. Проще всего задать их
вручную, например 3. В примере ниже пользователь ссылается на группу:

\begin{english}
  \begin{clojure}
(jdbc/insert! *db* :groups {:id 3 :name "Clojure fans"})
(jdbc/insert! *db* :users {:group_id 3 :name "Ivan"})
  \end{clojure}
\end{english}

Проблема в том, что случайный PK может вступить в конфликт со
счетчиком. Предположим, при вставке в \spverb|groups| счетчик был равен
нулю. Поскольку мы задали \spverb|id| явно, счетчик не увеличился. А теперь
нужны еще три группы. Нам не важен их \spverb|id|, поэтому опустим одноименный
ключ в словаре.  База назначит первичный ключ из счетчика. Две первых группы
получат значения 1 и 2. Для третьей возникнет ошибка:

\begin{english}
  \begin{text}
ERROR:  duplicate key value violates unique constraint 'groups_pkey'
DETAIL:  Key (id)=(3) already exists
  \end{text}
\end{english}

Ключ 3 в конфликте с записью, которую мы добавили в начале. Избежать этого можно
двумя способами: коррекцией счетчиков и особым загрузчиком данных. Разница в
том, кто контролирует счетчики: вы или база данных.

Под ручной коррекцией имеем в виду следующее. В тестовых данных явно указывают
первичные ключи. Для удобства некоторые из них выносят в переменную. Например,
если на админа ссылаются несколько сущностей, логично написать так:

\begin{english}
  \begin{clojure}
(def id-user-admin 1)

(def db-data
  [[:users [{:id id-user-admin :name "Ivan"}]]
   [:profiles [{:id 1 :user_id id-user-admin :avatar "..."}]
    :posts [{:id 1 :user_id id-user-admin :title "New book"}
            {:id 2 :user_id id-user-admin :title "Some post"}]]])
  \end{clojure}
\end{english}

После вставки данных поправим счетчики так, чтобы они перескочили значения,
которые мы использовали. Предположим, в тестовый набор входит семь
пользователей, и мы назначили им ключи от 1 до 7. Если установить счетчик в 100,
он уже не вернется к числам от 1 до 7. Дальнейшие записи в \spverb|users|
получат ключи 100, 101 и так далее.

Чтобы сбросить счетчик, выполните запрос:

\begin{english}
  \begin{clojure}
(jdbc/execute! *db* "ALTER SEQUENCE users_id_seq RESTART WITH 100")
  \end{clojure}
\end{english}

Если первичный ключ называется \spverb|id| (что рекомендуется), достаточно знать
только имя таблицы. Чтобы не перечислять таблицы вручную, получим их из массива
\spverb|db-data|. Добавьте в конец функции \spverb|load-data| код:

\begin{english}
  \begin{clojure}
(let [value 100
      tables (set (map first db-data))
      query "ALTER SEQUENCE %s_id_seq RESTART WITH %s"]
  (doseq [table tables]
    (jdbc/execute! *db* (format query (name table) value))))
  \end{clojure}
\end{english}

Он подхватит все таблицы, указанные в \spverb|db-data| и выставит счетчик в 100.
На больших данных из CSV эту цифру придется увеличить на порядок или два. Если
потребуется, по \spverb|id| вы отличите исходную запись от добавленной в
процессе. Например, запрос \spverb|delete ... where id > 100| удалит
записи, которые попали в базу после <<накрутки>> счетчиков.

Теперь рассмотрим свой загрузчик. В этом случае полагаются на ключи, которые
вернула база данных. Конкретные их значения не важны. Главное, чтобы у связанных
записей первичный и внешний ключи совпадали. Для этого пойдем на хитрость.

Для начала удалим первичные ключи из тестовых данных. Ни в одном словаре нет
поля \spverb|:id| с конкретным значением. Сущностям, на которые нужно ссылаться,
присвоим псевдонимы. Проще всего это сделать через поле в метаданных. В связных
сущностях в поле-ссылке укажем псевдоним.

\begin{english}
  \begin{clojure}
;; user
^{:entity :users/admin} {:name "Ivan" :email "ivan@test.com"}
;; profile
{:user_id :users/admin :avatar "/images/ivan.png"}
;; posts
{:user_id :users/admin :title "New book"}
{:user_id :users/admin :title "Some post"}
  \end{clojure}
\end{english}

Загрузчик перебирает записи и делает следующее. Если у записи псевдоним, мы
связываем его с ключом, который вернула база. На старте загрузчик объявляет атом
с пустым словарем и наполняет его в процессе. Например, при вставке первого
словаря вернулся ключ 42. Атом примет вид \spverb|{:users/admin 42}|.

Дополнительно загрузчик ищет ссылки в словаре перед записью. Если одно из полей
кейворд, считаем, что это внешний ключ. В словаре профиля встречается поле
\spverb|:user_id| со значением \spverb|:users/admin|. Очевидно, его нужно
заменить на то, что лежит в атоме не этому ключу (42). Если в атоме нет ключа,
бросаем исключение.

Предлагаем читателю написать загрузчик самостоятельно. Важный момент: ответ
\spverb|jdbc/insert!| зависит от типа базы данных. Приведем примеры для двух
популярных решений: PostgreSQL и MySQL/MariaDB. Обратите внимание, что даже для
одной записи вы получите список.

\begin{english}
  \begin{clojure}
(jdbc/insert! *db* :users {:name "Ivan"})
({:id 42 :name "Ivan}) ;; for PostgreSQL
({:generated_key 42})  ;; for MariaDB
  \end{clojure}
\end{english}

\subsubsection*{Удаление данных}

Очистка базы важна не меньше, чем наполнение. Она должна занимать минимум усилий
и не оставлять артефактов.

Наивный способ очистить базу~--- выполнить \spverb|DELETE FROM <table>| для всех
таблиц, с которыми работают тесты. Проблема \spverb|DELETE| в том, что он
учитывает зависимость ключей. Если запись из другой таблицы ссылается на
\spverb|users|, удалить пользователя не получится. Придется вызвать
\spverb|DELETE| в правильном порядке: сначала для связной таблицы, затем
\spverb|users|. Чем больше у вас таблиц, тем сложнее будет заполнить порядок.

Читатель, знакомый с PostgreSQL, возразит: каскадное удаление возможно при
помощи \spverb|ON DELETE| в описании ключа. Но это продвинутая техника со своими
недостатками, и сейчас мы не будем о ней говорить. Нас интересует как очистить
данные независимо от того, как заданы ключи и ссылки.

Команда \spverb|TRUNCATE| (анг. \emph{подрезать}) нужна для быстрой очистки
таблицы. В отличии от \spverb|DELETE| она не вызывает триггеры и не сканирует
всю таблицу. \spverb|TRUNCATE| принимает несколько таблиц за раз. Ее
преимущество в каскадном режиме. Если передан флаг \spverb|CASCADE|, все
таблицы, которые входят в граф связей, тоже очищаются. Каскадная очистка пары
таблиц вызывает цепную реакцию по всей базе.

Напишем функцию очистки. Она посылает запрос, в котором через запятую указаны
таблицы из данных для тестов. Добавьте ее в фикстуру \spverb|with-db-data| после
вызова \spverb|(t)|.

\begin{english}
  \begin{clojure}
(defn delete-data []
  (let [tables (set (map first db-data))
        tables-comma (clojure.string/join "," (map name tables))
        query (format "TRUNCATE %s CASCADE" tables-comma)]
    (jdbc/execute! *db* query)))
  \end{clojure}
\end{english}

\subsubsection*{Транзакция с откатом}

Другой способ избавиться от изменений в базе~--- обернуть действия с ней в
особую транзакцию. Она завершается оператором не \spverb|COMMIT|, а
\spverb|ROLLBACK|, что значит откатить все команды. С точки зрения базы это
выглядит так:

\begin{english}
  \begin{sql}
BEGIN;
INSERT INTO users ...
INSERT INTO profiles ...
UPDATE users SET name=...
ROLLBACK;
  \end{sql}
\end{english}

При выходе из транзакции мы не увидим эффекта \spverb|INSERT|, \spverb|UPDATE| и
других запросов на изменение.

В пакет JDBC входит функция \spverb|db-set-rollback-only!|. Она принимает
транзакционное соединение и выставляет ему флаг \spverb|rollback|. Если флаг
установлен, JDBC завершает блок оператором \spverb|ROLLBACK|.

Вы уже знакомы с макросом \spverb|with-db-transaction|: внутри его тела
действует транзакционное соединение, которые получают из JDBC-спеки. Напишем
макрос \spverb|with-db-rollback|, который делает то же самое, но дополнительно
устанавливает откат:

\begin{english}
  \begin{clojure}
(defmacro with-db-rollback
  [[t-conn & bindings] & body]
  `(jdbc/with-db-transaction [~t-conn ~@bindings]
     (jdbc/db-set-rollback-only! ~t-conn)
     ~@body))
  \end{clojure}
\end{english}

Макрос в действии:

\begin{english}
  \begin{clojure}
(with-db-rollback [tx *db*]
  (println "Inserting the data...")
  (jdbc/insert! tx :users {:name "Ivan"})
  (let [...]
    (do-something-with-db tx)))
  \end{clojure}
\end{english}

Разработчик следит за тем, чтобы все действия с базой протекали через
\spverb|tx|, а не \spverb|*db*|. Изменения в рамках обычного соединения
останутся в базе. Этим страдает загрузчик \spverb|load-data|: он ссылается на
глобальную переменную \spverb|*db*|. Если загрузчик <<упал>> на середине,
половина данных останется в базе. Чтобы загрузка была в транзакции, придется
передать параметр или связать \spverb|*db*| с \spverb|tx| формой
\spverb|binding|.

Пример с параметром: \spverb|load-data| принимает \spverb|tx|, который мы
установили на вершине теста.

\begin{english}
  \begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (load-data tx)
    (let [user (get-user-by-name tx "Ivan")]
      (is (= "Ivan" (:name user))))))
  \end{clojure}
\end{english}

Вариант с динамической переменной. В этом случае мы считаем, что все функции
ссылаются на \spverb|*db*|. Внутри макроса она станет транзакционным соединением
с откатом.

\begin{english}
  \begin{clojure}
(deftest test-user-with-rollback
  (with-db-rollback [tx *db*]
    (binding [*db* tx]
      (load-data) ;; parameter is not needed
      (let [user (get-user-by-name "Ivan")]
        (is (= "Ivan" (:name user)))))))
  \end{clojure}
\end{english}

Выбор зависит от того, как в проекте работают с базой. Решение с откатом
подходит для \spverb|mount| и похожей архитектуры, где база это глобальная
переменная. В случае с системой компонентов возникнут трудности с передачей
\spverb|tx| от теста к логике и наоборот.

Подумайте, как написать фикстуру с макросом \spverb|with-db-rollback|. Будет ли
она работать с системой компонентов? Что необходимо в этом случае?

\section{Тестирование веб-приложений}

До сих пор мы тестировали отдельные функции, связанные с расчетами. Эти тесты
необходимы, но недостаточны. Они защищают проект от случайных изменений, но не
обещают, что система устойчива. Поднимемся на уровень выше и рассмотрим, как
тестировать приложение целиком.

В главе про веб-разработку мы пришли к важному выводу. На каждом уровне
веб-приложение это функция одного аргумента. Обработчик запроса, маршруты,
цепочка middleware суть функции, которые принимают запрос и возвращают ответ.

Это определяет, как писать тесты для приложения. Тест составляет запрос и
вызывает приложение как функцию. Статус ответа проверяют на успех (200, 201) или
неудачу (404, 403). Если это JSON-ответ, его тело читают в коллекцию и
сравнивают с образцом.

Вспомним приложение из первой главы \page{compojure}. Отдельные страницы мы
соединили в маршруты с помощью Compojure. Получилось <<голое>> приложение. Мы
назвали его так потому, что оно многого не умеет. Например, читать параметры,
работать с JSON, сессиями и так далее. Эти возможности несут middleware, в
которые оборачивают приложение.

\begin{english}
  \begin{clojure}
(defroutes app-naked
  (GET "/"      request (page-index request))
  (GET "/hello" request (page-hello request))
  page-404)

(def app
  (-> app-naked
      wrap-session
      wrap-keyword-params
      wrap-params
      wrap-json-body
      wrap-json-response))
  \end{clojure}
\end{english}

Напишем несколько тестов для приложения. Проверим главную страницу и любую
другую, которой нет в маршрутах. Для экономии места проверим только статус
ответа.

\begin{english}
  \begin{clojure}
(deftest test-app-index
  (let [request {:request-method :get :uri "/"}
        response (app request)
        {:keys [status body]} response]
    (is (= 200 status))))

(deftest test-app-page-not-found
  (let [request {:request-method :get :uri "/missing"}
        response (app request)
        {:keys [status body]} response]
    (is (= 404 status))))
  \end{clojure}
\end{english}

Как видно из примеров, писать тесты для веб-приложения нетрудно. Если страница
обращается в сеть, вызов <<мокают>> или запускают стаб. В целом, работают все
приемы, что мы уже рассмотрели. Перечислим несколько новых, которые облегчат
вашу работу.

\subsubsection*{Приложение целиком}

Избегайте ситуации, когда тест вызывает не приложение, а один из
обработчиков:

\noindent
\begin{tabular}{ @{}p{5.5cm} @{}p{5.2cm} }

\begin{english}
  \begin{clojure}
;; bad
(deftest test-some-view
  (let [resp (page-index {...})
        {:keys [status]} resp]
    (is (= 200 status))))
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
;; good
(deftest test-some-view
  (let [resp (page-index {...})
        {:keys [status]} resp]
    (is (= 200 status))))
  \end{clojure}
\end{english}

\end{tabular}

Даже если страница работает, нет гарантии, что запрос пройдет сквозь
middleware. В боевых проектах они несут важную логику. Это права доступа, работа
с JWT, сессии. Убрав все это из теста, вы тем самым обманываете себя. Объект
\spverb|app|, который вы тестируете, должен быть максимально <<заряжен>>, то
есть близок к настоящему веб-серверу.

\subsubsection*{Библиотека запросов}

Выше мы объявили запрос в виде словаря. Это удобно, когда нет параметров строки
или тела. Если странице нужны параметры, придется писать их вручную, что
нечитаемо и тяжело в поддержке.

\begin{english}
  \begin{clojure}
{:request-method :get
 :uri "/users/?page=2&order=name&name=ivan&search_type=relevance"}
  \end{clojure}
\end{english}

Чтобы избежать ошибок, воспользуйтесь
\spverb|ring-mock|\footurl{https://github.com/ring-clojure/ring-mock}~---
библиотекой запросов к Ring-приложению. Ее функции покрывают основные сценарии в
тестах. Функция \spverb|request| принимает метод и путь. Если добавить словарь
параметров, то для \spverb|GET| они станут частью адреса, а для
\spverb|POST|~--- его телом. Библиотека берет на себя URL-кодирование. Функция
\spverb|json-body| пишет в запрос тело из коллекции.

Рассмотрим несколько примеров. \spverb|GET|-запрос по адресу \spverb|/help| :

\begin{english}
  \begin{clojure}
(mock/request :get "/help")
  \end{clojure}
\end{english}

Запрос к другой странице с параметрами:

\begin{english}
  \begin{clojure}
(mock/request :get "/movies" {:search "batman" :page 1})
  \end{clojure}
\end{english}

Запрос для отправки формы \spverb|POST /users|. Тело запроса станет классом
\spverb|ByteArrayInputStream|. Заголовок \spverb|Content-Type| равен
\spverb|application/x-www-form-urlencoded|.

\begin{english}
  \begin{clojure}
(mock/request :post "/users" {:name "Ivan" :email "test@test.com"})
  \end{clojure}
\end{english}

Случай для JSON-API. Адрес \spverb|/users| ожидает не поля формы, а
JSON-тело. Такой запрос составляют из двух функций:

\begin{english}
  \begin{clojure}
(-> (mock/request :post "/users")
    (mock/json-body {:name "Ivan" :email "test@test.com"}))
  \end{clojure}
\end{english}

Эти и другие функции описаны в документации на странице проекта.

\subsubsection*{Проверка тела}

Выше мы проверяли только статус ответа. На практике статуса недостаточно: число
200 еще не говорит, что пришло именно то, что нужно. Проверка тела зависит от
его типа. Если это текст или HTML, хватит и регулярного выражения. Например, по
фразе <<Login>> мы определим, что на этой странице пользователь не авторизован.

Интереснее вариант с JSON. В этом случае нужно восстановить коллекцию и сравнить
с образцом. Для простоты вызовем приложение \spverb|sites-handler|. Это
заглушка, которой мы пользовались для тестировании карт.

\begin{english}
  \begin{clojure}
(let [request (mock/request :get "/search/v1/" {:lat 11 :lon 22})
      response (sites-handler request)
      body (-> response :body (json/parse-string true))]
  (is (= {...} body)))
  \end{clojure}
\end{english}

Недостаток в том, что мы сравниваем данные как есть. В ответе могут быть поля,
которые меняются, например даты или \spverb|id|. Мы уже выяснили, что
\spverb|id| это ключ с автонумерацией. Если данные приходят из тестовой базы,
логично ожидать, что однажды их удалят и загрузят повторно, и номера будут
другими.

Перед сравнением лишние поля исключают с помощью \spverb|dissoc| и
\spverb|map|. Представим, что поиск кафе вернул следующий результат:

\begin{english}
  \begin{clojure}
{:sites [{:name "Site1" :date-updated "2019-11-12" :id 42}
         {:name "Site2" :date-updated "2019-11-10" :id 99}]}
  \end{clojure}
\end{english}

Напишем функцию, которая очищает тело от лишних полей.

\begin{english}
  \begin{clojure}
(defn fix-sites [body]
  (update body :sites
          (fn [sites]
            (map (fn [site]
                   (dissoc site :id :date-updated))
                 sites))))
  \end{clojure}
\end{english}

Теперь данные сравнивают не в лоб, а с помощью функции.

\begin{english}
  \begin{clojure}
(is (= {:sites [{:name "Site1"} {:name "Site2"}]}
       (fix-sites body)))
  \end{clojure}
\end{english}

Иногда проверяют не конкретные значения, а структуру ответа. Это удобно, когда
ответ развесистый: длинные списки, объемные словари. В таком случае пользуются
спекой или JSON-схемой. Преимущества спеки в том, что она лояльна к новым
полям. Если в ответ добавили новое поле, спека не упадет.

\begin{english}
  \begin{clojure}
(let [;; obtain the response
      body (-> response :body (json/parse-string true))]
  (is (s/valid? :api.search/result body)))
  \end{clojure}
\end{english}

Затраты на спеку окупаются в будущем. Ей проверяют входные параметры, генерируют
данные для тестов, описывают REST API (Swagger, RAML).

\section{Тестирование систем}

Коротко о том, как пишут тесты в проектах с системами, о которых мы говорили в
отдельной главе. Напомним, система это набор компонентов со связями между
ними. Покрыть тестами каждый компонент нетрудно; проблемы возникают при их
взаимодействии. В проекте обязательно должен быть тест, где система работает как
единое целое.

На время теста кто-то должен запустить систему и остановить ее. На эту роль
подходит фикстура. Предположим, система и функции \spverb|start!| и
\spverb|stop!| находятся в модуле \spverb|system.clj|. Напишем фикстуру
\spverb|fix-system|:

\begin{english}
  \begin{clojure}
(defn fix-system [t]
  (system/start!)
  (t)
  (system/stop!))
  \end{clojure}
\end{english}

На время теста в переменной \spverb|system/system| будет рабочая система. Другие
фикстуры, например для работы с базой, могут обратиться к компонентам
напрямую. Важно только, чтобы в вызове \spverb|use-fixtures| они шли в
правильном порядке (левее~--- раньше), иначе вы получите NPE-ошибки и другие
неприятности.

\begin{english}
  \begin{clojure}
(defn fix-db-data [t]
  (let [{:keys [db]} system/system]
    (prepare-test-data db)
    (t)
    (clear-test-data db)))

(use-fixtures :once fix-system fix-db-data)
  \end{clojure}
\end{english}

Фикстура \spverb|fix-db-data| нарушает правило, о котором мы говорили в главе
про системы. Это правило о том, что к системе нельзя обращаться напрямую и
копаться в ее компонентах. Для тестов в этом плане действуют
послабления. Обращаться к системе нельзя в промышленном коде. Тесты это не
промышленный код, поэтому на небольшие нарушения порой закрывают глаза.

Фикстура \spverb|fix-system| неслучайно стоит под ключом \spverb|:once|. Запуск
и остановка системы занимают много времени. В наших интересах прогнать как можно
больше тестов, пока система работает. Если же делать это поштучно, процесс
затянется надолго. Вы столкнетесь с этой проблемой при запуске тестов из
CIDER. Даже для одного теста придется ждать, пока сработают фикстуры, в том
числе \spverb|fix-system|.

Кажется, что пять секунд это немного. Но представьте, что работаете над задачей
и запускаете тест раз за разом~--- подобные паузы раздражают и сбивают с
ритма. Рассмотрим технику, которая решит проблему ожидания. Потребуется два
шага.

Первый~--- улучшить систему, чтобы она знала о своем состоянии. Например,
включена она сейчас или выключена. Проще всего это сделать полем с
метаданными. Вынесем имя поля в отдельную переменную. Перепишем \spverb|start!|
так, чтобы в метаданных системы появился флаг со значением \spverb|true|.

\begin{english}
  \begin{clojure}
(def state-field ::started?)

(defn start! []
  (let [sys (-> system
                component/start-system
                (with-meta {state-field true}))]
    (alter-var-root #'system (constantly sys))))

(defn started? []
  (some-> system meta (get state-field)))
  \end{clojure}
\end{english}

По аналогии изменим \spverb|stop!|, только флаг становится ложью. Функция
\spverb|started?| возвращает флаг из метаданных системы.

Второй шаг~--- перед тем, как включить систему в фикстуре, проверяем, была ли
она запущена вручную. Если нет, фикстура работает как обычно: запуск, тест,
остановка. Если система уже работает, это значит, кто-то управляет ей в ручном
режиме. В этом случае фикстура только выполнит тест, что гораздо быстрее.

\begin{english}
  \begin{clojure}
(defn fixture-system [t]
  (let [started-manually? (system/started?)]
    (when-not started-manually?
      (start!))
    (t)
    (when-not started-manually?
      (stop!))))
  \end{clojure}
\end{english}

Выполните в REPL (system/start!). Теперь вызывайте тест сколько угодно раз~---
не придется ждать систему.

\section{Интеграционные тесты}

Не протяжении главы мы постепенно усложняли тесты. С каждым шагом они все меньше
зависят от технических деталей и делают упор на бизнес-логику. Этот принцип
называют пирамидой тестов. В основании лежат юнит-тесты~--- множество отдельных
проверок. Поднимаясь к вершине, мы абстрагируемся от технических деталей. В
какой-то момент тестируют не функции, а части приложения.

Каждый уровень требует специальных знаний. Читатель готов к тому, чтобы
подняться на последний этаж~--- освоить \emph{интеграционное}
тестирование. По-другому их еще называют UI- или Selenium-тестами в честь
одноименного фреймворка. Для реалистичности запросы шлют не программно, а
имитируют действия человека. Например, управляют браузером: вводят данные в
форму, нажимают кнопку и проверяют, что появился нужный текст.

Интеграционные тесты работают медленно, потому что включают полный цикл
приложения. Это загрузка страницы, выполнение скриптов, реакция браузера. Если
возникнет ошибка, ее трудно расследовать из-за длины цепи. Представьте, что вы
нажали на кнопку, но текст не появился. Возможны десятки причин, почему этого не
произошло.

Рассмотрим, как писать UI-тесты на Clojure. С подготовительной частью вы уже
знакомы: нужно запустить систему и наполнить базу тестовыми данными. Новый тест
ведет себя по-другому: он захватывает контроль над браузером и командует
им. Например, открывает страницу \spverb|http://127.0.0.1:8080/| и щелкает по
ссылкам. В любой момент мы получим адрес страницы, ее заголовок и HTML-код. В
тест добавляют формы \spverb|(is (= ...))|, чтобы проверить, на какой странице
мы оказались или что видит пользователь.

Чтобы управлять браузером, нужен драйвер и библиотека к нему. Под драйвером
понимают утилиту командной строки. Когда драйвер запущен, он принимает запросы
по протоколу HTTP. Одновременно драйвер запускает браузер в особом режиме, и
между ними образуется связь. Драйвер это посредник между двумя акторами. Он
переводит HTTP-запросы в бинарный протокол браузера и наоборот.

Каждый браузер работает со своим драйвером. Для Chrome он называется
\spverb|chromedriver|, для FireFox~--- \spverb|geckodriver|. Одноименные утилиты
ставятся из пакетных менеджеров \spverb|apt|, \spverb|yum| или
\spverb|brew|. Пользователи Windows скачают бинарные файлы с сайта
проекта. Драйвер к Safari называется \spverb|safaridriver|. С версии 13 он идет
в комплекте с Mac OS.

Для работы с драйвером подойдет библиотека
\spverb|etaoin|\footurl{https://github.com/igrishaev/etaoin}. Добавьте ее в
зависимости профиля \spverb|:dev| (только для тестов):

\begin{english}
  \begin{clojure}
:dev {:dependencies [[etaoin "0.3.6"]]}
  \end{clojure}
\end{english}

Убедитесь, что драйвер находится в одной из папок, перечисленных в
\spverb|PATH|, например \spverb|/usr/local/bin|. Для этого выполните
\spverb|chromedriver| или \spverb|geckodriver| в терминале. Путь до драйвера
можно задать в опциях библиотеки, но проще положить его в \spverb|PATH|.

Напишем первый тест. Представим, что локальный сервер работает на порту
8080. Тест открывает форму входа, заполняет поля и нажимает кнопку
<<Login>>. Браузер обновляет страницу; наверху видно приветствие. Видны
элементы, которые прежде были скрыты (ссылки <<My profile>>, <<Logout>>).

\begin{english}
  \begin{clojure}
(ns project.integration-tests
  (:require [etaoin.api :as e]))

(deftest test-ui-login-ok
  (e/with-chrome {} driver
    (e/go driver "http://127.0.0.1:8080/login")
    (e/wait-visible driver {:fn/has-text "Login"})
    (e/fill driver {:tag :input :name :email} "test@test.com")
    (e/fill driver {:tag :input :name :password} "password")
    (e/click driver {:tag :button :fn/text "Login"})
    (e/wait-visible driver {:fn/has-text "Welcome"})
    (is (e/visible? driver {:tag :a :fn/text "My profile"}))
    (is (e/visible? driver {:tag :button :fn/text "Logout"}))))
  \end{clojure}
\end{english}

Разберем отдельные выражения. Форма \spverb|with-chrome| это макрос, который
запускает Хром на время исполнения тела. Макрос необходим, чтобы гарантированно
закрыть драйвер при выходе или в случае ошибки. Без него пришлось бы добавить
\spverb|try/catch|, что порождает вложенность и в целом неудобно:

\begin{english}
  \begin{clojure}
(let [driver (e/chrome)]
  (try
    (e/go driver "http://...")
    (e/click driver {:tag :button})
    (finally
      (e/quit driver))))
  \end{clojure}
\end{english}

Функция \spverb|wait-visible| ждет до тех пор, пока элемент не появится на
экране. К ней часто прибегают, чтобы дождаться, пока браузер нарисует
верстку. Если не разделить две команды ожиданием, между ними будет разница в
несколько миллисекунд. Браузер либо не успеет выполнить первое действие, либо
отбросит второе.

Ожидание в UI-тестах это нормально. Основное время уходит на то, чтобы выполнить
действия с задержкой, как это свойственно человеку. \spverb|Wait-visible| это
лишь одна из семейства \spverb|wait|-функций. В их число входит
\spverb|wait-has-text| (дождаться текст на экране), \spverb|wait-has-class|
(ждать, пока у элемента не появится класс) и другие.

Драйвер ищет элементы на странице с помощью \emph{селекторов}. Это строки с
особыми выражениями. Различают CSS- и XPath-селекторы. Мы не будем досконально
разбирать их синтаксис: это долго и заслуживает отдельной главы.

Для краткости рассмотрим альтернативу: на элемент можно сослаться, задав его
свойства словарем. Ключи \spverb|tag| и \spverb|id| означают имя тега и
идентификатор. Другие ключи означают атрибуты тега. В примере выше селектор
\spverb|{:tag :input :name :email}| становится выражением
\spverb|.//input[@name="email"]| на языке XPath.

Ключ \spverb|index| ссылается на $i$-ый элемент, если селектор нашел
несколько. Например, \spverb|{:tag :button :index 1}| вырождается в
\spverb|.//button[1]|. Индекс считают от нуля. Ключи с пространством \spverb|fn|
особые: они означают вызов функции XPath. В примере ниже ключ
\spverb|:fn/has-class| вызывает \spverb|contains| на имени класса:

\begin{english}
  \begin{clojure}
{:tag :a :fn/has-class "active"}
;; .//a[contains(@class, "active")]
  \end{clojure}
\end{english}

При помощи словаря можно сослаться на любой элемент страницы. Если путь к
элементу не получается записать словарем, исправьте верстку: добавьте класс или
идентификатор. В особых случаях элемент ищут в рамках другого элемента, чтобы
сузить выборку. Эти и другие ключи с примерами описаны в документации к
библиотеке.

Написанный тест можно улучшить по следующим пунктам.

\textbf{Конфигурация.} Порт 8080 <<захардкожен>> в теле теста. Мы уже знаем, что
подобные значения приходят из конфигурации. Исправьте тест так, чтобы и сервер,
и драйвер работали с одним и тем же портом.

\textbf{Фикстура.} Вспомним, как работает \spverb|with-chrome|: он создает новый
драйвер, выполняет тело и выключает его. Это напоминает систему. Если каждый
тест обернут в \spverb|with-chrome|, мы теряем время, многократно повторяя те же
шаги. Сделаем так, чтобы драйвер работал на протяжении всего прогона
тестов. Объявим динамическую переменную и фикстуру, которая связывает драйвер на
время тестов. Зарегистрируем ее с ключом \spverb|:once|.

\begin{english}
  \begin{clojure}
(defonce ^:dynamic *driver* nil)

(defn fix-chrome [t]
  (e/with-chrome {...} driver
    (binding [*driver* driver]
      (t))))
  \end{clojure}
\end{english}

\textbf{Второй браузер.} Мы тестируем приложение в Хроме, самом популярном
браузере. Но приходит задача~--- проверить, что поддерживается и Firefox. Это
значит, все тесты, которые мы написали для Хрома, должны сработать еще раз в
другом браузере. При этом мы не должны ничего копировать.

Поможет мульти-фикстура, с которой мы знакомились в середине главы. Она
пробегает по списку \emph{типов} браузеров. В примере ниже это \spverb|:chrome|
и \spverb|:firefox|. Макрос \spverb|with-driver| это общий случай
\spverb|with-chrome|. Отличие в том, что \spverb|with-driver| ожидает первым
аргументом тип браузера. На каждом шаге фикстура связывает драйвер с переменной
и выполняет тест.

\begin{english}
  \begin{clojure}
(defn fix-multi-driver [t]
  (doseq [driver-type [:chrome :firefox]]
    (e/with-driver driver-type {} driver
      (binding [*driver* driver]
        (testing (format "Browser %s" (name driver-type))
          (t))))))
  \end{clojure}
\end{english}

Теперь тесты сработают в каждом из браузеров. Для ясности мы обернули тест
сообщением о том, в рамках какого браузера его вызывают. Чтобы добавить новый
браузер, например Safari, расширьте список его типом.

\textbf{Пакетные действия.} Еще один способ улучшить тесты~--- вынести
одинаковые действия в фикстуру или функцию. Предположим, каждый тест начинается
с авторизации и заканчивается выходом из системы. Чтобы не копировать эти
действия каждый раз, напишем фикстуру \spverb|fix-login-logout|. В отличии от
предыдущих фикстур, ей назначают ключ \spverb|:each|.

\begin{english}
  \begin{clojure}
(defn fix-login-logout [t]
  (doto *driver*
    (e/go "http://127.0.0.1:8080/login")
    (e/fill {:tag :input :name :email} "test@test.com")
    (e/click {:tag :button :fn/text "Login"}))
  (t)
  (doto *driver*
    (e/click {:tag :button :fn/text "Logout"})
    (e/wait-has-text "Login")))
  \end{clojure}
\end{english}

Другие сложные действия выносите в функции. Например, ввод нужной даты в виджет
календаря может занять до десяти команд. Напишите условную функцию
\spverb|set-widget-date|, которая принимает драйвер, имя поля и дату, которую
нужно ввести.

\textbf{Используйте doto.} Когда несколько форм принимают одинаковый первый
аргумент, их объединяют в макрос \spverb|doto|. Он подставит \spverb|*driver*|
на второе место в каждый список тела. С \spverb|doto| код становится немного
короче и чище.

\section{Другие решения}

Перечислим другие библиотеки, полезные для тестов. Мы не будем изучать их
подробно: ограничимся кратким и примером кода. Подробности ищите в документации
к проектам.

\subsection{Продвинутые моки}

На минуту вернемся к мокам~--- подмене функции через
\spverb|with-redefs|. Макрос слишком многословен, чтобы работать с ним
напрямую. Появились библиотеки, которые описывают мокинг короче и
выразительнее. Одна из них называется
\spverb|mockery|\footurl{https://github.com/igrishaev/mockery}. Библиотека
предлагает макрос \spverb|with-mock|:

\begin{english}
  \begin{clojure}
(with-mock mock
  {:target :project.path/get-geo-point
   :return {:lat 14.23 :lng 52.52}}
  (get-geo-point "cafe" "200m"))
  \end{clojure}
\end{english}

Первый аргумент это символ, с которым связан будущий мок. Ключ \spverb|:target|
задает путь к объекту, который нужно заменить, а \spverb|:return|~---
результат. Выше мы <<замокали>> функцию \spverb|get-geo-point|, которая, судя по
названию, обращается к сервису карт.

Объект \spverb|mock| это атом, внутри которого словарь. Он наполняется данными
по мере того, как мы вызываем цель. Например, сколько раз ее вызвали и с какими
аргументами. Ниже мы добавили проверки на то, что функцию вызвали один раз с
аргументами \spverb|cafe| и \spverb|200m|.

\begin{english}
  \begin{clojure}
(let [{:keys [called? call-count call-args]} @mock]
  (is called?)
  (is (= 1 call-count))
  (is (= '("cafe" "200m") call-args)))
  \end{clojure}
\end{english}

Библиотека \spverb|spy|\footurl{https://github.com/alexanderjamesking/spy}
работает похожим образом. На функцию садят <<шпиона>>, который копит данные о
вызове.

\begin{english}
  \begin{clojure}
(defn adder [x y] (+ x y))
(def spy-adder (spy/spy adder))

(testing "calling the function"
  (is (= 3 (spy-adder 1 2))))

(testing "calls to the spy can be accessed via spy/calls"
  (is (= [[1 2]] (spy/calls spy-adder))))
  \end{clojure}
\end{english}

\subsection{Альтернативный синтаксис}

Проект \spverb|midje|\footurl{https://github.com/marick/Midje} предлагает другой
способ писать тесты. В этой библиотеке работают с \emph{фактами}. Факт это набор
проверок, сгруппированных по смыслу. Запишем факты о функции \spverb|split|:

\begin{english}
  \begin{clojure}
(facts "about split"
 (str/split "a/b/c" #"/") => ["a" "b" "c"]
 (str/split "" #"irrelvant") => [""])
  \end{clojure}
\end{english}

Стрелка между выражениями это особый оператор, который называется \emph{extended
  equality}, продвинутое равенство. С ее помощью величины сравнивают
короче. Например, форма \spverb|1 => even?| приходит к виду \spverb|(even? 1)|.
\spverb|Midje| предлагает и другие, более сложные стрелки для коллекций и
макросов.

\subsection{Вывод XUnit}

Плагин \spverb|test2junit|\footurl{https://github.com/ruedigergad/test2junit}
пишет отчет в XML-файл формата XUnit. Системы вроде CircleCI или TeamCity
понимают, как вывести его графически. Такой отчет легче читать, чем вывод
консоли: ошибки выделены красным, стектрейсы спрятаны под выпадающие
элементы.

Добавьте плагин в lein и задайте папку, куда писать файл. После прогона тестов
проверьте, что в ней появился XML-отчет.

\begin{english}
  \begin{clojure}
:plugins [[test2junit "1.1.2"]]
:test2junit-output-dir "target/test2junit"
  \end{clojure}
\end{english}

\subsection{Генерация данных}

Иногда для тестов нужен большой объем данных, например сто или двести тысяч
записей. При этом данные должны быть разнообразны~--- не подойдет один и тот же
набор, скопированный тысячу раз. Поможет библиотека \spverb|test.check|. Ее
модуль \spverb|gen| производит случайные данные по заданным правилам. Особенно
полезна генерация записей. В примере ниже мы получаем кортеж строки, числа и
булева типа. Затем передаем его в конструктор \spverb|->User|.

\begin{english}
  \begin{clojure}
(defrecord User [user-name user-id active?])

(def user-gen
  (gen/fmap (partial apply ->User)
            (gen/tuple (gen/not-empty gen/string-alphanumeric)
                       gen/nat
                       gen/boolean)))

(last (gen/sample user-gen))
;; #user.User{:user-name "dfgJKSHF3"
;;            :user-id 5
;;            :active? false}
  \end{clojure}
\end{english}

Библиотека \spverb|clojure.spec|, которой мы посвятили главу, идет еще дальше. С
помощью \spverb|test.check| она генерирует данные \emph{по спеке}. Появляется
еще одно свойство спек: кроме проверки, они подходят для тестовых
данных. Перепишем генерацию на спеку:

\begin{english}
  \begin{clojure}
(s/def :user/id int?)
(s/def :user/name string?)
(s/def :user/active? boolean?)
(s/def ::user (s/keys :req-un [:user/id :user/name :user/active?]))

(gen/generate (s/gen ::user))
{:id 88546920, :name "Z4MO7GH80k3mRD", :active? true}
  \end{clojure}
\end{english}

Возможности \spverb|spec.gen| обширны. С ее помощью порождают связанные данные,
например, пользователей, которые ссылаются на профили и наоборот. Вместо
случайных величин можно задать допустимые значения (список имен, городов). Спеки
могут быть любой вложенности, что открывает поле для экспериментов.

\section{Заключение}

Тест это код, который проверяет другой код. Тест защищает проект от случайных
изменений. Без тестов появляется эффект бабочки: изменение в одном месте
задевает другое.

Различают несколько видов тестов. Чаще всего работают с юнит-тестами, которые
еще называют модульными. Они проверяют функции из одноименного пространства. С
юнит-тестами связан термин <<покрытие>>. Это доля кода, который сработал во
время запуска тестов. Достаточным считается покрытие около 80\%. При анализе
покрытия смотрят, все ли ветки алгоритма приняли участие.

Чтобы подготовить тест к запуску, применяют фикстуры. Это функции, которые
вызывают тест до или после каких-то действий. Различают одно- и многоразовые
фикстуры, \spverb|:once| и \spverb|:each|. Фикстуры разнообразны: это может быть
запись в базу, локальный сервер, система компонентов. Иногда фикстура вызывает
тест несколько раз в цикле.

Чтобы выполнить подмножество тестов, применяют теги и селекторы. Тег это поле
метаданных теста. Селектор~--- функция, которая принимает метаданные и
возвращает истину или ложь. Тесты группируют в наборы, потому что не всегда
можно выполнить их все в текущем окружении.

Если код обращается к сети, помогут моки и стабы. Мок это подмена кода в момент
исполнения. Например, функцию \spverb|get-events| заменяют на
\spverb|(constantly {...})|.  Стаб это полноценный сервер на локальном
порту. Функцию \spverb|get-events| нацеливают на локальный хост с помощью
конфигурации. Сервер раздает данные, которые скопировали из боевого
источника. Чтобы не засорять код, данные хранят в файле.

Файлы в папке \spverb|resources| особые: JVM работает с ними как с
\emph{ресурсами}. Проект настраивают так, что в режиме тестов доступны новые
пути для ресурсов. Убедитесь, что при сборке \spverb|uberjar| в него не попали
данные для тестов.

Негативные сценарии важны в той же степени, что и позитивные. Проверяйте
неверные параметры и права доступа. Чтобы не повторяться, выносите повторы в
списки и пробегайте по ним в \spverb|doseq|.  Если вы \emph{ожидали} ошибки, но
ее не произошло, это \emph{ошибка}. Макрос \spverb|(is (thrown?...))| служит для
таких ситуаций.

Интеграционные (UI-) тесты проверяют программу целиком. Они имитируют действия
человека, что занимает больше времени. Технически тест управляет браузером или
мобильным устройством. Типичный сценарий теста~--- нажать на элементы и
проверить, что появился или исчез другой элемент. Интеграционные тесты дороги в
поддержке, поэтому их внедряют в последнюю очередь.

Clojure предлагает библиотеки и утилиты, чтобы помочь с тестами. Из коробки
доступен \spverb|clojure.test|, базовый фреймворк. Утилита \spverb|lein|
содержит модуль \spverb|test| для прогона тестов. Сторонники \spverb|deps.edn|
пользуются \spverb|test-runner|. Другие решения меняют синтаксис тестов,
отчетность, упрощают подмену функций.
