\chapter{Конфигурация}

\index{конфигурация}

\label{chapter-config}

\begin{teaser}
В этой главе мы рассмотрим, как сделать проект на Clojure удобным в
настройке. Разберем основы конфигурации: форматы файлов, переменные среды,
библиотеки, их достоинства и недостатки.
\end{teaser}

\section{Постановка проблемы}

В материалах по Clojure встречаются примеры:

\begin{english}
  \begin{clojure}
(def server
  (jetty/run-jetty app {:port 8080}))

(def db {:dbtype   "postgres"
         :dbname   "test"
         :user     "ivan"
         :password "test"})
  \end{clojure}
\end{english}

Это сервер на 8080 порту и параметры подключения к базе. Польза примеров в том,
что их можно скопировать в REPL и оценить результат: открыть страницу в браузере
или прочитать таблицу.

На практике код пишут так, чтобы в нем не было конкретных цифр и строк. С точки
зрения проекта плохо, что серверу явно задали порт. Это подойдет для
документации и примеров, но не боевого запуска.

Порт 8080 и другие комбинации нулей и восьмерок популярны у
программистов. Велики шансы, что порт занят другим сервером. Это случается,
когда запускают не отдельный сервис, а их связку на время разработки или тестов.

Код, написанный программистом, проходит несколько стадий. В~разных фирмах набор
отличается, но в целом это разработка, тестирование, предварительный и боевой
запуск.

\index{хардкод}
\index{hardcode}

На каждой стадии приложение запускают бок о бок с другими
проектами. Предположение, что порт 8080 свободен в любой момент это утопия. На
жаргоне разработчиков ситуацию называют <<хардкод>> (анг. <<hardcode>>) или
<<прибито гвоздями>>. Когда в коде <<прибитые>> значения, это вносит проблемы в
его цикл. Вы не сможете одновременно работать над проектом и тестировать его.

Приложение не должно знать порт сервера~--- информация об этом приходит извне. В
простом случае это файл настроек. Программа читает из него порт и запускает
сервер именно так, как это нужно на конкретной машине.

\index{менеджер конфигураций}

В более сложных сценариях файл составляет не человек, а специальная
программа~--- менеджер конфигураций. Менеджер хранит информацию о топологии
сети, адреса машин, параметры доступа к базам. По запросу он выдает файл для
определенной машины или сегмента сети.

Процесс, когда приложению сообщают параметры, а оно принимает их, называется
конфигурацией. Это интересный и важный процесс. Когда он устроен удачно, проект
легко проходит по всем стадиям производства.

\section{Семантика}

Цель конфигурации в том, чтобы управлять программой, не меняя е\"{е} код. К ней
приходят с ростом кодовой базы и инфраструктуры. Если у вас мелкий скрипт на
Python, нет ничего зазорного в том, чтобы открыть его в блокноте и поменять
константу. На предприятиях такие скрипты работают годами.

Чем сложнее инфраструктура фирмы, тем больше в ней ограничений. Современный
подход сводит на нет спонтанные изменения в проекте. Нельзя сделать \spverb|git push|
напрямую в мастер; запрещен \spverb|merge|, пока вашу работу не одобрят
двое коллег; приложение не попад\"{е}т на сервер, пока не пройдут тесты.

Это приводит к тому, что малейшее изменение в коде займет час, чтобы попасть в
бой. Правка в конфигурации дешевле, чем выпуск новой версии продукта. Из этого
следует правило: если можно вынести что-то в конфигурацию, сделайте это сейчас.

\index{фичи}
\index{feature flags}

В крупных фирмах практикуют то, что называют <<feature flag>>. Это логическое
поле, которое включает целый пласт логики в приложении. Например, новый
интерфейс, систему обработки заявок, улучшенный чат. Обновления тестируют внутри
фирмы, но всегда остается риск, что в бою \emph{что-то пойдет не так}. Тогда
флаг меняют на ложь и перезапускают сервер. Это не только сэкономит время, но и
сохранит репутацию фирмы.

\section{Цикл конфигурации}

При запуске приложение ищет конфигурацию. Чем лучше устроено приложение, тем
больше его частей опирается на параметры. Обработка конфигурации это не
монолитная задача, а набор шагов. Перечислим наиболее важные из них.

На первом этапе программа \textbf{читает конфигурацию}. Чаще всего это файл или
переменные среды. Данные в файлах хранят в форматах JSON, YAML и
других. Приложение несет на борту код, чтобы разобрать формат и получить
данные. Мы рассмотрим плюсы и минусы известных форматов ниже.

Переменные среды это часть операционной системы. Представьте~их как глобальный
словарь в памяти. Каждое приложение наследует его при запуске. Языки и
фреймворки предлагают функции, чтобы считать переменные в строки и словари.

Файлы и переменные среды дополняют друг друга. Например, приложение читает
данные из файла, но путь к нему ищет в переменных среды. Или в файле опущены
критические данные: пароли, API-ключи. Так поступают, чтобы их не увидели другие
программы, в том числе шпионские. Приложение читает параметры из файла, а
секретные данные из переменных.

\index{теги}

Продвинутые конфигурации используют теги. В файле перед значением
ставят тег: \spverb|:password #env DB_PASSWORD|. Это значит, в поле
\spverb|password| не строка \spverb|DB_PASSWORD|, а значение одноим\"{е}нной
переменной.

Первый этап завершается тем, что мы получили данные. Неважно, был ли это файл,
переменные среды или что-то другое. Приложение переходит ко второму этапу~---
\textbf{выводу типов}.

\index{вывод типов}

JSON или YAML выделяют базовые типы: строки, числа, булево и~null. Легко
заметить, что среди них нет даты. С помощью дат задают промо-акции или события,
связанные с праздниками. В файлах даты указывают либо строкой в формате ISO,
либо числом секунд c 1 января 1970 года (эпоха UNIX). Специальный код пробегает
про данным и приводит даты к типу, принятому в языке.

Вывод типов применяют и для коллекций. Иногда словарей и массивов не хватает для
комфортной работы. Типы события хранят в виде множества, потому что оно отсекает
дубли и предлагает быструю проверку на вхождение. Скаляры тоже оборачивают в
классы, например, \spverb|UUID| для идентификаторов.

Переменные среды не настолько гибки, как современные форматы. Если JSON выделяет
скаляры и коллекции, то переменные несут только текст. Вывод типов для них не
просто желателен, а необходим. Нельзя передать порт в виде строки туда, где
ожидают число.

\index{валидация}

После вывода типов приступают к \textbf{валидации данных}. В главе про Spec мы
выяснили, что тип не обещает верное значение \page{type-and-pred}.
Проверка нужна, чтобы в конфигурации нельзя было указать порт 0, -1 или 80.

Из той же главы мы помним, что иногда значения верны по отдельности, но не могут
быть в паре. Пусть в конфигурации задан период акции. Это массив из двух дат,
начало и завершение. Легко перепутать даты местами, и проверка любой даты
на интервал верн\"{е}т ложь.

После валидации переходят к последней стадии. Приложение решает, где
\textbf{хранить конфигурацию}. Это может быть глобальная переменная или
компонент системы. Другие части программы читают параметры уже оттуда, а не из
файла.

\section{Ошибки конфигурации}

\index{ошибки!конфигурации}

На каждом этапе может возникнуть ошибка: не найден файл, нарушения в синтаксисе,
неверное поле. В этом случае программа выводит сообщение и завершается.
Сообщение должно четко ответить на вопрос, что случилось. Часто программисты
держат в голове только положительный путь и забывают об ошибках. При запуске
их программ виден стек-трейс, который трудно понять.

Если ошибка случилась на этапе проверки, объясните, какое поле тому виной. В
главе про Spec мы рассмотрели, как улучшить отч\"{е}т спеки \page{spec-messages}.
Это требует усилий, но окупается со временем.

\index{DevOps}
\index{отч\"{е}ты!explain}

В IT-индустрии одни сотрудники пишут код, а другие управляют им. Ваш
коллега-DevOps не знает, что такое Clojure и не поймет сырой
\spverb|explain|. Рано или поздно он попросит доработать сообщения
конфигурации. Сделайте это заранее из уважения к коллегам.

Если с конфигурацией что-то не так, программа не должна работать в надежде, что
вс\"{е} обойдется. Бывает, когда один из параметров задан неверно, но программа к
нему не обращается. Избегайте этого: ошибка появится в неподходящий
момент.

\index{каналы!stderr}

Когда один из шагов конфигурации не сработал, программа завершается с кодом,
отличным от нуля. Сообщение пишут в канал \spverb|stderr|, чтобы подчеркнуть
внештатную ситуацию. Продвинутые терминалы пчатают \spverb|stderr| красным
цветом.

\section{Загрузчик конфигурации}

\index{конфигурация!загрузка}

Чтобы закрепить теорию, напишем систему конфигурации. Это отдельный модуль
примерно на сто строк. Прежде чем садиться за редактор, обдумаем основные
положения.

Будем хранить конфигурацию в JSON-файле. Считаем, что фирма недавно перешла на
Clojure, и у DevOps уже написаны скрипты на Python для управления
настройками. Формат EDN усложнит работу коллегам.

\index{даты}

Путь к файлу задают в переменной среды \spverb|CONFIG_PATH|. От файла мы ожидаем
порт сервера, параметры базы данных и диапазон дат для промо-акции. Даты должны
стать объектами \spverb|java.util.Date|. Дата начала строго меньше конца.

Готовый словарь запишем в глобальную переменную \spverb|CONFIG|. Если на одном
из шагов случилась ошибка, покажем сообщение и завершим программу.

Начнем со вспомогательной функции \spverb|exit|. Она принимает код завершения,
текст и параметры форматирования. Если код равен нулю, пишем сообщение в
\spverb|stdout|, иначе в \spverb|stderr|.

\index{функции!exit}

\begin{english}
  \begin{clojure}
(defn exit
  [code template & args]
  (let [out (if (zero? code) *out* *err*)]
    (binding [*out* out]
      (println (apply format template args))))
  (System/exit code))
  \end{clojure}
\end{english}

Переходим к загрузчику. Это набор шагов, каждый из которых принимает результат
предыдущего. Логику каждого легко понять по имени. Вывод типов и валидация
совмещены в \spverb|coerce-config|, поскольку технически это вызов
\spverb|s/conform|.

\index{функции!load-config"!}

\begin{english}
  \begin{clojure}
(defn load-config! []
  (-> (get-config-path)
      (read-config-file)
      (coerce-config)
      (set-config!)))
  \end{clojure}
\end{english}

Теперь опишем каждый шаг. Функция \spverb|get-config-path| читает переменную
среды и проверяет, есть ли такой файл на диске. Если вс\"{е} в~порядке, функция
верн\"{е}т путь к файлу, а иначе вызовет \spverb|exit|:

\index{файлы}

\begin{english}
  \begin{clojure}
(import 'java.io.File)

(defn get-config-path []
  (if-let [filepath (System/getenv "CONFIG_PATH")]
    (if (-> filepath (new File) .exists)
      filepath
      (exit 1 "File %s does not exist" filepath))
    (exit 1 "File path is not set")))
  \end{clojure}
\end{english}

Шаг \spverb|read-config-file| читает файл по его пути. Для разбора JSON служит
библиотека Cheshire. Функция \spverb|parse-string| верн\"{е}т данные из
строки документа.

\index{библиотеки!Cheshire}
\index{модули!cheshire.core}

\begin{english}
  \begin{clojure}
(require '[cheshire.core :as json])

(defn read-config-file
  [filepath]
  (try
    (-> filepath slurp (json/parse-string true))
    (catch Exception e
      (exit 1 "Malformed config file: %s" (ex-message e)))))
  \end{clojure}
\end{english}

\index{валидация}
\index{вывод типов}
\index{идентичность}
\index{библиотеки!Expound}

Вывод типов и проверка это самый важный этап. Нельзя допустить, чтобы приложение
получило неверные параметры. Шаг \spverb|coerce-config| пропускает данные из
файла через \spverb|s/conform|. Вызов опасен исключением, поэтому обернем его в
\spverb|pcall| (безопасный вызов, который верн\"{е}т ошибку и результат). Если
результат \spverb|::s/invalid|, формируем отч\"{е}т об ошибке и завершаем
программу. Для отч\"{е}та возьмем библиотеку Expound. Функция
\spverb|s/invalid?| это быстрая проверка на \emph{идентичность}
\spverb|::s/invalid|. В отличии от равенства, идентичность работает быстрее.

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
(require '[expound.alpha :as expound])

(defn coerce-config [config]
  (let [[e result] (pcall s/conform ::config config)]
    (cond
      (some? e)
      (exit 1 "Wrong config values: %s" (ex-message e))

      (s/invalid? result)
      (let [report (expound/expound-str ::config config)]
        (exit 1 "Invalid config values: %s %s" \newline report))

      :else result)))
  \end{clojure}
\end{english}

Не хватает спеки. Откроем конфигурацию и изучим е\"{е} структуру:

\index{форматы!JSON}

\begin{english}
  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}
\end{english}

\noindent
Опишем спеку сверху вниз. На верхнем уровне это словарь с ключами:

\begin{english}
  \begin{clojure}
(s/def ::config
  (s/keys :req-un [::server_port ::db ::event]))
  \end{clojure}
\end{english}

\index{даты!диапазон}

Порт сервера это комбинация двух предикатов: число и вхождение в диапазон.
Проверка на число нужна, чтобы во второй предикат не попали \spverb|nil| и
строка. Это вызовет исключение там, где его не ждали.

\begin{english}
  \begin{clojure}
(s/def ::server_port
  (s/and int? #(<= 1024 % 65534)))
  \end{clojure}
\end{english}

\index{spec!::ne-string}

\noindent
Подключение к базе данных. Напомним, что \spverb|::ne-string| означает
непустую строку.

\begin{english}
  \begin{clojure}
(s/def :db/dbtype   #{"mysql"})
(s/def :db/dbname   ::ne-string)
(s/def :db/user     ::ne-string)
(s/def :db/password ::ne-string)

(s/def ::db
  (s/keys :req-un [:db/dbtype
                   :db/dbname
                   :db/user
                   :db/password]))
  \end{clojure}
\end{english}

Поле \spverb|event| сложное. На верхнем уровне это кортеж дат и проверка
диапазона:

\begin{english}
  \begin{clojure}
(s/def ::event
  (s/and (s/tuple ::->date ::->date)
         ::date-range))
  \end{clojure}
\end{english}

\index{даты!разбор}
\index{модули!clojure.instant}
\index{функции!read-instant-date}
\index{spec!::ne-string}
\index{spec!::\arr{}date}

Спека \spverb|::->date| выводит дату из строки. Чтобы не парсить е\"{е} вручную,
возьмем функцию \spverb|read-instant-date| из пакета \spverb|clojure.instant|.
Функция лояльна к формату и читает неполные даты, например, только год.
Обернем е\"{е} в \spverb|s/conformer|. Впереди ставим \spverb|::ne-string|,
чтобы отсечь мусор.

\index{read-instant-date}

\begin{english}
  \begin{clojure}
(require '[clojure.instant :as inst])

(s/def ::->date
  (s/and ::ne-string (s/conformer read-instant-date)))
  \end{clojure}
\end{english}

\index{классы!Date}
\index{clojure.core!compare}

Опишем проверку диапазона. Она принимает пару объектов \spverb|java.util.Date| и
сравнивает их. Даты нельзя сравнить знаками <<больше>> или <<меньше>>. Для этого
служит функция \spverb|compare|, которая верн\"{е}т -1, 0 и 1 для случаев меньше,
равно и больше.

\begin{english}
  \begin{clojure}
(s/def ::date-range
  (fn [[date1 date2]]
    (neg? (compare date1 date2))))
  \end{clojure}
\end{english}

На этом месте можно вызвать \spverb|load-config!| и убедиться, что на выходе
словарь с правильными типами. Последний шаг \spverb|set-config!| пишет словарь в
глобальную переменную \spverb|CONFIG|. Имя в верхнем регистре, чтобы не затенить
его локальной \spverb|config|. Для подмены переменной ипользуем
\spverb|alter-var-root|.

\index{clojure.core!alter-var-root}

\begin{english}
  \begin{clojure}
(def CONFIG nil)

(defn set-config!
  [config]
  (alter-var-root (var CONFIG) (constantly config)))
  \end{clojure}
\end{english}

На старте программы выполните \spverb|(load-config!)|, чтобы в переменной
появилась конфигурация. Другие модули импортируют \spverb|CONFIG| и читают
нужные им ключи. Вот как запустить сервер или выполнить запрос с учетом
конфигурации:

\index{JDBC!query}

\begin{english}
  \begin{clojure}
(require '[project.config :refer [CONFIG]])

(jetty/run-jetty app {:port (:server_port CONFIG)
                      :join? false})

(jdbc/query (:db CONFIG) "select * from users")
  \end{clojure}
\end{english}

\subsection{Работа над ошибками}

Мы написали загрузчик конфигурации. Он удобен в поддержке: каждый шаг это
функция, которую легко доработать. Это не промышленное решение, но подойдет для
небольших проектов.

В любой момент можно считать конфигурацию заново. Это удобно при разработке:
измените файл и выполните \spverb|load-config!| в REPL. В \spverb|CONFIG|
появится новая конфигурация.

\index{функции!exit}

Недостаток загрузчика в том, что код привязан к функции \spverb|exit|, которая
завершает JVM. Это верный подход в боевом запуске: нельзя продолжать, если в
параметрах ошибка. Однако в разработке от завершения больше проблем: любая
ошибка убивает REPL, и нужно включать его заново.

Завершение JVM это слишком радикальное действие. Ошибка и реакция на не\"{е}
должны быть разделены. Наивный способ~--- вызвать \spverb|load-config!| в рамках
подмены \spverb|exit|. Функция ниже не завершит JVM, а только бросит исключение
с текстом, который передали в \spverb|exit|:

\begin{english}
  \begin{clojure}
(defn load-config-repl! []
  (with-redefs
    [exit (fn [_ template & args]
            (let [^String message
                  (apply format template args)]
              (throw (new Exception message))))]
    (load-config!)))
  \end{clojure}
\end{english}

\index{die-fn}
\index{функции!смерти}
\index{REPL}

Более удачное решение~--- передать в \spverb|load-config!| дополнительные
параметры. Один из них это \spverb|:die-fn|, <<функция смерти>>, которая
принимает исключение. В боевом запуске она завершает JVM, а в разработке пишет
сообщение в REPL. Доработайте загрузчик так, чтобы он поддерживал параметр
\spverb|:die-fn|. Продумайте поведение по умолчанию, если он не задан.

Для вывода типов загрузчик опирается на \spverb|s/conform|. В главе про Spec мы
рассмотрели случай, когда \spverb|s/conform| добавляет логические теги и меняет
структуру данных \page{jdbc-conform-warning}. Если заменить спеку \spverb|::db|
на \spverb|::jdbc/db-spec|, получим тот самый случай. Чтобы избежать этого, мы
задали свою версию \spverb|::db| без макросов \spverb|s/or|.

\index{теги}

По-другому типы выводят с помощью \emph{тегов}. Эту технику мы обсудим в
следующих разделах главы.

\section{Подробнее о переменных среды}

\index{environment}
\index{переменные!среды}

Загрузчик читает данные из файла. Из переменных среды он берет лишь малую
часть~--- путь к файлу. Изменим загрузчик: пусть он читает данные из переменных
среды и не нуждается в файлах. Чтобы понять преимущества этого подхода,
поговорим о переменных в отрыве от языка.

Переменные среды называют ENV, <<энвы>> (анг. <<environment>>, окружающая
среда). Это фундаментальное свойство операционной системы. Представьте
переменные как глобальный словарь, который наполняется во время запуска
компьютера. В словаре основные параметры системы: локаль, список путей, где
система ищет бинарные файлы и многое другое.

\index{утилиты!printenv}

Чтобы увидеть текущие переменные, запустите в терминале \spverb|env| или
\spverb|printenv|. На экране появится пары \spverb|ИМЯ=значение|. Имена
переменных в верхнем регистре, чтобы выделить на общем фоне и подчеркнуть
приоритет. Большинство систем различают регистр, поэтому \spverb|foo| и
\spverb|FOO| это разные переменные. Пробелы и дефисы недопустимы; лексемы
отделяют подчеркиванием. Фрагмент \spverb|printenv|:

\begin{english}
  \begin{bash}
LANG=en_US.UTF-8
PWD=/Users/ivan
SHELL=/bin/zsh
TERM_PROGRAM=iTerm.app
COMMAND_MODE=unix2003
  \end{bash}
\end{english}

Каждый процесс получает копию этого словаря. Процесс может добавить или удалить
переменную, но изменения видны только ему и потомкам. Потомок процесса наследует
переменные родителя.

\subsection{Локальные и глобальные переменные}

\index{шелл}
\index{переменные!среды}

Различают переменные \emph{среды} и \emph{шелла}, они же глобальные и локальные
переменные. Их часто путают новички. Выполните в терминале команду:

\begin{english}
  \begin{bash}
$ FOO=42
  \end{bash}
\end{english}

Вы задали переменную шелла (командной оболочки). Чтобы сослаться на значение по
имени (<<дерефнуть>>), поставьте перед ней доллар. Пример напечатает 42:

\begin{english}
  \begin{bash}
$ echo $FOO
42
  \end{bash}
\end{english}

\index{переменные!шелла}

Если выполнить \spverb|printenv|, мы не увидим \spverb|FOO| в выводе. Команда
\spverb|FOO=42| зада\"{е}т переменную шелла, а не среды. Эти переменные видны только
ему и не наследуются потомками. Проверим это: из текущего шелла запустим новый и
повторим печать.

\begin{english}
  \begin{bash}
$ sh
$ echo $FOO
  \end{bash}
\end{english}

Получим пустую строку, потому что у потомка нет такой переменной. Выполните
\spverb|exit|, чтобы вернуться в родительский шелл.

\index{export}
\index{переменные!экспорт}
\index{переменные!шелла}

Команда \spverb|export| помещает переменную в среду. Заданная таким образом,
переменная видна \spverb|printenv| и доступна потомкам:

\begin{english}
  \begin{bash}
$ export FOO=42

$ printenv | grep FOO
FOO=42

$ sh
$ echo $FOO
42
  \end{bash}
\end{english}

Иногда нужно запустить процесс с переменной, но так, чтобы не повлиять на
текущее состояние. Тогда команду указывают после выражения
\spverb|ИМЯ=значение|:

\begin{english}
  \begin{bash}
$ BAR=99 printenv | grep BAR
BAR=99
  \end{bash}
\end{english}

\spverb|Printenv| порождает новый процесс, которому доступна переменная
\spverb|BAR|. Если снова напечатать \spverb|$BAR|, получим пустую строку.

\index{базы данных!PostgreSQL}

Программы читают параметры из переменных среды. Клиент к базе данных PostgreSQL
различает два десятка переменных: \spverb|PGHOST|, \spverb|PGDATABASE|,
\spverb|PGUSER| и другие. У переменных среды выше приоритет, чем у параметров
\spverb|--host|, \spverb|--user| и аналогов. Если в текущем шелле выполнить:

\begin{english}
  \begin{bash}
$ export PGHOST=host.com PGDATABASE=project
  \end{bash}
\end{english}

\noindent
, то каждая утилита PostgreSQL сработает на заданном сервере и базе. Это удобно
для серии команд: не прид\"{е}тся каждый раз указывать \spverb|--host| и другие
аргументы.

Обратите внимание на префикс \spverb|PG|. Он нужен, чтобы не затереть чужую
переменную \spverb|HOST|. В среде нет пространств имен, поэтому префикс это
единственный способ отделить ваши переменные от других.

\section{Конфигурация в среде}

Переменными среды можно задать конфигурацию. Каждый язык предлагает функции,
чтобы читать переменные в строки или словарь. Разберем плюсы и минусы этого
подхода.

Поскольку окружение находится в памяти, приложение не обращается к диску при их
чтении. Дело не в том, что память быстрее диска: человек не отличит сотую долю
секунды от тысячной. Приложение, которое не зависит от файлов более автономно и
потому удобней в поддержке.

Иногда файл конфигурации оказался в другой папке, и приложение не может его
найти. Или, что хуже, запускается со старой версией файла. Это замедляет работу
и вносит путаницу.

\label{password-note}

\index{безопасность!конфигурации}

Хранить пароли и ключи в переменных безопаснее, чем в файлах. В случае с файлами
их могут прочесть другие программы, в том числе вредоносные. По ошибке файл
может попасть в репозиторий и остаться в истории. Существуют скрипты, которые
ищут в открытых репозиториях AWS-ключи (и порой находят, к сожалению).

Даже если файлом владеет другой пользователь, он может быть доступен для чтения
остальным. Переменные среды эфемерны: они живут только памяти операционной
системы. Один пользователь не может прочесть переменные другого.

\index{контейнеры}
\index{виртуализация}

Индустрия переходит от файлов к \emph{контейнерам}. Если раньше мы копировали
файлы по FTP, то сегодня приложение запускают из образов. Это архив, в который
упакован код и его окружение. В отличии от настоящего архива, образ нельзя
изменить. Чтобы обновить файл в образе, нужно собрать его заново, что усложняет
процесс.

\index{Docker}

Наоборот, виртуализация лояльна к переменным среды. Их указывают при запуске
образа в параметрах. Один и тот же образ запускают с разными переменными; новая
сборка не требуется. Чем больше опций можно задать переменными, тем удобней
образ в работе. Ниже сервер PostgreSQL включается с готовой базой и
пользователем:

\begin{english}
  \begin{bash}
$ docker run \
  -e POSTGRES_DB=book \
  -e POSTGRES_USER=ivan \
  -e POSTGRES_PASSWORD=**** \
  -d postgres
  \end{bash}
\end{english}

\index{сайты!https://12factor.net}

Принцип <<конфигурация в среде>> описан в <<The Twelve-Factor App>>\footurl{https://12factor.net/}.
Это свод правил для разработки надежных приложений. Его третий пункт посвящен конфигурации.
Автор упоминает те же плюсы переменных, что мы рассмотрели: независимость от файлов,
безопасность, поддержка на всех платформах.

\section{Недостатки среды}

\index{декларативность}

Переменные не поддерживают типы: любое значение это текст. Вывод типов остается
на ваше усмотрение. Делайте это декларативно, а не вручную. Неудачный пример на
Python:

\index{языки!Python}

\begin{english}
  \begin{python}
db_port = int(os.environ["DB_PORT"])
  \end{python}
\end{english}

Когда переменных больше двух, код становится уродливым. Задайте словарь, где
ключ это имя переменной, а значение~--- функция вывода. Специальный код обходит
словарь и наполняет результат. Для краткости опустим перехват ошибок:

\begin{english}
  \begin{python}
import os
env_mapping = {"DB_PORT": int}

result = {}
for (env, fn) in env_mapping.iteritems():
    result[env] = fn(os.environ[env])
  \end{python}
\end{english}

\noindent
Подход справедлив и для других языков. В Clojure для этого служит спека.

Переменные среды не работают с иерархией. Это плоский набор ключей и значений,
что не всегда ложиться на конфигурацию. Чем больше параметров, тем чаще их
группируют по смыслу. Предположим, подключение к базе задают задают десять
параметров. Чтобы не ставить перед каждым префикс, их выносят в дочерний
словарь.

\index{вложенность}
\index{коллекции!вложенность}

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{clojure}
;; so-so
{:db-name "book"
 :db-user "ivan"
 :db-pass "****"}
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
;; better
{:db {:name "book"
      :user "ivan"
      :pass "****"}}
  \end{clojure}
\end{english}

\end{tabular}

В разных системах вложенные переменные читают по-разному. Например, одинарное
подчеркивание разделет лексемы, но не меняет структуру. Двойное подчеркивание
означает вложенность:

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{clojure}
"DB_NAME=book"
;; {:db-name "book"}
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
"DB__NAME=book"
;; {:db {:name "book"}}
  \end{clojure}
\end{english}

\end{tabular}

\index{коллекции!массив}

Массив задают в квадратных скобках или через запятую. При разборе массива
возникает риск ложного разбиения. Это случается, когда запятая или скобка
относится к слову, а не к синтаксису.

\index{форматы!JSON}
\index{форматы!YAML}

Форматы JSON и YAML задают четкий стандарт, как описывать коллекции. Для
переменных среды нет единого соглашения. Ситуация ухудшается, когда ожидают
параметр большой вложенности, например, список словарей. Переменные среды не
справляются с такой структурой.

В разработке встает ещ\"{е} один недостаток переменных~--- в некоторых системах
они доступны только для чтения. Это верно идеологически, но вынуждает заново
включать REPL на каждое изменение конфигурации. Для файла достаточно изменить
его и прочитать заново.

\subsection{Env-файлы}

\index{файлы!переменных среды}

Когда переменных много, вводить их вручную через \spverb|export|
утомительно. Переменные выносят в файл, который называют
\emph{env}-конфигурацией.

Технически это шелл-скрипт, но чем меньше в нем скриптовых возможностей, тем
лучше. В идеале в файле только пары \spverb|ИМЯ=значение| по одной на каждую
строку. Назовем файл просто \spverb|ENV| без расширения.

\begin{english}
  \begin{bash}
DB_NAME=book
DB_USER=ivan
DB_PASS=****
  \end{bash}
\end{english}

Чтобы считать переменные в шелл, вызывают \spverb|source <file>|. Это одна из
команд \spverb|bash|, которая выполняет скрипт в \emph{текущем} сеансе. Cкрипт
добавит переменные в шелл, и вы увидите их после \spverb|source|. Это
важное отличие от команды \spverb|bash <file>|, которая выполнит скрипт в новом
шелле.

\begin{english}
  \begin{bash}
$ source ENV
$ echo $DB_NAME
book
  \end{bash}
\end{english}

Если запустить из текущего шелла приложение, оно не получит переменные
файла. Вспомним, что выражение \spverb|VAR=value| зада\"{е}т локальную
переменную. \spverb|DB_NAME| и другие не попадут в окружение, и программа не
унаследует их. Проверим это с помощью \spverb|printenv|:

\index{утилиты!printenv}

\begin{english}
  \begin{bash}
$ source ENV
$ printenv | grep DB
# exit 1
  \end{bash}
\end{english}

Есть два способа решить проблему. Первый~--- открыть файл и расставить перед
каждой парой выражение \spverb|export|. Тогда \spverb|source| этого файла
добавит переменные в окружение:

\begin{english}
  \begin{bash}
$ cat ENV
export DB_NAME=book
export DB_USER=ivan
export DB_PASS=****

$ source ENV
$ printenv | grep DB
DB_NAME=book
DB_USER=ivan
DB_PASS=****
  \end{bash}
\end{english}

Недостаток в том, что в файле появилась логика скрипта. Если не поставить
\spverb|export| перед переменной, и приложение не прочитает е\"{е}.

\index{allexport}

Второй способ основан на параметре \spverb|-a| (\textbf{a}llexport) текущего
шелла. Когда он установлен, локальная переменная попадает в окружение. Перед
тем, как читать переменные из файла, флаг возводят в истину, а затем снова в
ложь.

\begin{english}
  \begin{bash}
$ set -a
$ source ENV
$ printenv | grep DB
# prints all the vars
$ set +a
  \end{bash}
\end{english}

Выражение \spverb|set| противоречиво: параметр с минусом \emph{включает}
параметр, а с плюсом~--- отключает. Это исключение, которое прид\"{е}тся запомнить.

Если считать переменную, которая уже в окружении, она заменит прежнее
значение. Так появляются файлы с переопределениями. Если нужны особые настройки
для тестов, не обязательно копировать файл. Создайте файл с полями,
которые нужно заменить и выполните после главного.

Пусть тестовые настройки отличаются именем базы. Файл \spverb|ENV| несет
основные параметры. В \spverb|ENV_TEST| поместим новое значение
\spverb|DB_NAME=test|, затем прочтем оба файла.

\begin{english}
  \begin{bash}
$ set -a
$ source ENV
$ source ENV_TEST
$ set +a

$ echo $DB_NAME
test
  \end{bash}
\end{english}

Читатель заметит, что ENV-файлы противоречивы. Мы сказали, что переменные
снимают зависимость от файлов, но в итоге поместили их в файл. В ч\"{е}м смысл?

\index{DevOps}

Разница между JSON- и ENV-файлами в том, кто их читает. В первом случае это
приложение, а во втором~--- операционная система. Файл находится в строго
заданной директории, а переменные среды доступны ото всюду. Мы избавим
приложение от кода, который ищет и читает файл. Облегчим работу коллегам DevOps:
они задают переменные по-разному в зависимости от инструмента (шелл, Docker,
Kubernetes).

\section{Переменные среды в Clojure}

\index{классы!System}

Clojure это гостевая платформа, поэтому язык не предлагает доступ к системным
ресурсам. В главном модуле нет функции для чтения переменных среды. Получим их
из класса \spverb|java.lang.System|. Импортировать класс не нужно, он доступен в
любом пространстве имен.

Статический метод \spverb|getenv| верн\"{е}т либо одну переменную по имени, либо
весь словарь, если имя не указали.

\begin{english}
  \begin{clojure}
;; a single variable
(System/getenv "HOME")
"/Users/ivan"

;; all variables
(System/getenv)
{"JAVA_ARCH" "x86_64", "LANG" "en_US.UTF-8"} ;; truncated
  \end{clojure}
\end{english}

Во втором случае получили не Clojure-, а Java-коллекцию. Это постоянная версия
класса \spverb|Map|, поэтому переменные нельзя изменить после запуска JVM.

Чтобы облегчить работу со словарем, приведем его к типу Clojure. Заодно исправим
ключи: сейчас это строки в верхнем регистре и подчеркиваниями. В Clojure
пользуются кейвордами и записью <<kebab-case>>: нижний регистр с дефисами.

\index{kebab-case}

Напишем функцию для перевода ключа:

\begin{english}
  \begin{clojure}
(require '[clojure.string :as str])

(defn remap-key [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      keyword))
  \end{clojure}
\end{english}

\noindent
и убедимся в е\"{е} работе:

\begin{english}
  \begin{clojure}
(remap-key "DB_PORT")
:db-port
  \end{clojure}
\end{english}

\index{функции!remap-env}
\index{функции!remap-key}

Функция \spverb|remap-env| проходит по словарю Java и возвращает его
<<кложурную>> версию с привычными ключами:

\begin{english}
  \begin{clojure}
(defn remap-env [env]
  (reduce
   (fn [acc [k v]]
     (let [key (remap-key k)]
       (assoc acc key v)))
   {}
   env))
  \end{clojure}
\end{english}

\noindent
Приведем небольшую часть словаря:

\begin{english}
  \begin{clojure}
(remap-env (System/getenv))

{:home "/Users/ivan"
 :lang "en_US.UTF-8"
 :term "xterm-256color"
 :java-arch "x86_64"
 :term-program "iTerm.app"
 :shell "/bin/zsh"}
  \end{clojure}
\end{english}

Когда переменные это словарь, он ид\"{е}т по тому же конвейеру: вывод типов,
валидация спекой. Поскольку все значения строки, спеку нужно доработать, чтобы
она выводила числа из строк. Раньше в этом не было нужды, потому что числа
приходили из JSON в готовом виде. Будет удачной спека, которая учитывает и
число, и строку. Вот как выглядит умный парсер числа:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/conformer
   (fn [value]
     (cond
       (int? value) value
       (string? value)
       (try (Integer/parseInt value)
            (catch Exception e
              ::s/invalid))
       :else ::s/invalid))))
  \end{clojure}
\end{english}

\noindent
С этой спекой можно менять источник данных без изменений в коде.

\subsection{Проблема лишних ключей}

У словаря переменных недостаток~--- много посторонних полей. Приложению не нужно
знать версию терминала или путь к Python. Эти поля вносят шум при печати и
записи в лог. Если спека не прошла проверку, мы увидим лишние данные в
\spverb|explain|.

\index{clojure.core!select-keys}
\index{ключи!выборка}

На последнем шаге \spverb|s/conform| нужно выбрать из словаря только полезную
часть. Функция \spverb|select-keys| верн\"{е}т подмножество по списку ключей. Но где
взять ключи? Перечислять их вручную долго, и к тому же мы дублируем код. Мы уже
указали ключи в спеке \spverb|::config|, и делать это второй раз не хочется. С
помощью трюка вытащим ключи \emph{из спеки}.

Функция \spverb|s/form| принимает ключ спеки и возвращает <<замороженную>> форму
того, что передали в \spverb|s/def|. Это список, где каждый элемент примитив
(символ, кейворд) или коллекция (вектор, словарь). Для спеки \spverb|::config|
получим форму:

\begin{english}
  \begin{clojure}
(clojure.spec.alpha/keys
 :req-un [:book.config/server_port
          :book.config/db
          :book.config/event])
  \end{clojure}
\end{english}

\index{коллекции!список}

Обратите внимание: это \emph{список}, а не код. Нужные ключи находятся в третьем
элементе после \spverb|:req-un|. Ст\'{о}ит учесть и другие типы ключей, например
\spverb|:opt-un|. Напишем универсальную функцию, которая верн\"{е}т все ключи из
\spverb|s/keys|.

Отбросим первый символ формы. Останется список, где нечетные элементы тип ключа,
а четные~--- их вектор. Перестроим список в словарь и объединим значения. Для
ключей \spverb|-un| отбросим пространство. Все вместе дает нам функцию:

\index{spec!spec\arr{}keys}

\begin{english}
  \begin{clojure}
(defn spec->keys
  [spec-keys]
  (let [form (s/form spec-keys)
        params (apply hash-map (rest form))
        {:keys [req opt req-un opt-un]} params
        ->unqualify (comp keyword name)]
    (concat req
            opt
            (map ->unqualify opt-un)
            (map ->unqualify req-un))))
  \end{clojure}
\end{english}

\noindent
Проверим спеку загрузчика:

\begin{english}
  \begin{clojure}
(spec->keys ::config)
(:server_port :db :event)
  \end{clojure}
\end{english}

\noindent
Перепишем чтение переменных в словарь:

\begin{english}
  \begin{clojure}
(defn read-env-vars []
  (let [cfg-keys (spec->keys ::config)]
    (-> (System/getenv)
        (remap-env)
        (select-keys cfg-keys))))
  \end{clojure}
\end{english}

\noindent
Так мы получим только полезные ключи, то есть те, что указаны в спеке.

\subsection{Загрузчик среды}

Доработаем загрузчик, чтобы он работал с переменными среды. Замените первые два
шага на \spverb|read-env-vars|. Теперь программа не зависит от файла
конфигурации.

\begin{english}
  \begin{clojure}
(defn load-config! []
  (-> (read-env-vars)
      (coerce-config)
      (set-config!)))
  \end{clojure}
\end{english}

Сделайте так, чтобы источник данных можно было задать параметром. Например,
\spverb|:source "/path/to/config.json"| означает считать файл, а
\spverb|:source :env|~--- переменные среды.

\index{коллекции!слияние}

Ещ\"{е} сложнее: как считать оба источника и объединить их? Важен ли порядок и
как его обеспечить? Как объединить словари ассиметрично, то есть когда второй
только \emph{замещает} поля первого, но не дополняет новыми?

\subsection{Вывод структуры}

\index{структура}

Редко бывает так, что конфигурация это плоский словарь. Близкие параметры
выносят во вложенные словари, например, отдельно поля сервера и базы
данных. Сгруппированные настройки легче в поддержке.

Улучшим загрузчик: научим его читать вложенные переменные. Договоримся, что
двойное подчеркивание означает смену уровня. Поместим в файл \spverb|ENV_NEST|
следующие переменные:

\begin{english}
  \begin{bash}
DB__NAME=book
DB__USER=ivan
DB__PASS=****
HTTP__PORT=8080
HTTP__HOST=api.random.com
  \end{bash}
\end{english}

\index{REPL}

\noindent
Прочитаем его и запустим REPL с новой средой:

\begin{english}
  \begin{bash}
$ set -a
$ source ENV_NEST
$ lein repl
  \end{bash}
\end{english}

Изменим обход окружения и разбор ключа. Функция \spverb|remap-key-nest|
принимает ключ-строку и возвращает вектор составных частей (лексем):

\begin{english}
  \begin{clojure}
(defn remap-key-nest
  [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      (str/split #"--")
      (->> (map keyword))))

(remap-key-nest "DB__PORT")
;; (:db :port)
  \end{clojure}
\end{english}

\index{clojure.core!assoc}
\index{clojure.core!assoc-in}
\index{clojure.core!reduce}

Функция обхода делает не \spverb|assoc|, а \spverb|assoc-in|, что порождает
вложенность:

\begin{english}
  \begin{clojure}
(defn remap-env-nest
  [env]
  (reduce
   (fn [acc [k v]]
     (let [key-path (remap-key-nest k)]
       (assoc-in acc key-path v)))
   {}
   env))
  \end{clojure}
\end{english}

Код ниже верн\"{е}т параметры по группам, как и задумано. Приведем их подмножество:

\begin{english}
  \begin{clojure}
(-> (System/getenv)
    (remap-env-nest)
    (select-keys [:db :http]))

{:db {:user "ivan", :pass "****", :name "book"},
 :http {:port "8080", :host "api.random.com"}}
  \end{clojure}
\end{english}

\noindent
Дальше действуем как обычно: пишем спеку, выводим типы из строк и так далее.

Подумайте, как задать в переменной массив. Чем разделить элементы? Когда
возможно ложное разбиение и как его предотвратить?

\section{Простой менеджер конфигурации}

\index{менеджер конфигураций}

К этому моменту читатель решит, что конфигурация в файле это плохая идея. Однако
не бросайтесь переписывать код на переменные среды. На практике работают с
\emph{гибридными} моделями, которые сочетают оба подхода. Приложение читает
основные параметры из файла, а пароли и ключи доступа из среды.

\index{утилиты!gettext}
\index{утилиты!envsubst}

Рассмотрим, как подружить файлы и окружение. Наивное решение не потребует писать
код: оно работает на утилитах командной строки. Программа \spverb|envsubst| из
пакета <<GNU gettext>> предлагает простую шаблонную систему. Чтобы установить
\spverb|gettext|, выполните в терминале команду:


\begin{english}
  \begin{bash}
$ <manager> install gettext
  \end{bash}
\end{english}

\noindent
, где \spverb|<manager>| это мастер пакетов вашей системы (\spverb|brew|,
\spverb|apt|, \spverb|yum| и другие).

\index{каналы!stdin}
\index{шаблоны}

Текст шаблона приходит из \spverb|stdin|, а роль контекста играют переменные
среды. Утилита заменяет выражения \spverb|$VAR_NAME| на значения одноим\"{е}нной
переменной. Поместим шаблон в файл \spverb|config.tpl.json|. Частичка <<tpl>>
означает <<template>>.

\begin{english}
  \begin{json}
{
    "server_port": $HTTP_PORT,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "$DB_NAME",
        "user":     "$DB_USER",
        "password": "$DB_PASS"
    },
    "event": [
        "$EVENT_START",
        "$EVENT_END"
    ]
}
  \end{json}
\end{english}

\noindent
Обратите внимание, что порт сервера не окружен кавычками, потому что это
число. Поместим переменные в файл \spverb|ENV_TPL|:

\begin{english}
  \begin{bash}
$ cat ENV_TPL
DB_NAME=book
DB_USER=ivan
DB_PASS='*(&fd}A53z#$!'
HTTP_PORT=8080
EVENT_START='2019-07-05T12:00:00'
EVENT_END='2019-07-12T23:59:59'
  \end{bash}
\end{english}

\noindent
Считаем переменные и <<отрендерим>> шаблон:

\begin{english}
  \begin{bash}
$ source ENV_TPL
$ cat config.tpl.json | envsubst
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "*(&fd}A53z#$!"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{bash}
\end{english}

\noindent
Подстановка прошла успешно. Чтобы записать результат в файл, добавьте
в конец оператор вывода:

\begin{english}
  \begin{bash}
$ cat config.tpl.json | envsubst > config.ready.json
  \end{bash}
\end{english}

Способ с \spverb|envsubst| на первый взгляд примитивен, но полезен на
практике. Шаблон снимает вопрос о структуре: переменные подставляют в
нужное место, и не приходится думать о вложенности.

Иногда приложение требует несколько файлов конфигурации, в том числе для
инфраструктуры. Порт веб-сервера нужен Nginx для проксирования. В
Sendmail нужно указать тот же адрес почты, что и в приложении. Очевидно, должен
быть единый источник данных, и рендер шаблонов ложится на эту модель.

Утилита \spverb|envsubst| становится менеджером конфигураций. Чтобы
автоматизировать процесс, добавьте скрипт, который пробегает по шаблонам и
рендерит их переменными. Решение не тянет на промышленный уровень, но подойдет
для простых проектов.

\section{Чтение среды из конфигурации}

Следующие техники делают так, что приложение читает параметры
\emph{одновременно} из файла и среды. Разница в том, на каком шаге это
происходит.

Предположим, основные параметры записаны в файле, а пароль к~базе приходит из
среды. Договоримся с командой, что в поле \spverb|:password| записан не пароль,
а имя переменной, например \spverb|"DB_PASS"|. Напишем спеку, которая выводит
значение переменной по имени:

\begin{english}
  \begin{clojure}
(s/def ::->env
  (s/conformer
   (fn [varname]
     (or (System/getenv varname)
         ::s/invalid))))
  \end{clojure}
\end{english}

Если переменную не задали, вывод верн\"{е}т ошибку. Прежде чем подключиться к базе,
отбросим пустые символы и убедимся, что строка не пустая.

\begin{english}
  \begin{clojure}
(s/def ::db-password
  (s/and ::->env
         string?
         (s/conformer str/trim)
         not-empty))
  \end{clojure}
\end{english}

Быстрая проверка: запустим REPL с переменной \spverb|DB_PASS| и прочитаем е\"{е}
спекой:

\begin{english}
  \begin{bash}
DB_PASS='*(&fd}A53z#$!' lein repl

(s/conform ::db-password "DB_PASS")
"*(&fd}A53z#$!"
  \end{bash}
\end{english}

Чтобы вынести поле из файла в среду, замените значение на имя
переменной. Обновите спеку этого поля: добавьте \spverb|::->env| в начало
цепочки \spverb|s/and|.

\index{теги!EDN}

Другой способ прочитать переменные из файла~--- расширить его \emph{тегами}. Тег
это короткое слово, которое указывает, что значение за ним читают особым
образом. Форматы YAML и EDN поддерживают теги. Библиотеки для них предлагают
несколько основных.

\index{даты!разбор}
\index{модули!clojure.edn}

В EDN тег начинается со знака решетки и захватывает следующее
значение. Например, \spverb|#inst "2019-07-10"| выводит дату из строки. Тег
связан с функцией одного аргумента, которая вычисляет значение из
исходного. Чтобы задать свой тег, в функцию \spverb|clojure.edn/read-string|
передают словарь тегов. Ключи словаря это символы, значения~--- функции.

Добавим тег \spverb|#env|, который верн\"{е}т значение переменной по имени. Имя
может быть строкой или символом. Определим функцию:

\begin{english}
  \begin{clojure}
(defn tag-env
  [varname]
  (cond
    (symbol? varname)
    (System/getenv (name varname))
    (string? varname)
    (System/getenv varname)
    :else
    (throw (new Exception "Wrong variable type"))))
  \end{clojure}
\end{english}

\noindent
Прочитаем EDN-строку с новым тегом:

\begin{english}
  \begin{clojure}
(require '[clojure.edn :as edn])

(edn/read-string
 {:readers {'env tag-env}}
 "{:db-password #env DB_PASS}")

;; {:db-password "*(&fd}A53z#$!"}
  \end{clojure}
\end{english}

Чтобы не передавать теги каждый раз, объявим \spverb|partial| от
\spverb|edn/read-string|. Новая функция принимает только строку:

\begin{english}
  \begin{clojure}
(def read-config
  (partial edn/read-string
           {:readers {'env tag-env}}))
  \end{clojure}
\end{english}

Чтобы разобрать файл с тегами, считайте его в строку и передайте в
\spverb|read-config|:

\begin{english}
  \begin{clojure}
(-> "/path/to/config.edn"
    slurp
    read-config)
  \end{clojure}
\end{english}

YAML тоже предусматривает теги. Они начинаются с одного или двух восклицательных
знаков в зависимости от семантики. У стандартных тегов два знака, а у сторонних
(пользовательских) один. Так мы сразу поймем, где какой тег.

\index{форматы!YAML}
\index{библиотеки!Yummy}
\index{теги!YAML}

Библиотека Yummy предлагает парсер YAML, <<заряженный>> полезными тегами. Среди
прочих нас интересует \spverb|!envvar|: он верн\"{е}т значение переменной по
имени. Опишем конфигурацию в файле \spverb|config.yaml|:

\begin{english}
  \begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     !envvar DB_USER
  password: !envvar DB_PASS
  \end{yaml}
\end{english}

Подключим библиотеку и прочитаем файл. На месте тегов получим значения среды:

\begin{english}
  \begin{clojure}
(require '[yummy.config :as yummy])
(yummy/load-config {:path "config.yaml"})

{:server_port 8080
 :db {:dbtype "mysql"
      :dbname "book"
      :user "ivan"
      :password "*(&fd}A53z#$!"}}
  \end{clojure}
\end{english}

\noindent
Мы подробно рассмотрим Yummy в следующем разделе главы.

Теги несут преимущества и недостатки. С одной стороны, они делают конфигурацию
плотнее: строка с тегом несет больше смысла. Запись \spverb|#env DB_PASS|
выглядит короче и приятнее глазу. Сложные теги выносят в библиотеки и подключают
в зависимости.

С другой стороны, теги привязывают конфигурацию к платформе. Если в YAML-файле
встречается тег \spverb|!envvar|, библиотека на Python не сможет его прочитать:
в ней нет такого тега (если точнее, есть, но другим именем). Технически это
можно исправить: пропускать незнакомые теги или установить заглушку. Но подход
не гарантирует одинаковый результат на разных платформах.

С тегами конфигурация обрастает побочными эффектами. В терминах функционального
программирования она теряет чистоту. Появляется соблазн вынести в тег слишком
много логики: включить дочерний файл, форматировать строки. Теги стирают грань
между чтением конфигурации и е\"{е} обработкой. Когда их слишком много, конфигурацию
трудно поддерживать.

Оба при\"{е}ма~--- разбор спекой и тегами~--- оппонируют друг другу. Выбирайте тот
способ, что удобен команде и процессу.

\section{Короткий обзор форматов}

Мы упомянули три формата данных: JSON, EDN и YAML. Перечислим особенности
каждого из них. Наша цель не выявить идеальный формат, а подготовить читателя к
неочевидным моментам, которые возникнут в работе с ними.

\subsection{JSON}

\index{форматы!JSON}

JSON известен даже тем, кто не работает с вебом. Это запись данных по правилам
JavaScript. Стандарт зада\"{е}т числа, строки, логический тип, null и две коллекции:
массив и словарь. Коллекции могут быть вложены друг в друга.

\index{языки!JavaScript}

Преимущество JSON в его популярности: это стандарт обмена данными между
клиентом и сервером. По сравнению с XML его легче читать и поддерживать. JSON
поддерживают современные редакторы, языки и платформы. Это естественный способ
хранить данные в JavaScript.

В JSON не предусмотрены комментарии. На первый взгляд это мелочь, но на практике
комментарии важны. Если вы добавили новый параметр, напишите комментарий о том,
что он делает и какие значения принимает. Посмотрите конфигурации Redis,
PostgreSQL или Nginx~--- больше половины файла занимают комментарии.

Разработчики придумали уловки, чтобы обойти ограничение. Например, поставить
одноим\"{е}нное поле перед тем, к которому относится комментарий.

\index{комментарии}

\begin{english}
  \begin{json}
{
    "server_port": "A port for the HTTP server.",
    "server_port": 8080
}
  \end{json}
\end{english}

Расчет сделан на то, что библиотека обходит поля по очереди, и второе поле
заменит первое. Стандарт JSON ничего не говорит о порядке полей; при\"{е}м остается
на ваш риск. Логика библиотеки может быть иной, например, бросить исключение или
пропустить ключ, который уже обработали.

Иногда в JSON добавляют комментарии на уровне продукта. Редактор Sublime Text
хранит настройки в .json-файлах с поддержкой JavaScript-комментариев (двойная
косая черта). В общем случае у проблемы нет решения.

JSON выгодно отличается от многословного XML, которому пришел на замену. Данные
в JSON выглядят чище и удобнее, чем дерево XML-тегов. Но современные форматы
выражают данные ещ\"{е} чище. В YAML любую структуру можно записать без единой
скобки за счет отступов.

Синтаксис JSON <<шумит>>: он требует кавычек, двоеточий и запятых там, где
другие форматы лояльны. Запятая в конце массива или объекта считается
ошибкой. Ключи словаря не могут быть числами. Нельзя записать текст в несколько
строк.

Сравните данные в YAML и JSON. Первая запись короче и чище:

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\vspace{1.25em}

\begin{english}
  \begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     user
  password: '****'
event:
  - 2019-07-05T12:00:00
  - 2019-07-12T23:59:59
  \end{yaml}
\end{english}

&

\begin{english}
  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}
\end{english}

\end{tabular}

\index{библиотеки!Cheshire}

JSON не поддерживает теги, о которых мы говорили выше. Для работы с форматом
служат библиотеки Cheshire\footurl{https://github.com/dakrone/cheshire} и
Data.json\footurl{https://github.com/clojure/data.json}.

\subsection{YAML}

\index{форматы!YAML}

Язык YAML, как и JSON, различает базовые типы: скаляры, null и коллекции. YAML
делает ставку на краткость записи: вложенность задают отступы, а не
скобки. Запятые не обязательны там, где язык выводит их логически. Массив чисел
в одну строку выглядит как в JSON:

\index{коллекции!в YAML}

\begin{english}
  \begin{yaml}
numbers: [1, 2, 3]
  \end{yaml}
\end{english}

\noindent
Но при записи в столбик запятые и скобки отпадают:

\begin{english}
  \begin{yaml}
numbers:
  - 1
  - 2
  - 3
  \end{yaml}
\end{english}

YAML поддерживает комментарии в стиле Python (знак решетки), за что его любят
DevOps. Программы вроде Docker-compose и Kubernetes читают настройки из
YAML-файлов.

В YAML можно записать текст в несколько строк. Его проще читать и копировать,
чем одну строку с символом переноса \spverb|\n|.

\begin{english}
  \begin{yaml}
description: |
  To solve the problem, please do the following:

  - Press Control + Alt + Delete;
  - Turn off your computer;
  - Walk for a while.

  Then try again.
  \end{yaml}
\end{english}

Язык официально поддерживает теги.

\index{отступы!в YAML}

Недостатки YAML вытекают из его преимуществ. Отступы кажутся удачным решением до
тех пор, пока файл не вырастет. Глаз прыгает на большие расстояния, чтобы
сверять уровни структур. Иногда часть данных <<съезжает>> из-за лишнего
отступа. С точки зрения YAML ошибки нет, поэтому е\"{е} трудно найти.

Отказ от кавычек приводит к неверным типам или структуре. Предположим, в
поле \spverb|phrases| перечислены фразы, которые увидит пользователь:

\begin{english}
  \begin{yaml}
phrases:
  - Welcome!
  - See you soon!
  - Warning: wrong email address.
  \end{yaml}
\end{english}

Из-за двоеточия в последней строке парсер решит, что это вложенный
словарь. Получим неверную структуру:

\begin{english}
  \begin{clojure}
{:phrases
 ["Welcome!"
  "See you soon!"
  {:Warning "wrong email address."}]}
  \end{clojure}
\end{english}

Другие примеры: версия продукта \spverb|3.3| это число, но \spverb|3.3.1|~---
строка. Телефон \spverb|+79625241745| это число, потому что знак плюса считается
унарным оператором по аналогии с минусом. Лидирующие нули означают восьмеричную
запись: если не добавить кавычки к \spverb|000042|, получится \spverb|34|.

Это не значит, что YAML неудачный формат. Случаи выше описаны в стандарте и
имеют логическое объяснение. Но иногда он ведет себя не так, как вы ожидали~---
это плата за упрощенный синтаксис.

\subsection{EDN}

\index{форматы!EDN}

Формат EDN занимает особое место в обзоре. Он хранит данные Clojure и потому
играет такую же роль в языке, как JSON в JavaScript. Это родной способ связать
данные с файлом в Clojure.

Синтаксис EDN почти полностью совпадает правилам Clojure. Формат охватывает
больше типов, чем JSON и YAML. Из скалярных типов доступны символы и
кейворды (классы \spverb|Symbol| и \spverb|Keyword| из
\spverb|clojure.lang|). Кроме вектора и словаря EDN предлагает списки и
множества.

\index{теги!EDN}

Тег начинается с символа решетки. По умолчанию стандарт предлагает два тега:
\spverb|#inst| и \spverb|#uuid|. Первый читает строку в дату, а второй в
экземпляр \spverb|java.util.UUID|. Идентификаторы используют в распределенных
системах вроде Cassandra и Kafka. Выше мы показали, как добавить свой тег: нужно
связать его с функцией одного аргумента при чтении строки.

Пример с разными типами, коллекциями и тегами:

\begin{english}
  \begin{clojure}
{:user/banned? false
 :task-state #{:pending :in-progress :done}
 :account-ids [1001 1002 1003 nil]
 :server {:host "127.0.0.1" :port 8080}
 :date-range [#inst "2019-07-01" #inst "2019-07-31"]
 :cassandra-id #uuid "26577362-902e-49e3-83fb-9106be7f60e1"}
  \end{clojure}
\end{english}

Данные в EDN не отличаются от кода. Если скопировать их в REPL или модуль,
компилятор выполнит их. И наоборот: вывод REPL можно записать в файл для
дальнейшей работы.

Функция \spverb|pr-str| переводит данные в текст. Сброс в EDN сводится к простым
шагам: <<напечатать>> данные в строку и записать е\"{е} в файл. Ниже результат
функции пишут в файл \spverb|dataset.edn|:

\begin{english}
  \begin{clojure}
(-> (get-huge-dataset)
    (pr-str)
    (->> (spit "dataset.edn")))
  \end{clojure}
\end{english}

\index{синтаксис!\#\_ (игнорирование)}

EDN поддерживает не только обычные комментарии. Тег \spverb|#_| игнорирует
следующий за ним элемент. Им может быть что угодно, в том числе коллекция. Если
нужно <<заигнорить>> словарь, который занимает несколько строк, поставьте перед
ним \spverb|#_|, и парсер пропустит его.

\index{синтаксис!; (комментарий)}

Так отключают целые части конфигурации. В следующем примере мы игнорируем третий
элемент вектора. Если поставить обычный комментарий на строку (точка с запятой),
он заденет закрывающие скобки, и выражение будет неверным.

\begin{english}
  \begin{clojure}
{:users [{:id 1 :name "Ivan"}
         {:id 2 :name "Juan"}
         #_{:id 3 :name "Huan"}]}
  \end{clojure}
\end{english}

EDN это удачный выбор, когда и бекенд, и фронтенд работают на стеке Clojure и
ClojureScript.

EDN привязан к Clojure и поэтому непопулярен в других языках. Редакторы не
подсвечивают его синтаксис без плагинов. EDN доставит проблем DevOps, которые
работают только с JSON и YAML. Если конфигурацию читают скрипты на Python или
Ruby, прид\"{е}тся ставить библиотеку для работы с форматом. EDN выбирают там, где
Clojure преобладает над другими технологиями.

\section{Промышленные решения}

Понимать конфигурацию важно, но мы не ожидаем, что в каждом проекте е\"{е} пишут с
нуля. В последнем разделе мы рассмотрим, что предлагает сообщество для
конфигурации проектов. Мы остановили внимание на Cprop, Aero и Yummy. Библиотеки
отличаются в идеологии и архитектуре. Мы специально подобрали их так, чтобы
увидеть проблему с разных сторон.

\subsection{Cprop}

\index{библиотеки!Cprop}

Библиотека Cprop\footurl{https://github.com/tolitius/cprop} работает по принципу
<<данные отовсюду>>. В отличии от нашего загрузчика Cprop понимает больше
источников. Библиотека читает не только файл и переменные среды, но и ресурсы,
property-файлы и обычные словари.

В библиотеке задан порядок обхода источников и их приоритет. Параметры одного
источника заменяют другие. Например, у переменной среды более высокий приоритет,
чем у файла. Для частных случаев в Cprop легко задать свой порядок загрузки.

Нас интересует функция \spverb|load-config|. Без параметров она запускает
стандартный загрузчик. По умолчанию Cprop ищет два источника данных: ресурс и
property-файл. Ресурс должен называться \spverb|config.edn|. Если системное
свойство \spverb|conf| не пустое, библиотека полагает, что это путь к
property-файлу и загружает его.

Свойства это переменные Java-машины, аналог среды окружения JVM. При загрузке
она получает свойства по умолчанию: тип операционной системы, разделитель строк
и другие. Дополнительные свойства задают параметром \spverb|-D| при
запуске. Пример ниже запускает jar-файл со свойством \spverb|conf|:

\index{JVM!JAR}
\index{JVM!properties}

\begin{english}
  \begin{bash}
$ java -Dconf="/path/to/config.properties" -jar project.jar
  \end{bash}
\end{english}

Файлы \spverb|.properties| это пары \spverb|поле=значение| по одной на
строку. Поля похожи на домены: это лексемы, разделенные точкой. Лексемы убывают
по старшинству:

\begin{english}
  \begin{ini}
db.type=mysql
db.host=127.0.0.1
db.pool.connections=8
  \end{ini}
\end{english}

Библиотека трактует точки как вложенные словари. Файл верн\"{е}т структуру:

\begin{english}
  \begin{clojure}
{:db {:type "mysql"
      :host "127.0.0.1"
      :pool {:connections 8}}}
  \end{clojure}
\end{english}

Получив конфигурацию, Cprop ищет переопределения в переменных среды. Для них
работают те же правила, что и в нашем загрузчике. Например, переменная
\spverb|DB__POOL__CONNECTIONS=16| заменит значение 8 в словаре выше. Cprop
игнорирует переменные, которые не входят в конфигурацию и тем самым не
загрязняет~е\"{е}.

Нестандартные пути к ресурсу и файлу задают ключами:

\begin{english}
  \begin{clojure}
(load-config
 :resource "private/config.edn"
 :file "/path/custom/config.edn")
  \end{clojure}
\end{english}

\index{модули!cprop.source}

Для тонкой работы Cprop предлагает модуль \spverb|cprop.source|. Его функция
\spverb|from-env| верн\"{е}т все переменные среды, \spverb|from-props-file| загрузит
property-файл и так далее. Легко построить такую комбинацию, которая нужна
проекту.

Ключ \spverb|:merge| объединяет конфигурацию с любым источником. В н\"{е}м
выражения, которые вернут словарь. Убер-пример из документации:

\begin{english}
  \begin{clojure}
(load-config
 :resource "path/within/classpath/to.edn"
 :file "/path/to/some.edn"
 :merge [{:datomic {:url "datomic:mem://test"}}
         (from-file "/path/to/another.edn")
         (from-resource "path/within/classpath/to-another.edn")
         (from-props-file "/path/to/some.properties")
         (from-system-props)
         (from-env)])
  \end{clojure}
\end{english}

Чтобы отследить загрузку, установите переменную среды \spverb|DEBUG=y|. С ней
\spverb|cprop| выводит служебную информацию. Это список источников, порядок
загрузки, переопределение и так далее.

Cprop только читает данные из источников, но не проверяет их. В библиотеке нет
валидации спекой, как это сделано в нашем загрузчике. Шаг остается на ваше
усмотрение.

Библиотека по-своему выводит типы. Если строка состоит только из цифр, е\"{е}
приводят к числу. Значения с запятыми становятся списками. Иногда этих правил
недостаточно для полного контроля за типами. Вам по-прежнему понадобится
\spverb|spec| и \spverb|conform| для вывода типов и сообщений об ошибке.

\subsection{Aero}

\index{библиотеки!Aero}

Aero\footurl{https://github.com/juxt/aero} работает с файлами EDN. Библиотека
предлагает теги, с которыми формат похож на мини-язык программирования. В нем
появляются операторы ветвления, импорта, форматирования. Подход можно назвать
<<EDN на стероидах>>.

\index{модули!aero.core}

Функция \spverb|read-config| читает файл или ресурс EDN:

\begin{english}
  \begin{clojure}
(require '[aero.core :refer (read-config)])

(read-config "config.edn")
(read-config (clojure.java.io/resource "config.edn"))
  \end{clojure}
\end{english}

\index{теги!Aero}

Теги это главный момент в Aero, поэтому разберем основные из них. Тег
\spverb|#env| заменяет имя переменной среды на значение. Мы уже писали такой
же:

\begin{english}
  \begin{clojure}
{:db {:passwod #env DB_PASS}}
  \end{clojure}
\end{english}

Тег \spverb|#envf| форматирует строку переменными среды. Предположим,
подключение к базе состоит из отдельных полей, но вы предпочитаете JDBC URI~---
длинную строку, похожую на веб-адрес. Чтобы не повторяться, адрес вычисляют из
исходных полей:

\begin{english}
  \begin{clojure}
{:db-uri #envf ["jdbc:postgresql://%s/%s?user=%s"
                DB_HOST DB_NAME DB_USER]}
  \end{clojure}
\end{english}

Тег \spverb|#or| похож на аналог Clojure и нужен для значений по
умолчанию. Пусть в файле не задан порт базы данных. Чтобы избежать ошибки,
укажем стандартный порт PostgreSQL:

\begin{english}
  \begin{clojure}
{:db {:port #or [#env DB_PORT 5432]}}
  \end{clojure}
\end{english}

\index{профили!Aero}

Оператор \spverb|#profile| позволяет найти значение по
\emph{профилилю}. Значение за тегом должно быть словарем. Ключи словаря это
профили, а значения~--- то, что получим в результате его разрешения. Профиль
задают в параметрах \spverb|read-config|.

Пример ниже показывает, как найти имя базы по профилю. Без профиля получим
\spverb|"book"|, но для \spverb|:test| имя станет \spverb|"book_test"|:

\begin{english}
  \begin{clojure}
{:db {:name #profile {:default "book"
                      :dev     "book_dev"
                      :test    "book_test"}}}

(read-config "aero.test.edn" {:profile :test})
{:db {:name "book_test"}}
  \end{clojure}
\end{english}

Тег \spverb|#include| помещает в конфигурацию другой EDN-файл. В нем тоже могут
быть теги, и библиотека выполнит их рекурсивно. К импорту прибегают, когда
конфигурация становится большой.

\begin{english}
  \begin{clojure}
{:queue #include "message-queue.edn"}
  \end{clojure}
\end{english}

Тег \spverb|#ref| ставит ссылку на любое место конфигурации. Это вектор ключей,
который обычно передают в \spverb|get-in|. Ссылка позволит избежать повторов.
Например, компонент нуждается в пользователе, под которым мы подключаемся к базе
данных. Чтобы не копировать его, поставим ссылку:

\begin{english}
  \begin{clojure}
;; config.edn
{:db {:user #env DB_USER}
 :worker {:user #ref [:db :user]}}

;; result
{:db {:user "ivan"}, :worker {:user "ivan"}}
  \end{clojure}
\end{english}

Aero предлагает несложный язык описания конфигурации. Библиотека подкупает идеей
и красотой реализации. Но в момент, когда вам захочется переехать с негибкого
JSON на Aero, подумайте об обратной стороне медали.

\index{декларативность}

Конфигурацию не случайно отделяют от кода. Если бы не потребность индустрии, мы
бы хранили параметры в исходных файлах. Но этого не делают~--- наоборот, хорошие
практики советуют \emph{отделять} параметры от кода. В том числе потому, что в
отличие от кода конфигурация \emph{декларативна}.

Негибкие JSON-файлы обладают важным свойством: они декларативны. Если вы открыли
файл или сделали \spverb|cat|, то увидите данные. Синтаксис может быть неудобен,
но данные выражаются сами в себя, и ошибки быть не может.

Наоборот, файл с обилием тегов труден в поддержке. Это не конфигурация,
а \emph{код}. Чтобы увидеть данные, файл нужно выполнить. При чтении
файла в голове запускается мини-интерпретатор, который не гарантирует
правильный результат.

Получается своего рода круг: мы вынесли параметры в конфигурацию, добавили теги
и вернулись к коду. Подход имеет право на жизнь, но к нему приходят осознанно.

\subsection{Yummy}

\index{библиотеки!Yummy}
\index{организации!Exoscale}

Библиотека Yummy\footurl{https://github.com/exoscale/yummy} замыкает обзор. От
аналогов она отличается двумя свойствами. Во-первых, работает с файлами YAML для
чтения конфигурации (отсюда и название). Во-вторых, процесс загрузки похож на
тот, что мы рассмотрели в начале главы.

Полноценный загрузчик не только читает параметры. Цикл включает проверку данных
и вывод ошибки. Сообщение внятно объясняет, в чем причина. С помощью опций можно
задать реакцию на исключение, которые возникло в работе. Yummy предлагает все из
перечисленного.

Путь к файлу либо указывают в параметрах, либо библиотека ищет его по особым
правилам. Вариант, когда путь задан явно:

\begin{english}
  \begin{clojure}
(require '[yummy.config :refer [load-config]])

(load-config {:path "config.yaml"})
  \end{clojure}
\end{english}

Во втором случае вместо пути указали имя проекта. Yummy ищет путь к файлу в
переменной среды \spverb|<project>_CONFIGURATION| или свойстве
\spverb|<project>.configuration|:

\begin{english}
  \begin{bash}
export BOOK_CONFIGURATION=config.yaml
  \end{bash}
\end{english}

\begin{english}
  \begin{clojure}
(load-config {:program-name :book})
  \end{clojure}
\end{english}

Библиотека расширяет YAML несколькими тегами. Это знакомый \spverb|!envvar|
для переменных среды:

\index{теги!Yummy}

\begin{english}
  \begin{yaml}
db:
  password: !envvar DB_PASS
  \end{yaml}
\end{english}

\noindent
Тег \spverb|!keyword| полезен, чтобы привести строку к кейворду:

\begin{english}
  \begin{yaml}
states:
  - !keyword task/pending
  - !keyword task/in-progress
  - !keyword task/done
  \end{yaml}
\end{english}

\noindent
Результат:

\begin{english}
  \begin{clojure}
{:states [:task/pending :task/in-progress :task/done]}
  \end{clojure}
\end{english}

Тег \spverb|!uuid| аналогичен \spverb|#uuid| для EDN. Он возвращает объект
\spverb|java.util.UUID| из строки:

\begin{english}
  \begin{yaml}
system-user: !uuid cb7aa305-997c-4d53-a61a-38e0d8628dbb
  \end{yaml}
\end{english}

Тег \spverb|!slurp| читает файл, что полезно для сертификатов шифрования. Их
содержимое это длинная строка, которую неудобно хранить в общей конфигурации. В
ключах \spverb|:auth|, \spverb|:cert| и \spverb|:pkey| окажется содержимое
файлов из папки \spverb|certs|.

\begin{english}
  \begin{yaml}
tls:
  auth: !slurp "certs/ca.pem"
  cert: !slurp "certs/cert.pem"
  pkey: !slurp "certs/key.pk8"
  \end{yaml}
\end{english}

\index{spec!assert}

Чтобы проверить данные, в параметры \spverb|load-config| передают ключ
спеки. Когда ключ указан, Yummy выполняет \spverb|s/assert| над данными из
файла. Если проверка вернула ложь, всплывает исключение. Yummy использует
Expound, чтобы улучшить текст об ошибке.

\begin{english}
  \begin{clojure}
(load-config {:program-name :book
              :spec ::config})
  \end{clojure}
\end{english}

\index{die-fn}
\index{функции!смерти}

Словарь опций принимает параметр \spverb|:die-fn|. Это функция, которая
сработает, если любая стадия завершится с ошибкой. Функция принимает исключение
и метку с именем стадии.

\index{каналы!stderr}

Если \spverb|:die-fn| не задан, Yummy вызовет обработчик по умолчанию. Он
выводит текст в \spverb|stderr| и завершает JVM с кодом 1. На этапе разработки
мы не хотим обрывать REPL из-за ошибки в конфигурации. В интерактивном сеансе
наша \spverb|die-fn| только печатает текст и ошибку:

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (binding [*out* *err*]
              (println msg (ex-message e))))})
  \end{clojure}
\end{english}

\noindent
В боевом режиме запишем исключение в лог и завершим программу.

\index{логирование}

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (log/errorf e "Config error")
            (System/exit 1))})
  \end{clojure}
\end{english}

Для валидации Yummy вызывает \spverb|s/assert|. Функция не выводит значения, как
это делает \spverb|s/conform|, а только бросает исключение. Это сделано нарочно:
типы выводят тегами, а спека только проверяет данные.

\section{Заключение}

Перечислим основные тезисы из этой главы. Конфигурация нужна, чтобы проект
прошел стадии производства: разработку, тестирование, релиз. На каждой стадии
его запускают с разными настройками. Без конфигурации это невозможно.

Загрузка конфигурации означает чтение данных, вывод типов и проверку значений. В
случае ошибки программа выводит сообщение и завершается с аварийным
кодом. Нельзя продолжать работу с неверными параметрами.

Источником конфигурации может быть файл, ресурс, переменные окружения. Бывают
гибридные схемы, когда основные данные приходят из файла, а секретные поля из
окружения.

Переменные среды живут в памяти операционной системы. Когда переменных много, их
помещают в ENV-файл. Приложение не читает его: это делает скрипт, который
управляет приложением на сервере. Приложению неизвестно, откуда пришли
переменные.

Окружение это плоский словарь. Переменные хранят только текст, в ключах нет
вложенности или пространства им\"{е}н. В разных системах свои соглашения о том, как
извлечь структуру из имени переменной. Это могут быть точки, двойные
подчеркивания или что-то ещ\"{е}.

Форматы данных отличаются синтаксисом и типами. Общие форматы задают строки,
числа, словари и списки. Они не настолько гибки, но работают везде. Наоборот,
формат для конкретной платформы тесно связан с ней, но не популярен в других
языках.

Некоторые форматы поддерживают теги. С помощью тегов из скаляров получают более
сложные типы, например даты. Теги опасны тем, что когда их много, конфигурация
превращается в код.

Clojure предлагает несколько библиотек для конфигурации приложения. Они
различаются замыслом и архитектурой, и каждый разработчик найд\"{е}т то, что ему по
душе. Нет точного ответа на вопрос, какой формат или библиотека лучше. Выбирайте
то, что предельно д\"{е}шево решит задачу.
