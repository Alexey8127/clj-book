\chapter{Конфигурация}

\label{chapter-config}

\begin{teaser}
В этой главе мы рассмотрим, как сделать проект на Clojure удобным в
настройке. Разберем основы конфигурации: форматы файлов, переменные среды,
библиотеки, их достоинства и недостатки.
\end{teaser}

\section{Постановка проблемы}

В обучающих материалах по Clojure встречаются примеры:

\begin{english}
  \begin{clojure}
(def server
  (jetty/run-jetty app {:port 8080}))

(def db {:dbtype   "postgres"
         :dbname   "test"
         :user     "ivan"
         :password "test"})
  \end{clojure}
\end{english}

Это сервер на 8080 порту и параметры подключения к базе. Польза примеров в том,
что их можно скопировать в REPL и оценить результат: открыть страницу в браузере
или прочитать таблицу.

На практике код пишут так, чтобы в нем не было конкретных цифр и строк. С точки
зрения проекта плохо, что у серверу явно задали порт. Это подойдет для
документации и примеров, но не боевого запуска.

Порт 8080, ровно как и другие комбинации нулей и восьмерок, популярен у
программистов. Велика вероятность, что порт занят другим сервером. Это возможно,
когда запускают не отдельный сервис, а их связку на время разработки или тестов.

Код, написанный программистом, проходит несколько стадий. В разных фирмах набор
отличается, но в целом это разработка, тестирование, предварительный запуск и
боевой режим.

На каждой стадии приложение запускают бок о бок с другими
проектами. Предположение, что порт 8080 свободен в любой момент это утопия. На
жаргоне разработчиков ситуацию называют <<хардкод>> (анг. <<hardcode>>) или
<<прибито гвоздями>>.

Когда код работает на <<прибитых>> значениях, это вносит проблемы в его цикл. Вы
не сможете одновременно разрабатывать и тестировать приложение. Или два тестовых
сервера подключатся к одной базе данных, и вы не поймете, почему данные меняются
спонтанно.

Приложение не должно знать, на каком порту запускать веб-сервер. Информация об
этом приходит извне. В простом случае это файл настроек. Программа читает из
него порт и запускает сервер именно так, как это нужно на конкретной машине.

В более сложных сценариях файл составляет не человек, а специальная
программа~--- менеджер конфигураций. Менеджер хранит информацию о топологии
сети, адреса машин, типы баз данных и параметры доступа к ним. По запросу он
выдает файл для определенной машины или сегмента сети.

Процесс, когда приложению сообщают параметры, а оно принимает их, называется
конфигурацией. Это интересный и важный процесс. Когда он построен удачно, проект
не испытывает трудностей на всех стадиях производства.

\section{Семантика}

Цель конфигурации в том, чтобы управлять программой, не меняя ее код. К ней
приходят с ростом кодовой базы и инфраструктуры. Если у вас мелкий скрипт на
Python, нет ничего зазорного в том, чтобы открыть его в блокноте и поменять
константу. На предприятиях такие скрипты работают годами.

Чем сложнее инфраструктура фирмы, тем больше в ней ограничений. Современные
практики сводят на нет спонтанные изменения в проекте. Например, нельзя сделать
\spverb|git push| напрямую в мастер; запрещен \spverb|merge|, пока вашу работу
не одобрят двое коллег; приложение не попадет на сервер, пока не пройдут тесты.

Это приводит к тому, что малейшее изменение в коде займет час, чтобы попасть в
бой. Правка в конфигурации гораздо дешевле, чем выпуск новой версии продукта. Из
этого следует правило: если можно вынести что-то в конфигурацию, сделайте это
сейчас.

\label{feature-flags}

В крупных фирмах практикуют то, что называют <<feature flag>>. Это логическое
поле, которое включает целый пласт логики в приложении. Например, новый
интерфейс, систему обработки заявок, улучшенный чат. Значимые обновления долго
тестируют внутри фирмы, но всегда остается риск, что в бою \emph{что-то пойдет
не так}. Тогда флаг меняют на ложь и перезапускают сервер. Это не только
сэкономит время, но и сохранит репутацию фирмы.

\section{Цикл конфигурации}

Когда приложение запускают, оно ищет конфигурацию. Чем лучше устроено
приложение, тем больше его частей опирается на настройки. Обработка конфигурации
это не монолитная задача, а набор шагов. Перечислим наиболее важные из них.

На первом этапе программа \textbf{читает конфигурацию}. Чаще всего это файл или
переменные среды. Чтобы хранить данные в тексте, придуманы форматы JSON, YAML и
другие. Приложение несет на борту модуль, чтобы получить из файла данные. Мы
рассмотрим плюсы и минусы известных форматов ниже.

Переменные среды это часть операционной системы. Представьте их как глобальный
словарь в памяти. Каждое приложение наследует этот словарь при запуске. Языки и
фреймворки предлагают функции, чтобы считать переменные в строки и словари.

Файлы и переменные среды дополняют друг друга. Например, приложение читает
данные из файла, но путь к нему ищет в переменных среды. Или в файле опущены
критические данные: пароли, API-ключи. Так поступают, чтобы посторонние
программы не подсмотрели их. Приложение читает параметры из файла, а секретные
ключи из переменных.

Продвинутые конфигурации поддерживают теги. в файле перед значением переменной
ставят тег: \spverb|:password #env DB_PASSWORD|. Это значит, что в поле
\spverb|password| не строка \spverb|DB_PASSWORD|, а значение одноименной
переменной.

Первый этап завершается тем, что мы получили данные. Неважно, был ли это файл,
переменные среды или что-то другое. Приложение переходит ко второму этапу~---
\textbf{выводу типов}.

JSON или YAML выделяют базовые типы: строки, числа, булево и null. Легко
заметить, что среди них нет даты. С помощью дат задают промо-акции или события,
связанные с праздниками. В файлах даты указывают либо строкой в формате ISO,
либо числом секунд c 1 января 1970 года (эпоха UNIX). Специальный код пробегает
про данным и приводит даты к типу, принятому в языке.

Вывод типов применяют и для коллекций. Иногда словари и массивы недостаточны для
комфортной работы. Например, типы событий хранят в виде множества, потому что
поиск в нем быстрее, чем в массиве, и отсекаются дубли. Скаляры тоже оборачивают
в классы, например, \spverb|UUID| для идентификаторов.

Переменные среды не настолько гибки, как современные форматы. Если JSON выделяет
скаляры и коллекции, то переменные несут только строки. Вывод типов для них не
просто желателен, а необходим. Нельзя передать порт в виде строки туда, где
ожидают число.

После вывода типов приступают к \textbf{валидации данных}. В главе про Spec мы
выяснили, что верный тип не обещает верное значение. Проверка нужна, чтобы в
конфигурации нельзя было указать порт 0, -1 или 80.

Из той же главы мы помним, что иногда значения верны по отдельности, но их
комбинация ошибочна. Пусть в конфигурации задан период акции. Это массив из двух
дат, начало и завершение. Легко перепутать даты местами, и тогда проверка любой
даты на интервал вернет ложь.

После валидации переходят к последней стадии. Приложение определяет, где
\textbf{хранить конфигурацию}. Это может быть глобальная переменная или
компонент системы. Другие части программы читают оттуда параметры.

\section{Ошибки конфигурации}

На каждом этапе может возникнуть ошибка: не найден файл, ошибка синтаксиса,
неверное поле. В этом случае от система выводит сообщение и
завершается. Сообщение должно четко отвечать на вопрос, что случилось. Часто
программисты держат в голове только положительный путь и забывают об
ошибках. При запуске их программ виден стек-трейс, который трудно понять.

В главе про исключения мы рассмотрели прием. Если логика состоит из отдельных
шагов, каждый из них оборачивают в \spverb|try/catch|. Исключение, которое
поймали, кидают повторно с понятным сообщением и
контекстом \page{re-throw-example}.

Когда ошибка случилась на этапе проверки, объясните, какое поле было тому
виной. В главе про Spec мы рассмотрели, как улучшить стандартный отчет
спеки \page{spec-messages}. Это требует усилий, но окупается со временем.

В IT-индустрии одни сотрудники пишут код, а другие управляют им. Ваш
коллега-DevOps не знает, что такое Clojure и не поймет сырой
\spverb|explain|. Рано или поздно он придет с просьбой доработать сообщения
конфигурации. Сделайте это заранее из уважения к коллегам.

Если с конфигурацией что-то не так, программа не должна работать в надежде, что
все обойдется. Бывает, когда один из параметров задан неверно, но программа к
нему не обращается. Избегайте этого: ошибка всплывет в самый неподходящий
момент.

Когда один из шагов конфигурации не сработал, программа завершается с кодом,
отличным от нуля. Сообщение пишут в канал \spverb|stderr|, чтобы подчеркнуть
внештатную ситуацию. Продвинутые терминалы подсвечивают текст из \spverb|stderr|
красным цветом.

\section{Практика: загрузчик конфигурации}

Чтобы закрепить теорию, напишем свою систему конфигурации. Это отдельный модуль
примерно на сто строк. Прежде чем садиться за редактор, обдумаем основные
моменты кода.

Будем хранить конфигурацию в JSON-файле. Предположим, фирма недавно перешла на
Clojure, и у DevOps уже написаны скрипты на Python для управления
настройками. Формат EDN усложнит коллегам работу.

Путь к файлу задают в переменной среды \spverb|CONFIG_PATH|. От файла мы ожидаем
порт сервера, параметры базы данных и диапазон дат для промо-акции. Текстовые
даты должны стать объектами \spverb|java.util.Date|. Дата начала строго меньше
конца.

Готовый словарь запишем в глобальную переменную \spverb|CONFIG|. Если на одном
из шагов случилась ошибка, покажем сообщение и завершаем программу.

Начнем со вспомогательной функции \spverb|exit|. Она принимает код завершения,
текст и параметры форматирования. Если код равен нулю, пишем сообщение в
\spverb|stdout|, иначе в \spverb|stderr|.

\begin{english}
  \begin{clojure}
(defn exit
  [code template & args]
  (let [out (if (zero? code) *out* *err*)]
    (binding [*out* out]
      (println (apply format template args))))
  (System/exit code))
  \end{clojure}
\end{english}

Переходим к загрузчику. Это набор шагов, каждый из которых принимает результат
предыдущего. Логику каждого легко понять по имени. Вывод типов и валидация
совместим в одном шаге \spverb|coerce-config|, поскольку технически это вызов
\spverb|s/conform|.

\begin{english}
  \begin{clojure}
(defn load-config! []
  (-> (get-config-path)
      (read-config-file)
      (coerce-config)
      (set-config!)))
  \end{clojure}
\end{english}

Теперь опишем каждый шаг. Функция \spverb|get-config-path| читает переменную
среды и проверяет, есть ли такой файл на диске. Если все в порядке, функция
вернет путь к файлу, иначе вызовет \spverb|exit|:

\begin{english}
  \begin{clojure}
(import 'java.io.File)

(defn get-config-path []
  (if-let [filepath (System/getenv "CONFIG_PATH")]
    (if (-> filepath (new File) .exists)
      filepath
      (exit 1 "File %s does not exist" filepath))
    (exit 1 "File path is not set")))
  \end{clojure}
\end{english}

Шаг \spverb|read-config-file| читает файл по его пути. Для разбора JSON служит
библиотека \spverb|cheshire|. Ее функция \spverb|parse-string| вернет данные из
строки документа.

\begin{english}
  \begin{clojure}
(require '[cheshire.core :as json])

(defn read-config-file
  [filepath]
  (try
    (-> filepath slurp (json/parse-string true))
    (catch Exception e
      (exit 1 "Malformed config file: %s" (ex-message e)))))
  \end{clojure}
\end{english}

Вывод типов и проверка займут больше места. Это самый важный этап: нельзя
допустить, чтобы приложение запустилось с неверными параметрами. Шаг
\spverb|coerce-config| пропускает данные из файла через
\spverb|s/conform|. Вызов потенциально несет исключения, поэтому обернем его в
\spverb|pcall| (безопасный вызов, который вернет пару $\langle$ошибка,
результат$\rangle$). Если результат было \spverb|:invalid|, формируем отчет об
ошибке и завершаем программу. Для отчета возьмем библиотеку Expound.

\begin{english}
  \begin{clojure}
(require '[clojure.spec.alpha :as s])
(require '[expound.alpha :as expound])

(defn coerce-config [config]
  (let [[e result] (pcall s/conform ::config config)]
    (cond
      (some? e)
      (exit 1 "Wrong config values: %s" (ex-message e))

      (= result ::s/invalid)
      (let [report (expound/expound-str ::config config)]
        (exit 1 "Invalid config values: %s %s" \newline report))

      :else result)))
  \end{clojure}
\end{english}

Не хватает спеки. Откроем конфигурацию и изучим ее структуру:

\begin{english}
  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}
\end{english}

\noindent
Опишем спеку сверху вниз. На верхнем уровне это словарь с ключами:

\begin{english}
  \begin{clojure}
(s/def ::config
  (s/keys :req-un [::server_port ::db ::event]))
  \end{clojure}
\end{english}

Порт сервера это комбинация двух предикатов: число и вхождение в диапазон.
Проверка на число нужна, чтобы во второй предикат не попали \spverb|nil| и
строка. Это вызовет исключение там, где его не ждали.

\begin{english}
  \begin{clojure}
(s/def ::server_port
  (s/and int? #(<= 1024 % 65534)))
  \end{clojure}
\end{english}

Для подключения к базе данных укажем готовую спеку из JDBC:

\begin{english}
  \begin{clojure}
(require '[clojure.java.jdbc.spec :as jdbc])
(s/def ::db ::jdbc/db-spec)
  \end{clojure}
\end{english}


Поле \spverb|event| сложное, поэтому тоже опишем его сверху вниз. Это комбинация
кортежа дат и проверки диапазона:

\begin{english}
  \begin{clojure}
(s/def ::event
  (s/and (s/tuple ::->date ::->date)
         ::date-range))
  \end{clojure}
\end{english}

Спека \spverb|::->date| выводит дату из строки. Чтобы не писать ручной разбор,
возьмем функцию \spverb|read-instant-date| из пакета
\spverb|clojure.instant|. Функция лояльна к формату и читает неполные даты,
например, только год. Обернем ее в \spverb|s/conformer|. Впереди ставим
\spverb|::ne-string|, чтобы отсечь мусор.

\begin{english}
  \begin{clojure}
(require '[clojure.instant :as inst])

(s/def ::->date
  (s/and ::ne-string (s/conformer read-instant-date)))
  \end{clojure}
\end{english}

Опишем проверку диапазона. Она принимает пару объектов \spverb|java.util.Date| и
сравнивает их. Даты нельзя сравнить знаками <<больше>> или <<меньше>>: это
особенность класса \spverb|Date|. Для сравнения дат служит функция
\spverb|compare|, которая вернет -1, 0 и 1 для случаев меньше, равно и больше.

\begin{english}
  \begin{clojure}
(s/def ::date-range
  (fn [[date1 date2]]
    (neg? (compare date1 date2))))
  \end{clojure}
\end{english}

На этом месте можно вызвать \spverb|load-config!| и убедиться, что на выходе
словарь с правильными типами. Последний шаг \spverb|set-config!| пишет словарь в
глобальную переменную \spverb|CONFIG|. Верхний регистр не допустит, чтобы где-то
в коде мы затенили ее локальной \spverb|config|. Для подмены переменной
ипользуем \spverb|alter-var-root|.

\begin{english}
  \begin{clojure}
(def CONFIG nil)

(defn set-config!
  [config]
  (alter-var-root (var CONFIG) (constantly config)))
  \end{clojure}
\end{english}

На старте программы выполните \spverb|(load-config!)|, чтобы в переменной
появилась конфигурация. Другие модули импортируют \spverb|CONFIG| и читают
нужные им ключи. Вот как запустить сервер или выполнить запрос с учетом
конфигурации:

\begin{english}
  \begin{clojure}
(require '[project.config :refer [CONFIG]])

(def server
  (jetty/run-jetty app {:server_port CONFIG
                        :join? false}))

(jdbc/query (:db CONFIG) "select * from users")
  \end{clojure}
\end{english}

\subsection{Работа над ошибками}

Мы написали загрузчик конфигурации. Он удобен в поддержке: каждый шаг это
функция, которую легко доработать. Чтобы добавить новое поле, расширьте
спеку. Это не промышленное решение, но загрузчик подойдет для небольших
проектов.

Преимущество в том, что в любой момент можно считать конфигурацию заново. Это
особенно удобно при разработке: измените файл и выполните \spverb|load-config!|
в REPL. В \spverb|CONFIG| появится новая конфигурация.

Недостаток загрузчика в том, что код привязан к функции \spverb|exit|, которая
завершает JVM. В боевом запуске это правильный подход: нельзя продолжать, если в
параметрах ошибка. Однако в разработке от этого больше проблем: любая ошибка
завершает REPL, и придется включать его заново.

Завершение JVM это слишком радикальное действие. Загрузка и реакция на ошибки
должны быть разделены. Наивный способ~--- вызвать \spverb|load-config!| в рамках
подмены \spverb|exit|. Функция ниже не завершит JVM, а только бросит исключение
с текстом, который передали в \spverb|exit|:

\begin{english}
  \begin{clojure}
(defn load-config-repl! []
  (with-redefs
    [exit (fn [_ template & args]
            (let [^String message
                  (apply format template args)]
              (throw (new Exception message))))]
    (load-config!)))
  \end{clojure}
\end{english}

Более удачное решение~--- передать в \spverb|load-config!| дополнительные
параметры. Назовем один из них \spverb|:die-fn|. Это функция, которая принимает
исключение. В боевом запуске <<die function>> завершает JVM, а в разработке
пишет сообщение в REPL.

Доработайте загрузчик так, чтобы он поддерживал параметр
\spverb|:die-fn|. Продумайте поведение по умолчанию, если он не задан.

\section{Подробнее о переменных среды}

Загрузчик читает данные из файла. Из переменных среды он берет только малую
часть~--- путь к файлу. Изменим загрузчик: пусть он читает данные из переменных
среды и не нуждается в файлах. Чтобы понять преимущества этого подхода,
поговорим о переменных в отрыве от языка.

Переменные среды называют ENV, <<энвы>> (анг. <<environment>>, окружающая
среда). Это фундаментальное свойство операционной системы. Представьте
переменные как глобальный словарь, который наполняется во время запуска
компьютера. В словаре лежат основные параметры системы: локаль, список путей,
где система ищет бинарные файлы и многое другое.

Чтобы увидеть текущие переменные, запустите в терминале \spverb|env| или
\spverb|printenv|. На экране появится пары \spverb|ИМЯ=значение|. Имена
переменных пишут в верхнем регистре, чтобы выделить на общем фоне и подчеркнуть
их приоритет. Большинство систем различают регистр, поэтому \spverb|foo| и
\spverb|FOO| это разные переменные. Пробелы и дефисы недопустимы; лексемы
отделяют подчеркиванием. Фрагмент вывода \spverb|printenv|:

\begin{english}
  \begin{bash}
LANG=en_US.UTF-8
PWD=/Users/ivan
SHELL=/bin/zsh
TERM_PROGRAM=iTerm.app
COMMAND_MODE=unix2003
  \end{bash}
\end{english}

Каждый процесс получает копию этого словаря. Процесс может добавить или удалить
переменную, но изменения видны только ему и потомкам. Потомок процесса наследует
переменные родителя.

\subsection{Локальные и глобальные переменные}

Различают переменные \emph{среды} и \emph{шелла}, они же глобальные и локальные
переменные. Их часто путают новички. Выполните в терминале команду:

\begin{english}
  \begin{bash}
FOO=42
  \end{bash}
\end{english}

Вы задали переменную шелла. Чтобы сослаться на переменную (получить значение по
имени, <<дерефнуть>>), поставьте перед ней доллар. Пример ниже напечатает 42:

\begin{english}
  \begin{bash}
echo $FOO
42
  \end{bash}
\end{english}

Если выполнить \spverb|printenv|, мы не увидим \spverb|FOO| в выводе. Команда
\spverb|FOO=42| задает переменную шелла, а не среды. Переменные шелла видны
только ему и не наследуются потомками. Проверим это: из текущего шелла запустим
новый и повторим печать.

\begin{english}
  \begin{bash}
sh
echo $FOO
  \end{bash}
\end{english}

Получим пустую строку, потому что в процессе-потомке такой переменной
нет. Выполните \spverb|exit|, чтобы вернуться в родительский шелл.

Команда \spverb|export| означает, что переменная становится частью
среды. Заданная таким образом, она видна в \spverb|printenv| и доступна
потомкам:

\begin{english}
  \begin{bash}
export FOO=42

printenv | grep FOO
FOO=42

sh
echo $FOO
42
  \end{bash}
\end{english}

Иногда нужно запустить процесс с переменной, но так, чтобы не повлиять на
текущее состояние. Тогда команду указывают после выражения
\spverb|ИМЯ=значение|:

\begin{english}
  \begin{bash}
BAR=99 printenv | grep BAR
BAR=99
  \end{bash}
\end{english}

\spverb|Printenv| порождает новый процесс, которому доступна переменная
\spverb|BAR|. Если снова напечатать \spverb|$BAR|, получим пустую строку.

Программы читают из переменных свои настройки. Клиент к базе данных PostgreSQL
различает два десятка переменных: \spverb|PGHOST|, \spverb|PGDATABASE|,
\spverb|PGUSER| и другие. У переменных среды выше приоритет, чем у параметров
\spverb|--host|, \spverb|--user| и аналогов. Если в текущем шелле выполнить
команды:

\begin{english}
  \begin{bash}
export PGHOST=host.com PGDATABASE=project
  \end{bash}
\end{english}

\noindent
, то каждая утилита PostgreSQL сработает на заданном сервере и базе. Это удобно
для серии команд: не придется каждый раз указывать \spverb|--host| и другие
аргументы.

\section{Конфигурация в среде}

Переменными среды можно задать конфигурацию. Каждый язык предлагает функции,
чтобы читать переменные в строки или словарь. Разберем плюсы и минусы этого
подхода.

Поскольку окружение находится в памяти, приложение не обращается к диску при их
чтении. Дело даже не в том, что память быстрее диска: человек не отличит сотую
долю секунды от тысячной. Приложение, которое не зависит от файлов более
автономно и потому удобней в поддержке.

Бывает, файл конфигурации оказался в другой папке, и приложение не может его
найти. Или, что еще хуже, запускается со старой версией файла. Это замедляет
работу, съедает полезное время.

\label{password-note}

Хранить пароли и ключи в переменных безопаснее, чем в файлах. В случае с файлами
их могут прочесть другие программы, в том числе вредоносные. По ошибке файл
может попасть в репозиторий и остаться в истории. Существуют боты-скрипты,
которые ищут в публичных репозиториях AWS-ключи (и порой их находят).

Даже если файлом владеет другой пользователь, он может быть доступен для чтения
остальным. Переменные среды эфемерны: они живут только памяти операционной
системы. Невозможно прочитать переменные процесса другого пользователя.

Индустрия постепенно уходит от файлов в сторону \emph{контейнеров}. Если раньше
мы копировали файлы по FTP, то сегодня приложение запускают из образов. Это
архив, в который упакован код и его окружение. В отличии от настоящего архива,
образ нельзя изменить. Чтобы обновить файл в образе, придется собрать его
заново, что затрудняет процесс.

Наоборот, виртуализация лояльна к переменным среды. Их указывают при запуске
образа в параметрах. Один и тот же образ запускают с разными переменными; новая
сборка не требуется. Чем больше опций можно задать переменными, тем удобней
образ в работе. Ниже сервер PostgreSQL включается с готовой базой и
пользователем:

\begin{english}
  \begin{bash}
docker run \
  -e POSTGRES_DB=project_db \
  -e POSTGRES_USER=POSTGRES_USER \
  -e POSTGRES_PASSWORD=project_secret \
  -d postgres
  \end{bash}
\end{english}

Принцип <<конфигурация в среде>> встречается в одном из пунктов <<The
Twelve-Factor App>>\footurl{https://12factor.net/}. Это свод правил для
разработки надежных приложений. Его третий пункт посвящен конфигурации. Автор
упоминает те же плюсы переменных, что мы рассмотрели: независимость от файлов,
безопасность, поддержка на всех платформах.

\section{Недостатки среды}

Переменные не поддерживают типы: любое значение это текст. Вывод типов остается
на ваше усмотрение. Делайте это декларативно, а не вручную. Неудачный пример на
Python:

\begin{english}
  \begin{python}
db_port = int(os.environ["DB_PORT"])
  \end{python}
\end{english}

Когда переменных больше двух, код становится уродливым. Задайте словарь, где
ключ это имя переменной, а значение~--- функция вывода. Специальный код обходит
словарь и наполняет результат. Для краткости опустим перехват ошибок:

\begin{english}
  \begin{python}
import os
env_mapping = {"DB_PORT": int}

result = {}
for (env, fn) in env_mapping.iteritems():
    result[env] = fn(os.environ[env])
  \end{python}
\end{english}

\noindent
Подход справедлив и для других языков. В Clojure для этого служит спека.

Переменные среды не работают с иерархией. Это плоский набор ключей и значений,
что не всегда ложиться на конфигурацию. Чем больше параметров, тем чаще их
группируют по смыслу. Предположим, подключение к базе задают задают десять
параметров. Чтобы не ставить перед каждым префикс, их выносят в дочерний
словарь.

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{clojure}
;; so-so
{:db-name "book"
 :db-user "ivan"
 :db-pass "****"}
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
;; better
{:db {:name "book"
      :user "ivan"
      :pass "****"}}
  \end{clojure}
\end{english}

\end{tabular}

В разных системах вложенные переменные читают по-разному. Например, одинарное
подчеркивание разделет лексемы, но не меняет структуру. Двойное подчеркивание
означает вложенность:

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{clojure}
"DB_NAME=book"
;; {:db-name "book"}
  \end{clojure}
\end{english}

&

\begin{english}
  \begin{clojure}
"DB__NAME=book"
;; {:db {:name "book"}}
  \end{clojure}
\end{english}

\end{tabular}

Массив задают в квадратных скобках или через запятую. При разборе массива
остается риск ложного разбиения. Это случается, когда запятая или скобка
относится к слову, а не к синтаксису.

Форматы JSON и YAML задают четкий стандарт, как записывать коллекции. Для
переменных среды нет единого соглашения. Ситуация ухудшается, когда компонент
ожидает параметр большой вложенности, например, список словарей. Переменные
среды не справляются с такой структурой.

При разработке очевиден еще один недостаток переменных~--- в некоторых системах
они доступны только для чтения. Это верно идеологически, но вынуждает заново
включать REPL на каждое изменение конфигурации. Для файла достаточно изменить
его и прочитать заново.

\subsection{Env-файлы}

Когда переменных много, вводить их вручную ввод через \spverb|export|
утомительно. Переменные выносят в файл, который называют
\emph{env}-конфигурацией.

Технически это шелл-скрипт, но чем меньше в нем скриптовых возможностей, тем
лучше. В идеале в файле только пары \spverb|ИМЯ=значение| по одной на каждую
строку. Назовем файл просто \spverb|ENV| без расширения.

\begin{english}
  \begin{bash}
DB_NAME=book
DB_USER=ivan
DB_PASS=****
  \end{bash}
\end{english}

Чтобы считать переменные в шелл, вызывают \spverb|source <file>|. Это одна из
команд \spverb|bash|, которая выполняет скрипт в текущем сеансе. Cкрипт добавит
переменные в шелл, и вы увидите их после завершения \spverb|source|. Это важное
отличие от команды \spverb|bash <file>|, которая выполнит скрипт в новом шелле.

\begin{english}
  \begin{bash}
source ENV
echo $DB_NAME
book
  \end{bash}
\end{english}

Если запустить из текущего шелла приложение, оно не получит переменные из
файла. Вспомним, что выражение \spverb|VAR=value| задает локальную
переменную. \spverb|DB_NAME| и другие не попадут в окружение, и программа не
унаследует их. Проверим это с помощью \spverb|printenv|:

\begin{english}
  \begin{bash}
source ENV
printenv | grep DB
# exit 1
  \end{bash}
\end{english}

Есть два способа решить проблему. Первый~--- открыть файл и расставить перед
каждой парой выражение \spverb|export|. Тогда \spverb|source| этого файла
добавит переменные в окружение:

\begin{english}
  \begin{bash}
cat ENV
export DB_NAME=book
export DB_USER=ivan
export DB_PASS=****

source ENV
printenv | grep DB
DB_NAME=book
DB_USER=ivan
DB_PASS=****
  \end{bash}
\end{english}

Недостаток в том, что в файле появляется логика скрипта. Легко забыть
\spverb|export| перед переменной, и приложение не прочитает ее.

Второй способ основан на параметре \spverb|-a| (\textbf{a}llexport) текущего
шелла. Когда он установлен, локальная переменная переходит в окружение. Перед
тем, как читать переменные из файла, флаг возводят в истину, а затем снова в
ложь.

\begin{english}
  \begin{bash}
set -a
source ENV
printenv | grep DB
# prints all the vars
set +a
  \end{bash}
\end{english}

Выражение \spverb|set| противоречиво: параметр с минусом включает параметр, а с
плюсом~--- отключает. Это исключение, которое придется запомнить.

Если считать переменную, которая уже в окружении, она заменит прежнее
значение. Так строят конфигурации на файлах-переопределениях. Если нужны особые
настройки для тестов, не обязательно дублировать весь файл. Создайте файл с
полями, которые нужно заменить и выполнить его после главного.

Пусть тестовые настройки отличаются от стандартных именем базы. Файл
\spverb|ENV| несет базовые параметры. В \spverb|ENV_TEST| поместим новое
значение \spverb|DB_NAME=test|, затем прочтем оба файла.

\begin{english}
  \begin{bash}
set -a
source ENV
source ENV_TEST
set +a

echo $DB_NAME
test
  \end{bash}
\end{english}

Читатель заметит, что env-файлы противоречивы. Мы сказали, что переменные
снимают зависимость от файлов, но в итоге поместили переменные в файл. Какой в
этом смысл?

Разница между JSON- и ENV-файлами в том, кто их читает. В первом случае
конфигурацию читает приложение, а во втором~--- операционная система. Файл
находится в строго заданной директории, а переменные среды доступны ото
всюду. Мы избавим приложение от кода, который ищет и читает файл. Останется
запас для маневра: переменные задают по-разному в зависимости от инструмента
(шелл, Docker, Kubernetes).

\section{Переменные среды в Clojure}

Clojure это гостевая платформа, поэтому язык не предлагает доступ к системным
ресурсам. В главном модуле нет функции для чтения переменных среды. Получим их
из класса \spverb|java.lang.System|. Импортировать класс не нужно, он доступен в
любом пространстве имен.

Статический метод \spverb|getenv| вернет либо одну переменную по имени, либо
весь словарь, если имя не указали.

\begin{english}
  \begin{clojure}
;; a single variable
(System/getenv "HOME")
"/Users/ivan"

;; all variables
(System/getenv)
{"JAVA_ARCH" "x86_64", "LANG" "en_US.UTF-8"} ;; truncated
  \end{clojure}
\end{english}

Во втором случае получили не Clojure-, а Java-коллекцию. Это persistent-версия
класса \spverb|Map|, поэтому переменные нельзя изменить после запуска JVM.

%% ---------------

Чтобы облегчить работу со словарем, приведем его к типу Clojure. Заодно исправим
ключи: сейчас это строки в верхнем регистре и подчеркиваниями. В Clojure
пользуются кейвордами и записью <<kebab-case>>: нижний регистр с дефисами.

Напишем функцию для перевода ключа:

\begin{english}
  \begin{clojure}
(require '[clojure.string :as str])

(defn remap-key [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      keyword))
  \end{clojure}
\end{english}

\noindent
и убедимся в ее работе:

\begin{english}
  \begin{clojure}
(remap-key "DB_PORT")
:db-port
  \end{clojure}
\end{english}

Функция \spverb|remap-env| проходит по словарю Java и возвращает его
<<кложурную>> версию с привычными ключами:

\begin{english}
  \begin{clojure}
(defn remap-env [env]
  (reduce
   (fn [acc [k v]]
     (let [key (remap-key k)]
       (assoc acc key v)))
   {}
   env))
  \end{clojure}
\end{english}

\noindent
Приведем небольшую часть словаря:

\begin{english}
  \begin{clojure}
(remap-env (System/getenv))

{:home "/Users/ivan"
 :lang "en_US.UTF-8"
 :term "xterm-256color"
 :java-arch "x86_64"
 :term-program "iTerm.app"
 :shell "/bin/zsh"}
  \end{clojure}
\end{english}

Когда переменные это словарь, он идет по тому же конвейеру: вывод типов,
валидация спекой. Поскольку все значения строки, спеку нужно доработать, чтобы
она выводила числа из строк. Раньше в этом не было нужды, потому что числа
приходили из JSON. Удачной будет спека, которая учитывает и число, и строку. Вот
как выглядит умный парсер числа:

\begin{english}
  \begin{clojure}
(s/def ::->int
  (s/conformer
   (fn [value]
     (cond
       (int? value) value
       (string? value)
       (try (Integer/parseInt value)
            (catch Exception e
              ::s/invalid))
       :else ::s/invalid))))
  \end{clojure}
\end{english}

С этой спекой можно менять источник данных без изменений в коде.

\subsection{Проблема лишних ключей}

У словаря переменных недостаток~--- много посторонних полей. Приложению не нужно
знать версию терминала или путь к Python. Эти поля вносят шум при печати и
записи в лог. Если параметры не прошли спеку, мы увидим лишние данные в
\spverb|explain|. Их следует убрать.

На последнем шаге \spverb|s/conform| нужно выбрать из словаря только полезную
часть. Функция \spverb|select-keys| вернет подмножество словаря по списку
ключей. Но как задать ключи? Перечислять их вручную долго, и к тому же мы
дублируем код. Мы уже указали ключи в спеке \spverb|::config|, и делать это
второй раз не хочется. С помощью трюка вытащим из спеки ее ключи.

Функция \spverb|s/form| принимает ключ спеки и возвращает ее <<замороженную>>
форму: то, что передали в \spverb|s/def|. Это список, где каждый элемент
примитив Clojure: символ, кейворд, вектор и так далее. Для спеки
\spverb|::config| получим список:

\begin{english}
  \begin{clojure}
(clojure.spec.alpha/keys
 :req-un [:book.config/server_port
          :book.config/db
          :book.config/event])
  \end{clojure}
\end{english}

Обратите внимание: это \emph{список}, а не код. Нужные ключи находятся в третьем
элементе после \spverb|:req-un|. Будет правильно учесть и другие типы ключей,
например \spverb|:opt-un|. Напишем универсальную функцию, которая вернет все
ключи из спеки \spverb|s/keys|.

Отбросим первый символ формы. Останется список, где нечетные элементы это тип
ключа, а четные~--- их вектор. Перестроим список в словарь и объединим
значения. Для ключей \spverb|-un| отбросим пространство. Все вместе дает нам
функцию:

\begin{english}
  \begin{clojure}
(defn spec->keys
  [spec-keys]
  (let [form (s/form spec-keys)
        params (apply hash-map (rest form))
        {:keys [req opt req-un opt-un]} params
        ->unqualify (comp keyword name)]
    (concat req
            opt
            (map ->unqualify opt-un)
            (map ->unqualify req-un))))
  \end{clojure}
\end{english}

\noindent
Проверим спеку загрузчика:

\begin{english}
  \begin{clojure}
(spec->keys ::config)
(:server_port :db :event)
  \end{clojure}
\end{english}

\noindent
Перепишем чтение переменных в словарь:

\begin{english}
  \begin{clojure}
(defn read-env-vars []
  (let [cfg-keys (spec->keys ::config)]
    (-> (System/getenv)
        (remap-env)
        (select-keys cfg-keys))))
  \end{clojure}
\end{english}

\noindent
Так мы получим только полезные ключи, то есть те, что указаны в спеке.

\subsection{Загрузчик среды}

Доработаем загрузчик, чтобы он работал с переменными среды. Замените первые два
шага на \spverb|read-env-vars|. Теперь программа не зависит от файла
конфигурации.

\begin{english}
  \begin{clojure}
(defn load-config! []
  (-> (read-env-vars)
      (coerce-config)
      (set-config!)))
  \end{clojure}
\end{english}

Сделайте так, чтобы источник данных можно было задать параметром. Например,
\spverb|:source "/path/to/config.json"| означает считать файл, а
\spverb|:source :env|~--- переменные среды.

Еще сложнее: как считать оба источника и объединить их? Важен ли порядок и как
его обеспечить? Как сделать объединение ассиметричным, то есть когда второй
словарь только \emph{замещает} поля первого, но не дополняет новыми?

\subsection{Вывод структуры}

Мы упоминали проблему структуры в переменных среды. Редко бывает так, что
конфигурация это плоский словарь. Близкие параметры собирают во вложенные
словари, например, отдельно параметры сервера и базы данных. Сгруппированные
настройки удобней в поддержке.

Улучшим загрузчик: научим его читать вложенные переменные. Договоримся, что
двойное подчеркивание означает вложенную структуру. Поместим в файл
\spverb|ENV_NEST| следующие переменные:

\begin{english}
  \begin{bash}
DB__NAME=book
DB__USER=ivan
DB__PASS=****
HTTP__PORT=8080
HTTP__HOST=api.random.com
  \end{bash}
\end{english}

\noindent
Прочитаем его и запустим REPL с новой средой:

\begin{english}
  \begin{bash}
set -a
source ENV_NEST
lein repl
  \end{bash}
\end{english}

Изменим функции разбора ключа и обхода окружения. Функция
\spverb|remap-key-nest| принимает ключ-строку и возвращает вектор составных
частей, лексем:

\begin{english}
  \begin{clojure}
(def ->keywords (partial map keyword))

(defn remap-key-nest
  [^String key]
  (-> key
      str/lower-case
      (str/replace #"_" "-")
      (str/split #"--")
      ->keywords))

(remap-key-nest "DB__PORT")
;; (:db :port)
  \end{clojure}
\end{english}

Функция обхода отличается тем, что делает не \spverb|assoc|, а
\spverb|assoc-in|, что порождает вложенность:

\begin{english}
  \begin{clojure}
(defn remap-env-nest
  [env]
  (reduce
   (fn [acc [k v]]
     (let [key-path (remap-key-nest k)]
       (assoc-in acc key-path v)))
   {}
   env))
  \end{clojure}
\end{english}

Код ниже вернет параметры по группам, как и задумано. Приведем их подмножество:

\begin{english}
  \begin{clojure}
(-> (System/getenv)
    (remap-env-nest)
    (select-keys [:db :http]))

{:db {:user "ivan", :pass "****", :name "book"},
 :http {:port "8080", :host "api.random.com"}}
  \end{clojure}
\end{english}

\noindent
Дальше действуем как обычно: пишем спеку, выводим типы из строк и так далее.

Подумайте, как задать в переменной массив. Чем разделить элементы? В каких
случаях возможно ложное разбиение?

\section{Простой менеджер конфигурации}

К этому моменту читатель решит, что конфигурация в файле это плохая идея. Однако
не бросайтесь переписывать код на переменные среды. На практике работают с
\emph{гибридными} моделями, которые сочетают оба подхода. Приложение читает
основные параметры из файла, а пароли и ключи доступа из среды.

Рассмотрим, как подружить файлы и окружение. Наивное решение не потребует писать
код: оно работает на утилитах командной строки. Программа \spverb|envsubst| из
пакета \spverb|GNU gettext| предлагает простую шаблонную систему. Чтобы
установить \spverb|gettext|, выполните в терминале команду

\begin{english}
  \begin{bash}
<manager> install gettext
  \end{bash}
\end{english}

\noindent
, где \spverb|<manager>| это мастер пакетов для вашей системы (\spverb|brew|,
\spverb|apt|, \spverb|yum| и другие).

Текст шаблона приходит из \spverb|stdin|, а роль контекста играют переменные
среды. Утилита заменяет выражения \spverb|$VAR_NAME| на значения одноименной
переменной. Поместим шаблон в файл \spverb|config.tpl.json|. Частичка <<tpl>>
означает <<template>>.

\begin{english}
  \begin{json}
{
    "server_port": $HTTP_PORT,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "$DB_NAME",
        "user":     "$DB_USER",
        "password": "$DB_PASS"
    },
    "event": [
        "$EVENT_START",
        "$EVENT_END"
    ]
}
  \end{json}
\end{english}

\noindent
Обратите внимание, что порт сервера не окружен кавычками, потому что это
число. Поместим переменные в отдельный файл:

\begin{english}
  \begin{bash}
cat ENV_TPL

DB_NAME=book
DB_USER=ivan
DB_PASS='*(&fd}A53z#$!'
HTTP_PORT=8080
EVENT_START='2019-07-05T12:00:00'
EVENT_END='2019-07-12T23:59:59'
  \end{bash}
\end{english}

\noindent
Считаем переменные и <<отрендерим>> шаблон:

\begin{english}
  \begin{bash}
source ENV_TPL
cat config.tpl.json | envsubst
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "*(&fd}A53z#$!"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{bash}
\end{english}

\noindent
Видим, что подстановка прошла успешно. Чтобы записать результат в файл, добавьте
в конец оператор вывода:

\begin{english}
  \begin{bash}
cat config.tpl.json | envsubst > config.ready.json
  \end{bash}
\end{english}

Способ с \spverb|envsubst| на первый взгляд примитивен, но полезен на
практике. Принцип шаблона снимает вопрос о структуре: переменные подставляют в
нужное место, и не приходится думать о вложенности.

Иногда приложение требует несколько файлов конфигурации, в том числе для
инфраструктуры. Порт веб-сервера понадобится в Nginx для проксирования. В
Sendmail нужно указать тот же адрес почты, что и в приложении. Очевидно, должен
быть единый источник данных, и рендер шаблонов ложится на эту модель.

Утилита \spverb|envsubst| становится менеджером конфигураций. Чтобы
автоматизировать процесс, добавьте скрипт, который пробегает по шаблонам и
<<рендерит>> их переменными. Решение не тянет на промышленный уровень, но
подойдет для простых проектов.

%% -----------------

\section{Чтение среды из конфигурации}

Следующие техники делают так, что приложение читает параметры
\emph{одновременно} из файла и среды. Разница в том, на каком шаге это
происходит.

Предположим, основные параметры записаны в файле, а пароль к базе приходит из
среды. Договоримся с командой, что в поле \spverb|:password| в файле записан не
пароль, а имя переменной, например \spverb|"DB_PASS"|. Напишем спеку, которая
выводит значение переменной по имени:

\begin{english}
  \begin{clojure}
(s/def ::->env
  (s/conformer
   (fn [varname]
     (or (System/getenv varname)
         ::s/invalid))))
  \end{clojure}
\end{english}

Если переменную не задали, вывод вернет ошибку. Прежде чем подключиться к базе,
отбросим пустые символы и убедимся, что строка не пустая.

\begin{english}
  \begin{clojure}
(s/def ::db-password
  (s/and ::->env
         string?
         (s/conformer str/trim)
         not-empty))
  \end{clojure}
\end{english}

Быстрая проверка: запустим REPL с переменной \spverb|DB_PASS| и прочитаем ее
спекой:

\begin{english}
  \begin{bash}
DB_PASS='*(&fd}A53z#$!' lein repl

(s/conform ::db-password "DB_PASS")
"*(&fd}A53z#$!"
  \end{bash}
\end{english}

Чтобы вынести поле из файла в переменную, замените значение на имя
переменной. Обновите спеку этого поля: добавьте \spverb|::->env| в начало
цепочки \spverb|s/and|.

Другой способ прочитать переменные из файла~--- расширить его \emph{тегами}. Тег
это короткое слово, которое указывает, что значение за ним читают особым
образом. Форматы YAML и EDN поддерживают теги. Библиотеки для них предлагают
несколько основных тегов.

В EDN тег начинается со знака решетки и захватывает следующее
значение. Например, \spverb|#inst "2019-07-10"| выводит дату из строки. Тег
связан с функцией одного аргумента, которая вычисляет новое значение из
исходного. Чтобы задать свой тег, в функцию \spverb|clojure.edn/read-string|
передают словарь тегов. Ключи словаря это символы, значения~--- функции.

Добавим тег \spverb|#env|, который вернет значение переменной по имени. Имя
переменной может быть строкой или символом. Определим функцию:

\begin{english}
  \begin{clojure}
(defn tag-env
  [varname]
  (cond
    (symbol? varname)
    (System/getenv (name varname))
    (string? varname)
    (System/getenv varname)
    :else
    (throw (new Exception "wrong var type"))))
  \end{clojure}
\end{english}

\noindent
Прочитаем edn-строку с новым тегом:

\begin{english}
  \begin{clojure}
(require '[clojure.edn :as edn])

(edn/read-string
 {:readers {'env tag-env}}
 "{:db-password #env DB_PASS}")

;; {:db-password "*(&fd}A53z#$!"}
  \end{clojure}
\end{english}

Чтобы не передавать теги каждый раз, объявим \spverb|partial| от
\spverb|edn/read-string|. Новая функция принимает только текст:

\begin{english}
  \begin{clojure}
(def read-config
  (partial edn/read-string
           {:readers {'env tag-env}}))
  \end{clojure}
\end{english}

Чтобы разобрать файл с тегами, считайте его в строку и передайте в
\spverb|read-config|:

\begin{english}
  \begin{clojure}
(-> "/path/to/config.edn"
    slurp
    read-config)
  \end{clojure}
\end{english}

YAML тоже предусматривает теги. Тег начинается с одного или двух восклицательных
знаков в зависимости от семантики. У стандартных тегов один знак, а у сторонних
два. Так мы сразу поймем, где какой тег. К сожалению, правилу следуют не всегда.

Библиотека Yummy предлагает парсер YAML, <<заряженный>> полезными тегами. Среди
прочих нас интересует \spverb|!envvar|: он вернет значение переменной по
имени. Опишем конфигурацию в файле \spverb|config.yaml|:

\begin{english}
  \begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     !envvar DB_USER
  password: !envvar DB_PASS
  \end{yaml}
\end{english}

Подключим библиотеку и прочтем файл. На месте тегов получим значения среды:

\begin{english}
  \begin{clojure}
(require '[yummy.config :as yummy])
(yummy/load-config {:path "config.yaml"})

{:server_port 8080
 :db {:dbtype "mysql"
      :dbname "book"
      :user "ivan"
      :password "*(&fd}A53z#$!"}}
  \end{clojure}
\end{english}

Мы подробно рассмотрим Yummy в следующем разделе главы.

Теги несут преимущества и недостатки. С одной стороны, они делают конфигурацию
плотнее: на строку с тегом приходится больше смысла. Запись \spverb|#env DB_PASS|
выглядит короче и приятнее глазу. Сложные теги выносят в библиотеки и подключают
в зависимости.

С другой стороны, теги привязывают конфигурацию к платформе. Если в YAML-файле
встречается тег \spverb|!envvar|, библиотека на Python не сможет его прочитать:
в ней нет такого тега. Технически это можно исправить: игнорировать незнакомые
теги или установить заглушку. Но подход не гарантирует одинаковый результат на
разных платформах.

Другой минус в том, что с тегами конфигурация обрастает побочными эффектами. В
терминах функционального программирования она теряет чистоту. Появляется соблазн
вынести в тег слишком много логики, например, включить дочерний файл или
форматировать строки. Теги стирают грань между чтением конфигурации и ее
обработкой. Когда их слишком много, конфигурацию трудно поддерживать.

Оба приема~--- разбор спекой и тегами~--- оппонируют друг другу. Делайте так,
чтобы было удобно команде и рабочему процессу.

\section{Короткий обзор форматов}

Мы упомянули три формата данных: JSON, EDN и YAML. Перечислим особенности
каждого из них. Наша цель не выявить идеальный формат, а подготовить читателя к
неочевидным моментам, которые возникнут при работе с ними.

\subsection{JSON}

JSON известен даже тем, кто не работает с вебом. Это запись данных по правилам
JavaScript. Стандарт задает числа, строки, логический тип, null и две коллекции:
массив и словарь. Коллекции могут быть произвольно вложены друг в друга.

Ключевое преимущество JSON в его популярности: это стандарт обмена данными между
клиентом и сервером. По сравнению с XML его легче читать и поддерживать. JSON
поддерживают современные редакторы, языки и платформы. Это естественный способ
хранить данные в JavaScript.

В JSON не предусмотрены комментарии. На первый взгляд это мелочь, но на практике
комментарии важны. Если разработчик добавил новый параметр, будет правильно
написать комментарий о том, что он делает и какие значения принимает. Посмотрите
конфигурации Redis, PostgreSQL или Nginx~--- больше половины файла занимают
комментарии.

Разработчики придумали уловки, чтобы обойти ограничение. Например, поставить
одноименное поле перед тем, к которому относится комментарий.

\begin{english}
  \begin{json}
{
    "server_port": "A port which the web-server is bound to.",
    "server_port": 8080
}
  \end{json}
\end{english}

Расчет сделан на то, что библиотека обходит поля по очереди, и второе поле
заменит первое. Стандарт JSON ничего не гвоорит о порядке полей; прием остается
на ваш риск. Логика библиотеки может быть иной, например, бросить исключение или
пропустить ключ, который уже в словаре.

Иногда в JSON добавляют комментарии на уровне продукта. Редактор Sublime Text
хранит настройки в .json-файлах с поддержкой JavaScript-комментариев (двойная
косая черта). Но в общем случае у проблемы нет решения.

JSON выгодно отличается от многословного XML, которому пришел на замену. Данные
в JSON выглядят чище и удобнее, чем дерево XML-тегов. Но современные форматы
выражают данные еще чище. Например, в YAML любую структуру можно записать без
единой скобки за счет отступов.

Синтаксис JSON <<шумит>>: он требует кавычек, двоеточий и запятых там, где
другие форматы лояльны. Например, запятая в конце массива или объекта считается
ошибкой. Ключи словаря не могут быть числами; нет токенов (кейвордов). Нельзя
записать текст в несколько строк.

Сравните данные в YAML и JSON. Первая запись короче и чище:

\noindent
\begin{tabular}{ @{}p{5cm} @{}p{5cm} }

\begin{english}
  \begin{yaml}
server_port: 8080
db:
  dbtype:   mysql
  dbname:   book
  user:     user
  password: '****'
event:
  - 2019-07-05T12:00:00
  - 2019-07-12T23:59:59
  \end{yaml}
\end{english}

&

\begin{english}
  \begin{json}
{
    "server_port": 8080,
    "db": {
        "dbtype":   "mysql",
        "dbname":   "book",
        "user":     "ivan",
        "password": "****"
    },
    "event": [
        "2019-07-05T12:00:00",
        "2019-07-12T23:59:59"
    ]
}
  \end{json}
\end{english}

\end{tabular}

JSON не поддерживает теги, о которых мы говорили выше. Для работы с форматом
служат библиотеки Cheshire\footurl{https://github.com/dakrone/cheshire} и
Data.json\footurl{https://github.com/clojure/data.json}.

%% -----------------

\subsection{YAML}

Язык YAML, как и JSON, различает базовые типы: скаляры, null и коллекции. YAML
делает ставку на краткость записи: вложенность задают отступы, а не
скобки. Запятые не обязательны там, где язык выводит их логически. Например,
массив чисел в одну строку выглядит как в JSON:

\begin{english}
  \begin{yaml}
numbers: [1, 2, 3]
  \end{yaml}
\end{english}

\noindent
Но при записи в столбик запятые и скобки отпадают:

\begin{english}
  \begin{yaml}
numbers:
  - 1
  - 2
  - 3
  \end{yaml}
\end{english}

YAML поддерживает комментарии в стиле Python (знак решетки), за что его любят в
DevOps. Программы вроде Docker-compose и Kubernetes читают настройки из
YAML-файлов.

В YAML можно записать текст в несколько строк. Его проще читать и копировать,
чем одну строку с символом переноса \spverb|\n|.

\begin{english}
  \begin{yaml}
description: |
  To solve the problem, please do the following:

  - Press Control + Alt + Delete;
  - Turn off your computer;
  - Walk for a while.

  Then try again.
  \end{yaml}
\end{english}

Язык официально поддерживает теги.

Недостатки YAML вытекают из его преимуществ. Вложенность отступами кажется
удачным решением до тех пор, пока файл не станет большим. Глаз начнет прыгать на
большие расстояния, чтобы сверять уровни структур. Иногда часть данных
<<съезжает>> из-за лишнего отступа. С точки зрения YAML ошибки нет, поэтому ее
трудно найти.

Иногда отказ от кавычек приводит к неверным типам или структуре. Предположим, в
поле \spverb|phrases| перечислены фразы, которые увидит пользователь:

\begin{english}
  \begin{yaml}
phrases:
  - Welcome aboard!
  - See you soon!
  - Warning: wrong email address.
  \end{yaml}
\end{english}

Из-за двоеточия в последней строке парсер решит, что это вложенный
словарь. Получим неверную структуру:

\begin{english}
  \begin{clojure}
{:phrases
 ["Welcome aboard!"
  "See you soon!"
  {:Warning "wrong email address."}]}
  \end{clojure}
\end{english}

Другие примеры: версия продукта \spverb|3.3| это число, но \spverb|3.3.1|~---
строка. Телефон \spverb|+79625241745| это число, потому что знак плюса считается
унарным оператором по аналогии с минусом. Лидирующие нули означают восьмеричную
запись: если не добавить кавычки к \spverb|000042|, получится число \spverb|34|.

Это не значит, что YAML неудачный формат. Случаи выше описаны в стандарте и
имеют логическое объяснение. Но иногда он ведет себя не так, как вы ожидали~---
это плата за упрощенный синтаксис.

\subsection{EDN}

Формат EDN занимает особое место в обзоре. Он хранит данные Clojure и потому
играет такую же роль в языке, как JSON в JavaScript. Это родной способ связать
данные с файлом в Clojure.

Синтаксис EDN почти полностью совпадает компилятором Clojure. Формат охватывает
больше типов, чем JSON и YAML. Например, из скалярных типов доступны символы и
кейворды (типы \spverb|Symbol| и \spverb|Keyword| из
\spverb|clojure.lang|). Кроме вектора и словаря EDN предлагает списки и
множества.

Тег начинается с символа решетки. По умолчанию стандарт предлагает два тега:
\spverb|#inst| и \spverb|#uuid|. Первый читает строку в дату, а второй в
экземпляр \spverb|java.util.UUID|. Идентификаторы используют в распределенных
системах вроде Cassandra и Kafka. Выше мы показали, как добавить свой тег: нужно
связать его с функцией одного аргумента при чтении строки.

Пример-комбо с разными типами, коллекциями и тегами:

\begin{english}
  \begin{clojure}
{:user/banned? false
 :task-state #{:pending :in-progress :done}
 :account-ids [1001 1002 1003 nil]
 :server {:host "127.0.0.1" :port 8080}
 :date-range [#inst "2019-07-01" #inst "2019-07-31"]
 :cassandra-id #uuid "26577362-902e-49e3-83fb-9106be7f60e1"}
  \end{clojure}
\end{english}

Данные в EDN не отличаются от кода. Если скопировать их в REPL или модуль,
компилятор выполнит их. И наоборот: вывод REPL можно скопировать в файл для
дальнейшей работы.

%% -------------

Функция \spverb|pr-str| переводит данные в текст. Сброс в EDN сводится к простым
шагам: <<напечатать>> данные в строку и записать ее в файл. В примере ниже
результат \spverb|get-huge-dataset| пишут в файл \spverb|dataset.edn|:

\begin{english}
  \begin{clojure}
(-> (get-huge-dataset)
    pr-str
    (as-> dump
        (spit "dataset.edn" dump)))
  \end{clojure}
\end{english}

EDN поддерживает не только обычные комментарии. Тег \spverb|#_| игнорирует
следующий за ним элемент. Элементом может быть что угодно, в том числе
коллекция. Если нужно <<заигнорить>> словарь, который занимает несколько строк,
поставьте перед ним \spverb|#_|, и парсер пропустит его.

Это позволяет отключить целые части конфигурации. В следующем примере мы
игнорируем пользователя Ioann. Если поставить обычный комментарий (точка с
запятой), он заденет закрывающие скобки, и выражение не будет закончено.

\begin{english}
  \begin{clojure}
{:users [{:id 1 :name "Ivan"}
         {:id 2 :name "Juan"}
         #_{:id 3 :name "Ioann"}]}
  \end{clojure}
\end{english}

EDN это удачный выбор, когда и бекенд, и фронтенд работают на едином стеке
Clojure и ClojureScript.

EDN привязан к Clojure и потому не известен разработчикам на других
языках. Современные редакторы не подсвечивают его синтаксис без сторонних
плагинов. Это может доставить проблем коллегам DevOps, которые работают только с
JSON и YAML. Если к конфигурации обращаются скрипты на Python или Ruby, придется
ставить библиотеку для работы с этим форматом. EDN выбирают там, где Clojure
преобладает над другими технологиями.

\section{Промышленные решения}

Разработчику важно понимать, как работает конфигурация, но мы не ожидаем, что в
каждом проекте ее пишут с нуля. Идеи из этой главы выражены в сторонних
решениях. В последнем разделе мы рассмотрим, какие библиотеки предлагает
сообщество для конфигурации проектов.

Мы остановили внимание на проектах \spverb|cprop|, \spverb|aero| и
\spverb|yummy|. Библиотеки отличаются в идеологии и архитектуре. Мы специально
подобрали их так, чтобы увидеть проблему с разных сторон.

\subsection{Cprop}

Библиотека \spverb|cprop|\footurl{https://github.com/tolitius/cprop} работает по
принципу <<данные отовсюду>>. В отличии от нашего загрузчика у \spverb|cprop|
больше источников данных. Библиотека читает не только файл и переменные среды,
но и ресурсы, property-файлы и обычные словари.

\spverb|Cprop| приводит данные из разных источников к одному виду. Можно
сказать, это обертка над различными <<бекендами>> данных. В \spverb|cprop| можно
задать конфигурацию разным способом, но получить одинаковый результат.

В библиотеке задан порядок обхода источников и их приоритет. Параметры из одного
источника заменяют другие. Так, переменная среды имеет более высокий приоритет,
чем одноименная из файла. Для частных случаев в \spverb|cprop| легко задать свой
порядок загрузки.

Нас интересует функция \spverb|load-config|. Вызванная без параметров, она
запускает стандартный загрузчик. По умолчанию \spverb|cprop| ищет два источника
данных: Java-ресурс и property-файл.

Под ресурсом понимают особый файл, который позже становится частью проекта. На
этапе разработки ресурсы хранят в директории \spverb|resources|. \spverb|Cprop|
ищет ресурс с именем \spverb|config.edn|. Это первичный источник данных.

Если системное свойство \spverb|conf| не пустое, библиотека полагает, что это
путь к property-файлу и загружает его. \emph{Свойства} это особые переменные
Java-машины. Свойства это аналог среды окружения для JVM.

При загрузке JVM получает свойства по умолчанию: тип и версию операционной
системы, тип файловой системы и другие. Дополнительные свойства задают
параметром \spverb|-D| при запуске программы. Пример ниже запускает
скомпилированный jar-файл со свойством \spverb|conf|:

\begin{english}
  \begin{bash}
java -Dconf="/path/to/config.properties" -jar project.jar
  \end{bash}
\end{english}

Файлы \spverb|.properties| это пары \spverb|поле=значение| по одной на
строку. Поля похожи на домены: это лексемы, разделенные точкой. Лексемы убывают
по старшинству:

\begin{english}
  \begin{ini}
db.type=mysql
db.host=127.0.0.1
db.pool.connections=8
  \end{ini}
\end{english}

Библиотека трактует точки как вложенные словари. Файл вернет структуру:

\begin{english}
  \begin{clojure}
{:db {:type "mysql"
      :host "127.0.0.1"
      :pool {:connections 8}}}
  \end{clojure}
\end{english}

Получив конфигурацию из ресурса или property-файла, \spverb|cprop| ищет
\emph{переопределения} в переменных среды. Для них работают те же правила, что и
в нашем загрузчике. Например, переменная \spverb|DB__POOL__CONNECTIONS=16|
заменит значение 8 в словаре из файла. При этом \spverb|cprop| игнорирует
переменные, которые не входят в конфигурацию и тем самым не загрязняет~ее.

Нестандартные пути к ресурсу и файлу задают ключами:

\begin{english}
  \begin{clojure}
(load-config
 :resource "private/config.edn"
 :file "/path/custom/config.edn")
  \end{clojure}
\end{english}

Для тонкой работы \spverb|cprop| предлагает модуль \spverb|cprop.source|. Его
функция \spverb|from-env| вернет словарь всех переменных среды,
\spverb|from-props-file| загрузит properties-файл и так далее. Можно построить
такую комбинацию, которая нужна проекту.

Ключ \spverb|:merge| объединяет конфигурацию с любым источником. Убер-пример из
документации:

\begin{english}
  \begin{clojure}
(load-config
 :resource "path/within/classpath/to.edn"
 :file "/path/to/some.edn"
 :merge [{:datomic {:url "datomic:mem://test"}}
         (from-file "/path/to/another.edn")
         (from-resource "path/within/classpath/to-another.edn")
         (from-props-file "/path/to/some.properties")
         (from-system-props)
         (from-env)])
  \end{clojure}
\end{english}

В вектор \spverb|:merge| ставят любое выражение, которое вернет словарь. В общем
случае \spverb|(load-config)| без параметров будет достаточным решением.

Чтобы отследить загрузку сложной конфигурации, установите переменную среды
\spverb|DEBUG=y|. С ней \spverb|cprop| выводит в лог служебную информацию. Это
список источников, порядок их загрузки, переопределение переменных и так далее.

\spverb|Cprop| только загружает данные из источников, но не проверяет их. В
библиотеке нет валидации спекой, как это сделано в нашем загрузчике. Этот шаг
остается на усмотрение разработчика.

В \spverb|cprop| по-своему выводит типы. Если строка состоит только из цифр, ее
приводят к числу. Значения с запятыми становятся списками. Иногда этих правил
недостаточно для полного контроля за типами. Вам по-прежнему понадобится
\spverb|spec| и \spverb|conform| для вывода типов и сообщений об ошибке.

\subsection{Aero}

Проект \spverb|aero|\footurl{https://github.com/juxt/aero} предлагает другой
подход. В отличии от \spverb|cprop|, библиотека работает только с одним
источником данных: файлами \spverb|*.edn|. \spverb|Aero| несет на борту теги, с
которыми EDN становится похож на мини-язык программирования. В нем появляются
операторы ветвления, импорта, форматирования. Можно назвать подход <<EDN на
стероидах>>.

Функция \spverb|read-config| читает файл или ресурс EDN:

\begin{english}
  \begin{clojure}
(require '[aero.core :refer (read-config)])

(read-config "config.edn")
(read-config (clojure.java.io/resource "config.edn"))
  \end{clojure}
\end{english}

Главное в библиотеке это теги, которые вносят дополнительную логику. Разберем
основные из них. Тег \spverb|#env| заменяет имя переменной среды на ее
значение. Мы написали такой же:

\begin{english}
  \begin{clojure}
{:db {:passwod #env DB_PASS}}
  \end{clojure}
\end{english}

Тег \spverb|#envf| форматирует строку переменными среды. Предположим, параметры
базы заданы отдельными полями, но вы предпочитаете JDBC URI~--- длинную строку,
похожую на веб-адрес. Чтобы не дублировать данные, адрес вычисляют на базе
исходных полей:

\begin{english}
  \begin{clojure}
{:db-uri #envf ["jdbc:postgresql://%s/%s?user=%s"
                DB_HOST DB_NAME DB_USER]}
  \end{clojure}
\end{english}

Тег \spverb|#or| похож на одноименную форму Clojure и в основном нужен для
значений по умолчанию. Пусть в env-файле не задан порт базы данных. Чтобы
избежать неочевидности, укажем стандартный порт:

\begin{english}
  \begin{clojure}
{:db {:port #or [#env DB_PORT 5432]}}
  \end{clojure}
\end{english}

Оператор \spverb|#profile| предлагает интересный способ взять значение по
\emph{профилилю}. Значение за тегом должно быть словарем. Ключи словаря это
профили, а значения~--- то, что получим в результате его разрешения. Профиль
задают в параметрах \spverb|read-config|.

Пример ниже показывает, как определить имя базы по профилю. Без профиля мы
получим \spverb|"book"|, но для \spverb|:test| имя станет \spverb|"book_test"|:

\begin{english}
  \begin{clojure}
{:db {:name #profile {:default "book"
                      :dev     "book_dev"
                      :test    "book_test"}}}

(read-config "aero.test.edn" {:profile :test})
{:db {:name "book_test"}}
  \end{clojure}
\end{english}

Тег \spverb|#include| помещает в конфигурацию другой edn-файл. В нем тоже могут
быть теги, и библиотека выполнит их рекурсивно. К импорту прибегают, когда
конфигурация становится большой.

\begin{english}
  \begin{clojure}
{:queue #include "message-queue.edn"}
  \end{clojure}
\end{english}

Тег \spverb|#ref| ставит ссылку на любое место конфигурации. Это вектор ключей,
который обычно передают в \spverb|get-in|. Ссылка позволяет избежать
дублирования данных. Например, сторонний компонент нуждается в пользователе, под
которым мы подключаемся к базе данных:

\begin{english}
  \begin{clojure}
;; config.edn
{:db {:user #env DB_USER}
 :worker {:user #ref [:db :user]}}

;; result
{:db {:user "ivan"}, :worker {:user "ivan"}}
  \end{clojure}
\end{english}

Эти и другие теги комбинируют и добавляют собственные.

\spverb|Aero| предлагает несложный язык описания конфигураций. Проект выглядит
многообещающе: \spverb|aero| подкупает интересной идеей и красотой
реализации. Но в момент, когда вам захочется переехать с негибкого JSON на
\spverb|aero|, подумайте об обратной стороне медали.

Конфигурацию не случайно отделяют от кода. Если бы не потребность индустрии, мы
бы хранили параметры в исходных файлах. Но этого не делают~--- наоборот, хорошие
практики в один голос советуют \emph{отделять} параметры от кода. В том числе
потому, что в отличие от кода конфигурация \emph{декларативна}.

Негибкие JSON- и properties-файлы обладают важным свойством: они
декларативны. Когда вы открыли файл в редакторе или сделали \spverb|cat|, то
сразу видите данные. Отдельные части могут повторяться, синтаксис неудобен для
чтения. Но данные выражаются сами в себя, и ошибки быть не может.

Наоборот, файл с нестандартными тегами труден в поддержке. Это не конфигурация,
а \emph{код}. Файл становится трудно читать, его нужно выполнить. При чтении
файла в вашей голове запускается мини-интерпретатор, который не гарантирует
правильный результат.

Получается своего рода круг. Мы вынесли параметры в конфигурацию, добавили теги
и вернулись к коду. Такой подход имеет право на жизнь, но к нему следует прийти
осознанно.

\subsection{Yummy}

Библиотека \spverb|yummy|\footurl{https://github.com/exoscale/yummy} замыкает
обзор. От аналогов она отличается двумя свойствами. Во-первых, работает с
файлами YAML для чтения конфигурации (отсюда и название). Во-вторых, процесс
загрузки похож на тот, что мы рассмотрели в начале главы.

Полноценный загрузчик не только читает параметры. Цикл конфигурации включает
проверку данных и вывод ошибки. Сообщение об ошибке внятно объясняет, в чем
причина. С помощью необязательных параметров можно зацепиться за основные
события. \spverb|Yummy| предлагает почти все из перечисленного.

Библиотека читает YAML-разметку из файла. Путь к файлу либо передан в
параметрах, либо библиотека ищет его по определенному имени в переменных среды
или свойствах JVM. Вариант, когда путь задан явно:

\begin{english}
  \begin{clojure}
(require '[yummy.config :refer [load-config]])

(load-config {:path "config.yaml"})
  \end{clojure}
\end{english}

Во втором случае вместо пути задали \emph{имя программы}. \spverb|Yummy| ищет
путь к файлу в переменной среды \spverb|<program>_CONFIGURATION| или свойстве
\spverb|<program>.configuration|:

\begin{english}
  \begin{bash}
export BOOK_CONFIGURATION=config.yaml
  \end{bash}
\end{english}

\begin{english}
  \begin{clojure}
(load-config {:program-name :book})
  \end{clojure}
\end{english}

Библиотека расширяет YAML несколькими тегами. Это знакомый вам \spverb|!envvar|
для переменных среды:

\begin{english}
  \begin{yaml}
db:
  password: !envvar DB_PASS
  \end{yaml}
\end{english}

Тег \spverb|!keyword| полезен, когда вместо строки ожидают кейворд:

\begin{english}
  \begin{yaml}
states:
  - !keyword task/pending
  - !keyword task/in-progress
  - !keyword task/done
  \end{yaml}
\end{english}

Результат:

\begin{english}
  \begin{clojure}
{:states [:task/pending :task/in-progress :task/done]}
  \end{clojure}
\end{english}

Тег \spverb|!uuid| аналогичен \spverb|#uuid| для EDN. Он возвращает объект
\spverb|java.util.UUID| из строки:

\begin{english}
  \begin{yaml}
system-user: !uuid cb7aa305-997c-4d53-a61a-38e0d8628dbb
  \end{yaml}
\end{english}

Тег \spverb|!slurp| читает текст из стороннего файла. Это полезно для
сертификатов шифрования. Их содержимое это длинная строка, которую неудобно
хранить в общей конфигурации.

\begin{english}
  \begin{yaml}
tls:
  auth: !slurp "certs/ca.pem"
  cert: !slurp "certs/cert.pem"
  pkey: !slurp "certs/key.pk8"
  \end{yaml}
\end{english}

В ключах \spverb|:auth|, \spverb|:cert| и \spverb|:pkey| будет содержимое файлов
из папки \spverb|certs|.

Чтобы проверить данные, в параметры \spverb|load-config| передают ключ
спеки. Когда ключ указан, \spverb|yummy| выполняет \spverb|s/assert| для
параметров из yaml-файла. Если проверка вернула ложь, всплывает
исключение. \spverb|Yummy| пользуется \spverb|expound|, чтобы улучшить отчет об
ошибке.

\begin{english}
  \begin{clojure}
(load-config {:program-name :book
              :spec ::config})
  \end{clojure}
\end{english}

Словарь опцией принимает параметр \spverb|:die-fn|. Это функция, которая
сработает, если любая из стадий завершится с ошибкой. Функция принимает два
аргумента: исключение и метку с именем стадии.

Если \spverb|:die-fn| не задан, \spverb|yummy| вызовет обработчик по
умолчанию. Он выводит текст в \spverb|stderr| и завершает программу со кодом
1. Это неудобно на этапе разработки: мы не хотим обрывать REPL из-за ошибки в
конфигурации. В интерактивном сеансе наша \spverb|die-fn| только печатает текст
и ошибку:

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (binding [*out* *err*]
              (println msg)
              (println (ex-message e))))})
  \end{clojure}
\end{english}

В боевом режиме запишем исключение в лог и завершим программу.

\begin{english}
  \begin{clojure}
(load-config
 {:program-name :book
  :spec ::config
  :die-fn (fn [e msg]
            (log/errorf e "Config error")
            (System/exit 1))})
  \end{clojure}
\end{english}

Из недостатков \spverb|yummy| отметим, что для валидации используется
\spverb|s/assert|. Функция не выводит новые значения, как это делает
\spverb|s/conform|, а только бросает исключение. Поэтому вы не сможете вывести
типы с помощью \spverb|conform|-спек. С другой стороны, это сделано
нарочно. Библиотека устроена так, чтобы типы выводят тегами, а спека только
проверяет данные.

\section{Заключение}

Перечислим основные тезисы из этой главы.

Конфигурация нужна, чтобы проект прошел стадии производства: разработку,
тестирование, боевой запуск. На каждой стадии его запускают с разными
настройками. Без конфигурации это невозможно.

Загрузка конфигурации означает чтение данных, вывод типов и проверку значений. В
случае ошибки программа выводит понятное сообщение и завершается с аварийным
кодом. Нет смысла продолжать работу с неверными параметрами.

Источником конфигурации может быть файл, Java-ресурс, переменные
окружения. Допустимы гибридные схемы, когда основные данные приходят из файла, а
секретные поля из окружения.

Переменные среды живут в памяти операционной системы. Если переменных много, их
помещают в ENV-файл. Приложение не читает этот файл; это делает скрипт, который
управляет приложением на сервере. Приложению неизвестно, откуда пришли
переменные.

Окружение это плоский словарь. Переменные хранят только текст, ключи не
структурированы. В разных системах свои соглашения о том, как извлечь структуру
из имени переменной. Это могут быть точки, двойные подчеркивания или что-то еще.

Форматы файлов различаются синтаксисом и типами данных. Общие форматы задают
базовые типы: строки, числа, словари и списки. Они не настолько гибки, но
работают в разных языках. Наоборот, формат для особой платформы тесно связан с
ней, но не поддерживается в других языках.

Некоторые форматы поддерживают теги. С помощью тегов из скаляров получают более
сложные типы, например даты. Теги опасны тем, что когда их много, конфигурация
превращается в код.

Clojure предлагает несколько библиотек для конфигурации приложения. Они
различаются замыслом и архитектурой, и каждый разработчик найдет то, что ему по
душе.

Нет однозначного ответа на вопрос о том, какой формат, библиотека или
\emph{рабочий процесс} лучше. В каждой команде действуют свои порядки,
продиктованные бизнесом.
